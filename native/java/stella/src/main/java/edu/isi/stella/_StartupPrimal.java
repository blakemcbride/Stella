//  -*- Mode: Java -*-
//
// _StartupPrimal.java

/*
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
*/

package edu.isi.stella;

import edu.isi.stella.javalib.*;

public class _StartupPrimal {
  static void helpStartupPrimal1() {
    {
      Stella.SYM_STELLA_FLOOR = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("FLOOR", null, 0)));
      Stella.KWD_CPP = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CPP", null, 2)));
      Stella.KWD_FUNCTION = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("FUNCTION", null, 2)));
      Stella.SYM_STELLA_ROUND = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ROUND", null, 0)));
      Stella.SYM_STELLA_FMOD = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("FMOD", null, 0)));
      Stella.SYM_STELLA_RANDOM = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("RANDOM", null, 0)));
      Stella.SYM_STELLA_SQRT = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SQRT", null, 0)));
      Stella.SYM_STELLA_COS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("COS", null, 0)));
      Stella.SYM_STELLA_SIN = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SIN", null, 0)));
      Stella.SYM_STELLA_TAN = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("TAN", null, 0)));
      Stella.SYM_STELLA_ACOS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ACOS", null, 0)));
      Stella.SYM_STELLA_ASIN = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ASIN", null, 0)));
      Stella.SYM_STELLA_ATAN = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ATAN", null, 0)));
      Stella.SYM_STELLA_ATAN2 = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ATAN2", null, 0)));
      Stella.SYM_STELLA_EXP = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("EXP", null, 0)));
      Stella.SYM_STELLA_LOG = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("LOG", null, 0)));
      Stella.SYM_STELLA_MIN = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("MIN", null, 0)));
      Stella.SYM_STELLA_MAX = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("MAX", null, 0)));
      Stella.KWD_WHITE_SPACE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("WHITE-SPACE", null, 2)));
      Stella.KWD_ASCII_CASE_SENSITIVE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("ASCII-CASE-SENSITIVE", null, 2)));
      Stella.KWD_ASCII_CASE_INSENSITIVE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("ASCII-CASE-INSENSITIVE", null, 2)));
      Stella.KWD_ASCII_CASE_NORMALIZED = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("ASCII-CASE-NORMALIZED", null, 2)));
      Stella.KWD_UPCASE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("UPCASE", null, 2)));
      Stella.KWD_DOWNCASE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("DOWNCASE", null, 2)));
      Stella.KWD_CAPITALIZE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CAPITALIZE", null, 2)));
      Stella.KWD_PRESERVE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("PRESERVE", null, 2)));
      Stella.KWD_LEFT = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("LEFT", null, 2)));
      Stella.KWD_RIGHT = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("RIGHT", null, 2)));
      Stella.KWD_CENTER = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CENTER", null, 2)));
      Stella.SYM_STELLA_HASH_CODE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("HASH-CODE", null, 0)));
      Stella.KWD_UNIX = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("UNIX", null, 2)));
      Stella.KWD_MAC = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("MAC", null, 2)));
      Stella.KWD_WINDOWS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("WINDOWS", null, 2)));
      Stella.KWD_TYPE_4 = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("TYPE-4", null, 2)));
      Stella.KWD_RANDOM = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("RANDOM", null, 2)));
      Stella.SYM_STELLA_SLEEP = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SLEEP", null, 0)));
      Stella.SYM_STELLA_STARTUP_PRIMAL = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-PRIMAL", null, 0)));
    }
  }

  static void helpStartupPrimal2() {
    {
      Stella.MOST_NEGATIVE_INTEGER = Stella.NULL_INTEGER + 1;
      Stella.MOST_NEGATIVE_LONG_INTEGER = Stella.NULL_LONG_INTEGER + 1;
      Stella.LEAST_NEGATIVE_FLOAT = 0 - Stella.LEAST_POSITIVE_FLOAT;
      Stella.RECIPROCAL_NL2 = 1.0 / Math.log(2.0);
      Stella.RECIPROCAL_NL10 = 1.0 / Math.log(10.0);
      Stella.$TRANSIENTOBJECTSp$.setDefaultValue(new Boolean(false));
      Stella.LONG_INTEGER_BIT_WIDTH = Native.round(Math.log((Stella.MOST_POSITIVE_LONG_INTEGER * 2.0)) / Math.log((2.0)));
    }
  }

  static void helpStartupPrimal3() {
    {
      Stella.defineFunctionObject("LISP-NULL-ARRAY-SYMBOL-STRING", "(DEFUN (LISP-NULL-ARRAY-SYMBOL-STRING STRING) ((RANK INTEGER)))", Native.find_java_method("edu.isi.stella.Stella", "lispNullArraySymbolString", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("PRINT-NUMERIC-CONSTANTS", "(DEFUN PRINT-NUMERIC-CONSTANTS () :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "printNumericConstants", new java.lang.Class [] {}), null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X UNKNOWN)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X OBJECT)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X SECOND-CLASS-OBJECT)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X NATIVE-VECTOR)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X ARRAY)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X STRING)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X MUTABLE-STRING)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X CHARACTER)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X CODE)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (NULL? BOOLEAN) ((X FLOAT)) :DOCUMENTATION \"Return true if `x' is undefined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X UNKNOWN)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X OBJECT)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X SECOND-CLASS-OBJECT)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X NATIVE-VECTOR)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X ARRAY)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X STRING)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X MUTABLE-STRING)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X CHARACTER)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X CODE)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (DEFINED? BOOLEAN) ((X FLOAT)) :DOCUMENTATION \"Return true if `x' is defined (handled specially by all translators).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("EQ?", "(DEFUN (EQ? BOOLEAN) ((X UNKNOWN) (Y UNKNOWN)) :DOCUMENTATION \"Return true if `x' and `y' are literally the same object (or\nsimple number).  Analogue to the Common Lisp EQL and C++ and Java's ==.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("=", "(DEFUN (= BOOLEAN) ((X NUMBER) (Y NUMBER)) :DOCUMENTATION \"Return true if `x' and `y' are numbers of exactly the same magnitude.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("EQL?", "(DEFUN (EQL? BOOLEAN) ((X OBJECT) (Y OBJECT)) :DOCUMENTATION \"Return true if `x' and `y' are `eq?' or equivalent literals\nsuch as strings that also might be wrapped in non-identical wrappers.  For\nthe case where `x' or `y' are plain literals such as strings or integers, the\nSTELLA translator substitutes the equality test appropriate for the particular\ntarget language and does not actually call this function.  For cases where\n`x' or `y' are known to be of type STANDARD-OBJECT, the STELLA translator\nsubstitutes the faster `eq?' test inline.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "eqlP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("EQUAL?", "(DEFUN (EQUAL? BOOLEAN) ((X OBJECT) (Y OBJECT)) :DOCUMENTATION \"Return true if `x' and `y' are `eql?' or considered equal\nby a user-defined `object-equal?' method.  This implements a fully extensible\nequality test similar to Java's `equals' method.  Note that writers of custom\n`object-equal?' methods must also implement a corresponding `equal-hash-code'\nmethod.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "equalP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X OBJECT) (Y OBJECT)) :DOCUMENTATION \"Return true if `x' and `y' are `eq?'.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella_Object", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X WRAPPER) (Y OBJECT)) :DOCUMENTATION \"Return true if `x' and `y' are literal wrappers whose\nliterals are considered `eql?'.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Wrapper", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineFunctionObject(">", "(DEFUN (> BOOLEAN) ((X NUMBER) (Y NUMBER)) :DOCUMENTATION \"Return true if `x' is greater than `y'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject(">=", "(DEFUN (>= BOOLEAN) ((X NUMBER) (Y NUMBER)) :DOCUMENTATION \"Return true if `x' is greater than or equal to `y'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("<", "(DEFUN (< BOOLEAN) ((X NUMBER) (Y NUMBER)) :DOCUMENTATION \"Return true if `x' is less than `y'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("<=", "(DEFUN (<= BOOLEAN) ((X NUMBER) (Y NUMBER)) :DOCUMENTATION \"Return true if `x' is less than or equal to `y'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("+", "(DEFUN (+ NUMBER) (|&REST| (ARGUMENTS NUMBER)) :DOCUMENTATION \"Return the sum of all `arguments'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("-", "(DEFUN (- NUMBER) ((X NUMBER) |&REST| (ARGUMENTS NUMBER)) :DOCUMENTATION \"If only `x' was supplied return the result of 0 - `x'.\nOtherwise, return the result of (...((`x' - arg1) - arg2) - ... - argN).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("*", "(DEFUN (* NUMBER) (|&REST| (ARGUMENTS NUMBER)) :DOCUMENTATION \"Return the product of all `arguments'.\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineFunctionObject("/", "(DEFUN (/ NUMBER) ((X NUMBER) |&REST| (ARGUMENTS NUMBER)) :DOCUMENTATION \"If only `x' was supplied return the result of 1 / `x'.\nOtherwise, return the result of (...((`x' / arg1) / arg2 ) / ... / argN).\" :PUBLIC? TRUE :NATIVE? TRUE)", null, null);
      Stella.defineMethodObject("(DEFMETHOD (ZERO? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:= X 0) :CPP \"(!x)\" :JAVA \"(x == 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_zeroP", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (ZERO? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:= X 0) :CPP \"(!x)\" :JAVA \"(x == 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_zeroP", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (PLUS? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is greater than 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:> X 0) :CPP \"(x > 0)\" :JAVA \"(x > 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_plusP", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (PLUS? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is greater than 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:> X 0) :CPP \"(x > 0)\" :JAVA \"(x > 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_plusP", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (EVEN? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is an even number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:NOT (CL:LOGBITP 0 X)) :CPP \"!(x % 2)\" :JAVA \"((x % 2) == 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_evenP", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (EVEN? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is an even number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:NOT (CL:LOGBITP 0 X)) :CPP \"!(x % 2)\" :JAVA \"((x % 2) == 0)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_evenP", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (ODD? BOOLEAN) ((X INTEGER)) :DOCUMENTATION \"Return true if `x' is an odd number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGBITP 0 X) :CPP \"(x % 2)\" :JAVA \"((x % 2) == 1)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_oddP", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (ODD? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return true if `x' is an odd number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGBITP 0 X) :CPP \"(x % 2)\" :JAVA \"((x % 2) == 1)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_oddP", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (DIV INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the integer quotient from dividing `x' by `y'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:VALUES (CL:TRUNCATE X Y)) :CPP \"(x / y)\" :JAVA \"(x / y)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_div", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (DIV LONG-INTEGER) ((X LONG-INTEGER) (Y LONG-INTEGER)) :DOCUMENTATION \"Return the integer quotient from dividing `x' by `y'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:VALUES (CL:TRUNCATE X Y)) :CPP \"(x / y)\" :JAVA \"(x / y)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_div", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (REM INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the remainder from dividing `x' by `y'.  The\nsign of the result is always the same as the sign of `x'.  This has slightly\ndifferent behavior than the `mod' function, and has less overhead in C++ and\nJava, which don't have direct support for a true modulus function.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:REM X Y) :CPP \"(x % y)\" :JAVA \"(x % y)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_rem", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (REM LONG-INTEGER) ((X LONG-INTEGER) (Y LONG-INTEGER)) :DOCUMENTATION \"Return the remainder from dividing `x' by `y'.  The\nsign of the result is always the same as the sign of `x'.  This has slightly\ndifferent behavior than the `mod' function, and has less overhead in C++ and\nJava, which don't have direct support for a true modulus function.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:REM X Y) :CPP \"(x % y)\" :JAVA \"(x % y)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_rem", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineFunctionObject("FREM", "(DEFUN (FREM FLOAT) ((X FLOAT) (Y FLOAT)) :DOCUMENTATION \"Return the floating point remainder from dividing `x' by `y'.  The\nsign of the result is always the same as the sign of `x'.  This has slightly\ndifferent behavior than the `mod' function, and has less overhead in C++ and\nJava, which don't have direct support for a true modulus function.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:REM X Y) :CPP \"fmod(x, y)\" :JAVA \"(x % y)\")))", Native.find_java_method("edu.isi.stella.Stella", "frem", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (MOD INTEGER) ((X INTEGER) (MODULUS INTEGER)) :DOCUMENTATION \"True modulus.  Return the result of `x' mod `modulo'.\nNote: In C++ and Java, `mod' has more overhead than the similar\nfunction `rem'.  The  answers returned by `mod' and `rem' are only\ndifferent when the signs of `x' and `modulo' are different.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_mod", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MOD LONG-INTEGER) ((X LONG-INTEGER) (MODULUS LONG-INTEGER)) :DOCUMENTATION \"True modulus.  Return the result of `x' mod `modulo'.\nNote: In C++ and Java, `mod' has more overhead than the similar\nfunction `rem'.  The  answers returned by `mod' and `rem' are only\ndifferent when the signs of `x' and `modulo' are different.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_mod", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineFunctionObject("FMOD", "(DEFUN (FMOD FLOAT) ((X FLOAT) (MODULUS FLOAT)) :DOCUMENTATION \"True modulus for floats.  Return the result of `x' mod `modulo'.\nNote: In C++ and Java, `mod' has more overhead than the similar\nfunction `rem'.  The  answers returned by `mod' and `rem' are only\ndifferent when the signs of `x' and `modulo' are different.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "fmod", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("GCD", "(DEFUN (GCD LONG-INTEGER) ((X LONG-INTEGER) (Y LONG-INTEGER)) :DOCUMENTATION \"Return the greatest common divisor of `x' and `y'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "gcd", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("CEILING", "(DEFUN (CEILING INTEGER) ((N NUMBER)) :DOCUMENTATION \"Return the smallest integer >= `n'.\" :NATIVE? TRUE :PUBLIC? TRUE)", null, null);
      Stella.defineFunctionObject("FLOOR", "(DEFUN (FLOOR INTEGER) ((N NUMBER)) :DOCUMENTATION \"Return the biggest integer <= `n'.\" :NATIVE? TRUE :PUBLIC? TRUE)", null, null);
      Stella.defineFunctionObject("ROUND", "(DEFUN (ROUND INTEGER) ((N NUMBER)) :DOCUMENTATION \"Round `n' to the closest integer and return the result.\" :NATIVE? TRUE :PUBLIC? TRUE)", null, null);
    }
  }

  static void helpStartupPrimal4() {
    {
      Stella.defineFunctionObject("TRUNCATE", "(DEFUN (TRUNCATE INTEGER) ((N NUMBER)) :DOCUMENTATION \"Truncate `n' toward zero and return the result.\" :NATIVE? TRUE :PUBLIC? TRUE)", null, null);
      Stella.defineFunctionObject("REGULAR-INTEGER-VALUED?", "(DEFUN (REGULAR-INTEGER-VALUED? BOOLEAN) ((X LONG-INTEGER)) :DOCUMENTATION \"Return `true' if `x' can be represented by a regular integer.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (AND (>= X NULL-INTEGER) (<= X MOST-POSITIVE-INTEGER))))", Native.find_java_method("edu.isi.stella.Stella", "regularIntegerValuedP", new java.lang.Class [] {java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("INTEGER-VALUED?", "(DEFUN (INTEGER-VALUED? BOOLEAN) ((X FLOAT)) :DOCUMENTATION \"Returns `true' if `x' is the floating point representation of an integer.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "integerValuedP", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("FLOAT-TO-BASE60", "(DEFUN (FLOAT-TO-BASE60 (CONS OF NUMBER-WRAPPER)) ((X FLOAT) (ALL-INTEGERS? BOOLEAN)) :DOCUMENTATION \"Returns a cons of `x' in a base-60 form.  That means\nthe first value will be the integer part of `x', the next value\nthe iteger value of the fraction part of `x' times 60 and the\nthird value the fraction part of `x' time 3600.  If `all-integers?'\nis `true', then the last value will be rounded to an integer.\nThis can be used to convert from decimal degree values to Degree-Minute-Second\nor from decimal hours to Hour-Minute-Second format.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "floatToBase60", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("BASE60-TO-FLOAT", "(DEFUN (BASE60-TO-FLOAT FLOAT) ((L (CONS OF NUMBER-WRAPPER))) :DOCUMENTATION \"Converts (x y z) into a float.  The return value\nis x + y/60 + z/3600.\nThis can be used to convert from Degree-Minute-Second to decimal degrees\nor from Hour-Minute-Second format to decimal hours.\")", Native.find_java_method("edu.isi.stella.Cons", "base60ToFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("RANDOM", "(DEFUN (RANDOM INTEGER) ((N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a random integer in the interval [0..n-1].\nThe random number generator is seeded based on the current time every\ntime STELLA starts up; however, your mileage may vary depending on\nthe native language implementation.\")", Native.find_java_method("edu.isi.stella.Stella", "random", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("SEED-RANDOM-NUMBER-GENERATOR", "(DEFUN SEED-RANDOM-NUMBER-GENERATOR () :DOCUMENTATION \"Seeds the random number generator based on the current time.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "seedRandomNumberGenerator", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("SEED-RANDOM-NUMBER-GENERATOR2", "(DEFUN SEED-RANDOM-NUMBER-GENERATOR2 () :DOCUMENTATION \"Seeds the random number generator based on the current time and /dev/urandom if it is available.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "seedRandomNumberGenerator2", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("SQRT", "(DEFUN (SQRT FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the square root of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:SQRT N) :CPP \"::sqrt(n)\" :JAVA \"Math.sqrt(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "sqrt", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("COS", "(DEFUN (COS FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the cosine of `n' radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:COS N) :CPP \"::cos(n)\" :JAVA \"Math.cos(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "cos", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("SIN", "(DEFUN (SIN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the sine of `n' radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:SIN N) :CPP \"::sin(n)\" :JAVA \"Math.sin(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "sin", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("TAN", "(DEFUN (TAN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the tangent of `n' radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:TAN N) :CPP \"::tan(n)\" :JAVA \"Math.tan(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "tan", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("ACOS", "(DEFUN (ACOS FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the arccosine of `n' in radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:ACOS N) :CPP \"::acos(n)\" :JAVA \"Math.acos(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "acos", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("ASIN", "(DEFUN (ASIN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the arcsine of `n' in radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:ASIN N) :CPP \"::asin(n)\" :JAVA \"Math.asin(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "asin", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("ATAN", "(DEFUN (ATAN FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the arc tangent of `n' in radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:ATAN N) :CPP \"::atan(n)\" :JAVA \"Math.atan(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "atan", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("ATAN2", "(DEFUN (ATAN2 FLOAT) ((X FLOAT) (Y FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the arc tangent of `x' / `y' in radians.\" (RETURN (VERBATIM :COMMON-LISP (CL:ATAN X Y) :CPP \"::atan2(x,y)\" :JAVA \"Math.atan2(x,y)\")))", Native.find_java_method("edu.isi.stella.Stella", "atan2", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("LOG", "(DEFUN (LOG FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the natural logarithm (base e) of `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:LOG N) :CPP \"::log(n)\" :JAVA \"Math.log(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "log", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("LOG2", "(DEFUN (LOG2 FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the logarithm (base 2) of `n'.\" (RETURN (VERBATIM :COMMON-LISP \"(CL:LOG n 2.0d0)\" :OTHERWISE (* (LOG N) RECIPROCAL-NL2))))", Native.find_java_method("edu.isi.stella.Stella", "log2", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("LOG10", "(DEFUN (LOG10 FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the logarithm (base 10) of `n'.\" (RETURN (VERBATIM :COMMON-LISP \"(CL:LOG n 10.0d0)\" :OTHERWISE (* (LOG N) RECIPROCAL-NL10))))", Native.find_java_method("edu.isi.stella.Stella", "log10", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("EXP", "(DEFUN (EXP FLOAT) ((N FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the e to the power `n'.\" (RETURN (VERBATIM :COMMON-LISP (CL:EXP N) :CPP \"::exp(n)\" :JAVA \"Math.exp(n)\")))", Native.find_java_method("edu.isi.stella.Stella", "exp", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("EXPT", "(DEFUN (EXPT FLOAT) ((X FLOAT) (Y FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `x' ^ `y'.\" (RETURN (VERBATIM :COMMON-LISP (CL:EXPT X Y) :CPP \"::pow(x,y)\" :JAVA \"Math.pow(x,y)\")))", Native.find_java_method("edu.isi.stella.Stella", "expt", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (MIN INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_min", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MIN LONG-INTEGER) ((X LONG-INTEGER) (Y LONG-INTEGER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_min", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MIN FLOAT) ((X FLOAT) (Y FLOAT)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "float_min", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MIN NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :DOCUMENTATION \"Return the minimum of `x' and `y'.  If `y' is NULL, return `x'.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.NumberWrapper", "min", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.NumberWrapper")})), null);
      Stella.defineMethodObject("(DEFMETHOD (MAX INTEGER) ((X INTEGER) (Y INTEGER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_max", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MAX LONG-INTEGER) ((X LONG-INTEGER) (Y LONG-INTEGER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_max", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MAX FLOAT) ((X FLOAT) (Y FLOAT)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If either is NULL, return the other.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "float_max", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Double.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (MAX NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :DOCUMENTATION \"Return the maximum of `x' and `y'.  If `y' is NULL, return `x'.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.NumberWrapper", "max", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.NumberWrapper")})), null);
      Stella.defineMethodObject("(DEFMETHOD (ABS INTEGER) ((X INTEGER)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0) (- 0 X) X)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_abs", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (ABS LONG-INTEGER) ((X LONG-INTEGER)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0) (- 0 X) X)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_abs", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (ABS FLOAT) ((X FLOAT)) :DOCUMENTATION \"Return the absolute value of `x'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (CHOOSE (< X 0.0) (- 0.0 X) X)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "float_abs", new java.lang.Class [] {java.lang.Double.TYPE})), null);
      Stella.defineFunctionObject("CHARACTER-CODE", "(DEFUN (CHARACTER-CODE INTEGER) ((CH CHARACTER)) :DOCUMENTATION \"Return the 8-bit ASCII code of `ch' as an integer.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CHAR-CODE CH) :CPP \"(int)(unsigned char) ch\" :JAVA \"(int) ch\")))", Native.find_java_method("edu.isi.stella.Stella", "characterCode", new java.lang.Class [] {java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("CODE-CHARACTER", "(DEFUN (CODE-CHARACTER CHARACTER) ((CODE INTEGER)) :DOCUMENTATION \"Return the character encoded by `code' (0 <= `code' <= 255).\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:CODE-CHAR CODE) :CPP \"(char) code\" :JAVA \"(char) code\")))", Native.find_java_method("edu.isi.stella.Stella", "codeCharacter", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("CHARACTER-DOWNCASE", "(DEFUN (CHARACTER-DOWNCASE CHARACTER) ((CH CHARACTER)) :DOCUMENTATION \"If `ch' is lowercase, return its uppercase version,\notherwise, return 'ch' unmodified.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (DOWNCASE-CHARACTER CH)))", Native.find_java_method("edu.isi.stella.Stella", "characterDowncase", new java.lang.Class [] {java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("CHARACTER-UPCASE", "(DEFUN (CHARACTER-UPCASE CHARACTER) ((CH CHARACTER)) :DOCUMENTATION \"If `ch' is uppercase, return its lowercase version,\notherwise, return 'ch' unmodified.  If only the first character of\na sequence of characters is to be capitalized, `character-capitalize'\nshould be used instead.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (UPCASE-CHARACTER CH)))", Native.find_java_method("edu.isi.stella.Stella", "characterUpcase", new java.lang.Class [] {java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("CHARACTER-CAPITALIZE", "(DEFUN (CHARACTER-CAPITALIZE CHARACTER) ((CH CHARACTER)) :DOCUMENTATION \"Return the capitalized character for `ch'.  This is generally the same\nas the uppercase character, except for obscure non-English characters in Java.  It should\nbe used if only the first character of a sequence of characters is to be capitalized.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :JAVA \"Character.toTitleCase(ch)\" :OTHERWISE (CHARACTER-UPCASE CH))))", Native.find_java_method("edu.isi.stella.Stella", "characterCapitalize", new java.lang.Class [] {java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("STRING-EQL?", "(DEFUN (STRING-EQL? BOOLEAN) ((X STRING) (Y STRING)) :DOCUMENTATION \"Return true if `x' and `y' are equal strings or are both undefined.  This\ntest is substituted automatically by the STELLA translator if `eql?' is applied\nto strings.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stringEqlP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-EQUAL?", "(DEFUN (STRING-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :DOCUMENTATION \"Return true if `x' and `y' are equal strings ignoring character case or\nare both undefined.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stringEqualP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-COMPARE", "(DEFUN (STRING-COMPARE INTEGER) ((X STRING) (Y STRING) (CASE-SENSITIVE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Compare `x' and `y' lexicographically, and return -1, 0, \nor 1, depending on whether `x' is less than, equal, or greater than `y'.\nIf `case-sensitive?' is true, then case does matter for the comparison\")", Native.find_java_method("edu.isi.stella.Stella", "stringCompare", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Boolean.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((X STRING)) :DOCUMENTATION \"Return true if `x' is the empty string \\\"\\\"\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (STRING-EQL? X \"\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_emptyP", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((X STRING)) :DOCUMENTATION \"Return true if `x' is not the empty string \\\"\\\"\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NOT (EMPTY? X))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_nonEmptyP", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((X STRING-WRAPPER)) :DOCUMENTATION \"Return true if `x' is the wrapped empty string \\\"\\\"\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (STRING-EQL? (WRAPPER-VALUE X) \"\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringWrapper", "emptyP", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((X STRING-WRAPPER)) :DOCUMENTATION \"Return true if `x' is not the wrapped empty string \\\"\\\"\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NOT (EMPTY? X))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringWrapper", "nonEmptyP", new java.lang.Class [] {})), null);
      Stella.defineFunctionObject("BLANK-STRING?", "(DEFUN (BLANK-STRING? BOOLEAN) ((STRING STRING)) :DOCUMENTATION \"Return true if `string' is either NULL, empty, or only\ncontains white space characters.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "blankStringP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING<", "(DEFUN (STRING< BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically < `y', considering case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringL", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING<=", "(DEFUN (STRING<= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically <= `y', considering case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringLE", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING>=", "(DEFUN (STRING>= BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically >= `y', considering case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringGE", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING>", "(DEFUN (STRING> BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically > `y', considering case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringG", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-LESS?", "(DEFUN (STRING-LESS? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically < `y', ignoring case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringLessP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-LESS-EQUAL?", "(DEFUN (STRING-LESS-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically <= `y', ignoring case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringLessEqualP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-GREATER-EQUAL?", "(DEFUN (STRING-GREATER-EQUAL? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically >= `y', ignoring case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringGreaterEqualP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-GREATER?", "(DEFUN (STRING-GREATER? BOOLEAN) ((X STRING) (Y STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return true if `x' is lexicographically > `y', ignoring case.\")", Native.find_java_method("edu.isi.stella.Stella", "stringGreaterP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-COMPARE-CASE-NORMALIZED", "(DEFUN (STRING-COMPARE-CASE-NORMALIZED INTEGER) ((X STRING) (Y STRING)) :DOCUMENTATION \"Compare `x' and `y' and return -1, 0, or 1, depending on whether\n`x' is less than, equal, or greater than `y' relative to the :ascii-case-normalized\ncollation.  In this collation `a < A < b' which gives strings that only differ in case a\ndefinite order while otherwise behaving identically to :ascii-case-insensitive.  This is\nsimilar to using a Java Collator for Locale.US with strength set to TERTIARY (which see).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stringCompareCaseNormalized", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("COMPARE-STRINGS", "(DEFUN (COMPARE-STRINGS INTEGER) ((X STRING) (Y STRING) (COLLATION KEYWORD)) :DOCUMENTATION \"Compare `x' and `y' and return -1, 0, or 1, depending on whether\n`x' is less than, equal, or greater than `y' relative to `collation'.  Currently\nsupported values for `collation' are :ascii-case-sensitive, :ascii-case-insensitive\n:ascii-case-normalized.  The first two correspond to `string-compare' called with\nthe appropriate third argument.  :ascii-case-normalized calls the function\n`string-compare-case-normalized' (which see).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "compareStrings", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("SAFE-COMPARE-STRINGS", "(DEFUN (SAFE-COMPARE-STRINGS INTEGER) ((X STRING) (Y STRING) (COLLATION KEYWORD)) :DOCUMENTATION \"Variant of `compare-strings' that also tolerates NULL values.\nNULL sorts after everything else in any collation.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "safeCompareStrings", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("MAKE-STRING", "(DEFUN (MAKE-STRING STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new string filled with `size' `initchar's.\" :PUBLIC? TRUE :NATIVE? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "makeString", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("MAKE-MUTABLE-STRING", "(DEFUN (MAKE-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER) (INITCHAR CHARACTER)) :DOCUMENTATION \"Return a new mutable string filled with `size' `initchar's.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:MAKE-STRING SIZE :INITIAL-ELEMENT INITCHAR) :CPP \"native_make_mutable_string(size, initchar)\" :JAVA \"#$(STELLAROOT).javalib.Native.makeMutableString(size, initchar)\")))", Native.find_java_method("edu.isi.stella.Stella", "makeMutableString", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("MAKE-RAW-MUTABLE-STRING", "(DEFUN (MAKE-RAW-MUTABLE-STRING MUTABLE-STRING) ((SIZE INTEGER)) :DOCUMENTATION \"Return a new uninitialized mutable string of `size'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (LET ((S MUTABLE-STRING NULL)) (VERBATIM :COMMON-LISP (SETQ S (CL:MAKE-STRING SIZE)) :CPP \"s = new (PointerFreeGC) char[size+1]; s[size]='\\\\0'\" :JAVA \"s = new StringBuffer(size); s.setLength(size)\") (RETURN S)))", Native.find_java_method("edu.isi.stella.Stella", "makeRawMutableString", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("STRING-CONCATENATE", "(DEFUN (STRING-CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING)) :DOCUMENTATION \"Return a new string representing the concatenation of\n`string1' and `string2'.\" :NATIVE? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringConcatenate", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
    }
  }

  static void helpStartupPrimal5() {
    {
      Stella.defineMethodObject("(DEFMETHOD (CONCATENATE STRING) ((STRING1 STRING) (STRING2 STRING) |&REST| (OTHERSTRINGS STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a new string representing the concatenation\nof `string1', `string2', and `otherStrings'.  The two mandatory parameters\nallow us to optimize the common binary case by not relying on the somewhat\nless efficient variable arguments mechanism.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_concatenate", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")})), null);
      Stella.defineFunctionObject("STRING-UPCASE", "(DEFUN (STRING-UPCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return an upper-case copy of `string'.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringUpcase", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-DOWNCASE", "(DEFUN (STRING-DOWNCASE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a lower-case copy of `string'.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringDowncase", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-CAPITALIZE", "(DEFUN (STRING-CAPITALIZE STRING) ((STRING STRING)) :DOCUMENTATION \"Return a capitalized version of `string'.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringCapitalize", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD (COPY STRING) ((STRING STRING)) :DOCUMENTATION \"Return a copy of `string'.\" :NATIVE? TRUE :C-CALLABLE? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_copy", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (COPY MUTABLE-STRING) ((STRING MUTABLE-STRING)) :DOCUMENTATION \"Return a copy of `string'.\" :NATIVE? TRUE :C-CALLABLE? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "mutableString_copy", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE STRING) ((SELF STRING) (NEW-CHAR CHARACTER) (OLD-CHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of `old-char' with `new-char'\nin the string `self'.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_substitute", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Character.TYPE, java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE MUTABLE-STRING) ((SELF MUTABLE-STRING) (NEW-CHAR CHARACTER) (OLD-CHAR CHARACTER)) :DOCUMENTATION \"Substitute all occurences of `old-char' with `new-char'\nin the string `self'.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "mutableString_substitute", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE, java.lang.Character.TYPE})), null);
      Stella.defineFunctionObject("HELP-SUBSTITUTE-CHARACTERS", "(DEFUN (HELP-SUBSTITUTE-CHARACTERS MUTABLE-STRING) ((SELF MUTABLE-STRING) (NEW-CHARS STRING) (OLD-CHARS STRING)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE (LET ((POS INTEGER NULL)) (FOREACH I IN (INTERVAL 0 (1- (LENGTH SELF))) DO (SETQ POS (POSITION OLD-CHARS (NTH SELF I) 0)) (WHEN (DEFINED? POS) (SETF (NTH SELF I) (NTH NEW-CHARS POS)))) (RETURN SELF)))", Native.find_java_method("edu.isi.stella.Stella", "helpSubstituteCharacters", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE-CHARACTERS MUTABLE-STRING) ((SELF MUTABLE-STRING) (NEW-CHARS STRING) (OLD-CHARS STRING)) :DOCUMENTATION \"Substitute all occurences of of a member of `old-chars' with the \ncorresponding member of `new-chars' in the string `self'.  IMPORTANT:  The return\nvalue should be used instead of relying on destructive substitution, since the\nsubstitution will not be destructive in all translated languages.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_substituteCharacters", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE-CHARACTERS STRING) ((SELF STRING) (NEW-CHARS STRING) (OLD-CHARS STRING)) :DOCUMENTATION \"Substitute all occurences of of a member of `old-chars' with the \ncorresponding member of `new-chars' in the string `self'.  Returns a new string.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_substituteCharacters", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")})), null);
      Stella.defineFunctionObject("REPLACE-SUBSTRINGS", "(DEFUN (REPLACE-SUBSTRINGS STRING) ((STRING STRING) (NEW STRING) (OLD STRING)) :DOCUMENTATION \"Replace all occurrences of `old' in `string' with `new'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "replaceSubstrings", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("INSTANTIATE-STRING-TEMPLATE", "(DEFUN (INSTANTIATE-STRING-TEMPLATE STRING) ((TEMPLATE STRING) |&REST| (|VARS&VALUES| STRING)) :DOCUMENTATION \"For each occurrence of a <var> string from `vars&values' in `template' replace it\nwith its corresponding <value> string.  Replacement is done in sequence which\nmeans (part of) a value might be replaced further with a later <var> and <value>.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "instantiateStringTemplate", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("INSERT-STRING", "(DEFUN (INSERT-STRING INTEGER) ((SOURCE STRING) (START INTEGER) (END INTEGER) (TARGET MUTABLE-STRING) (TARGET-INDEX INTEGER) (CASE-CONVERSION KEYWORD)) :DOCUMENTATION \"Inserts characters from `source' begining at `start' and\nending at `end' into `target' starting at `target-index'.  If `end' is `null',\nthen the entire length of the string is used. The copy of characters is affected\nby the `case-conversion' keyword which should be one of\n   :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.\n\nThe final value of target-index is returned.\")", Native.find_java_method("edu.isi.stella.Stella", "insertString", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.StringBuffer"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("STRING-TRIM", "(DEFUN (STRING-TRIM STRING) ((STRING STRING)) :DOCUMENTATION \"Remove any leading and trailing white space from `string'\nand return a copy of the trimmed substring (which might be empty if we had\nall white space).  If no white space was removed, `string' is returned\nunmodified and uncopied.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stringTrim", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("INTEGER-TO-STRING", "(DEFUN (INTEGER-TO-STRING STRING) ((I LONG-INTEGER)) :DOCUMENTATION \"Convert `i' to its string representation and return the result.\n This is more efficient than using a string stream.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "integerToString", new java.lang.Class [] {java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("INT-TO-STRING", "(DEFUN (INT-TO-STRING STRING) ((I INTEGER)) :DOCUMENTATION \"Convert `i' to its string representation and return the result.\nThis is a convenience function that expects regular integers as opposed to longs\nwhich is useful in contexts where we do automatic unwrapping based on the target.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (INTEGER-TO-STRING I)))", Native.find_java_method("edu.isi.stella.Stella", "intToString", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("INTEGER-TO-HEX-STRING", "(DEFUN (INTEGER-TO-HEX-STRING STRING) ((I LONG-INTEGER)) :DOCUMENTATION \"Convert `i' to a string representation in hexadecimal notation and return the result.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "integerToHexString", new java.lang.Class [] {java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("INTEGER-TO-STRING-IN-BASE", "(DEFUN (INTEGER-TO-STRING-IN-BASE STRING) ((I LONG-INTEGER) (BASE INTEGER)) :DOCUMENTATION \"Convert `i' to a string representation in `base' and return the\nresult.  `base' must be positive and not more than 36.\n\nNote that in the C++ version, only 8, 10 and 16 will work as `base' arguments,\nsince that is all the underlying implementation supports.  Other argument\nvalues will be treated as `10'.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "integerToStringInBase", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("FLOAT-TO-STRING", "(DEFUN (FLOAT-TO-STRING STRING) ((F FLOAT)) :DOCUMENTATION \"Convert `f' to its string representation and return the result.  This is more\nefficient than using a string stream.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "floatToString", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("CHARACTER-TO-STRING", "(DEFUN (CHARACTER-TO-STRING STRING) ((C CHARACTER)) :DOCUMENTATION \"Convert `c' into a one-element string and return the result.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MAKE-STRING 1 C)))", Native.find_java_method("edu.isi.stella.Stella", "characterToString", new java.lang.Class [] {java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("STELLA-INTEGER-TO-STRING-IN-BASE", "(DEFUN (STELLA-INTEGER-TO-STRING-IN-BASE STRING) ((INTEGER LONG-INTEGER) (BASE INTEGER)) :DOCUMENTATION \"STELLA version of `integer-to-string-in-base' which is faster than\nthe C++ version we have but slower than the native Java version.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stellaIntegerToStringInBase", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("STRING-TO-INTEGER", "(DEFUN (STRING-TO-INTEGER LONG-INTEGER) ((STRING STRING)) :DOCUMENTATION \"Convert a `string' representation of an integer into an integer.\nUse `parse-long-integer' if the syntax of `string' needs to be checked for errors.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringToInteger", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-TO-INT", "(DEFUN (STRING-TO-INT INTEGER) ((STRING STRING)) :DOCUMENTATION \"Convert a `string' representation of an integer into an integer.\nThis is a convenience function that ensures a regular integer return value.  If\n`string' represents a long integer, the behavior is undefined.  Use `parse-integer'\nif the syntax of `string' needs to be checked for errors.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (STRING-TO-INTEGER STRING)))", Native.find_java_method("edu.isi.stella.Stella", "stringToInt", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STRING-TO-FLOAT", "(DEFUN (STRING-TO-FLOAT FLOAT) ((STRING STRING)) :DOCUMENTATION \"Convert a `string' representation of a float into a float.\nUse `parse-float' if the syntax of `string' needs to be checked for errors.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringToFloat", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("FORMAT-FLOAT", "(DEFUN (FORMAT-FLOAT STRING) ((F FLOAT) (NDECIMALS INTEGER)) :DOCUMENTATION \"Print `f' in fixed-point format with `nDecimals' behind the decimal point\nand return the result as a string.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "formatFloat", new java.lang.Class [] {java.lang.Double.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("FORMAT-WITH-PADDING", "(DEFUN (FORMAT-WITH-PADDING STRING) ((INPUT STRING) (LENGTH INTEGER) (PADCHAR CHARACTER) (ALIGN KEYWORD) (TRUNCATE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Formats `input' to be (at least) `length' long, using `padchar' to\nfill if necessary.  `align' must be one of :LEFT, :RIGHT, :CENTER and will control\nhow `input' will be justified in the resulting string.  If `truncate?' is true, then\nthen an overlength string will be truncated, using the opposite of `align' to pick\nthe truncation direction.\")", Native.find_java_method("edu.isi.stella.Stella", "formatWithPadding", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Character.TYPE, Native.find_java_class("edu.isi.stella.Keyword"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("ZERO-PAD-INTEGER", "(DEFUN (ZERO-PAD-INTEGER STRING) ((VALUE INTEGER) (SIZE INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns a string representing `value' of at least length\n'size', padded if necessary with 0 characters.\")", Native.find_java_method("edu.isi.stella.Stella", "zeroPadInteger", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("ZERO-PAD-STRING", "(DEFUN (ZERO-PAD-STRING STRING) ((INPUT STRING) (SIZE INTEGER)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.stella.Stella", "zeroPadString", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF STRING) (CHAR CHARACTER)) :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_memberP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIRST CHARACTER) ((SELF STRING)) :DOCUMENTATION \"Return the first character of `self'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 0)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_first", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIRST CHARACTER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the first character of `self' (settable via `setf').\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 0)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_first", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIRST-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER)) :DOCUMENTATION \"Set the first character of `self' to `ch' and return `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH SELF 0) CH)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_firstSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SECOND CHARACTER) ((SELF STRING)) :DOCUMENTATION \"Return the second character of `self'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 1)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_second", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (SECOND CHARACTER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the second character of `self' (settable via `setf').\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 1)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_second", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (SECOND-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER)) :DOCUMENTATION \"Set the second character of `self' to `ch' and return `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH SELF 1) CH)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_secondSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (THIRD CHARACTER) ((SELF STRING)) :DOCUMENTATION \"Return the third character of `self'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 2)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_third", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (THIRD CHARACTER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the third character of `self' (settable via `setf').\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 2)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_third", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (THIRD-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER)) :DOCUMENTATION \"Set the third character of `self' to `ch' and return `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH SELF 2) CH)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_thirdSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (FOURTH CHARACTER) ((SELF STRING)) :DOCUMENTATION \"Return the fourth character of `self'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 3)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_fourth", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FOURTH CHARACTER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the fourth character of `self' (settable via `setf').\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 3)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_fourth", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FOURTH-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER)) :DOCUMENTATION \"Set the fourth character of `self' to `ch' and return `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH SELF 3) CH)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_fourthSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIFTH CHARACTER) ((SELF STRING)) :DOCUMENTATION \"Return the fifth character of `self'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 4)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_fifth", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIFTH CHARACTER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the fifth character of `self' (settable via `setf').\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH SELF 4)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_fifth", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (FIFTH-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER)) :DOCUMENTATION \"Set the fifth character of `self' to `ch' and return `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH SELF 4) CH)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_fifthSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (NTH CHARACTER) ((SELF STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_nth", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (NTH CHARACTER) ((SELF MUTABLE-STRING) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) :CPP \"self[position]\" :JAVA \"self.charAt(position)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_nth", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF MUTABLE-STRING) (CH CHARACTER) (POSITION INTEGER)) :DOCUMENTATION \"Set the character in `self' at `position' to `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (SETF (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)) (CL:THE CL:CHARACTER CH)) :CPP \"self[position] = ch\" :JAVA \"#$(STELLAROOT).javalib.Native.mutableString_nthSetter(self, ch, position)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_nthSetter", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Character.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (REST STRING) ((SELF STRING)) :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_rest", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_length", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF MUTABLE-STRING)) :DOCUMENTATION \"Return the length of the string `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LENGTH SELF) :CPP \"strlen(self)\" :JAVA \"self.length()\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "mutableString_length", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer")})), null);
      Stella.defineMethodObject("(DEFMETHOD (POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (START INTEGER)) :DOCUMENTATION \"Return the position of `character' within `string' (counting\nfrom zero); or return NULL if `character' does not occur within `string'.\nIf `start' was supplied as non-NULL, only consider the substring starting\nat `start', however, the returned position will always be relative to the\nentire string.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_position", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Character.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LAST-POSITION INTEGER) ((STRING STRING) (CHARACTER CHARACTER) (END INTEGER)) :DOCUMENTATION \"Return the last position of `character' within `string'\n(counting from zero); or return NULL if `character' does not occur \nwithin `string'.  If `end' was supplied as non-NULL, only consider\nthe substring ending at `end', however, the returned position will\nalways be relative to the entire string.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_lastPosition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Character.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineFunctionObject("STRING-SEARCH", "(DEFUN (STRING-SEARCH INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence of\n`substring' in `string', beginning from `start'.  Return NULL if it is not\na substring.  The comparison is exact.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringSearch", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("STRING-SEARCH-IGNORE-CASE", "(DEFUN (STRING-SEARCH-IGNORE-CASE INTEGER) ((STRING STRING) (SUBSTRING STRING) (START INTEGER)) :DOCUMENTATION \"Return start position of the left-most occurrence of\n`substring' in `string', beginning from `start'.  Return NULL if it is not\na substring.  The comparison ignores differences in letter case.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "stringSearchIgnoreCase", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("STARTS-WITH?", "(DEFUN (STARTS-WITH? BOOLEAN) ((STRING STRING) (PREFIX STRING) (START INTEGER)) :DOCUMENTATION \"Return TRUE if `string' starts with `prefix' starting from\n`start' (which defaults to 0 if it is supplied as NULL).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "startsWithP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("ENDS-WITH?", "(DEFUN (ENDS-WITH? BOOLEAN) ((STRING STRING) (SUFFIX STRING) (END INTEGER)) :DOCUMENTATION \"Return TRUE if the substring of `string' ending at `end'\nends with `suffix'.  If `end' is NULL it defaults to the length of `string'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "endsWithP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("HELP-FIND-MATCHING-PREFIX-LENGTH", "(DEFUN (HELP-FIND-MATCHING-PREFIX-LENGTH INTEGER) ((STRING1 STRING) (START1 INTEGER) (END1 INTEGER) (STRING2 STRING) (START2 INTEGER) (END2 INTEGER)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Helping function for `find-matching-prefix' that requires `end1' and `end2'\nto be properly set up.\" (LET ((I1 START1) (I2 START2)) (WHILE (AND (< I1 END1) (< I2 END2) (EQL? (NTH STRING1 I1) (NTH STRING2 I2))) (++ I1) (++ I2)) (RETURN (- I1 START1))))", Native.find_java_method("edu.isi.stella.Stella", "helpFindMatchingPrefixLength", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("FIND-MATCHING-PREFIX-LENGTH", "(DEFUN (FIND-MATCHING-PREFIX-LENGTH INTEGER) ((STRING1 STRING) (START1 INTEGER) (END1 INTEGER) (STRING2 STRING) (START2 INTEGER) (END2 INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Finds the length of the matching prefix strings of `string1' and\n`string2', starting at position `start1' and `start2' respectively.\nThe search will end when `end1' or `end2' is reached.  If either `end1'\nor `end2' is null, then they will be set to the length of their respective\nstrings.\")", Native.find_java_method("edu.isi.stella.Stella", "findMatchingPrefixLength", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("FIND-MISMATCH", "(DEFUN (FIND-MISMATCH INTEGER INTEGER) ((STRING1 STRING) (START1 INTEGER) (END1 INTEGER) (STRING2 STRING) (START2 INTEGER) (END2 INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Finds the first position in each of `string1' and `string2' where\nthey mismatch, starting at position `start1' and `start2' respectively.\nThe search will end when `end1' or `end2' is reached.  If either `end1'\nor `end2' is null, then they will be set to the length of their respective\nstrings.  If there is no mismatch, then `null' values are returned.\")", Native.find_java_method("edu.isi.stella.Stella", "findMismatch", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("[Ljava.lang.Object;")}), null);
    }
  }

  static void helpStartupPrimal6() {
    {
      Stella.defineFunctionObject("NON-MATCHING-POSITION-HELPER", "(DEFUN (NON-MATCHING-POSITION-HELPER INTEGER) ((SOURCE STRING) (START INTEGER) (END INTEGER) (MATCH STRING)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Helper for `non-matching-position' that requires `end' to not be `null'.\" (WHILE (AND (< START END) (MEMBER? MATCH (NTH SOURCE START))) (++ START)) (RETURN START))", Native.find_java_method("edu.isi.stella.Stella", "nonMatchingPositionHelper", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NON-MATCHING-POSITION", "(DEFUN (NON-MATCHING-POSITION INTEGER) ((SOURCE STRING) (START INTEGER) (MATCH STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the index into `source', starting from `start', of the first\ncharacter that is not included in `match'.\")", Native.find_java_method("edu.isi.stella.Stella", "nonMatchingPosition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("HELP-ADVANCE-PAST-WHITESPACE", "(DEFUN (HELP-ADVANCE-PAST-WHITESPACE INTEGER) ((SOURCE STRING) (START INTEGER) (END INTEGER)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Helper for `advance-past-whitespace' that requires `end' to be properly set.\" (WHILE (AND (< START END) (WHITE-SPACE-CHARACTER? (NTH SOURCE START))) (++ START)) (RETURN START))", Native.find_java_method("edu.isi.stella.Stella", "helpAdvancePastWhitespace", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("ADVANCE-PAST-WHITESPACE", "(DEFUN (ADVANCE-PAST-WHITESPACE INTEGER) ((SOURCE STRING) (START INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the first index into `source', starting from `start', of\nthe first character that is not white space.\")", Native.find_java_method("edu.isi.stella.Stella", "advancePastWhitespace", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("EQL-EXCEPT-IN-WHITESPACE?", "(DEFUN (EQL-EXCEPT-IN-WHITESPACE? BOOLEAN) ((S1 STRING) (S2 STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the strings `s1' and `s2' are the same\nexcept for the amounts of whitespace separating words.  Leading or\ntrailing whitespace is also not considered.\")", Native.find_java_method("edu.isi.stella.Stella", "eqlExceptInWhitespaceP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSEQUENCE STRING) ((STRING STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of `string' beginning at position `start'\nand ending up to but not including position `end', counting from zero.  An\n`end' value of NULL stands for the rest of the string.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "string_subsequence", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSEQUENCE STRING) ((STRING MUTABLE-STRING) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of `string' beginning at position `start'\nand ending up to but not including position `end', counting from zero.  An\n`end' value of NULL stands for the rest of the string.\" :NATIVE? TRUE :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.javalib.Native", "mutableString_subsequence", new java.lang.Class [] {Native.find_java_class("java.lang.StringBuffer"), java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineFunctionObject("SPLIT-STRING", "(DEFUN (SPLIT-STRING (CONS OF STRING-WRAPPER)) ((INPUT STRING) (SEPARATOR CHARACTER)) :DOCUMENTATION \"Split `input' into separate strings based on the `separator' character.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "splitString", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Character.TYPE}), null);
      Stella.defineFunctionObject("STRINGIFY", "(DEFUN (STRINGIFY STRING) ((EXPRESSION OBJECT)) :DOCUMENTATION \"Print `expression' onto a string and return the result.\nPrinting is done with `*printReadably?*' set to true and with `*printPretty?*'\nset to false.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "stringify", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("UNSTRINGIFY", "(DEFUN (UNSTRINGIFY OBJECT) ((STRING STRING)) :DOCUMENTATION \"Read a STELLA expression from `string' and return the result.\nThis is identical to `read-s-expression-from-string'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (READ-S-EXPRESSION-FROM-STRING STRING)))", Native.find_java_method("edu.isi.stella.Stella", "unstringify", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD FREE-HASH-TABLE-VALUES ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Call free on each value in the hash table `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.AbstractHashTable", "freeHashTableValues", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF ABSTRACT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.AbstractHashTable", "initializeHashTable", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.HashTable", "lookup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.HashTable", "insertAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.HashTable", "removeAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.IntegerHashTable", "initializeHashTable", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF INTEGER-HASH-TABLE) (KEY INTEGER)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.IntegerHashTable", "lookup", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF INTEGER-HASH-TABLE) (KEY INTEGER) (VALUE OBJECT)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.IntegerHashTable", "insertAt", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF INTEGER-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.IntegerHashTable", "removeAt", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF FLOAT-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.FloatHashTable", "initializeHashTable", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF FLOAT-HASH-TABLE) (KEY FLOAT)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.FloatHashTable", "lookup", new java.lang.Class [] {java.lang.Double.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF FLOAT-HASH-TABLE) (KEY FLOAT) (VALUE OBJECT)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.FloatHashTable", "insertAt", new java.lang.Class [] {java.lang.Double.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF FLOAT-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.FloatHashTable", "removeAt", new java.lang.Class [] {java.lang.Double.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringHashTable", "initializeHashTable", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringHashTable", "lookup", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF STRING-HASH-TABLE) (KEY STRING) (VALUE OBJECT)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringHashTable", "insertAt", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object")})), null);
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF STRING-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringHashTable", "removeAt", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STRING-TO-INTEGER-HASH-TABLE)) :DOCUMENTATION \"Insert a newly-created native hash table into `self'.\")", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringToIntegerHashTable", "initializeHashTable", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP INTEGER) ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringToIntegerHashTable", "lookup", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING) (VALUE INTEGER)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringToIntegerHashTable", "insertAt", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF STRING-TO-INTEGER-HASH-TABLE) (KEY STRING)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringToIntegerHashTable", "removeAt", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineFunctionObject("HASHMOD", "(DEFUN (HASHMOD INTEGER) ((CODE INTEGER) (SIZE INTEGER)) :DOCUMENTATION \"Map the hash code `code' onto a bucket index for a hash table\nof `size' (i.e., onto the interval [0..size-1].  This is just like `rem' for\npositive hash codes but also works for negative hash codes by mapping those\nonto a positive number first.  Note, that the sign conversion mapping is not\nequivalent to calling the `abs' function (it simply masks the sign bit for\nspeed) and therefore really only makes sense for hash codes.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:REM (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*)) SIZE) :CPP \"(((unsigned int) code) % size)\" :JAVA \"((code & 0x7FFFFFFF) % size)\")))", Native.find_java_method("edu.isi.stella.Stella", "hashmod", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("ROTATE-HASH-CODE", "(DEFUN (ROTATE-HASH-CODE INTEGER) ((ARG INTEGER)) :DOCUMENTATION \"Rotate `arg' to the right by 1 position.  This means shift `arg' to the right\nby one and feed in `arg's bit zero from the left.  In Lisp the result will stay\nin positive FIXNUM range.  In C++ and Java this might return a negative\nvalue which might be equal to NULL-INTEGER.  Important: to make this inlinable,\nit must be called with an atom (i.e., constant or variable) as its argument.\nThis function is primarily useful for hashing sequences of items where the hash\ncode should take the sequential order of elements into account (e.g., lists).\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE (= (LOGAND ARG 1) 0) (UNSIGNED-SHIFT-RIGHT-BY-1 ARG) (LOGOR (SHIFT-RIGHT ARG 1) *INTEGER-MSB-MASK*))))", Native.find_java_method("edu.isi.stella.Stella", "rotateHashCode", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("OBJECT-HASH-CODE", "(DEFUN (OBJECT-HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self' (can be negative).  Two objects that are `eq?'\nare guaranteed to generate the same hash code.  Two objects that are not `eq?'\ndo not necessarily generate different hash codes.  Similar to `hash-code' but\nalways hashes on the address of `self' even if it is a wrapper.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP \"(STELLA::%%OBJECT-HASH-CODE SELF)\" :CPP \"(size_t)self\" :JAVA \"self.hashCode()\")))", Native.find_java_method("edu.isi.stella.Stella_Object", "objectHashCode", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self' (can be negative).  Two objects that are `eql?'\nare guaranteed to generate the same hash code.  Two objects that are not `eql?'\ndo not necessarily generate different hash codes.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella_Object", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineFunctionObject("SAFE-HASH-CODE", "(DEFUN (SAFE-HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self'.  Just like `hash-code'\n- which see, but also works for NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "safeHashCode", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF STANDARD-OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (OBJECT-HASH-CODE SELF)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StandardObject", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF WRAPPER)) :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Wrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF STRING-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.StringWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.IntegerWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF LONG-INTEGER-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.LongIntegerWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF FLOAT-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.FloatWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF CHARACTER-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (HASH-CODE (WRAPPER-VALUE SELF))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.CharacterWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF BOOLEAN-WRAPPER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE (WRAPPER-VALUE SELF) 7333705 1891526)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.BooleanWrapper", "hashCode_", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SXHASH SELF) :JAVA \"self.hashCode()\" :CPP \"native_hash_string(self)\" :OTHERWISE (HASH-STRING SELF 0))))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_hashCode_", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN SELF))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_hashCode_", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF LONG-INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CAST (LOGAND (LOGXOR SELF (SHIFT-RIGHT SELF 32)) MOST-POSITIVE-INTEGER) INTEGER)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_hashCode_", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF FLOAT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SXHASH SELF) :CPP \"(size_t)self\" :JAVA \"(int)(Double.doubleToLongBits(self)^(Double.doubleToLongBits(self)>>>32))\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "float_hashCode_", new java.lang.Class [] {java.lang.Double.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (HASH-CODE INTEGER) ((SELF CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (LOGXOR (AREF *HASH-BYTE-RANDOM-TABLE* (CHARACTER-CODE SELF)) 15119378)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "character_hashCode_", new java.lang.Class [] {java.lang.Character.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self' (can be negative).  Two objects that are `equal?'\nare guaranteed to generate the same hash code (provided, that writers of\n`object-equal?' methods also implemented the appropriate `equal-hash-code'\nmethod).  Two objects that are not `equal?'do not necessarily generate different\nhash codes.\" :PUBLIC? TRUE)", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella_Object", "equalHashCode", new java.lang.Class [] {})), null);
      Stella.defineFunctionObject("SAFE-EQUAL-HASH-CODE", "(DEFUN (SAFE-EQUAL-HASH-CODE INTEGER) ((SELF OBJECT)) :DOCUMENTATION \"Return a hash code for `self'.  Just like `equal-hash-code'\n- which see, but also works for NULL.  `equal-hash-code' methods that expect to\nhandle NULL components should use this function for recursive calls.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "safeEqualHashCode", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("HASH-STRING", "(DEFUN (HASH-STRING INTEGER) ((STRING STRING) (SEEDCODE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Generate a hash-code for `string' and return it.\nTwo strings that are equal but not eq will generate the same code.\nThe hash-code is based on `seedCode' which usually will be 0.  However,\n`seedCode' can also be used to supply the result of a previous hash\noperation to achieve hashing on sequences of strings without actually\nhaving to concatenate them.\" (LET ((CODE SEEDCODE) (CURSOR (LENGTH STRING))) (IF (= CURSOR 0) (RETURN 4303803) (-- CURSOR)) (LOOP (SETQ CODE (LOGXOR CODE (AREF *HASH-BYTE-RANDOM-TABLE* (CHARACTER-CODE (NTH STRING CURSOR))))) (IF (= CURSOR 0) (BREAK) (-- CURSOR)) (SETQ CODE (ROTATE-HASH-CODE CODE))) (RETURN CODE)))", Native.find_java_method("edu.isi.stella.Stella", "hashString", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("PICK-HASH-TABLE-SIZE-PRIME", "(DEFUN (PICK-HASH-TABLE-SIZE-PRIME INTEGER) ((MINSIZE INTEGER)) :DOCUMENTATION \"Return a hash table prime of at least `minSize'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "pickHashTableSizePrime", new java.lang.Class [] {java.lang.Integer.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-VECTOR ((SELF VECTOR)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Vector", "initializeVector", new java.lang.Class [] {})), null);
      Stella.defineFunctionObject("RESIZE-VECTOR", "(DEFUN RESIZE-VECTOR ((SELF VECTOR) (SIZE INTEGER)) :DOCUMENTATION \"Change the size of `self' to `size'.  If `size' is smaller\nthan the current size of `self' the vector will be truncated.  Otherwise, \nthe internal array of `self' will be grown to `size' and unused elements\nwill be initialized to NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "resizeVector", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Vector"), java.lang.Integer.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (POSITION INTEGER)) :DOCUMENTATION \"Return the element in `self' at `position'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:AREF SELF POSITION) :CPP \"self[position]\" :JAVA \"self[position]\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "nativeVector_nth", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF NATIVE-VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :DOCUMENTATION \"Set the element in `self' at `position' to `value'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SETF (CL:AREF SELF POSITION) VALUE) :CPP \"self[position] = value\" :JAVA \"self[position] = value\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "nativeVector_nthSetter", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE})), null);
      Stella.defineFunctionObject("UNMAKE", "(DEFUN UNMAKE ((SELF OBJECT)))", Native.find_java_method("edu.isi.stella.Stella_Object", "unmake", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("NATIVE-PROBE-FILE?", "(DEFUN (NATIVE-PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return true if file `fileName' exists.  Note that this does\nnot necessarily mean that the file can also be read.  This does not handle any\nnecessary pathname translations or error conditions.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "nativeProbeFileP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NATIVE-PROBE-DIRECTORY?", "(DEFUN (NATIVE-PROBE-DIRECTORY? BOOLEAN) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return true if file `fileName' exists and is a directory.\nNote that this does not necessarily mean that the directory can also be read.\nThis does not handle any necessary pathname translations or error conditions.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "nativeProbeDirectoryP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
    }
  }

  static void helpStartupPrimal7() {
    {
      Stella.defineFunctionObject("PROBE-FILE?", "(DEFUN (PROBE-FILE? BOOLEAN) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return true if file `fileName' exists.  Note that this does\nnot necessarily mean that the file can also be read.\nIMPORTANT Java idiosyncrasy: if file `foo/bar' exists and is not a directory,\nJava will also say `foo/bar/' exists, which is different behavior than in Lisp\nand C++.  For this reason, make sure to always use `probe-directory?' to test\nwhether a directory exists.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "probeFileP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("PROBE-DIRECTORY?", "(DEFUN (PROBE-DIRECTORY? BOOLEAN) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return true if file `fileName' exists and is a directory.\nNote that this does not necessarily mean that the directory can also be read.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "probeDirectoryP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NATIVE-FILE-WRITE-DATE", "(DEFUN (NATIVE-FILE-WRITE-DATE CALENDAR-DATE) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return the time at which file `fileName' was last modified or\nNULL if that cannot be determined.  This does not handle any necessary pathname\ntranslations or error conditions.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "nativeFileWriteDate", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("FILE-WRITE-DATE", "(DEFUN (FILE-WRITE-DATE CALENDAR-DATE) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return the time at which file `fileName' was last modified or\nNULL if that cannot be determined.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "fileWriteDate", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NATIVE-FILE-LENGTH", "(DEFUN (NATIVE-FILE-LENGTH LONG-INTEGER) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return the length of file `fileName' in bytes or NULL if that\ncannot be determined.  This does not handle any necessary pathname translations\nor error conditions.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "nativeFileLength", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("FILE-LENGTH", "(DEFUN (FILE-LENGTH LONG-INTEGER) ((FILENAME FILE-NAME)) :DOCUMENTATION \"Return the length of file `fileName' in bytes or NULL if that\ncannot be determined.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "fileLength", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NATIVE-DELETE-FILE", "(DEFUN NATIVE-DELETE-FILE ((FILENAME FILE-NAME)) :DOCUMENTATION \"Delete the file `fileName'.  This does not handle any necessary\npathname translations or error conditions.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "nativeDeleteFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("DELETE-FILE", "(DEFUN DELETE-FILE ((FILENAME FILE-NAME)) :DOCUMENTATION \"Delete the file `fileName'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "deleteFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("NATIVE-RENAME-FILE", "(DEFUN NATIVE-RENAME-FILE ((FROMFILE FILE-NAME) (TOFILE FILE-NAME)) :DOCUMENTATION \"Rename the file `fromFile' to `toFile'.  This does not handle\nany necessary pathname translations or error conditions.\" :NATIVE? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "nativeRenameFile", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("RENAME-FILE", "(DEFUN RENAME-FILE ((FROMFILE FILE-NAME) (TOFILE FILE-NAME)) :DOCUMENTATION \"Rename the file `fromFile' to `toFile'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "renameFile", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("COPY-STREAM-TO-STREAM", "(DEFUN COPY-STREAM-TO-STREAM ((IN INPUT-STREAM) (OUT OUTPUT-STREAM)) :DOCUMENTATION \"Copy `in' verbatimely to `out'.  Does the right thing for binary data.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.InputStream", "copyStreamToStream", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.InputStream"), Native.find_java_class("edu.isi.stella.OutputStream")}), null);
      Stella.defineFunctionObject("COPY-FILE", "(DEFUN COPY-FILE ((FROMFILE FILE-NAME) (TOFILE FILE-NAME)) :DOCUMENTATION \"Copy file `fromFile' to file `toFile', clobbering\nany data already in `toFile'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "copyFile", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("GET-TEMP-DIRECTORY", "(DEFUN (GET-TEMP-DIRECTORY STRING) () :DOCUMENTATION \"Return a suitable directory for temporary files.\nUses the value of `stella.tempDirectory' if defined; otherwise, it\nwill use a suitable OS-specific default.  The returned directory will\nend in a separator for immediate concatenation with a physical filename.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "getTempDirectory", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("MAKE-TEMPORARY-FILE-NAME", "(DEFUN (MAKE-TEMPORARY-FILE-NAME STRING) ((PREFIX STRING) (SUFFIX STRING)) :DOCUMENTATION \"Return a file name of the form `<prefix>NNNNNN<suffix>'\nwhich is guaranteed to not refer to any existing file.  A null `prefix'\ndefaults to `tmpfile', a null `suffix' defaults to the empty string.\nThe number portion NNNNNN will correpond to a random number between 0\nand 999999.  If no qualifying filename can be found after 100 attempts,\nNULL will be returned.  Note that it is possible due to multi-threading\nor processing that the generated filename becomes used by another thread\nor OS process.  If necessary, this case can be handled by the caller.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "makeTemporaryFileName", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("MAKE-TEMPORARY-FILE", "(DEFUN (MAKE-TEMPORARY-FILE STRING) ((PREFIX STRING) (SUFFIX STRING)) :DOCUMENTATION \"Variant of `make-temporary-file-name' that actually\nallocates the file to prevent other processes from using that name.\nThis is still not fully thread safe - for that we would need a file lock -\nbut maybe a bit better in avoiding collisions.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "makeTemporaryFile", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CL-LIST-DIRECTORY-FILES", "(DEFUN (CL-LIST-DIRECTORY-FILES (CONS OF STRING-WRAPPER)) ((DIRECTORY STRING)))", Native.find_java_method("edu.isi.stella.Stella", "clListDirectoryFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CPP-LIST-DIRECTORY-FILES", "(DEFUN (CPP-LIST-DIRECTORY-FILES (CONS OF STRING-WRAPPER)) ((DIRECTORY STRING)))", Native.find_java_method("edu.isi.stella.Stella", "cppListDirectoryFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("JAVA-LIST-DIRECTORY-FILES", "(DEFUN (JAVA-LIST-DIRECTORY-FILES (CONS OF STRING-WRAPPER)) ((DIRECTORY STRING)))", Native.find_java_method("edu.isi.stella.Stella", "javaListDirectoryFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("LIST-DIRECTORY-FILES", "(DEFUN (LIST-DIRECTORY-FILES (CONS OF STRING-WRAPPER)) ((DIRECTORY STRING)) :DOCUMENTATION \"Return all the files and sub-directories in `directory' sorted by name.\nEach returned file is a bare file name without a `directory' component.  If a file is\na directory, it will look just like a plain file.  This means consumers might have to\nexplicitly test whether a file is a directory depending on what they do. Excludes . and ..\ndirectories.  Handles logical pathnames but resulting files will always use physical pathname\nsyntax.  This is mostly consistent across native languages, but some differences still exist -\ne.g., Lisp will convert . or .. into absolute pathnames.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "listDirectoryFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "listDirectoryFilesEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("LIST-DIRECTORY-FILES-RECURSIVELY", "(DEFUN (LIST-DIRECTORY-FILES-RECURSIVELY (CONS OF STRING-WRAPPER)) ((DIRECTORY STRING)) :DOCUMENTATION \"Just like `list-directory-files' (which see) but also recurses into\nsubdirectories.  Files at the top level of `directory' will be bare file names without\na `directory' component.  Files in subdirectories will be prefixed with the relative\nsubdirectory path starting right below `directory'.  The sort order is lexicographic\nwithin directories which results in a depth-first presentation order of files.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "listDirectoryFilesRecursively", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "listDirectoryFilesRecursivelyEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("CPP-CREATE-DIRECTORY", "(DEFUN CPP-CREATE-DIRECTORY ((DIRECTORY STRING)))", Native.find_java_method("edu.isi.stella.Stella", "cppCreateDirectory", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CREATE-DIRECTORIES", "(DEFUN CREATE-DIRECTORIES ((DIRECTORY STRING)) :DOCUMENTATION \"If `directory' does not yet exist, create it and any of its parents\nthat do not yet exist.  If `directory' already does exist, this simply is a no-op.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "createDirectories", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "createDirectoriesEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("ENSURE-DIRECTORIES-EXIST", "(DEFUN ENSURE-DIRECTORIES-EXIST ((FILENAME FILE-NAME)) :DOCUMENTATION \"Ensure all physical directories in the directory portion of `fileName' exist.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "ensureDirectoriesExist", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "ensureDirectoriesExistEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineMethodObject("(DEFMETHOD (LOGNOT INTEGER) ((ARG INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGNOT ARG) :CPP \"(~ arg)\" :JAVA \"(~ arg)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_lognot", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGNOT LONG-INTEGER) ((ARG LONG-INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGNOT ARG) :CPP \"(~ arg)\" :JAVA \"(~ arg)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_lognot", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGAND INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND ARG1 ARG2) :CPP \"(arg1 & arg2)\" :JAVA \"(arg1 & arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_logand", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGAND LONG-INTEGER) ((ARG1 LONG-INTEGER) (ARG2 LONG-INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND ARG1 ARG2) :CPP \"(arg1 & arg2)\" :JAVA \"(arg1 & arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_logand", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGIOR ARG1 ARG2) :CPP \"(arg1 | arg2)\" :JAVA \"(arg1 | arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_logor", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGOR LONG-INTEGER) ((ARG1 LONG-INTEGER) (ARG2 LONG-INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGIOR ARG1 ARG2) :CPP \"(arg1 | arg2)\" :JAVA \"(arg1 | arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_logor", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGXOR INTEGER) ((ARG1 INTEGER) (ARG2 INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGXOR ARG1 ARG2) :CPP \"(arg1 ^ arg2)\" :JAVA \"(arg1 ^ arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_logxor", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (LOGXOR LONG-INTEGER) ((ARG1 LONG-INTEGER) (ARG2 LONG-INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGXOR ARG1 ARG2) :CPP \"(arg1 ^ arg2)\" :JAVA \"(arg1 ^ arg2)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_logxor", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE})), null);
      Stella.defineFunctionObject("INTEGER-LENGTH", "(DEFUN (INTEGER-LENGTH INTEGER) ((X LONG-INTEGER)) :DOCUMENTATION \"Return the 1-based position of the left-most bit in `x'.\nIf `x' is negative, we only count the value bits, not the sign.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "integerLength", new java.lang.Class [] {java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("INTEGER-LENGTH10", "(DEFUN (INTEGER-LENGTH10 INTEGER) ((X LONG-INTEGER)) :DOCUMENTATION \"Return the 1-based position of the left-most non-zero digit\nin the base-10 representation of `x'.  If `x' is negative, we only consider\nits absolute value, not the sign.  This effectively computes the minimum number\nof base-10 digits to represent `x', with the exception of x=0.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "integerLength10", new java.lang.Class [] {java.lang.Long.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (SHIFT-LEFT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG COUNT) :CPP \"(arg << count)\" :JAVA \"(arg << count)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_shiftLeft", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SHIFT-LEFT LONG-INTEGER) ((ARG LONG-INTEGER) (COUNT INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG COUNT) :CPP \"(arg << count)\" :JAVA \"(arg << count)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_shiftLeft", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SHIFT-RIGHT INTEGER) ((ARG INTEGER) (COUNT INTEGER)) :DOCUMENTATION \"Shift `arg' to the right by `count' positions and\n0-extend from the left if `arg' is positive or 1-extend if it is\nnegative.  This is an arithmetic shift that preserve the sign of `arg'\nand is equivalent to dividing `arg' by 2** `count'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))) :CPP \"(arg >> count)\" :JAVA \"(arg >> count)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_shiftRight", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (SHIFT-RIGHT LONG-INTEGER) ((ARG LONG-INTEGER) (COUNT INTEGER)) :DOCUMENTATION \"Shift `arg' to the right by `count' positions and\n0-extend from the left if `arg' is positive or 1-extend if it is\nnegative.  This is an arithmetic shift that preserve the sign of `arg'\nand is equivalent to dividing `arg' by 2** `count'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))) :CPP \"(arg >> count)\" :JAVA \"(arg >> count)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_shiftRight", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (UNSIGNED-SHIFT-RIGHT-BY-1 INTEGER) ((ARG INTEGER)) :DOCUMENTATION \"Shift `arg' to the right by 1 position and 0-extend\nfrom the left.  This does not preserve the sign of `arg' and shifts\nthe sign-bit just like a regular bit.  In Common-Lisp we can't do that\ndirectly and need to do some extra masking.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1)) *INTEGER-UNSIGNED-BITS-MASK*) :CPP \"((unsigned int)arg >> 1)\" :JAVA \"(arg >>> 1)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "integer_unsignedShiftRightBy1", new java.lang.Class [] {java.lang.Integer.TYPE})), null);
      Stella.defineMethodObject("(DEFMETHOD (UNSIGNED-SHIFT-RIGHT-BY-1 LONG-INTEGER) ((ARG LONG-INTEGER)) :DOCUMENTATION \"Shift `arg' to the right by 1 position and 0-extend\nfrom the left.  This does not preserve the sign of `arg' and shifts\nthe sign-bit just like a regular bit.  In Common-Lisp we can't do that\ndirectly and need to do some extra masking.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:LOGAND (CL:ASH ARG -1) *LONG-INTEGER-UNSIGNED-BITS-MASK*) :CPP \"((unsigned long long int)arg >> 1)\" :JAVA \"(arg >>> 1)\")))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "longInteger_unsignedShiftRightBy1", new java.lang.Class [] {java.lang.Long.TYPE})), null);
      Stella.defineFunctionObject("GENERATE-UUID", "(DEFUN (GENERATE-UUID STRING) ((UUID-TYPE KEYWORD)) :PUBLIC? TRUE :DOCUMENTATION \"Generates a UUID of the specified type.  Legal types are\na subset of the IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )\nUUID types.  Currently supported are:\n    :TYPE-4  :RANDOM       A type-4 (random) UUID.  These are synonyms.\")", Native.find_java_method("edu.isi.stella.Keyword", "generateUuid", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("GENERATE-RANDOM-UUID", "(DEFUN (GENERATE-RANDOM-UUID STRING) () :PUBLIC? TRUE :DOCUMENTATION \"Generates a random UUID (Type 4), according to the guidelines\nof IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )\n\nTake 16 random bytes (octets), put them all behind each other, for the description\nthe numbering starts with byte 1 (most significant, first) to byte 16 \n   (least significant, last). Then put in the version and variant.\nTo put in the version, take the 7th byte and perform an and operation using 0x0f,\n   followed by an or operation with 0x40. \nTo put in the variant, take the 9th byte and perform an and operation using 0x3f,\n   followed by an or operation with 0x80.\nTo make the string representation, take the hexadecimal presentation of bytes 1-4\n   (without 0x in front of it) let them follow by a -, then take bytes 5 and 6, - \nbytes 7 and 8, - bytes 9 and 10, - then followed by bytes 11-16.\")", Native.find_java_method("edu.isi.stella.Stella", "generateRandomUuid", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("STELLIFY", "(DEFUN (STELLIFY OBJECT) ((SELF OBJECT)) :DOCUMENTATION \"Convert a Lisp object into a STELLA object.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "stellify", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STELLA-OBJECT?", "(DEFUN (STELLA-OBJECT? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return true if `self' is a member of the STELLA class `OBJECT'.\")", Native.find_java_method("edu.isi.stella.Stella_Object", "stellaObjectP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("RUNNING-AS-LISP?", "(DEFUN (RUNNING-AS-LISP? BOOLEAN) () :DOCUMENTATION \"Return true if the executable code is a Common Lisp application.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "runningAsLispP", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("RUNNING-IN-LANGUAGE", "(DEFUN (RUNNING-IN-LANGUAGE KEYWORD) () :DOCUMENTATION \"Returns the keyword for the language the current implementation is running in.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "runningInLanguage", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("RUNNING-SYSTEM-INFORMATION", "(DEFUN (RUNNING-SYSTEM-INFORMATION STRING) () :DOCUMENTATION \"Returns an information string about the current running system environment.\")", Native.find_java_method("edu.isi.stella.Stella", "runningSystemInformation", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("GETENV", "(DEFUN (GETENV STRING) ((VARNAME STRING) |&REST| (DEFLT STRING)) :DOCUMENTATION \"Return the value of the OS environment variable `varname'.  If it is not defined\nor if its value is the empty string and a `deflt' is provided, return the default value instead.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "getenv", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "getenvEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("GET-TICKTOCK", "(DEFUN (GET-TICKTOCK TICKTOCK) () :DOCUMENTATION \"Return the current CPU time.  If the current OS/Language\ncombination does not support measuring of CPU time, return real time instead.\nUse `ticktock-difference' to measure the time difference between values\nreturned by this function.  This is an attempt to provide some platform\nindependent support to measure (at least approximately) consumed CPU time.\" :PUBLIC? TRUE :NATIVE? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "getTicktock", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("TICKTOCK-DIFFERENCE", "(DEFUN (TICKTOCK-DIFFERENCE FLOAT) ((T1 TICKTOCK) (T2 TICKTOCK)) :DOCUMENTATION \"The difference in two TICKTOCK time values in seconds where\n`t1' is the earlier time.  The resolution is implementation dependent but will\nnormally be some fractional value of a second.\" :PUBLIC? TRUE :NATIVE? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "ticktockDifference", new java.lang.Class [] {java.lang.Long.TYPE, java.lang.Long.TYPE}), null);
      Stella.defineFunctionObject("TICKTOCK-RESOLUTION", "(DEFUN (TICKTOCK-RESOLUTION FLOAT) () :DOCUMENTATION \"The minimum theoretically detectable resolution of the\ndifference in two TICKTOCK time values in seconds.  This\nresolution is implementation dependent.  It may also not\nbe realizable in practice, since the timing grain size may\nbe larger than this resolution.\" :PUBLIC? TRUE :NATIVE? TRUE)", Native.find_java_method("edu.isi.stella.javalib.Native", "ticktockResolution", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("SLEEP", "(DEFUN SLEEP ((SECONDS FLOAT)) :DOCUMENTATION \"The program will sleep for the indicated number of seconds.\nFractional values are allowed, but the results are implementation dependent:\nCommon Lisp uses the fractions natively, Java with a resolution of 0.001,\nand C++ can only use integral values.\")", Native.find_java_method("edu.isi.stella.Stella", "sleep", new java.lang.Class [] {java.lang.Double.TYPE}), null);
      Stella.defineFunctionObject("EXCEPTION-MESSAGE", "(DEFUN (EXCEPTION-MESSAGE STRING) ((E NATIVE-EXCEPTION)) :DOCUMENTATION \"Accesses the error message of the exception `e'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "exceptionMessage", new java.lang.Class [] {Native.find_java_class("java.lang.Exception")}), null);
      Stella.defineFunctionObject("PRINT-EXCEPTION-CONTEXT", "(DEFUN PRINT-EXCEPTION-CONTEXT ((E NATIVE-EXCEPTION) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Prints system dependent information about the context of the specified\nexception `e'.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "printExceptionContext", new java.lang.Class [] {Native.find_java_class("java.lang.Exception"), Native.find_java_class("edu.isi.stella.OutputStream")}), null);
      Stella.defineFunctionObject("EXCEPTION-CONTEXT", "(DEFUN (EXCEPTION-CONTEXT STRING) ((E NATIVE-EXCEPTION)) :DOCUMENTATION \"Print the exception context of `e' to a string and return the result.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "exceptionContext", new java.lang.Class [] {Native.find_java_class("java.lang.Exception")}), null);
      Stella.defineFunctionObject("MAKE-PROCESS-LOCK", "(DEFUN (MAKE-PROCESS-LOCK PROCESS-LOCK-OBJECT) () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "makeProcessLock", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("STARTUP-PRIMAL", "(DEFUN STARTUP-PRIMAL () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella._StartupPrimal", "startupPrimal", new java.lang.Class [] {}), null);
      { MethodSlot function = Symbol.lookupFunction(Stella.SYM_STELLA_STARTUP_PRIMAL);

        KeyValueList.setDynamicSlotValue(function.dynamicSlots, Stella.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupPrimal"), Stella.NULL_STRING_WRAPPER);
      }
    }
  }

  public static void startupPrimal() {
    if (Stella.currentStartupTimePhaseP(0)) {
      Stella.$HASH_BYTE_RANDOM_TABLE$ = new int[256];
      { int i = Stella.NULL_INTEGER;
        int iter005 = 0;
        int upperBound006 = 255;

        for (;iter005 <= upperBound006; iter005 = iter005 + 1) {
          i = iter005;
          Stella.$HASH_BYTE_RANDOM_TABLE$[i] = 0;
        }
      }
      { int bit = Stella.NULL_INTEGER;
        int iter007 = 0;
        int upperBound008 = 31;

        for (;iter007 <= upperBound008; iter007 = iter007 + 1) {
          bit = iter007;
          { int i = Stella.NULL_INTEGER;
            int iter009 = 0;
            int upperBound010 = 255;

            for (;iter009 <= upperBound010; iter009 = iter009 + 1) {
              i = iter009;
              Stella.$HASH_BYTE_RANDOM_TABLE$[i] = ((Stella.$HASH_BYTE_RANDOM_TABLE$[i]) | (((Stella.random(2)) << bit)));
            }
          }
        }
      }
      Stella.$HASH_TABLE_SIZE_PRIME_STRINGS$ = Stella.vector(Cons.cons(StringWrapper.wrapString("29"), Cons.cons(StringWrapper.wrapString("53"), Cons.cons(StringWrapper.wrapString("97"), Cons.cons(StringWrapper.wrapString("193"), Cons.cons(StringWrapper.wrapString("389"), Cons.cons(StringWrapper.wrapString("769"), Cons.cons(StringWrapper.wrapString("1543"), Cons.cons(StringWrapper.wrapString("3079"), Cons.cons(StringWrapper.wrapString("6151"), Cons.cons(StringWrapper.wrapString("12289"), Cons.cons(StringWrapper.wrapString("24593"), Cons.cons(StringWrapper.wrapString("49157"), Cons.cons(StringWrapper.wrapString("98317"), Cons.cons(StringWrapper.wrapString("196613"), Cons.cons(StringWrapper.wrapString("393241"), Cons.cons(StringWrapper.wrapString("786433"), Cons.cons(StringWrapper.wrapString("1572869"), Cons.cons(StringWrapper.wrapString("3145739"), Cons.cons(StringWrapper.wrapString("6291469"), Cons.cons(StringWrapper.wrapString("12582917"), Cons.cons(StringWrapper.wrapString("25165843"), Cons.cons(StringWrapper.wrapString("50331653"), Cons.cons(StringWrapper.wrapString("100663319"), Cons.cons(StringWrapper.wrapString("201326611"), Cons.cons(StringWrapper.wrapString("402653189"), Cons.cons(StringWrapper.wrapString("805306457"), Cons.cons(StringWrapper.wrapString("1610612741"), Stella.NIL))))))))))))))))))))))))))));
      Stella.$HASH_TABLE_SIZE_PRIMES$ = Vector.newVector(Stella.$HASH_TABLE_SIZE_PRIME_STRINGS$.length());
      { StringWrapper s = null;
        Vector vector012 = Stella.$HASH_TABLE_SIZE_PRIME_STRINGS$;
        int index013 = 0;
        int length014 = vector012.length();
        int i = Stella.NULL_INTEGER;
        int iter015 = 0;

        for (;index013 < length014; index013 = index013 + 1, iter015 = iter015 + 1) {
          s = ((StringWrapper)((vector012.theArray)[index013]));
          i = iter015;
          (Stella.$HASH_TABLE_SIZE_PRIMES$.theArray)[i] = (IntegerWrapper.wrapInteger(((int)(Native.stringToInteger(s.wrapperValue)))));
        }
      }
    }
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.$STELLA_MODULE$);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          _StartupPrimal.helpStartupPrimal1();
        }
        if (Stella.currentStartupTimePhaseP(4)) {
          _StartupPrimal.helpStartupPrimal2();
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          _StartupPrimal.helpStartupPrimal3();
          _StartupPrimal.helpStartupPrimal4();
          _StartupPrimal.helpStartupPrimal5();
          _StartupPrimal.helpStartupPrimal6();
          _StartupPrimal.helpStartupPrimal7();
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("/STELLA")))));
          Stella.defineGlobalVariableObject("(DEFCONSTANT PI FLOAT (VERBATIM :COMMON-LISP \"(cl:float CL:PI 0.0d0)\" :CPP \"3.141592653589793\" :JAVA \"java.lang.Math.PI\") :PUBLIC? TRUE :DOCUMENTATION \"A float approximation of the mathematical constant pi.\")", null);
          Stella.defineStellaGlobalVariableFromStringifiedSource("(defconstant NULL UNKNOWN NULL\n       :public? TRUE\n       :documentation\n       \"Generic undefined value for any STELLA data type.  The STELLA\ntranslator substitutes specific NULL-values appropriate for a particular data\ntype.  For example, NULL-INTEGER represents the undefined INTEGER value.\")");
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-INTEGER INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"std::numeric_limits<int>::min()\" :JAVA \"Integer.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-SHORT-INTEGER SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"std::numeric_limits<short int>::min()\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-LONG-INTEGER LONG-INTEGER (VERBATIM :COMMON-LISP \"(CL:- (CL:expt 2 63))\" :CPP \"std::numeric_limits<long long int>::min()\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-UNSIGNED-SHORT-INTEGER UNSIGNED-SHORT-INTEGER (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-FIXNUM :CPP \"std::numeric_limits<unsigned short int>::min()\" :JAVA \"Short.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-UNSIGNED-LONG-INTEGER UNSIGNED-LONG-INTEGER (VERBATIM :COMMON-LISP \"(CL:1- (CL:expt 2 64))\" :CPP \"std::numeric_limits<unsigned long long int>::min()\" :JAVA \"Long.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"std::numeric_limits<double>::infinity() != 0 ?\n                    -std::numeric_limits<double>::infinity() :\n                    // work around a problem in g++ 3.2.2 where infinity()==0:\n                    NULL_INTEGER / (double)ceiling(-0.42)\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-SINGLE-FLOAT SINGLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-SINGLE-FLOAT :CPP \"-std::numeric_limits<float>::infinity()\" :JAVA \"Float.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-DOUBLE-FLOAT DOUBLE-FLOAT (VERBATIM :COMMON-LISP CL:MOST-NEGATIVE-DOUBLE-FLOAT :CPP \"-std::numeric_limits<double>::infinity()\" :JAVA \"Double.NEGATIVE_INFINITY; /* IEEE Infinity */\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-CHARACTER CHARACTER (VERBATIM :COMMON-LISP (CL:CODE-CHAR 0) :CPP \"'\\\\0'\" :JAVA \"Character.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-BYTE BYTE (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT NULL-OCTET OCTET (VERBATIM :COMMON-LISP \"255\" :CPP \"255\" :JAVA \"-128\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-POSITIVE-INTEGER INTEGER (VERBATIM :COMMON-LISP CL:MOST-POSITIVE-FIXNUM :CPP \"std::numeric_limits<int>::max()\" :JAVA \"Integer.MAX_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-NEGATIVE-INTEGER INTEGER (1+ NULL-INTEGER) :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-POSITIVE-LONG-INTEGER LONG-INTEGER (VERBATIM :COMMON-LISP \"(CL:1- (CL:expt 2 63))\" :CPP \"std::numeric_limits<long long int>::max()\" :JAVA \"Long.MAX_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-NEGATIVE-LONG-INTEGER LONG-INTEGER (1+ NULL-LONG-INTEGER) :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-POSITIVE-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:MOST-POSITIVE-DOUBLE-FLOAT :CPP \"std::numeric_limits<double>::max()\" :JAVA \"Double.MAX_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT MOST-NEGATIVE-FLOAT FLOAT (VERBATIM :COMMON-LISP \"(cl:multiple-value-bind (signif expon)\n                (cl:integer-decode-float cl:most-positive-double-float)\n              (cl:- (cl:scale-float (CL:- signif 1.0) expon)))\" :OTHERWISE (- MOST-POSITIVE-FLOAT)) :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT LEAST-POSITIVE-FLOAT FLOAT (VERBATIM :COMMON-LISP CL:LEAST-POSITIVE-DOUBLE-FLOAT :CPP \"std::numeric_limits<double>::min()\" :JAVA \"Double.MIN_VALUE\") :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT LEAST-NEGATIVE-FLOAT FLOAT (- LEAST-POSITIVE-FLOAT) :PUBLIC? TRUE)", null);
          Stella.seedRandomNumberGenerator2();
          Stella.defineGlobalVariableObject("(DEFCONSTANT RECIPROCAL-NL2 FLOAT (/ 1.0 (LOG 2.0)) :DOCUMENTATION \"1 / (log 2) Reciprocal of the Log base e of 2.\nUsed for log 2 conversions.\")", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT RECIPROCAL-NL10 FLOAT (/ 1.0 (LOG 10.0)) :DOCUMENTATION \"1 / (log 10) Reciprocal of the Log base e of 10.\nUsed for log 10 conversions.\")", null);
          Symbol.registerNativeName(Stella.SYM_STELLA_FLOOR, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_ROUND, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_FMOD, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_RANDOM, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_SQRT, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_COS, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_SIN, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_TAN, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_ACOS, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_ASIN, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_ATAN, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_ATAN2, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_EXP, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_LOG, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_MIN, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Symbol.registerNativeName(Stella.SYM_STELLA_MAX, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Stella.defineGlobalVariableObject("(DEFSPECIAL *TRANSIENTOBJECTS?* BOOLEAN FALSE :PUBLIC? TRUE)", null);
          Symbol.registerNativeName(Stella.SYM_STELLA_HASH_CODE, Stella.KWD_JAVA, Stella.KWD_FUNCTION);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *HASH-BYTE-RANDOM-TABLE* (ARRAY (256) OF INTEGER) NULL :DOCUMENTATION \"A table of 256 N-bit random numbers that can be used to\nhash sequences of bytes.  Each bit-column in the table has an approximately\neven number of 0's and 1's.\")", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT *INTEGER-MSB-MASK* INTEGER (VERBATIM :COMMON-LISP \"#.(cl:abs (cl:ash cl:most-negative-fixnum -1))\" :CPP \"1 << (sizeof (int) / sizeof (char) * 8 - 1)\" :JAVA \"0x80000000\") :DOCUMENTATION \"The most significant bit of a regular integer (FIXNUM\nin Common-Lisp).  In C++ and Java this corresponds to the sign bit, in\nLisp this corresponds to the left-most bit of `CL:most-positive-fixnum'.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT *INTEGER-UNSIGNED-BITS-MASK* INTEGER (VERBATIM :OTHERWISE MOST-POSITIVE-INTEGER) :DOCUMENTATION \"Mask that covers all the unsigned bits of an integer.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT *LONG-INTEGER-MSB-MASK* LONG-INTEGER (VERBATIM :OTHERWISE NULL-LONG-INTEGER) :DOCUMENTATION \"The sign bit of a long integer.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT *LONG-INTEGER-UNSIGNED-BITS-MASK* LONG-INTEGER (VERBATIM :OTHERWISE MOST-POSITIVE-LONG-INTEGER) :DOCUMENTATION \"Mask that covers all the unsigned bits of a long integer.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *HASH-TABLE-SIZE-PRIME-STRINGS* (VECTOR OF STRING-WRAPPER) NULL :DOCUMENTATION \"List of prime numbers approximately growing by a factor of 2\nthat are suitable to be used as hash table sizes.  This is in string\nformat to enable processing by Lisps with different fixnum sizes.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *HASH-TABLE-SIZE-PRIMES* (VECTOR OF INTEGER-WRAPPER) NULL :DOCUMENTATION \"List of prime numbers approximately growing by a factor of 2\nthat are suitable to be used as hash table sizes.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFCONSTANT LONG-INTEGER-BIT-WIDTH INTEGER (ROUND (/ (LOG (* MOST-POSITIVE-LONG-INTEGER 2.0)) (LOG 2))) :DOCUMENTATION \"The number of bits in a long integer.\")", null);
          Symbol.registerNativeName(Stella.SYM_STELLA_SLEEP, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *BOOTSTRAP-LOCK* PROCESS-LOCK-OBJECT (VERBATIM :COMMON-LISP \"(%make-process-lock)\" :JAVA \"new java.lang.Object()\" :CPP \"NULL\") :PUBLIC? TRUE :DOCUMENTATION \"Process lock object for bootstrap use.\")", null);
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
