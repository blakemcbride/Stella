//  -*- Mode: Java -*-
//
// _StartupSystems.java

/*
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
*/

package edu.isi.stella;

import edu.isi.stella.javalib.*;

public class _StartupSystems {
  static void helpStartupSystems1() {
    {
      Stella.KWD_TRUE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("TRUE", null, 2)));
      Stella.KWD_FALSE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("FALSE", null, 2)));
      Stella.SGT_STELLA_IDENTITY = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("IDENTITY", null, 1)));
      Stella.SYM_STELLA_IN_MODULE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("IN-MODULE", null, 0)));
      Stella.SYM_STELLA_DEFSYSTEM = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("DEFSYSTEM", null, 0)));
      Stella.KWD_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("FILES", null, 2)));
      Stella.KWD_REQUIRED_SYSTEMS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("REQUIRED-SYSTEMS", null, 2)));
      Stella.KWD_LOAD_SYSTEM = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("LOAD-SYSTEM", null, 2)));
      Stella.KWD_MAKE_SYSTEM = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("MAKE-SYSTEM", null, 2)));
      Stella.KWD_LISP_ONLY_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("LISP-ONLY-FILES", null, 2)));
      Stella.KWD_CPP_ONLY_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CPP-ONLY-FILES", null, 2)));
      Stella.KWD_JAVA_ONLY_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("JAVA-ONLY-FILES", null, 2)));
      Stella.KWD_DATA_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("DATA-FILES", null, 2)));
      Stella.KWD_PREPROCESSED_FILES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("PREPROCESSED-FILES", null, 2)));
      Stella.KWD_CARDINAL_MODULE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CARDINAL-MODULE", null, 2)));
      Stella.KWD_BANNER = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("BANNER", null, 2)));
      Stella.KWD_COPYRIGHT_HEADER = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("COPYRIGHT-HEADER", null, 2)));
      Stella.KWD_PRODUCTION_SETTINGS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("PRODUCTION-SETTINGS", null, 2)));
      Stella.KWD_DEVELOPMENT_SETTINGS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("DEVELOPMENT-SETTINGS", null, 2)));
      Stella.KWD_FINALIZATION_FUNCTION = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("FINALIZATION-FUNCTION", null, 2)));
      Stella.KWD_FORCE_RECOMPILATIONp = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("FORCE-RECOMPILATION?", null, 2)));
      Stella.KWD_LOAD_SYSTEMp = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("LOAD-SYSTEM?", null, 2)));
      Stella.KWD_STARTUPp = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP?", null, 2)));
      Stella.SYM_STELLA_SYSTEM_STARTED_UPp = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SYSTEM-STARTED-UP?", null, 0)));
      Stella.KWD_EARLY_INITS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("EARLY-INITS", null, 2)));
      Stella.SYM_STELLA_STARTUP = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP", null, 0)));
      Stella.SYM_STELLA_PHASE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("PHASE", null, 0)));
      Stella.SYM_STELLA_PHASE_TO_INTEGER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("PHASE-TO-INTEGER", null, 0)));
      Stella.KWD_DAYS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("DAYS", null, 2)));
      Stella.KWD_HOURS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("HOURS", null, 2)));
      Stella.KWD_MINUTES = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("MINUTES", null, 2)));
      Stella.KWD_SECONDS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("SECONDS", null, 2)));
      Stella.SYM_STELLA_SYSTEM_VERSION = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SYSTEM-VERSION", null, 0)));
      Stella.KWD_SET = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("SET", null, 2)));
      Stella.KWD_ADD = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("ADD", null, 2)));
      Stella.SYM_STELLA_CONFIGURATION_TABLE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("CONFIGURATION-TABLE", null, 0)));
      Stella.KWD_REMOVE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("REMOVE", null, 2)));
      Stella.SYM_STELLA_TEST_PROPERTY_DEMON = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("TEST-PROPERTY-DEMON", null, 0)));
      Stella.SGT_STELLA_CMD_LINE_OPTION = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("CMD-LINE-OPTION", null, 1)));
      Stella.SYM_STELLA_KEYS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("KEYS", null, 0)));
      Stella.SYM_STELLA_VALUE_TYPE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("VALUE-TYPE", null, 0)));
      Stella.SYM_STELLA_MULTI_VALUEDp = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("MULTI-VALUED?", null, 0)));
      Stella.SYM_STELLA_N_ARGUMENTS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("N-ARGUMENTS", null, 0)));
      Stella.SYM_STELLA_DEFAULT_VALUE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("DEFAULT-VALUE", null, 0)));
      Stella.SYM_STELLA_CONFIGURATION_PROPERTY = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("CONFIGURATION-PROPERTY", null, 0)));
      Stella.SYM_STELLA_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("HANDLER", null, 0)));
      Stella.SYM_STELLA_ERROR_ACTION = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("ERROR-ACTION", null, 0)));
      Stella.KWD_KEY2 = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("KEY2", null, 2)));
      Stella.KWD_KEY3 = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("KEY3", null, 2)));
      Stella.KWD_KEYS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("KEYS", null, 2)));
      Stella.KWD_VALUE_TYPE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("VALUE-TYPE", null, 2)));
      Stella.KWD_MULTI_VALUEDp = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("MULTI-VALUED?", null, 2)));
      Stella.KWD_N_ARGUMENTS = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("N-ARGUMENTS", null, 2)));
      Stella.KWD_DEFAULT_VALUE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("DEFAULT-VALUE", null, 2)));
      Stella.KWD_PROPERTY = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("PROPERTY", null, 2)));
      Stella.KWD_HANDLER = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("HANDLER", null, 2)));
      Stella.KWD_ERROR_ACTION = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("ERROR-ACTION", null, 2)));
      Stella.KWD_IGNORE = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("IGNORE", null, 2)));
      Stella.SYM_STELLA_EVAL_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("EVAL-OPTION-HANDLER", null, 0)));
      Stella.SYM_STELLA_EVAL_IN_MODULE_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("EVAL-IN-MODULE-OPTION-HANDLER", null, 0)));
    }
  }

  static void helpStartupSystems2() {
    {
      Stella.$FILE_LOAD_PATH$ = Stella.NIL;
      Stella.$STELLA_FILE_EXTENSIONS$ = Cons.consList(Cons.cons(StringWrapper.wrapString(".ste"), Stella.NIL));
      Stella.$CURRENTLOADFILE$.setDefaultValue(null);
      Stella.$SYSTEMDEFINITIONS$ = List.newList();
      Stella.$CURRENT_SYSTEM_ACTION$.setDefaultValue(null);
      Stella.$SYSTEM_CONFIGURATION_TABLE$ = KeyValueList.newKeyValueList();
      Stella.$PL_ROOT_DIRECTORY$ = null;
      Stella.$REGISTERED_PROPERTY_DEMONS$ = KeyValueMap.newKeyValueMap();
      Stella.$REGISTERED_COMMAND_LINE_OPTIONS$ = KeyValueMap.newKeyValueMap();
    }
  }

  static void helpStartupSystems3() {
    {
      Stella.defineFunctionObject("PARSE-DIRECTORY-PATH", "(DEFUN (PARSE-DIRECTORY-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)))", Native.find_java_method("edu.isi.stella.Stella", "parseDirectoryPath", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("SET-LOAD-PATH", "(DEFUN (SET-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Set the STELLA load path to the |-separated\ndirectories listed in `path'.  Return the resulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "setLoadPath", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "setLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("GET-LOAD-PATH", "(DEFUN (GET-LOAD-PATH (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return the current STELLA load path.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "getLoadPath", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("PUSH-LOAD-PATH", "(DEFUN (PUSH-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Add the directories listed in the |-separated\n`path' to the front of the STELLA load path.  Return the\nresulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "pushLoadPath", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "pushLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("POP-LOAD-PATH", "(DEFUN (POP-LOAD-PATH STRING) () :DOCUMENTATION \"Remove the first element from the STELLA load path\nand return the removed element.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "popLoadPath", new java.lang.Class [] {}), Native.find_java_method("edu.isi.stella.Cons", "popLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("ADD-LOAD-PATH", "(DEFUN (ADD-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Append the directories listed in the |-separated\n`path' to the end of the STELLA load path.  Return the resulting\nload path.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "addLoadPath", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "addLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("DROP-LOAD-PATH", "(DEFUN (DROP-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Remove the directories listed in the |-separated\n`path' from the PowerLoom load path.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "dropLoadPath", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "dropLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("FIND-FILE-IN-LOAD-PATH", "(DEFUN (FIND-FILE-IN-LOAD-PATH STRING) ((FILE STRING) (EXTENSIONS (CONS OF STRING-WRAPPER))) :DOCUMENTATION \"Try to find `file' in the current load path and, if found,\nreturn its full name.  If `file' can't be found literally, try to find it\nwith any of the listed `extensions' added.  If `extensions' is NULL it defaults\nto `*stella-file-extensions*', therefore, to not default to any extensions\nthe value has to be supplied as NIL.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "findFileInLoadPath", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "findFileInLoadPathEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("COERCE-VALUE-TO-BOOLEAN", "(DEFUN (COERCE-VALUE-TO-BOOLEAN BOOLEAN-WRAPPER) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the boolean object represented by `value'.  Return NULL\nif coercion is not possible or raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceValueToBoolean", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("COERCE-TO-BOOLEAN", "(DEFUN (COERCE-TO-BOOLEAN BOOLEAN-WRAPPER) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the boolean object represented by `object'.\nReturn NULL if coercion is not possible.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceToBoolean", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("COERCE-VALUE-TO-STRING", "(DEFUN (COERCE-VALUE-TO-STRING STRING) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' into a string if possible, return NULL\notherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceValueToString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("COERCE-TO-STRING", "(DEFUN (COERCE-TO-STRING STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `object' into a string.  If no standard coercion\nis possible, simply stringify `object'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceToString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("COERCE-VALUE-TO-FLOAT", "(DEFUN (COERCE-VALUE-TO-FLOAT FLOAT) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to a float value if possible, return\nNULL otherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceValueToFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("COERCE-TO-FLOAT", "(DEFUN (COERCE-TO-FLOAT FLOAT) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `number' to a float value or NULL if not possible.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceToFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("COERCE-VALUE-TO-TYPE", "(DEFUN (COERCE-VALUE-TO-TYPE OBJECT) ((VALUE OBJECT) (TYPE TYPE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible\nor raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceValueToType", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Surrogate"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("COERCE-OPTION-VALUE", "(DEFUN (COERCE-OPTION-VALUE OBJECT) ((VALUE OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceOptionValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Surrogate")}), null);
      Stella.defineFunctionObject("VET-OPTIONS", "(DEFUN (VET-OPTIONS PROPERTY-LIST) ((PLIST OBJECT) (LEGALOPTIONS (CONS OF KEYWORD))))", Native.find_java_method("edu.isi.stella.Stella_Object", "vetOptions", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("PARSE-OPTIONS", "(DEFUN (PARSE-OPTIONS PROPERTY-LIST) ((OPTIONS OBJECT) (|LEGALOPTIONS&TYPES| CONS) (COERCIONERROR? BOOLEAN) (ALLOWOTHERKEYS? BOOLEAN)) :DOCUMENTATION \"Parse `options', check their validity according to\n`legalOptions&Types' and return the result as a PROPERTY-LIST.\n`legalOptions&Types' has to either be NULL or a flat list of legal\n<keyword> <coercionType> pairs.  A type specifcation of @IDENTITY\nmeans don't perform any coercion.\nIf `coercionError?' is TRUE, raise an error if a coercion failed.\nIf `allowOtherKeys?' is TRUE options other than those specified in\n`legalOptions&Types' are allowed but won't be coerced since we don't\nknow their type.  A special implicit :options keyword that does not\nneed to be declared can be used to pass in an already parsed options\nlist from a caller, which will then be analyzed and used instead.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "parseOptions", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons"), java.lang.Boolean.TYPE, java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("EVALUATE-COMMAND", "(DEFUN (EVALUATE-COMMAND OBJECT) ((COMMAND OBJECT) (FINALIZE? BOOLEAN)))", Native.find_java_method("edu.isi.stella.Stella_Object", "evaluateCommand", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("LOAD-FILE", "(DEFUN LOAD-FILE ((FILE STRING)) :DOCUMENTATION \"Read STELLA commands from `file' and evaluate them.\nThe file should begin with an `in-module' declaration that specifies\nthe module within which all remaining commands are to be evaluated\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\" :COMMAND? TRUE :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "loadFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "loadFileEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("MAKE-SYSTEM-DEFINITION-FILE-NAME", "(DEFUN (MAKE-SYSTEM-DEFINITION-FILE-NAME FILE-NAME) ((NAME STRING)) :DOCUMENTATION \"Make a canonical system definition file name for a system named `name'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "makeSystemDefinitionFileName", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("BUILD-STELLA-SYSTEMS-PATH", "(DEFUN (BUILD-STELLA-SYSTEMS-PATH (CONS OF STRING-WRAPPER)) ())", Native.find_java_method("edu.isi.stella.Stella", "buildStellaSystemsPath", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("FIND-SYSTEM-DEFINITION-FILE", "(DEFUN (FIND-SYSTEM-DEFINITION-FILE FILE-NAME) ((NAME STRING)) :DOCUMENTATION \"Try to find an existing system definition file for a system named `name'\nin the current STELLA_SYSTEMS_PATH or built-in implicit systems path.  Return NULL if no\nsuch definition file can be found.  See `build-stella-systems-path' on where it looks.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "findSystemDefinitionFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE", "(DEFUN (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE FILE-NAME) ((SYSDEFFILE FILE-NAME)) :DOCUMENTATION \"Given a system definition file `sysDefFile' try to determine the root directory\nof the STELLA installation containing this system by looking for top-level native directories.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "findSystemRootDirectoryFromFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("FIND-SYSTEM-ROOT-DIRECTORY", "(DEFUN (FIND-SYSTEM-ROOT-DIRECTORY FILE-NAME) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Given a system definition `system' try to determine the root directory\nof the STELLA installation containing this system based on its definition file.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.SystemDefinition", "findSystemRootDirectory", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("COMPUTE-SYSTEM-ROOT-DIRECTORIES", "(DEFUN COMPUTE-SYSTEM-ROOT-DIRECTORIES ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute any root directories for sources, native and Lisp binary directories\nin case they were not explicitly specified in `system's definition.  Raises an error in case\nany of those root directories is missing and can't be computed.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.SystemDefinition", "computeSystemRootDirectories", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("PARSE-LIST-OF-FILE-PATHS", "(DEFUN (PARSE-LIST-OF-FILE-PATHS (CONS OF STRING-WRAPPER)) ((FILES CONS)))", Native.find_java_method("edu.isi.stella.Cons", "parseListOfFilePaths", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("DEFINE-SYSTEM", "(DEFUN (DEFINE-SYSTEM SYSTEM-DEFINITION) ((NAME OBJECT) (OPTIONS CONS)))", Native.find_java_method("edu.isi.stella.Stella_Object", "defineSystem", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("DEFSYSTEM", "(DEFUN (DEFSYSTEM SYSTEM-DEFINITION) ((NAME SYMBOL) |&REST| (OPTIONS OBJECT)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE :DOCUMENTATION \"Define a system of files that collectively define\na Stella application.\n   Required options are:\n   :directory -- the relative path from the respective source/native/binary root directory\n                 to the directory containing the system files.  Can be a string or a list\n                 of strings (do not include directory separators).\n   :files -- a list of files in the system, containing strings and lists\n             of strings; the latter defines exploded paths to files\n             in subdirectories.\n   Optional options are:\n   :data-files       -- a list of files like the :files keyword, which contain\n                        data or other content that should not be processed, but\n                        instead copied verbatim to the native directory\n   :required-systems -- a list of systems (strings) that should be loaded\n                        prior to loading this system.\n   :cardinal-module -- the name (a string) of the principal module for this\n                       system.\n   :copyright-header -- string with a header for inclusion into all translated\n                        files produced by Stella.\n   :lisp-only-files  -- Like the :files keyword, but these are only included\n   :cpp-only-files      in the translation for the specific language, namely\n   :java-only-files     Common Lisp, C++ or Java\")", Native.find_java_method("edu.isi.stella.Symbol", "defsystem", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "defsystemEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("GET-SYSTEM-DEFINITION", "(DEFUN (GET-SYSTEM-DEFINITION SYSTEM-DEFINITION) ((NAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a system named 'name'.  If no such system is currently defined,\nlook for a system definition file for `name' in standard locations and try to load it.\nIf no matching system could be found or loaded and `error?' is true, raise an error,\notherwise, simply return NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "getSystemDefinition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("GET-CARDINAL-MODULE", "(DEFUN (GET-CARDINAL-MODULE MODULE) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "getCardinalModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("HELP-GET-SYSTEM-FILES", "(DEFUN HELP-GET-SYSTEM-FILES ((FILENAME FILE-NAME) (COLLECTION LIST) (PROBEFILE? BOOLEAN)))", Native.find_java_method("edu.isi.stella.Stella", "helpGetSystemFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.List"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("GET-SYSTEM-FILES", "(DEFUN (GET-SYSTEM-FILES (LIST OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION) (TYPE KEYWORD) (PROBEFILES? BOOLEAN)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "getSystemFiles", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition"), Native.find_java_class("edu.isi.stella.Keyword"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("CLEAN-SYSTEM", "(DEFUN CLEAN-SYSTEM ((SYSTEMNAME STRING)))", Native.find_java_method("edu.isi.stella.Stella", "cleanSystem", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("COMPUTE-OPTIMIZATION-LEVELS", "(DEFUN COMPUTE-OPTIMIZATION-LEVELS ((SYSTEM SYSTEM-DEFINITION) (PRODUCTIONMODE? BOOLEAN)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "computeOptimizationLevels", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("MAKE-SYSTEM", "(DEFUN (MAKE-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Translate all out-of-date files of system `systemName'\ninto `language' (the first optional argument of `language&options') and\nthen compile and load them (the latter is only possible for Lisp right now).\nThe following keyword/value `options' are recognized:\n\n`:language': can be used as an alternative to the optional language argument.\nIf not specified, the language of the running implementation is assumed.\n\n`:two-pass?': if true, all files will be scanned twice, once to\nload the signatures of objects defined in them, and once to actually\ntranslate the definitions.  Otherwise, the translator will make one pass in\nthe case that the system is already loaded (and is being remade), and two\npasses otherwise.\n\n`:development-settings?' (default false): if true translation will favor\nsafe, readable and debuggable code over efficiency (according to the value\nof `:development-settings' on the system definition).  If false, efficiency\nwill be favored instead (according to the value of `:production-settings'\non the system definition).\n\n`:production-settings?' (default true): inverse to `:development-settings?'.\n\n`:force-translation?' (default false): if true, files will be translated\nwhether or not their translations are up-to-date.\n\n`:force-recompilation?' (default false): if true, translated files will be\nrecompiled whether or not their compilations are up-to-date (only supported\nin Lisp right now).\n\n`:load-system?' (default true): if true, compiled files will be loaded into\nthe current STELLA image (only supported in Lisp and Java right now).\n\n`:startup?' (default true): if true, the system startup function will\nbe called once all files have been loaded.\n\n`:recursive?' (default false): if true, perform `make-system' with the provided\noptions on `systemName' as well as all its required systems and so on.  Required\nsystems will be processed first.  Note that even without this option, any required\nsystems that have not yet been loaded or started up will also be processed, since\nthat is assumed when loading `systemName' and supporting modules from a definition file.\n\n`:root-source-directory', `:root-native-directory', `:root-binary-directory': if\nspecified these directories will be used to override the respective paths provided\nin system definitions or computed as defaults from a system's home location.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "makeSystem", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "makeSystemEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("RUN-SYSTEM-FINALIZATION", "(DEFUN RUN-SYSTEM-FINALIZATION ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "runSystemFinalization", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("SYSTEM-DEFINITION-SOURCE-FILES", "(DEFUN (SYSTEM-DEFINITION-SOURCE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "systemDefinitionSourceFiles", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("FILES-PLUS-SYSTEM-STARTUP", "(DEFUN (FILES-PLUS-SYSTEM-STARTUP (CONS OF STRING-WRAPPER)) ((FILES (CONS OF STRING-WRAPPER))))", Native.find_java_method("edu.isi.stella.Cons", "filesPlusSystemStartup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("SYSTEM-DEFINITION-NATIVE-FILES", "(DEFUN (SYSTEM-DEFINITION-NATIVE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "systemDefinitionNativeFiles", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("SYSTEM-LOADED?", "(DEFUN (SYSTEM-LOADED? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has been loaded.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "systemLoadedP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("SYSTEM-LOADED-OR-STARTED-UP?", "(DEFUN (SYSTEM-LOADED-OR-STARTED-UP? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has either been loaded\nor initialized with its startup function.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "systemLoadedOrStartedUpP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CLEAR-SYSTEM", "(DEFUN CLEAR-SYSTEM ((NAME STRING)) :DOCUMENTATION \"Clears out the system definition named `name'.  If\n`name' is `null', then clear out all system definitions.  This function\nis useful when changes have been made to the system definition, and one\nwants to have it reloaded from the standard location in the file system.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "clearSystem", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("LOAD-PREPROCESSED-FILES", "(DEFUN LOAD-PREPROCESSED-FILES ((SYSTEMNAME STRING)))", Native.find_java_method("edu.isi.stella.Stella", "loadPreprocessedFiles", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("LOAD-SYSTEM", "(DEFUN (LOAD-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Natively `language'-compile out-of-date translated files of system\n`systemName' (only supported for Lisp at the moment) and then load them\ninto the running system.  Return true if at least one file was compiled.\nThe following keyword/value `options' are recognized:\n\n`:language': can be used as an alternative to the optional language argument.\nIf not specified, the language of the running implementation is assumed.\n\n`:force-recompilation?' (default false): if true, files will be compiled\nwhether or not their compilations are up-to-date.\n\n`:startup?' (default true): if true, the system startup function will\nbe called once all files have been loaded.\n\n`:recursive?' (default false): if true, perform `load-system' with the provided\noptions on `systemName' as well as all its required systems and so on.  Required\nsystems will be processed first.  Note that even without this option, any required\nsystems that have not yet been loaded or started up will also be processed, since\nthat is assumed when loading `systemName' and supporting modules from a definition file.\n\n`:root-source-directory', `:root-native-directory', `:root-binary-directory': if\nspecified these directories will be used to override the respective paths provided\nin system definitions or computed as defaults from a system's home location.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "loadSystem", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "loadSystemEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("COMPILE-AND-LOAD-FILES", "(DEFUN (COMPILE-AND-LOAD-FILES BOOLEAN) ((FILES (CONS OF STRING-WRAPPER)) (LANGUAGE KEYWORD) (FORCERECOMPILATION? BOOLEAN)))", Native.find_java_method("edu.isi.stella.Cons", "compileAndLoadFiles", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Keyword"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("RUN-SYSTEM-STARTUP-FUNCTION", "(DEFUN RUN-SYSTEM-STARTUP-FUNCTION ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "runSystemStartupFunction", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineMethodObject("(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.SystemDefinition", "systemStartupFunctionName", new java.lang.Class [] {})), null);
      Stella.defineMethodObject("(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEMNAME STRING)))", MethodCodeWrapper.wrapMethodCode(Native.find_java_method("edu.isi.stella.Stella", "string_systemStartupFunctionName", new java.lang.Class [] {Native.find_java_class("java.lang.String")})), null);
      Stella.defineFunctionObject("SYSTEM-STARTUP-FUNCTION-SYMBOL", "(DEFUN (SYSTEM-STARTUP-FUNCTION-SYMBOL SYMBOL) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "systemStartupFunctionSymbol", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("STARTUP-NAME-FROM-FILE", "(DEFUN (STARTUP-NAME-FROM-FILE SYMBOL) ((FILE FILE-NAME)))", Native.find_java_method("edu.isi.stella.Stella", "startupNameFromFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("STARTUP-NAMES-FROM-FILES", "(DEFUN (STARTUP-NAMES-FROM-FILES (CONS OF SYMBOL)) ((FILES (CONS OF STRING-WRAPPER))))", Native.find_java_method("edu.isi.stella.Cons", "startupNamesFromFiles", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("SYSTEM-STARTUP-FILE-NAME", "(DEFUN (SYSTEM-STARTUP-FILE-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "systemStartupFileName", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("SYSTEM-STARTUP-FILE?", "(DEFUN (SYSTEM-STARTUP-FILE? BOOLEAN) ((FILE FILE-NAME)))", Native.find_java_method("edu.isi.stella.Stella", "systemStartupFileP", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("SYSTEM-STARTED-UP?", "(DEFUN (SYSTEM-STARTED-UP? BOOLEAN) ((SYSTEMNAME STRING) (SYSTEMMODULENAME STRING)))", Native.find_java_method("edu.isi.stella.Stella", "systemStartedUpP", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("YIELD-STARTUP-REQUIRED-SYSTEMS", "(DEFUN (YIELD-STARTUP-REQUIRED-SYSTEMS CONS) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "yieldStartupRequiredSystems", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE", "(DEFUN (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (CONS OF CONS)) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "collectStartupFormsFromSystemFile", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE", "(DEFUN (COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE (CONS OF MODULE)) ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "collectDefinedModulesFromSystemFile", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("CREATE-SYSTEM-STARTUP-FILE", "(DEFUN CREATE-SYSTEM-STARTUP-FILE ((SYSTEM SYSTEM-DEFINITION)))", Native.find_java_method("edu.isi.stella.SystemDefinition", "createSystemStartupFile", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("HELP-ALL-REQUIRED-SYSTEMS", "(DEFUN (HELP-ALL-REQUIRED-SYSTEMS (LIST OF STRING-WRAPPER)) ((SYSTEM-NAME STRING) (FOUND (LIST OF STRING-WRAPPER))))", Native.find_java_method("edu.isi.stella.Stella", "helpAllRequiredSystems", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.List")}), null);
    }
  }

  static void helpStartupSystems4() {
    {
      Stella.defineFunctionObject("ALL-REQUIRED-SYSTEMS", "(DEFUN (ALL-REQUIRED-SYSTEMS (CONS OF STRING-WRAPPER)) ((SYSTEM-NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns a CONS of all of the systems required by `system-name'\")", Native.find_java_method("edu.isi.stella.Stella", "allRequiredSystems", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("DATE-TO-VERSION-STRING", "(DEFUN (DATE-TO-VERSION-STRING STRING) ((DATE CALENDAR-DATE) (GRANULARITY KEYWORD)) :DOCUMENTATION \"Transform `date' into a version string according to `granularity'\nwhich is at least :days and defaults to :seconds.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CalendarDate", "dateToVersionString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CalendarDate"), Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("GET-SYSTEM-LAST-MODIFIED-DATE", "(DEFUN (GET-SYSTEM-LAST-MODIFIED-DATE CALENDAR-DATE) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute a last-modified date for `system' based on its most recently modified source file.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.SystemDefinition", "getSystemLastModifiedDate", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineExternalSlotFromStringifiedSource("(DEFSLOT SYSTEM-DEFINITION SYSTEM-VERSION :TYPE STRING :OPTION-KEYWORD :VERSION :DOCUMENTATION \"Explicitly define a version number for this system.\" :ALLOCATION :DYNAMIC)");
      Stella.defineFunctionObject("GET-SYSTEM-VERSION-STRING", "(DEFUN (GET-SYSTEM-VERSION-STRING STRING) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute a version string for `system' which is either based on an explicit :version\nannotation on `system's definition, the readable value of an existing `*<system>-version[-string]*',\nvariable or on its most recent modification date of any of its source files.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.SystemDefinition", "getSystemVersionString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.SystemDefinition")}), null);
      Stella.defineFunctionObject("AUTOLOAD", "(DEFUN (AUTOLOAD FUNCTION-CODE) ((QUALIFIEDNAME STRING) (SYSTEMNAME STRING) (CACHE SURROGATE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Autoload function `qualifiedName' from system `systemName'.\nIf it is already present in the system, simply return its code.  If `cache'\nis defined, return its value if defined, otherwise, set its value to the\nfunction found.  If the function failed to be defined by loading `systemName'\nand `error?' is true, raise an error.  Otherwise, simply return NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "autoload", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Surrogate"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("MAKE-STELLA", "(DEFUN MAKE-STELLA ((FORCERECOMPILATION? BOOLEAN)))", Native.find_java_method("edu.isi.stella.Stella", "makeStella", new java.lang.Class [] {java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("PARSE-CONFIGURATION-FILE-LINE", "(DEFUN (PARSE-CONFIGURATION-FILE-LINE STRING-WRAPPER WRAPPER KEYWORD) ((LINE STRING)))", Native.find_java_method("edu.isi.stella.Stella", "parseConfigurationFileLine", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("[Ljava.lang.Object;")}), null);
      Stella.defineFunctionObject("LOAD-CONFIGURATION-FILE", "(DEFUN (LOAD-CONFIGURATION-FILE CONFIGURATION-TABLE) ((FILE FILE-NAME)) :DOCUMENTATION \"Read a configuration `file' and return its content as a configuration table.\nAlso enter each property read into the global system configuration table.\nAssumes Java-style property file syntax.  Each property name is represented\nas a wrapped string and each value as a wrapped string/integer/float or boolean.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueList", "loadConfigurationFile", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "loadConfigurationFileEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("SAVE-CONFIGURATION-VALUE", "(DEFUN SAVE-CONFIGURATION-VALUE ((STREAM OUTPUT-STREAM) (VALUE OBJECT)) :DOCUMENTATION \"Save `value' to `stream' as a properly formatted configuration\nvalue.\")", Native.find_java_method("edu.isi.stella.OutputStream", "saveConfigurationValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.OutputStream"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("SAVE-CONFIGURATION-FILE", "(DEFUN SAVE-CONFIGURATION-FILE ((TABLE CONFIGURATION-TABLE) (FILE FILE-NAME) (TITLE STRING)) :DOCUMENTATION \"Save `table' as a configuration file.  Uses a Java-style property file syntax.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueList", "saveConfigurationFile", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.KeyValueList"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("LOOKUP-CONFIGURATION-PROPERTY", "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (DEFAULTVALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration' and return its value.\nUse the global system configuration table if `configuration' is NULL.  Return\n`defaultValue' if `property' is not defined.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "lookupConfigurationProperty", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("LOOKUP-CONFIGURATION-PROPERTY-VALUES", "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY-VALUES CONS) ((PROPERTY STRING) (DEFAULTVALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration', assume it is a multi-valued\nproperty and return its value(s) as a list.  Use the global system configuration table\nif `configuration' is NULL.  Return `defaultValue' if `property' is not defined or\nNIL is no default value is specified.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "lookupConfigurationPropertyValues", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("SET-CONFIGURATION-PROPERTY", "(DEFUN (SET-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Set `property' in `configuration' to `value' and return it.\nUse the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "setConfigurationProperty", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("ADD-CONFIGURATION-PROPERTY", "(DEFUN (ADD-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Add `value' to `property' in `configuration' and return it.\nIf a previous value exists add `value' to the end (listify the old value\nif it is not yet a list).  Otherwise, create a new list containing `value'.\nUse the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "addConfigurationProperty", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("CLEAR-CONFIGURATION-PROPERTY", "(DEFUN (CLEAR-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `property' in `configuration' and return the previous\nvalue.\nUse the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "clearConfigurationProperty", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("REMOVE-CONFIGURATION-PROPERTY", "(DEFUN (REMOVE-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `value' from `property' in `configuration' and return it.\nUse the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "removeConfigurationProperty", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("PRINT-CONFIGURATION-PROPERTIES", "(DEFUN PRINT-CONFIGURATION-PROPERTIES ((CONFIGURATION CONFIGURATION-TABLE) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Print all properties defined in `configuration' to `stream'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueList", "printConfigurationProperties", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.KeyValueList"), Native.find_java_class("edu.isi.stella.OutputStream")}), null);
      Stella.defineFunctionObject("*PL-ROOT-DIRECTORY*-SETTER", "(DEFUN (*PL-ROOT-DIRECTORY*-SETTER STRING) ((VALUE STRING)))", Native.find_java_method("edu.isi.stella.Stella", "$PlRootDirectory$Setter", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CONFIGURE-STELLA", "(DEFUN CONFIGURE-STELLA ((FILE FILE-NAME)) :DOCUMENTATION \"Perform STELLA run-time configuration.  If supplied, load the\nconfiguration file `file' first which should be supplied with a physical pathname.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "configureStella", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), Native.find_java_method("edu.isi.stella.Cons", "configureStellaEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("GET-PROPERTY", "(DEFUN (GET-PROPERTY OBJECT) ((PROPERTY NAME) |&REST| (DEFAULTVALUE OBJECT)) :DOCUMENTATION \"Lookup `property' (a string or symbol) in the configuration\ntable and return its value.  If it is undefined, return the optional `defaultValue'.\nNote that `property' is evaluated and will need to be quoted if supplied as a\nsymbol.  Symbols will also be upcased if this command is run in a non-case-\nsensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "getProperty", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons")}), Native.find_java_method("edu.isi.stella.Cons", "getPropertyEvaluatorWrapper", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}));
      Stella.defineFunctionObject("SET-PROPERTY", "(DEFUN SET-PROPERTY ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Set `property' (a string or symbol) in the configuration\ntable to `value'.  Note that `property' is evaluated and will need to be quoted\nif supplied as a symbol.  Symbols will also be upcased if this command is run in\na non-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "setProperty", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("ADD-PROPERTY-VALUE", "(DEFUN ADD-PROPERTY-VALUE ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Add `value' to the end of `property's (a string or symbol) value\nlist in the configuration table.  Coerces the current value to a list or initializes\nthe list if it is as yet undefined.  Allows incremental addition of values to\nlist-valued propertys.  Note that `property' is evaluated and will need to be quoted\nif supplied as a symbol.  Symbols will also be upcased if this command is run in a\nnon-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "addPropertyValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("PRINT-PROPERTIES", "(DEFUN PRINT-PROPERTIES () :DOCUMENTATION \"Print all current configuration property information to\nstandard output.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "printProperties", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("REGISTER-PROPERTY-DEMON", "(DEFUN REGISTER-PROPERTY-DEMON ((PROPERTY STRING) (DEMONNAME SYMBOL)) :DOCUMENTATION \"Register the function named `demonName' as the demon for `property'.\nDemons will be run as after demons on every configuration table update.  Set the\nproperty `stella.test.propertyDemon' to see a test demon in action.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "registerPropertyDemon", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Symbol")}), null);
      Stella.defineFunctionObject("UNREGISTER-PROPERTY-DEMON", "(DEFUN UNREGISTER-PROPERTY-DEMON ((PROPERTY STRING)) :DOCUMENTATION \"Unregister any demon for `property'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "unregisterPropertyDemon", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("LOOKUP-VARIABLE-DEMON-SETTER", "(DEFUN (LOOKUP-VARIABLE-DEMON-SETTER METHOD-SLOT) ((DEMON GLOBAL-VARIABLE)))", Native.find_java_method("edu.isi.stella.GlobalVariable", "lookupVariableDemonSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.GlobalVariable")}), null);
      Stella.defineFunctionObject("RUN-CONFIGURATION-PROPERTY-DEMON", "(DEFUN RUN-CONFIGURATION-PROPERTY-DEMON ((ACTION KEYWORD) (PROPERTY STRING) (VALUE OBJECT) (TABLE CONFIGURATION-TABLE)))", Native.find_java_method("edu.isi.stella.Keyword", "runConfigurationPropertyDemon", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Keyword"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineExternalSlotFromStringifiedSource("(DEFSLOT METHOD-SLOT DEMON-PROPERTY :TYPE STRING :OPTION-KEYWORD :DEMON-PROPERTY :OPTION-HANDLER DEMON-PROPERTY-HANDLER :DOCUMENTATION \"Holds the property monitored by a demon function.  This slot is primarily used\nto allow us the use of the :demon-property option handler for demon registration.\" :ALLOCATION :DYNAMIC)");
      Stella.defineExternalSlotFromStringifiedSource("(DEFSLOT GLOBAL-VARIABLE DEMON-PROPERTY :TYPE STRING :OPTION-KEYWORD :DEMON-PROPERTY :OPTION-HANDLER DEMON-PROPERTY-HANDLER :DOCUMENTATION \"Holds the property monitored by a demon for this variable.  This slot is\nprimarily used to allow us the use of the :demon-property option handler for demon registration.\" :ALLOCATION :DYNAMIC)");
      Stella.defineFunctionObject("DEMON-PROPERTY-HANDLER", "(DEFUN DEMON-PROPERTY-HANDLER ((DEMON MAPPABLE-OBJECT) (SLOT STORAGE-SLOT) (PROPERTY OBJECT)))", Native.find_java_method("edu.isi.stella.MappableObject", "demonPropertyHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.MappableObject"), Native.find_java_class("edu.isi.stella.StorageSlot"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("TEST-PROPERTY-DEMON", "(DEFUN TEST-PROPERTY-DEMON ((ACTION KEYWORD) (PROPERTY STRING) (VALUE OBJECT) (TABLE CONFIGURATION-TABLE)) :DOCUMENTATION \"A test demon for the property demon machinery which simply prints arguments.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Keyword", "testPropertyDemon", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Keyword"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
      Stella.defineFunctionObject("REGISTER-CMD-LINE-OPTION", "(DEFUN REGISTER-CMD-LINE-OPTION (|&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Register a command line option.  :key identifies the name of the option which\nwill usually start with a dash such as `-e' or `--eval'.  :key2 and :key3 can be used to supply\nadditional options (e.g., long option formats).  To supply even more keys, a list can be supplied\nwith the :keys option.  If a :property is supplied, this option simply sets or adds to the values\nof the specified system configuration property.  If a :handler name is specified, its function\nwill be used to interpret the values of the option.  :documentation can be used to supply a\ndocumentation string which will be printed by the `help-option-handler' (usually bound to `-?').\n:value-type describes what type an option value should be coerced to before assigning it to the\nspecified configuration :property.  :n-arguments describes how many arguments this option\ntakes.  This will be 0 for simple switches and can be 1 or greater than one for option handlers\nthat need one or more arguments.  :default-value defines the value to use for zero-argument\n:property options.  If :multi-valued? is true, values of multiple occurrences of the option will be\nadded to the specified configuration :property.  :error-action can be one of :ignore, :warn or\n:error to specify what to do in case an error is encountered during option processing.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "registerCmdLineOption", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("UNREGISTER-CMD-LINE-OPTION", "(DEFUN UNREGISTER-CMD-LINE-OPTION ((KEY STRING)) :DOCUMENTATION \"Unregister the command line option identified by `key' under all its keys.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "unregisterCmdLineOption", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("UNREGISTER-ALL-CMD-LINE-OPTIONS", "(DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS () :DOCUMENTATION \"Unregister all currently registered command line options.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "unregisterAllCmdLineOptions", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("DEFAULT-CMD-LINE-OPTION-HANDLER", "(DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Default handler that tries to set a system property based on `option' and `value'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "defaultCmdLineOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("PROCESS-COMMAND-LINE-ARGUMENTS", "(DEFUN PROCESS-COMMAND-LINE-ARGUMENTS ((COUNT INTEGER) (ARGUMENTS (ARRAY () OF STRING)) (UNHANDLEDOPTIONACTION KEYWORD)) :DOCUMENTATION \"Interpret any command line `arguments' for which handlers have been registered.\nLeave any remaining unprocessed arguments in `*unprocessed-command-line-arguments*'.\nIf any unprocessed arguments use option syntax (that is they start with a `-'), proceed\naccording to `unhandledOptionAction' which can be one of :ignore, :warn or :error.\nThis ensures that at any point in the option processing, `*unprocessed-command-line-arguments*'\naccurately reflects the arguments which have been either skipped or not handled yet.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "processCommandLineArguments", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("[Ljava.lang.String;"), Native.find_java_class("edu.isi.stella.Keyword")}), null);
      Stella.defineFunctionObject("UNPROCESSED-COMMAND-LINE-ARGUMENTS", "(DEFUN (UNPROCESSED-COMMAND-LINE-ARGUMENTS (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return all command line arguments which have not yet been processed\nby (or been ignored by) `process-command-line-arguments'.  If arguments have not yet\nbeen processed, this will return NULL.\" :PUBLIC? TRUE :COMMAND? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "unprocessedCommandLineArguments", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("EVAL-OPTION-HANDLER", "(DEFUN EVAL-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval option by evaluating `value'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "evalOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("EVAL-IN-MODULE-OPTION-HANDLER", "(DEFUN EVAL-IN-MODULE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval-in-module option.  `value' is expected\nto be of the form `(<module-name> <s-expression>)'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "evalInModuleOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("LOAD-PATH-OPTION-HANDLER", "(DEFUN LOAD-PATH-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Modify the current file load path according to `option' and `value'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "loadPathOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("CONFIG-FILE-OPTION-HANDLER", "(DEFUN CONFIG-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the configuration file `value'.  This will\nmodify currently set system properties defined in `value' with new\nvalues but leave all other currently set properties as they are.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "configFileOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("LOAD-FILE-OPTION-HANDLER", "(DEFUN LOAD-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the file `value' using the STELLA `load-file' command.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "loadFileOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("DEFINE-PROPERTY-OPTION-HANDLER", "(DEFUN DEFINE-PROPERTY-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)))", Native.find_java_method("edu.isi.stella.CmdLineOption", "definePropertyOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("HELP-OPTION-HANDLER", "(DEFUN HELP-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Print documentation about all currently registered option handlers.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CmdLineOption", "helpOptionHandler", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STARTUP-SYSTEMS", "(DEFUN STARTUP-SYSTEMS () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella._StartupSystems", "startupSystems", new java.lang.Class [] {}), null);
      { MethodSlot function = Symbol.lookupFunction(Stella.SYM_STELLA_STARTUP_SYSTEMS);

        KeyValueList.setDynamicSlotValue(function.dynamicSlots, Stella.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupSystems"), Stella.NULL_STRING_WRAPPER);
      }
    }
  }

  public static void startupSystems() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.$STELLA_MODULE$);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          _StartupSystems.helpStartupSystems1();
          Stella.SYM_STELLA_LOAD_PATH_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("LOAD-PATH-OPTION-HANDLER", null, 0)));
          Stella.SYM_STELLA_CONFIG_FILE_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("CONFIG-FILE-OPTION-HANDLER", null, 0)));
          Stella.SYM_STELLA_LOAD_FILE_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("LOAD-FILE-OPTION-HANDLER", null, 0)));
          Stella.SYM_STELLA_DEFINE_PROPERTY_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("DEFINE-PROPERTY-OPTION-HANDLER", null, 0)));
          Stella.SYM_STELLA_HELP_OPTION_HANDLER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("HELP-OPTION-HANDLER", null, 0)));
          Stella.SYM_STELLA_STARTUP_SYSTEMS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-SYSTEMS", null, 0)));
        }
        if (Stella.currentStartupTimePhaseP(4)) {
          _StartupSystems.helpStartupSystems2();
        }
        if (Stella.currentStartupTimePhaseP(5)) {
          Stella.defineStellaTypeFromStringifiedSource("(DEFTYPE CONFIGURATION-TABLE (KEY-VALUE-LIST OF STRING-WRAPPER OBJECT))");
          { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("CMD-LINE-OPTION", "(DEFCLASS CMD-LINE-OPTION (STANDARD-OBJECT) :SLOTS ((DOCUMENTATION :TYPE STRING :INITIALLY \"Not documented.\") (KEYS :TYPE (CONS OF STRING-WRAPPER) :INITIALLY NIL) (VALUE-TYPE :TYPE TYPE :INITIALLY @STRING) (MULTI-VALUED? :TYPE BOOLEAN :INITIALLY FALSE) (N-ARGUMENTS :TYPE INTEGER :INITIALLY 0 :DOCUMENTATION \"The number of args expected by this option.\nCommon values are 0 or 1, but certain options might take more than one argument.\") (DEFAULT-VALUE :TYPE OBJECT :DOCUMENTATION \"The value to use for 0-arg options.\nDefaults to TRUE for 0-arg options with boolean value type.\") (CONFIGURATION-PROPERTY :TYPE STRING) (HANDLER :TYPE FUNCTION-CODE :INITIALLY (THE-CODE :FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER)) (ERROR-ACTION :TYPE KEYWORD :INITIALLY :ERROR :DOCUMENTATION \"One of :ignore, :warn, :error.\")))");

            renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.CmdLineOption", "newCmdLineOption", new java.lang.Class [] {});
            renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.stella.CmdLineOption", "accessCmdLineOptionSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.CmdLineOption"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
          }
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          _StartupSystems.helpStartupSystems3();
          _StartupSystems.helpStartupSystems4();
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("STELLA")))));
          Stella.defineGlobalVariableObject("(DEFGLOBAL *FILE-LOAD-PATH* (CONS OF STRING-WRAPPER) NIL)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *STELLA-FILE-EXTENSIONS* CONS (CONS-LIST \".ste\") :DOCUMENTATION \"File extensions to append by default when a\nfile is looked up by `find-file-in-load-path'.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFSPECIAL *CURRENTLOADFILE* STRING NULL :DOCUMENTATION \"Full pathname of file that is currently being loaded (or similar).\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *SYSTEMDEFINITIONS* (LIST OF SYSTEM-DEFINITION) (NEW LIST) :DOCUMENTATION \"A list of all defined systems.\")", null);
          Stella.defineGlobalVariableObject("(DEFSPECIAL *CURRENT-SYSTEM-ACTION* PROPERTY-LIST NULL :DOCUMENTATION \"Holds the action and options of the current system action\nsuch as :make-system, :load-system or :translate-system.  This is used to\nperform the appropriate actions on required systems in `define-system'.\")", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *SYSTEM-CONFIGURATION-TABLE* CONFIGURATION-TABLE (NEW CONFIGURATION-TABLE))", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *PL-ROOT-DIRECTORY* STRING NULL :DOCUMENTATION \"The :root-directory portion of the PL logical host.  This variable\nis primarily defined to allow us to dynamically change this via a configuration demon.\" :DEMON-PROPERTY \"stella.plRootDirectory\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *REGISTERED-PROPERTY-DEMONS* (KEY-VALUE-MAP OF STRING-WRAPPER MAPPABLE-OBJECT) (NEW KEY-VALUE-MAP))", null);
          Stella.registerPropertyDemon("stella.test.propertyDemon", Stella.SYM_STELLA_TEST_PROPERTY_DEMON);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *REGISTERED-COMMAND-LINE-OPTIONS* (KEY-VALUE-MAP OF STRING-WRAPPER CMD-LINE-OPTION) (NEW KEY-VALUE-MAP))", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *UNPROCESSED-COMMAND-LINE-ARGUMENTS* (CONS OF STRING-WRAPPER) NULL)", null);
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("-e"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--eval"), Cons.cons(Stella.KWD_KEY3, Cons.cons(StringWrapper.wrapString("-eval"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<s-expression>\n  Evaluate the STELLA <s-expression> in the current module."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_EVAL_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("--eval-in-module"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<module-name> <s-expression>\n  Evaluate the STELLA <s-expression> in module <module-name>."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(2), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_EVAL_IN_MODULE_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("--path"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--path+="), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<path>\n  Add <path> to the front of the current file load path."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_LOAD_PATH_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("--path="), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<path>\n  Set the current file load path to <path>."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_LOAD_PATH_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("--path=+"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<path>\n  Add <path> at the end of the current file load path."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_LOAD_PATH_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("-c"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--configuration-file"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<file>\n  Load the STELLA configuration file <file>."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_CONFIG_FILE_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("-l"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--load"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<file>\n  Load the STELLA file <file>."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_LOAD_FILE_OPTION_HANDLER, Cons.cons(Stella.KWD_ERROR_ACTION, Cons.cons(Stella.KWD_WARN, Stella.NIL)))))))))))));
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("-D"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--define"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("<property>{=|+=|-=}<value>}\n  Set the STELLA configuration <property> to <value>.  Multi-valued properties can be\n  added to via the `+=' and removed from via the `-=' assignment operator."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_DEFINE_PROPERTY_OPTION_HANDLER, Stella.NIL)))))))))));
          Stella.defineGlobalVariableObject("(DEFGLOBAL *COMMAND-LINE-HELP-HEADER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the beginning of command line help.\" :PUBLIC? TRUE)", null);
          Stella.defineGlobalVariableObject("(DEFGLOBAL *COMMAND-LINE-HELP-TRAILER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the end of command line help.\" :PUBLIC? TRUE)", null);
          Stella.registerCmdLineOption(Cons.cons(Stella.KWD_KEY, Cons.cons(StringWrapper.wrapString("-?"), Cons.cons(Stella.KWD_KEY2, Cons.cons(StringWrapper.wrapString("--help"), Cons.cons(Stella.KWD_DOCUMENTATION, Cons.cons(StringWrapper.wrapString("\n  Print this command line help message."), Cons.cons(Stella.KWD_N_ARGUMENTS, Cons.cons(IntegerWrapper.wrapInteger(0), Cons.cons(Stella.KWD_HANDLER, Cons.cons(Stella.SYM_STELLA_HELP_OPTION_HANDLER, Stella.NIL)))))))))));
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
