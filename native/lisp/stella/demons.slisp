;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; demons.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-DEMONS-MODIFY NULL)
(CL:DEFVAR KWD-DEMONS-CREATE NULL)
(CL:DEFVAR KWD-DEMONS-DESTROY NULL)
(CL:DEFVAR KWD-DEMONS-ALL NULL)
(CL:DEFVAR KWD-DEMONS-CLASS NULL)
(CL:DEFVAR KWD-DEMONS-SLOT NULL)
(CL:DEFVAR KWD-DEMONS-CODE NULL)
(CL:DEFVAR KWD-DEMONS-METHOD NULL)
(CL:DEFVAR KWD-DEMONS-GUARD? NULL)
(CL:DEFVAR KWD-DEMONS-INHERITED? NULL)
(CL:DEFVAR KWD-DEMONS-DOCUMENTATION NULL)
(CL:DEFVAR KWD-DEMONS-ACTIVATE? NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SLOT-GUARD-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CLASS-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CLASS-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-WRAP-LITERAL NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-PROGN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-DEFINE-DEMON NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-THE-CODE NULL)
(CL:DEFVAR KWD-DEMONS-FUNCTION NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-DEFDEMON NULL)
(CL:DEFVAR KWD-DEMONS-COMMON-LISP NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-LET NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-VALUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SLOT-VALUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SELF NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-WHEN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-RETURN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-NEW NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SETF NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-OWNER-INSTANCE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-ACTIVE-SLOT NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-GET-SLOT NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-BQUOTE NULL)
(CL:DEFVAR SGT-DEMONS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT NULL)
(CL:DEFVAR SGT-DEMONS-STELLA-LITERAL NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SLOT NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-OLDVALUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-NOT NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-EQL? NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-IF NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CHECK-FOR-SLOT-DEMONS? NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-WRAPPEDOLDVALUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-NULL NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-WRAPPEDNEWVALUE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-RUN-SLOT-GUARD-DEMONS? NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-RUN-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-FREE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-AND NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-EQ? NULL)
(CL:DEFVAR SGT-DEMONS-STELLA-HOOK-LIST NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-SIGNATURE NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-STARTUP-DEMONS NULL)
(CL:DEFVAR SYM-DEMONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* STANDARD-ERROR TRUE-WRAPPER NIL
  STANDARD-OUTPUT EOL))

;;; (DEFGLOBAL *DEMONS-TABLE* ...)

(CL:DEFVAR *DEMONS-TABLE* NULL
  "Table containing all active and inactive demons, indexed
on their names.")

;;; (DEFGLOBAL *CONSTRUCTOR-DEMONS* ...)

(CL:DEFVAR *CONSTRUCTOR-DEMONS* NULL
  "These demons trigger every time an active instance is created.")

;;; (DEFGLOBAL *DESTRUCTOR-DEMONS* ...)

(CL:DEFVAR *DESTRUCTOR-DEMONS* NULL
  "These demons trigger every time an active instance is destroyed.")

;;; (DEFGLOBAL *ALL-SLOTS-DEMONS* ...)

(CL:DEFVAR *ALL-SLOTS-DEMONS* NULL
  "These demons trigger every time a slot value is modified.")

;;; (DEFGLOBAL *ALL-SLOTS-GUARD-DEMONS* ...)

(CL:DEFVAR *ALL-SLOTS-GUARD-DEMONS* NULL
  "These demons trigger every time a slot value is modified, and
cancel slot update when they return `false'.")

;;; (DEFUN (VALIDATE-DEMON-REFERENCES? BOOLEAN) ...)

(CL:DEFUN VALIDATE-DEMON-REFERENCES? (DEMON)
  (CL:LET*
   ((CLASSREF
     (CL:IF (CL:NOT (CL:EQ (%DEMON.DEMON-CLASS-REFS DEMON) NULL))
      (FIRST (%DEMON.DEMON-CLASS-REFS DEMON)) NULL))
    (SLOTREF
     (CL:IF (CL:NOT (CL:EQ (%DEMON.DEMON-SLOT-REFS DEMON) NULL))
      (FIRST (%DEMON.DEMON-SLOT-REFS DEMON)) NULL))
    (SLOT NULL))
   (CL:WHEN (CL:AND (CL:EQ CLASSREF NULL) (CL:EQ SLOTREF NULL))
    (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:T))
   (CL:WHEN (CL:EQ CLASSREF NULL)
    (CL:WARN "Missing :class option in demon `~A'" DEMON)
    (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:NIL))
   (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE CLASSREF) NULL)
    (CL:WARN "Class `~A' not yet defined." CLASSREF)
    (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:NIL))
   (CL:WHEN (CL:EQ (%DEMON.DEMON-ACTION DEMON) KWD-DEMONS-MODIFY)
    (CL:WHEN (CL:EQ SLOTREF NULL)
     (CL:WARN "Missing :slot option in demon `~A'" DEMON)
     (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:NIL))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:LET* ()
      (CL:SETQ SLOT
       (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE CLASSREF) SLOTREF))
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SLOT NULL))))
     (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
     (CL:WHEN TEST-VALUE-000
      (CL:WARN
       "No slot named `~A' exists on class `~A'.~%Can't create demon `~A'"
       SLOTREF (%SURROGATE.SURROGATE-VALUE CLASSREF) DEMON)
      (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:NIL)))
    (CL:WHEN (CL:NOT (STORAGE-SLOT? SLOT))
     (CL:WARN "Can't install a demon on the method.`~A'" SLOT)
     (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:NIL)))
   (CL:RETURN-FROM VALIDATE-DEMON-REFERENCES? CL:T)))

;;; (DEFUN (INCORPORATE-DEMON-OPTIONS? BOOLEAN) ...)

(CL:DEFUN INCORPORATE-DEMON-OPTIONS? (DEMON OPTIONS)
  (CL:COND
   ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-DEMONS-CREATE) NULL))
    (CL:SETF (%DEMON.DEMON-ACTION DEMON) KWD-DEMONS-CREATE))
   ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-DEMONS-DESTROY) NULL))
    (CL:SETF (%DEMON.DEMON-ACTION DEMON) KWD-DEMONS-DESTROY))
   (CL:T (CL:SETF (%DEMON.DEMON-ACTION DEMON) KWD-DEMONS-MODIFY)))
  (CL:LET*
   ((K NULL) (V NULL) (ITER-000 (%PROPERTY-LIST.THE-PLIST OPTIONS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ K (%%VALUE ITER-000))
    (CL:SETQ V (%%VALUE (%%REST ITER-000)))
    (CL:LET* ((TEST-VALUE-000 K))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-DEMONS-CREATE)
        (CL:EQ TEST-VALUE-000 KWD-DEMONS-DESTROY))
       (CL:SETF (%DEMON.DEMON-ACTION DEMON) K)
       (CL:IF (CL:EQ V KWD-DEMONS-ALL)
        (CL:SETF (%DEMON.DEMON-ALL? DEMON) CL:T)
        (INSERT (%DEMON.DEMON-CLASS-REFS DEMON) (SURROGATIFY V))))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-CLASS)
       (INSERT (%DEMON.DEMON-CLASS-REFS DEMON) (SURROGATIFY V)))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-SLOT)
       (CL:IF (CL:EQ V KWD-DEMONS-ALL)
        (CL:SETF (%DEMON.DEMON-ALL? DEMON) CL:T)
        (INSERT (%DEMON.DEMON-SLOT-REFS DEMON) (PERMANENTIFY V))))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-CODE)
       (CL:SETF (%DEMON.DEMON-CODE DEMON)
        (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE V)))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-METHOD)
       (CL:SETF (%DEMON.DEMON-METHOD DEMON) V))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-GUARD?)
       (CL:SETF (%DEMON.DEMON-GUARD? DEMON) CL:T))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-INHERITED?)
       (CL:SETF (%DEMON.DEMON-INHERIT? DEMON) CL:T)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Inherit? not yet implemented for demons" EOL))
      ((CL:EQ TEST-VALUE-000 KWD-DEMONS-DOCUMENTATION)
       (CL:SETF (%DEMON.DEMON-DOCUMENTATION DEMON)
        (%STRING-WRAPPER.WRAPPER-VALUE V)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
  (CL:WHEN (CL:NOT (CL:EQ (%DEMON.DEMON-METHOD DEMON) NULL))
   (CL:SETF (%DEMON.DEMON-CODE DEMON)
    (%METHOD-SLOT.FUNCTION-CODE (%DEMON.DEMON-METHOD DEMON))))
  (FREE OPTIONS)
  (CL:RETURN-FROM INCORPORATE-DEMON-OPTIONS?
   (VALIDATE-DEMON-REFERENCES? DEMON)))

;;; (DEFUN (LOOKUP-DEMON DEMON) ...)

(CL:DEFUN LOOKUP-DEMON (NAME)
  "Return the demon named `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOOKUP-DEMON (LOOKUP *DEMONS-TABLE* NAME)))

;;; (DEFUN (DEFINE-DEMON DEMON) ...)

(CL:DEFUN DEFINE-DEMON (NAME CL:&REST OPTIONS)
  "Define a class or slot demon.  Options are :create,
:destroy, :class, :slot, :guard?, :code, :method, :inherit?, and :documentation."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((DEMON (NEW-DEMON)) (PLIST (NEW-PROPERTY-LIST)) (CONSLIST NIL)
    (OLDDEMON NULL) (ACTIVATE? CL:NIL))
   (CL:LET* ((ITEM NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ITEM (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
       (CL:IF (CL:EQ CONSLIST NIL) (CL:SETQ CONSLIST COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CONSLIST COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST PLIST) CONSLIST)
   (CL:SETF (%DEMON.DEMON-NAME DEMON) NAME)
   (CL:SETQ ACTIVATE?
    (CL:EQ (REMOVE-AT PLIST KWD-DEMONS-ACTIVATE?) TRUE-WRAPPER))
   (CL:WHEN (INCORPORATE-DEMON-OPTIONS? DEMON PLIST)
    (CL:LET* () (CL:SETQ OLDDEMON (LOOKUP-DEMON NAME))
     (CL:WHEN (CL:NOT (CL:EQ OLDDEMON NULL))
      (DEACTIVATE-DEMON OLDDEMON) (FREE OLDDEMON)))
    (INSERT-AT *DEMONS-TABLE* (%DEMON.DEMON-NAME DEMON) DEMON)
    (CL:WHEN ACTIVATE? (ACTIVATE-DEMON DEMON))
    (CL:RETURN-FROM DEFINE-DEMON DEMON))
   (FREE DEMON) (CL:RETURN-FROM DEFINE-DEMON NULL)))

;;; (DEFUN (INJECT-DEMON (LIST OF DEMON)) ...)

(CL:DEFUN INJECT-DEMON (DEMONLIST DEMON)
  (CL:WHEN (NULL-LIST? DEMONLIST) (CL:SETQ DEMONLIST (NEW-LIST)))
  (CL:LET* ((IT (ALLOCATE-ITERATOR DEMONLIST)))
   (CL:LOOP WHILE (NEXT? IT) DO
    (CL:WHEN
     (STRING-EQL? (%DEMON.DEMON-NAME (%LIST-ITERATOR.VALUE IT))
      (%DEMON.DEMON-NAME DEMON))
     (VALUE-SETTER IT DEMON) (CL:RETURN-FROM INJECT-DEMON DEMONLIST))))
  (INSERT DEMONLIST DEMON)
  (CL:RETURN-FROM INJECT-DEMON DEMONLIST))

;;; (DEFUN (EJECT-DEMON (LIST OF DEMON)) ...)

(CL:DEFUN EJECT-DEMON (DEMONLIST DEMON)
  (CL:WHEN (CL:EQ DEMONLIST NULL) (CL:RETURN-FROM EJECT-DEMON NULL))
  (REMOVE DEMONLIST DEMON)
  (CL:WHEN (EMPTY? DEMONLIST) (FREE DEMONLIST) (CL:SETQ DEMONLIST NULL))
  (CL:RETURN-FROM EJECT-DEMON DEMONLIST))

;;; (DEFUN ACTIVATE-DEMON ...)

(CL:DEFUN ACTIVATE-DEMON (DEMON)
  "Install `demon' in the location(s) specified by its internal
structure."
  (CL:WHEN (CL:EQ DEMON NULL) (CL:RETURN-FROM ACTIVATE-DEMON))
  (CL:LET* ((TEST-VALUE-000 (%DEMON.DEMON-ACTION DEMON)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-MODIFY)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:IF (%DEMON.DEMON-GUARD? DEMON)
       (CL:SETQ *ALL-SLOTS-GUARD-DEMONS*
        (INJECT-DEMON *ALL-SLOTS-GUARD-DEMONS* DEMON))
       (CL:SETQ *ALL-SLOTS-DEMONS*
        (INJECT-DEMON *ALL-SLOTS-DEMONS* DEMON)))
      (CL:LET*
       ((TYPE NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON)))
        (SLOTNAME NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-SLOT-REFS DEMON))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ TYPE (%%VALUE ITER-000))
        (CL:SETQ SLOTNAME (%%VALUE ITER-001))
        (CL:TAGBODY
         (CL:LET*
          ((SLOT
            (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME)))
          (CL:WHEN (CL:EQ SLOT NULL)
           (CL:WARN
            "Can't install demon on non-existant slot `~A'.`~A'"
            (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
            SYM-DEMONS-STELLA-SLOT-GUARD-DEMONS
            (INJECT-DEMON (SLOT-GUARD-DEMONS SLOT) DEMON) NULL)
           (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
            SYM-DEMONS-STELLA-SLOT-DEMONS
            (INJECT-DEMON (SLOT-DEMONS SLOT) DEMON) NULL)))
         :CONTINUE)
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-CREATE)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:SETQ *CONSTRUCTOR-DEMONS*
       (INJECT-DEMON *CONSTRUCTOR-DEMONS* DEMON))
      (CL:LET*
       ((CLASSREF NULL)
        (ITER-002
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ CLASSREF (%%VALUE ITER-002))
        (CL:TAGBODY
         (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE CLASSREF)))
          (CL:WHEN (CL:EQ CLASS NULL)
           (CL:WARN "Can't install demon on non-existant class `~A'"
            CLASSREF)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
            (INJECT-DEMON (CLASS-GUARD-CONSTRUCTOR-DEMONS CLASS) DEMON)
            NULL)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-CONSTRUCTOR-DEMONS
            (INJECT-DEMON (CLASS-CONSTRUCTOR-DEMONS CLASS) DEMON)
            NULL)))
         :CONTINUE)
        (CL:SETQ ITER-002 (%%REST ITER-002))))))
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-DESTROY)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:SETQ *DESTRUCTOR-DEMONS*
       (INJECT-DEMON *DESTRUCTOR-DEMONS* DEMON))
      (CL:LET*
       ((CLASSREF NULL)
        (ITER-003
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:SETQ CLASSREF (%%VALUE ITER-003))
        (CL:TAGBODY
         (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE CLASSREF)))
          (CL:WHEN (CL:EQ CLASS NULL)
           (CL:WARN "Can't install demon on non-existant class `~A'"
            CLASSREF)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
            (INJECT-DEMON (CLASS-GUARD-DESTRUCTOR-DEMONS CLASS) DEMON)
            NULL)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-DESTRUCTOR-DEMONS
            (INJECT-DEMON (CLASS-DESTRUCTOR-DEMONS CLASS) DEMON)
            NULL)))
         :CONTINUE)
        (CL:SETQ ITER-003 (%%REST ITER-003))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  :VOID)

;;; (DEFUN DEACTIVATE-DEMON ...)

(CL:DEFUN DEACTIVATE-DEMON (DEMON)
  "Detach `demon' from the location(s) specified by its internal
structure."
  (CL:WHEN (CL:EQ DEMON NULL) (CL:RETURN-FROM DEACTIVATE-DEMON))
  (CL:LET* ((TEST-VALUE-000 (%DEMON.DEMON-ACTION DEMON)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-MODIFY)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:IF (%DEMON.DEMON-GUARD? DEMON)
       (CL:SETQ *ALL-SLOTS-GUARD-DEMONS*
        (EJECT-DEMON *ALL-SLOTS-GUARD-DEMONS* DEMON))
       (CL:SETQ *ALL-SLOTS-DEMONS*
        (EJECT-DEMON *ALL-SLOTS-DEMONS* DEMON)))
      (CL:LET*
       ((TYPE NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON)))
        (SLOTNAME NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-SLOT-REFS DEMON))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ TYPE (%%VALUE ITER-000))
        (CL:SETQ SLOTNAME (%%VALUE ITER-001))
        (CL:TAGBODY
         (CL:LET*
          ((SLOT
            (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME)))
          (CL:WHEN (CL:EQ SLOT NULL)
           (CL:WARN
            "Can't remove demon from non-existant slot `~A'.`~A'"
            (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
            SYM-DEMONS-STELLA-SLOT-GUARD-DEMONS
            (EJECT-DEMON (SLOT-GUARD-DEMONS SLOT) DEMON) NULL)
           (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
            SYM-DEMONS-STELLA-SLOT-DEMONS
            (EJECT-DEMON (SLOT-DEMONS SLOT) DEMON) NULL)))
         :CONTINUE)
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-CREATE)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:SETQ *CONSTRUCTOR-DEMONS*
       (EJECT-DEMON *CONSTRUCTOR-DEMONS* DEMON))
      (CL:LET*
       ((CLASSREF NULL)
        (ITER-002
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ CLASSREF (%%VALUE ITER-002))
        (CL:TAGBODY
         (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE CLASSREF)))
          (CL:WHEN (CL:EQ CLASS NULL)
           (CL:WARN "Can't install demon on non-existant class `~A'"
            CLASSREF)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
            (EJECT-DEMON (CLASS-GUARD-CONSTRUCTOR-DEMONS CLASS) DEMON)
            NULL)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-CONSTRUCTOR-DEMONS
            (EJECT-DEMON (CLASS-CONSTRUCTOR-DEMONS CLASS) DEMON)
            NULL)))
         :CONTINUE)
        (CL:SETQ ITER-002 (%%REST ITER-002))))))
    ((CL:EQ TEST-VALUE-000 KWD-DEMONS-DESTROY)
     (CL:IF (%DEMON.DEMON-ALL? DEMON)
      (CL:SETQ *DESTRUCTOR-DEMONS*
       (EJECT-DEMON *DESTRUCTOR-DEMONS* DEMON))
      (CL:LET*
       ((CLASSREF NULL)
        (ITER-003
         (%LIST.THE-CONS-LIST (%DEMON.DEMON-CLASS-REFS DEMON))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:SETQ CLASSREF (%%VALUE ITER-003))
        (CL:TAGBODY
         (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE CLASSREF)))
          (CL:WHEN (CL:EQ CLASS NULL)
           (CL:WARN "Can't install demon on non-existant class `~A'"
            CLASSREF)
           (CL:GO :CONTINUE))
          (CL:IF (%DEMON.DEMON-GUARD? DEMON)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
            (EJECT-DEMON (CLASS-GUARD-DESTRUCTOR-DEMONS CLASS) DEMON)
            NULL)
           (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
            SYM-DEMONS-STELLA-CLASS-DESTRUCTOR-DEMONS
            (EJECT-DEMON (CLASS-DESTRUCTOR-DEMONS CLASS) DEMON) NULL)))
         :CONTINUE)
        (CL:SETQ ITER-003 (%%REST ITER-003))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  :VOID)

;;; (DEFUN (DESTRUCTURE-DEFDEMON-BODY CONS CONS) ...)

(CL:DEFUN DESTRUCTURE-DEFDEMON-BODY (DEMONTREE)
  (CL:LET*
   ((OPTIONSTREE DEMONTREE) (BODYTREE DEMONTREE) (TRAILINGCURSOR NULL))
   (CL:LOOP WHILE (KEYWORD? (%%VALUE BODYTREE)) DO
    (CL:SETQ TRAILINGCURSOR BODYTREE)
    (CL:SETQ BODYTREE (%%REST (%%REST BODYTREE))))
   (CL:IF (CL:NOT (CL:EQ TRAILINGCURSOR NULL))
    (CL:SETF (%%REST (%%REST TRAILINGCURSOR)) NIL)
    (CL:SETQ OPTIONSTREE NIL))
   (CL:RETURN-FROM DESTRUCTURE-DEFDEMON-BODY
    (CL:VALUES OPTIONSTREE BODYTREE))))

;;; (DEFUN IN-PLACE-NORMALIZE-DEMON-OPTIONS ...)

(CL:DEFUN IN-PLACE-NORMALIZE-DEMON-OPTIONS (OPTIONSTREE)
  (CL:LET* ((IT (ALLOCATE-ITERATOR OPTIONSTREE)))
   (CL:LOOP WHILE (NEXT? IT) DO
    (CL:COND
     ((WRAPPER? (%CONS-ITERATOR.VALUE IT))
      (VALUE-SETTER IT
       (LIST* SYM-DEMONS-STELLA-WRAP-LITERAL (%CONS-ITERATOR.VALUE IT)
        NIL)))
     ((CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-DEMONS-STELLA-TRUE)
      (VALUE-SETTER IT
       (LIST* SYM-DEMONS-STELLA-WRAP-BOOLEAN SYM-DEMONS-STELLA-TRUE
        NIL)))
     ((CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-DEMONS-STELLA-FALSE)
      (VALUE-SETTER IT
       (LIST* SYM-DEMONS-STELLA-WRAP-BOOLEAN SYM-DEMONS-STELLA-FALSE
        NIL))))))
  :VOID)

;;; (DEFMACRO DEFDEMON ...)

(CL:DEFUN %DEFDEMON (NAME PARAMETERSTREE OPTIONSANDBODY)
  "Define a demon `name' and attach it to a class or slot."
  (CL:LET*
   ((FIRSTPARAMETER (%%VALUE PARAMETERSTREE)) (TYPE NULL)
    (DEMONFUNCTIONNAME
     (INTERN-SYMBOL (%STRING-WRAPPER.WRAPPER-VALUE NAME))))
   (CL:WHEN (CL:NOT (CONS? FIRSTPARAMETER))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal first parameter in demon `"
       (DE-UGLIFY-PARSE-TREE NAME) "'." EOL)))
    (CL:RETURN-FROM %DEFDEMON NIL))
   (CL:SETQ TYPE
    (TYPE-SPEC-TO-BASE-TYPE
     (SAFE-YIELD-TYPE-SPECIFIER (%%VALUE (%%REST FIRSTPARAMETER)))))
   (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE TYPE) NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Demon defined on the non-existent class `"
       (DE-UGLIFY-PARSE-TREE TYPE) "'." EOL)))
    (CL:RETURN-FROM %DEFDEMON NIL))
   (CL:LET* ((OPTIONSTREE NULL) (BODYTREE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OPTIONSTREE BODYTREE)
     (DESTRUCTURE-DEFDEMON-BODY OPTIONSANDBODY))
    (IN-PLACE-NORMALIZE-DEMON-OPTIONS OPTIONSTREE)
    (CL:RETURN-FROM %DEFDEMON
     (LIST* SYM-DEMONS-STELLA-PROGN
      (LIST* SYM-DEMONS-STELLA-DEFUN DEMONFUNCTIONNAME
       (CONS PARAMETERSTREE (CONCATENATE BODYTREE NIL)))
      (LIST* SYM-DEMONS-STELLA-STARTUP-TIME-PROGN
       (LIST* SYM-DEMONS-STELLA-DEFINE-DEMON NAME
        (CONCATENATE OPTIONSTREE
         (LIST* KWD-DEMONS-CODE
          (LIST* SYM-DEMONS-STELLA-WRAP-LITERAL
           (LIST* SYM-DEMONS-STELLA-THE-CODE KWD-DEMONS-FUNCTION
            DEMONFUNCTIONNAME NIL)
           NIL)
          NIL)))
       NIL)
      NIL)))))

(CL:DEFMACRO DEFDEMON (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define a demon `name' and attach it to a class or slot."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* TRUE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DEFDEMON|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFDEMON)))

;;; (DEFUN (READ-SLOT-VALUE OBJECT) ...)

(CL:DEFUN READ-SLOT-VALUE (SELF SLOT)
  "Read and return a (possibly wrapped) value for the slot `slot' on `self'."
  (CL:LET*
   ((CODE (GET-GENERIC-SLOT-ACCESSOR SLOT (PRIMARY-CLASS SELF) CL:T)))
   (CL:IF (CL:NOT (CL:EQ CODE NULL))
    (CL:RETURN-FROM READ-SLOT-VALUE
     (CL:FUNCALL CODE SELF (CANONICAL-SLOT-NAME SLOT) NULL CL:NIL))
    (CL:RETURN-FROM READ-SLOT-VALUE NULL))))

;;; (DEFUN (WRITE-SLOT-VALUE OBJECT) ...)

(CL:DEFUN WRITE-SLOT-VALUE (SELF SLOT VALUE)
  "Write a (possibly wrapped) `value' for the slot `slot' on `self'."
  (CL:LET*
   ((CODE (GET-GENERIC-SLOT-ACCESSOR SLOT (PRIMARY-CLASS SELF) CL:T)))
   (CL:IF (CL:NOT (CL:EQ CODE NULL))
    (CL:RETURN-FROM WRITE-SLOT-VALUE
     (CL:FUNCALL CODE SELF (CANONICAL-SLOT-NAME SLOT) VALUE CL:T))
    (CL:RETURN-FROM WRITE-SLOT-VALUE NULL))))

;;; (DEFUN (PUT-SLOT-VALUE OBJECT) ...)

(CL:DEFUN PUT-SLOT-VALUE (SELF SLOT VALUE)
  "Set or insert `value' for the slot `slot' on `self'.
CAUTION: Assumes that collection-valued slots are non-null."
  (CL:IF (COLLECTION-VALUED? SLOT)
   (CL:LET* ((OLDVALUES (READ-SLOT-VALUE SELF SLOT)))
    (INSERT OLDVALUES VALUE) (CL:RETURN-FROM PUT-SLOT-VALUE VALUE))
   (CL:RETURN-FROM PUT-SLOT-VALUE (WRITE-SLOT-VALUE SELF SLOT VALUE))))

;;; (DEFUN DROP-SLOT-VALUE ...)

(CL:DEFUN DROP-SLOT-VALUE (SELF SLOT VALUE)
  "Clear or remove `value' for the slot `slot' on `self'.
CAUTION: Assumes that collection-valued slots are non-null."
  (CL:IF (COLLECTION-VALUED? SLOT)
   (CL:LET* ((OLDVALUES (READ-SLOT-VALUE SELF SLOT)))
    (REMOVE OLDVALUES VALUE))
   (CL:LET* ((OLDVALUE (READ-SLOT-VALUE SELF SLOT)))
    (CL:WHEN (EQL? VALUE OLDVALUE) (WRITE-SLOT-VALUE SELF SLOT NULL))))
  :VOID)

;;; (DEFUN (CPP-FIND-NATIVE-SLOT-VALUE-OFFSET INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  CPP-FIND-NATIVE-SLOT-VALUE-OFFSET))
(CL:DEFUN CPP-FIND-NATIVE-SLOT-VALUE-OFFSET (SELF SLOT)
  "Dynamically determine the byte offset where the native value for `slot' starts in `self'.
This basically performs the function of the C++ macro `offsetof' but does it dynamically.  Of course, it
relies on a working `read/write-slot-value' mechanism and we currently primarily use this for the Python API.
This basically writes value changes of `slot' to determine a byte position where a change occurred and
then restores the original value (which can be NULL).  This handles all native OBJECT and LITERAL slots
but does not handle special slots such as `dynamic-slots' or hardwired slots or other non-standard types."
  (CL:PROGN (CL:PROGN (CL:SETQ SELF SELF) (CL:SETQ SLOT SLOT))
   (CL:RETURN-FROM CPP-FIND-NATIVE-SLOT-VALUE-OFFSET -1)))

;;; (DEFUN (CHECK-FOR-SLOT-DEMONS? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-SLOT-DEMONS? (SLOT)
  (CL:RETURN-FROM CHECK-FOR-SLOT-DEMONS?
   (CL:OR (CL:NOT (CL:EQ *ALL-SLOTS-DEMONS* NULL))
    (CL:NOT (CL:EQ *ALL-SLOTS-GUARD-DEMONS* NULL))
    (CL:NOT (CL:EQ (SLOT-GUARD-DEMONS SLOT) NULL))
    (CL:NOT (CL:EQ (SLOT-DEMONS SLOT) NULL)))))

;;; (DEFUN (RUN-SLOT-GUARD-DEMONS? BOOLEAN) ...)

(CL:DEFUN RUN-SLOT-GUARD-DEMONS? (SELF SLOT OLDVALUE NEWVALUE)
  (CL:WHEN (CL:NOT (CL:EQ *ALL-SLOTS-GUARD-DEMONS* NULL))
   (CL:LET*
    ((DEMON NULL)
     (ITER-000 (%LIST.THE-CONS-LIST *ALL-SLOTS-GUARD-DEMONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DEMON (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF SLOT OLDVALUE
        NEWVALUE))
      (CL:RETURN-FROM RUN-SLOT-GUARD-DEMONS? CL:NIL))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CL:WHEN (CL:NOT (CL:EQ (SLOT-GUARD-DEMONS SLOT) NULL))
   (CL:LET*
    ((DEMON NULL)
     (ITER-001 (%LIST.THE-CONS-LIST (SLOT-GUARD-DEMONS SLOT))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ DEMON (%%VALUE ITER-001))
     (CL:WHEN
      (CL:NOT
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF SLOT OLDVALUE
        NEWVALUE))
      (CL:RETURN-FROM RUN-SLOT-GUARD-DEMONS? CL:NIL))
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  (CL:RETURN-FROM RUN-SLOT-GUARD-DEMONS? CL:T))

;;; (DEFUN RUN-SLOT-DEMONS ...)

(CL:DEFUN RUN-SLOT-DEMONS (SELF SLOT OLDVALUE NEWVALUE)
  (CL:WHEN (CL:NOT (CL:EQ *ALL-SLOTS-DEMONS* NULL))
   (CL:LET*
    ((DEMON NULL) (ITER-000 (%LIST.THE-CONS-LIST *ALL-SLOTS-DEMONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DEMON (%%VALUE ITER-000))
     (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF SLOT OLDVALUE NEWVALUE)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CL:WHEN (CL:NOT (CL:EQ (SLOT-DEMONS SLOT) NULL))
   (CL:LET*
    ((DEMON NULL) (ITER-001 (%LIST.THE-CONS-LIST (SLOT-DEMONS SLOT))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ DEMON (%%VALUE ITER-001))
     (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF SLOT OLDVALUE NEWVALUE)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  :VOID)

;;; (DEFUN RUN-CONSTRUCTOR-DEMONS ...)

(CL:DEFUN RUN-CONSTRUCTOR-DEMONS (SELF)
  (CL:LET* ((CLASS (PRIMARY-CLASS SELF)))
   (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
    (CL:WHEN (CL:NOT (CL:EQ *CONSTRUCTOR-DEMONS* NULL))
     (CL:LET*
      ((DEMON NULL)
       (ITER-000 (%LIST.THE-CONS-LIST *CONSTRUCTOR-DEMONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ DEMON (%%VALUE ITER-000))
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF CLASS)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:WHEN (CL:NOT (CL:EQ (CLASS-CONSTRUCTOR-DEMONS CLASS) NULL))
     (CL:LET*
      ((DEMON NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST (CLASS-CONSTRUCTOR-DEMONS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ DEMON (%%VALUE ITER-001))
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF CLASS)
       (CL:SETQ ITER-001 (%%REST ITER-001)))))))
  :VOID)

;;; (DEFUN RUN-DESTRUCTOR-DEMONS ...)

(CL:DEFUN RUN-DESTRUCTOR-DEMONS (SELF)
  (CL:LET* ((CLASS (PRIMARY-CLASS SELF)))
   (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
    (CL:WHEN (CL:NOT (CL:EQ *DESTRUCTOR-DEMONS* NULL))
     (CL:LET*
      ((DEMON NULL)
       (ITER-000 (%LIST.THE-CONS-LIST *DESTRUCTOR-DEMONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ DEMON (%%VALUE ITER-000))
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF CLASS)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:WHEN (CL:NOT (CL:EQ (CLASS-DESTRUCTOR-DEMONS CLASS) NULL))
     (CL:LET*
      ((DEMON NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST (CLASS-DESTRUCTOR-DEMONS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ DEMON (%%VALUE ITER-001))
       (CL:FUNCALL (%DEMON.DEMON-CODE DEMON) SELF CLASS)
       (CL:SETQ ITER-001 (%%REST ITER-001)))))))
  :VOID)

;;; (DEFUN (YIELD-ACTIVE-SLOT-READER-BODY CONS) ...)

(CL:DEFUN YIELD-ACTIVE-SLOT-READER-BODY (SLOT DEFAULTEXPRESSION)
  (CL:LET* ((SLOTNAME (%STORAGE-SLOT.SLOT-NAME SLOT)))
   (CL:IF (CL:NOT (COLLECTION-VALUED? SLOT))
    (CL:RETURN-FROM YIELD-ACTIVE-SLOT-READER-BODY
     (WRAP-WITH-DEFAULT-VALUE-AND-RETURN-CODE SLOT DEFAULTEXPRESSION))
    (CL:PROGN
     (CL:WHEN (CL:NOT (CL:EQ DEFAULTEXPRESSION NULL))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL
         " Can't define a default value for the active collection-valued slot named.`"
         (%STORAGE-SLOT.SLOT-NAME SLOT) "'Ignoring the default value.."
         EOL))))
     (CL:RETURN-FROM YIELD-ACTIVE-SLOT-READER-BODY
      (LIST* SYM-DEMONS-STELLA-LET
       (CONS
        (LIST* SYM-DEMONS-STELLA-VALUE
         (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
          SLOTNAME NIL)
         NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-WHEN
        (LIST* SYM-DEMONS-STELLA-DEFINED? SYM-DEMONS-STELLA-VALUE NIL)
        (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-VALUE NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-SETQ SYM-DEMONS-STELLA-VALUE
        (LIST* SYM-DEMONS-STELLA-NEW (TYPE-TO-SYMBOL (TYPE SLOT)) NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-SETF
        (LIST* SYM-DEMONS-STELLA-OWNER-INSTANCE SYM-DEMONS-STELLA-VALUE
         NIL)
        SYM-DEMONS-STELLA-SELF NIL)
       (LIST* SYM-DEMONS-STELLA-SETF
        (LIST* SYM-DEMONS-STELLA-ACTIVE-SLOT SYM-DEMONS-STELLA-VALUE
         NIL)
        (LIST* SYM-DEMONS-STELLA-GET-SLOT SYM-DEMONS-STELLA-SELF
         (LIST* SYM-DEMONS-STELLA-BQUOTE (%STORAGE-SLOT.SLOT-NAME SLOT)
          NIL)
         NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-SETF
        (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
         SLOTNAME NIL)
        SYM-DEMONS-STELLA-VALUE NIL)
       (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-VALUE NIL)
       NIL))))))

;;; (DEFUN CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT ...)

(CL:DEFUN CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT (SELF SLOTNAME)
  (CL:WARN
   "Can't replace the value of the active slot `~A' on the object ~%`~A'.  Call `insert' or `remove' to add/remove slot values."
   SLOTNAME SELF)
  :VOID)

;;; (DEFUN (YIELD-ACTIVE-SLOT-WRITER-BODY CONS) ...)

(CL:DEFUN YIELD-ACTIVE-SLOT-WRITER-BODY (SLOT)
  (CL:LET*
   ((SLOTNAME (%STORAGE-SLOT.SLOT-NAME SLOT))
    (WRAPPINGFUNCTION
     (CL:IF
      (CL:EQ (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT)
       SGT-DEMONS-STELLA-BOOLEAN)
      SYM-DEMONS-STELLA-WRAP-BOOLEAN SYM-DEMONS-STELLA-WRAP-LITERAL)))
   (CL:COND
    ((COLLECTION-VALUED? SLOT)
     (CL:RETURN-FROM YIELD-ACTIVE-SLOT-WRITER-BODY
      (LIST* SYM-DEMONS-STELLA-PROGN SYM-DEMONS-STELLA-VALUE
       (LIST* SYM-DEMONS-STELLA-CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT
        SYM-DEMONS-STELLA-SELF
        (LIST* SYM-DEMONS-STELLA-BQUOTE SLOTNAME NIL) NIL)
       (LIST* SYM-DEMONS-STELLA-RETURN
        (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
         (%STORAGE-SLOT.SLOT-NAME SLOT) NIL)
        NIL)
       NIL)))
    ((SUBTYPE-OF? (TYPE SLOT) SGT-DEMONS-STELLA-LITERAL)
     (CL:RETURN-FROM YIELD-ACTIVE-SLOT-WRITER-BODY
      (LIST* SYM-DEMONS-STELLA-LET
       (LIST*
        (LIST* SYM-DEMONS-STELLA-SLOT
         (LIST* SYM-DEMONS-STELLA-GET-SLOT SYM-DEMONS-STELLA-SELF
          (LIST* SYM-DEMONS-STELLA-BQUOTE SLOTNAME NIL) NIL)
         NIL)
        (LIST* SYM-DEMONS-STELLA-OLDVALUE
         (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
          SLOTNAME NIL)
         NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-WHEN
        (LIST* SYM-DEMONS-STELLA-NOT
         (LIST* SYM-DEMONS-STELLA-EQL? SYM-DEMONS-STELLA-OLDVALUE
          SYM-DEMONS-STELLA-VALUE NIL)
         NIL)
        (LIST* SYM-DEMONS-STELLA-IF
         (LIST* SYM-DEMONS-STELLA-CHECK-FOR-SLOT-DEMONS?
          SYM-DEMONS-STELLA-SLOT NIL)
         (LIST* SYM-DEMONS-STELLA-LET
          (LIST*
           (LIST* SYM-DEMONS-STELLA-WRAPPEDOLDVALUE
            (LIST* SYM-DEMONS-STELLA-CHOOSE
             (LIST* SYM-DEMONS-STELLA-DEFINED?
              SYM-DEMONS-STELLA-OLDVALUE NIL)
             (CONS WRAPPINGFUNCTION
              (CONS SYM-DEMONS-STELLA-OLDVALUE NIL))
             SYM-DEMONS-STELLA-NULL NIL)
            NIL)
           (LIST* SYM-DEMONS-STELLA-WRAPPEDNEWVALUE
            (LIST* SYM-DEMONS-STELLA-CHOOSE
             (LIST* SYM-DEMONS-STELLA-DEFINED? SYM-DEMONS-STELLA-VALUE
              NIL)
             (CONS WRAPPINGFUNCTION (CONS SYM-DEMONS-STELLA-VALUE NIL))
             SYM-DEMONS-STELLA-NULL NIL)
            NIL)
           NIL)
          (LIST* SYM-DEMONS-STELLA-WHEN
           (LIST* SYM-DEMONS-STELLA-RUN-SLOT-GUARD-DEMONS?
            SYM-DEMONS-STELLA-SELF SYM-DEMONS-STELLA-SLOT
            SYM-DEMONS-STELLA-WRAPPEDOLDVALUE
            SYM-DEMONS-STELLA-WRAPPEDNEWVALUE NIL)
           (LIST* SYM-DEMONS-STELLA-SETF
            (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
             SLOTNAME NIL)
            SYM-DEMONS-STELLA-VALUE NIL)
           (LIST* SYM-DEMONS-STELLA-RUN-SLOT-DEMONS
            SYM-DEMONS-STELLA-SELF SYM-DEMONS-STELLA-SLOT
            SYM-DEMONS-STELLA-WRAPPEDOLDVALUE
            SYM-DEMONS-STELLA-WRAPPEDNEWVALUE NIL)
           (LIST* SYM-DEMONS-STELLA-WHEN
            (LIST* SYM-DEMONS-STELLA-DEFINED?
             SYM-DEMONS-STELLA-WRAPPEDOLDVALUE NIL)
            (LIST* SYM-DEMONS-STELLA-FREE
             SYM-DEMONS-STELLA-WRAPPEDOLDVALUE NIL)
            NIL)
           (LIST* SYM-DEMONS-STELLA-WHEN
            (LIST* SYM-DEMONS-STELLA-DEFINED?
             SYM-DEMONS-STELLA-WRAPPEDNEWVALUE NIL)
            (LIST* SYM-DEMONS-STELLA-FREE
             SYM-DEMONS-STELLA-WRAPPEDNEWVALUE NIL)
            NIL)
           (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-VALUE NIL)
           NIL)
          (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-OLDVALUE
           NIL)
          NIL)
         (LIST* SYM-DEMONS-STELLA-RETURN
          (LIST* SYM-DEMONS-STELLA-SETF
           (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
            SLOTNAME NIL)
           SYM-DEMONS-STELLA-VALUE NIL)
          NIL)
         NIL)
        NIL)
       NIL)))
    (CL:T
     (CL:RETURN-FROM YIELD-ACTIVE-SLOT-WRITER-BODY
      (LIST* SYM-DEMONS-STELLA-LET
       (LIST*
        (LIST* SYM-DEMONS-STELLA-SLOT
         (LIST* SYM-DEMONS-STELLA-GET-SLOT SYM-DEMONS-STELLA-SELF
          (LIST* SYM-DEMONS-STELLA-BQUOTE SLOTNAME NIL) NIL)
         NIL)
        (LIST* SYM-DEMONS-STELLA-OLDVALUE
         (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
          SLOTNAME NIL)
         NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-WHEN
        (LIST* SYM-DEMONS-STELLA-AND
         (LIST* SYM-DEMONS-STELLA-NOT
          (LIST* SYM-DEMONS-STELLA-EQ? SYM-DEMONS-STELLA-OLDVALUE
           SYM-DEMONS-STELLA-VALUE NIL)
          NIL)
         (LIST* SYM-DEMONS-STELLA-RUN-SLOT-GUARD-DEMONS?
          SYM-DEMONS-STELLA-SELF SYM-DEMONS-STELLA-SLOT
          SYM-DEMONS-STELLA-OLDVALUE SYM-DEMONS-STELLA-VALUE NIL)
         NIL)
        (LIST* SYM-DEMONS-STELLA-SETF
         (LIST* SYM-DEMONS-STELLA-SLOT-VALUE SYM-DEMONS-STELLA-SELF
          SLOTNAME NIL)
         SYM-DEMONS-STELLA-VALUE NIL)
        (LIST* SYM-DEMONS-STELLA-RUN-SLOT-DEMONS SYM-DEMONS-STELLA-SELF
         SYM-DEMONS-STELLA-SLOT SYM-DEMONS-STELLA-OLDVALUE
         SYM-DEMONS-STELLA-VALUE NIL)
        (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-VALUE NIL)
        NIL)
       (LIST* SYM-DEMONS-STELLA-RETURN SYM-DEMONS-STELLA-OLDVALUE NIL)
       NIL))))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF ACTIVE-LIST) VALUE)
  (CL:LET*
   ((SLOT (%ACTIVE-LIST.ACTIVE-SLOT SELF))
    (OWNER (%ACTIVE-LIST.OWNER-INSTANCE SELF)))
   (CL:WHEN (RUN-SLOT-GUARD-DEMONS? OWNER SLOT SELF VALUE)
    (CL:SETF (%ACTIVE-LIST.THE-CONS-LIST SELF)
     (CONS VALUE (%ACTIVE-LIST.THE-CONS-LIST SELF)))
    (RUN-SLOT-DEMONS OWNER SLOT NULL VALUE)))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF ACTIVE-SET) VALUE)
  (CL:LET*
   ((SLOT (%ACTIVE-SET.ACTIVE-SLOT SELF))
    (OWNER (%ACTIVE-SET.OWNER-INSTANCE SELF)))
   (CL:WHEN (CL:NOT (MEMBER? (%ACTIVE-SET.THE-CONS-LIST SELF) VALUE))
    (CL:WHEN (RUN-SLOT-GUARD-DEMONS? OWNER SLOT SELF VALUE)
     (CL:SETF (%ACTIVE-SET.THE-CONS-LIST SELF)
      (CONS VALUE (%ACTIVE-SET.THE-CONS-LIST SELF)))
     (RUN-SLOT-DEMONS OWNER SLOT NULL VALUE))))
  :VOID)

;;; (DEFMETHOD (REMOVE ACTIVE-LIST) ...)

(CL:DEFMETHOD REMOVE ((SELF ACTIVE-LIST) VALUE)
  (CL:LET*
   ((SLOT (%ACTIVE-LIST.ACTIVE-SLOT SELF))
    (OWNER (%ACTIVE-LIST.OWNER-INSTANCE SELF)))
   (CL:WHEN (MEMBER? (%ACTIVE-LIST.THE-CONS-LIST SELF) VALUE)
    (CL:WHEN (RUN-SLOT-GUARD-DEMONS? OWNER SLOT VALUE NULL)
     (CL:SETF (%ACTIVE-LIST.THE-CONS-LIST SELF)
      (REMOVE (%ACTIVE-LIST.THE-CONS-LIST SELF) VALUE))
     (RUN-SLOT-DEMONS OWNER SLOT VALUE NULL)))
   (CL:RETURN-FROM REMOVE SELF)))

;;; (DEFMETHOD (REMOVE ACTIVE-SET) ...)

(CL:DEFMETHOD REMOVE ((SELF ACTIVE-SET) VALUE)
  (CL:LET*
   ((SLOT (%ACTIVE-SET.ACTIVE-SLOT SELF))
    (OWNER (%ACTIVE-SET.OWNER-INSTANCE SELF)))
   (CL:WHEN (MEMBER? (%ACTIVE-SET.THE-CONS-LIST SELF) VALUE)
    (CL:WHEN (RUN-SLOT-GUARD-DEMONS? OWNER SLOT VALUE NULL)
     (CL:SETF (%ACTIVE-SET.THE-CONS-LIST SELF)
      (REMOVE (%ACTIVE-SET.THE-CONS-LIST SELF) VALUE))
     (RUN-SLOT-DEMONS OWNER SLOT VALUE NULL)))
   (CL:RETURN-FROM REMOVE SELF)))

(CL:DEFUN NEW-HOOK-LIST ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-HOOK-LIST))
   (CL:SETF (%HOOK-LIST.THE-KV-LIST SELF) NULL)
   (CL:SETF (%HOOK-LIST.DOCUMENTATION SELF) STELLA::NULL-STRING)
   (CL:SETF (%HOOK-LIST.SIGNATURE SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-HOOK-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HOOK-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-DEMONS-STELLA-HOOK-LIST))

(CL:DEFUN ACCESS-HOOK-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-DEMONS-STELLA-SIGNATURE)
    (CL:IF SETVALUE?
     (CL:SETF (%HOOK-LIST.SIGNATURE SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%HOOK-LIST.SIGNATURE SELF)))))
   ((CL:EQ SLOTNAME SYM-DEMONS-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%HOOK-LIST.DOCUMENTATION SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%HOOK-LIST.DOCUMENTATION SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-HOOK-LIST-SLOT-VALUE VALUE))

;;; (DEFUN ADD-HOOK ...)

(CL:DEFUN ADD-HOOK (HOOKLIST HOOKFUNCTION)
  "Insert the function named `hookFunction' into `hookList'."
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION HOOKFUNCTION)))
   (CL:WHEN (CL:EQ FUNCTION NULL)
    (CL:WARN
     "Reference to non-existent hook function: `hookFunction'.")
    (CL:RETURN-FROM ADD-HOOK))
   (INSERT-AT HOOKLIST HOOKFUNCTION
    (WRAP-FUNCTION-CODE (%METHOD-SLOT.FUNCTION-CODE FUNCTION))))
  :VOID)

;;; (DEFUN DROP-HOOK ...)

(CL:DEFUN DROP-HOOK (HOOKLIST HOOKFUNCTION)
  "Remove the function named `hookFunction' from `hookList'."
  (REMOVE-AT HOOKLIST HOOKFUNCTION)
  :VOID)

;;; (DEFUN RUN-HOOKS ...)

(CL:DEFUN RUN-HOOKS (HOOKLIST ARGUMENT)
  "Run all hook functions in `hooklist', applying
each one to `argument'."
  (CL:LET* ((IT (ALLOCATE-ITERATOR HOOKLIST)))
   (CL:LOOP WHILE (NEXT? IT) DO
    (CL:FUNCALL
     (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE
      (%KV-LIST-ITERATOR.VALUE IT))
     ARGUMENT)))
  :VOID)

;;; (DEFGLOBAL *CHANGE-MODULE-HOOKS* ...)

(CL:DEFVAR *CHANGE-MODULE-HOOKS* NULL
  "HOOK-LIST called by `in-module', applied to a
`module' argument.")

;;; (DEFGLOBAL *CLEAR-MODULE-HOOKS* ...)

(CL:DEFVAR *CLEAR-MODULE-HOOKS* NULL
  "HOOK-LIST called by `clear-module', applied to a
`module' argument.")

;;; (DEFGLOBAL *DESTROY-CONTEXT-HOOKS* ...)

(CL:DEFVAR *DESTROY-CONTEXT-HOOKS* NULL
  "HOOK-LIST called by `clear-module', applied to a
`module' argument.")

;;; (DEFGLOBAL *REDEFINE-RELATION-HOOKS* ...)

(CL:DEFVAR *REDEFINE-RELATION-HOOKS* NULL
  "HOOK-LIST is called by `undefine-old-class'.  Each
hook function is passed a LIST of two RELATION objects; the first is the
old relation object and the second is the new (redefined) relation object.
The hook functions are expected to copy/transfer information from the
old relation to the new relation so that it won't be lost.")

;;; (DEFGLOBAL *FINALIZE-RELATION-HOOKS* ...)

(CL:DEFVAR *FINALIZE-RELATION-HOOKS* NULL
  "HOOK-LIST is called by `finalize-one-class'
and `finalize-local-slot', applied to a RELATION argument.")

;;; (DEFGLOBAL *BLOCK-NATIVE-CLASS-CREATION-HOOKS* ...)

(CL:DEFVAR *BLOCK-NATIVE-CLASS-CREATION-HOOKS* NULL
  "HOOK-LIST called by `create-native-class', applied to
a STELLA class.  Return value of TRUE blocks creation.")

;;; (DEFGLOBAL *STELLA-EXIT-HOOKS* ...)

(CL:DEFVAR *STELLA-EXIT-HOOKS* NULL
  "HOOK-LIST of cleanup functions to be called upon exit from
the STELLA application or any point where such cleanup is required.  The
functions on this list should be highly tolerant of their invocation environment
and not assume any special state; that is, they should be no-ops if no special
cleanup is required.")

(CL:DEFUN HELP-STARTUP-DEMONS1 ()
  (CL:PROGN
   (CL:SETQ KWD-DEMONS-MODIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODIFY" NULL 2))
   (CL:SETQ KWD-DEMONS-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 2))
   (CL:SETQ KWD-DEMONS-DESTROY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY" NULL 2))
   (CL:SETQ KWD-DEMONS-ALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL" NULL 2))
   (CL:SETQ KWD-DEMONS-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 2))
   (CL:SETQ KWD-DEMONS-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 2))
   (CL:SETQ KWD-DEMONS-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE" NULL 2))
   (CL:SETQ KWD-DEMONS-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
   (CL:SETQ KWD-DEMONS-GUARD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GUARD?" NULL 2))
   (CL:SETQ KWD-DEMONS-INHERITED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITED?" NULL 2))
   (CL:SETQ KWD-DEMONS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-DEMONS-ACTIVATE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVATE?" NULL 2))
   (CL:SETQ SYM-DEMONS-STELLA-SLOT-GUARD-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-GUARD-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-SLOT-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-CONSTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CLASS-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-DESTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CLASS-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-WRAP-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LITERAL" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-STARTUP-TIME-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-DEFINE-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-DEMON" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-THE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
   (CL:SETQ KWD-DEMONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-DEMONS-STELLA-DEFDEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFDEMON" NULL 0))
   (CL:SETQ KWD-DEMONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-DEMONS-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-SETF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-OWNER-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OWNER-INSTANCE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-ACTIVE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-SLOT" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-GET-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SLOT" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-BQUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BQUOTE" NULL 0))
   (CL:SETQ SGT-DEMONS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SYM-DEMONS-STELLA-CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT" NULL 0))
   (CL:SETQ SGT-DEMONS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
   (CL:SETQ SYM-DEMONS-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-OLDVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OLDVALUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL?" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CHECK-FOR-SLOT-DEMONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHECK-FOR-SLOT-DEMONS?" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-WRAPPEDOLDVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPEDOLDVALUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-WRAPPEDNEWVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPEDNEWVALUE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-RUN-SLOT-GUARD-DEMONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-SLOT-GUARD-DEMONS?" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-RUN-SLOT-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-SLOT-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-FREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FREE" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-DEMONS2 ()
  (CL:PROGN
   (CL:SETQ SYM-DEMONS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-EQ?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQ?" NULL 0))
   (CL:SETQ SGT-DEMONS-STELLA-HOOK-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOOK-LIST" NULL 1))
   (CL:SETQ SYM-DEMONS-STELLA-SIGNATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNATURE" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-STARTUP-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-DEMONS" NULL 0))
   (CL:SETQ SYM-DEMONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN STARTUP-DEMONS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-DEMONS1)
    (HELP-STARTUP-DEMONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *DEMONS-TABLE* (NEW-STRING-HASH-TABLE))
    (CL:SETQ *CHANGE-MODULE-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *CLEAR-MODULE-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *DESTROY-CONTEXT-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *REDEFINE-RELATION-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *FINALIZE-RELATION-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *BLOCK-NATIVE-CLASS-CREATION-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *STELLA-EXIT-HOOKS* (NEW-HOOK-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HOOK-LIST"
        "(DEFCLASS HOOK-LIST (KEY-VALUE-LIST) :DOCUMENTATION \"Each HOOK-LIST object contains a list of zero or
more function codes that get funcall'd some procedure.\" :PARAMETERS ((ANY-KEY :TYPE SYMBOL) (ANY-VALUE :TYPE FUNCTION-CODE-WRAPPER)) :SLOTS ((SIGNATURE :TYPE STRING) (DOCUMENTATION :TYPE STRING)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-HOOK-LIST))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-HOOK-LIST-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "VALIDATE-DEMON-REFERENCES?"
     "(DEFUN (VALIDATE-DEMON-REFERENCES? BOOLEAN) ((DEMON DEMON)))"
     (CL:FUNCTION VALIDATE-DEMON-REFERENCES?) NULL)
    (DEFINE-FUNCTION-OBJECT "INCORPORATE-DEMON-OPTIONS?"
     "(DEFUN (INCORPORATE-DEMON-OPTIONS? BOOLEAN) ((DEMON DEMON) (OPTIONS PROPERTY-LIST)))"
     (CL:FUNCTION INCORPORATE-DEMON-OPTIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-DEMON"
     "(DEFUN (LOOKUP-DEMON DEMON) ((NAME STRING)) :DOCUMENTATION \"Return the demon named `name'.\")"
     (CL:FUNCTION LOOKUP-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-DEMON"
     "(DEFUN (DEFINE-DEMON DEMON) ((NAME STRING) |&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Define a class or slot demon.  Options are :create,
:destroy, :class, :slot, :guard?, :code, :method, :inherit?, and :documentation.\")"
     (CL:FUNCTION DEFINE-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "INJECT-DEMON"
     "(DEFUN (INJECT-DEMON (LIST OF DEMON)) ((DEMONLIST (LIST OF DEMON)) (DEMON DEMON)))"
     (CL:FUNCTION INJECT-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "EJECT-DEMON"
     "(DEFUN (EJECT-DEMON (LIST OF DEMON)) ((DEMONLIST (LIST OF DEMON)) (DEMON DEMON)))"
     (CL:FUNCTION EJECT-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "ACTIVATE-DEMON"
     "(DEFUN ACTIVATE-DEMON ((DEMON DEMON)) :DOCUMENTATION \"Install `demon' in the location(s) specified by its internal
structure.\")" (CL:FUNCTION ACTIVATE-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "DEACTIVATE-DEMON"
     "(DEFUN DEACTIVATE-DEMON ((DEMON DEMON)) :DOCUMENTATION \"Detach `demon' from the location(s) specified by its internal
structure.\")" (CL:FUNCTION DEACTIVATE-DEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTRUCTURE-DEFDEMON-BODY"
     "(DEFUN (DESTRUCTURE-DEFDEMON-BODY CONS CONS) ((DEMONTREE CONS)))"
     (CL:FUNCTION DESTRUCTURE-DEFDEMON-BODY) NULL)
    (DEFINE-FUNCTION-OBJECT "IN-PLACE-NORMALIZE-DEMON-OPTIONS"
     "(DEFUN IN-PLACE-NORMALIZE-DEMON-OPTIONS ((OPTIONSTREE CONS)))"
     (CL:FUNCTION IN-PLACE-NORMALIZE-DEMON-OPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFDEMON"
     "(DEFUN DEFDEMON ((NAME STRING-WRAPPER) (PARAMETERSTREE CONS) |&BODY| (OPTIONSANDBODY CONS)) :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"Define a demon `name' and attach it to a class or slot.\" :PUBLIC? TRUE :LISP-MACRO? TRUE)"
     (CL:FUNCTION %DEFDEMON) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-SLOT-VALUE"
     "(DEFUN (READ-SLOT-VALUE OBJECT) ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT)) :DOCUMENTATION \"Read and return a (possibly wrapped) value for the slot `slot' on `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-SLOT-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "WRITE-SLOT-VALUE"
     "(DEFUN (WRITE-SLOT-VALUE OBJECT) ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (VALUE OBJECT)) :DOCUMENTATION \"Write a (possibly wrapped) `value' for the slot `slot' on `self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WRITE-SLOT-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "PUT-SLOT-VALUE"
     "(DEFUN (PUT-SLOT-VALUE OBJECT) ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (VALUE OBJECT)) :DOCUMENTATION \"Set or insert `value' for the slot `slot' on `self'.
CAUTION: Assumes that collection-valued slots are non-null.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PUT-SLOT-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "DROP-SLOT-VALUE"
     "(DEFUN DROP-SLOT-VALUE ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (VALUE OBJECT)) :DOCUMENTATION \"Clear or remove `value' for the slot `slot' on `self'.
CAUTION: Assumes that collection-valued slots are non-null.\" :PUBLIC? TRUE)"
     (CL:FUNCTION DROP-SLOT-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "CPP-FIND-NATIVE-SLOT-VALUE-OFFSET"
     "(DEFUN (CPP-FIND-NATIVE-SLOT-VALUE-OFFSET INTEGER) ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT)) :DOCUMENTATION \"Dynamically determine the byte offset where the native value for `slot' starts in `self'.
This basically performs the function of the C++ macro `offsetof' but does it dynamically.  Of course, it
relies on a working `read/write-slot-value' mechanism and we currently primarily use this for the Python API.
This basically writes value changes of `slot' to determine a byte position where a change occurred and
then restores the original value (which can be NULL).  This handles all native OBJECT and LITERAL slots
but does not handle special slots such as `dynamic-slots' or hardwired slots or other non-standard types.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CPP-FIND-NATIVE-SLOT-VALUE-OFFSET) NULL)
    (DEFINE-FUNCTION-OBJECT "CHECK-FOR-SLOT-DEMONS?"
     "(DEFUN (CHECK-FOR-SLOT-DEMONS? BOOLEAN) ((SLOT STORAGE-SLOT)))"
     (CL:FUNCTION CHECK-FOR-SLOT-DEMONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-SLOT-GUARD-DEMONS?"
     "(DEFUN (RUN-SLOT-GUARD-DEMONS? BOOLEAN) ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (OLDVALUE OBJECT) (NEWVALUE OBJECT)))"
     (CL:FUNCTION RUN-SLOT-GUARD-DEMONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-SLOT-DEMONS"
     "(DEFUN RUN-SLOT-DEMONS ((SELF STANDARD-OBJECT) (SLOT STORAGE-SLOT) (OLDVALUE OBJECT) (NEWVALUE OBJECT)))"
     (CL:FUNCTION RUN-SLOT-DEMONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-CONSTRUCTOR-DEMONS"
     "(DEFUN RUN-CONSTRUCTOR-DEMONS ((SELF STANDARD-OBJECT)))"
     (CL:FUNCTION RUN-CONSTRUCTOR-DEMONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-DESTRUCTOR-DEMONS"
     "(DEFUN RUN-DESTRUCTOR-DEMONS ((SELF STANDARD-OBJECT)))"
     (CL:FUNCTION RUN-DESTRUCTOR-DEMONS) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-ACTIVE-SLOT-READER-BODY"
     "(DEFUN (YIELD-ACTIVE-SLOT-READER-BODY CONS) ((SLOT STORAGE-SLOT) (DEFAULTEXPRESSION OBJECT)))"
     (CL:FUNCTION YIELD-ACTIVE-SLOT-READER-BODY) NULL)
    (DEFINE-FUNCTION-OBJECT "CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT"
     "(DEFUN CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT ((SELF STANDARD-OBJECT) (SLOTNAME SYMBOL)))"
     (CL:FUNCTION CANT-OVERWRITE-ACTIVE-COLLECTION-SLOT) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-ACTIVE-SLOT-WRITER-BODY"
     "(DEFUN (YIELD-ACTIVE-SLOT-WRITER-BODY CONS) ((SLOT STORAGE-SLOT)))"
     (CL:FUNCTION YIELD-ACTIVE-SLOT-WRITER-BODY) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT ((SELF ACTIVE-LIST) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INSERT ((SELF ACTIVE-SET) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE ACTIVE-LIST) ((SELF ACTIVE-LIST) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (WRAP-METHOD-CODE (CL:FUNCTION REMOVE)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (REMOVE ACTIVE-SET) ((SELF ACTIVE-SET) (VALUE (LIKE (ANY-VALUE SELF)))))"
     (WRAP-METHOD-CODE (CL:FUNCTION REMOVE)) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-HOOK"
     "(DEFUN ADD-HOOK ((HOOKLIST HOOK-LIST) (HOOKFUNCTION SYMBOL)) :PUBLIC? TRUE :DOCUMENTATION \"Insert the function named `hookFunction' into `hookList'.\")"
     (CL:FUNCTION ADD-HOOK) NULL)
    (DEFINE-FUNCTION-OBJECT "DROP-HOOK"
     "(DEFUN DROP-HOOK ((HOOKLIST HOOK-LIST) (HOOKFUNCTION SYMBOL)) :PUBLIC? TRUE :DOCUMENTATION \"Remove the function named `hookFunction' from `hookList'.\")"
     (CL:FUNCTION DROP-HOOK) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-HOOKS"
     "(DEFUN RUN-HOOKS ((HOOKLIST HOOK-LIST) (ARGUMENT OBJECT)) :DOCUMENTATION \"Run all hook functions in `hooklist', applying
each one to `argument'.\")" (CL:FUNCTION RUN-HOOKS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-DEMONS"
     "(DEFUN STARTUP-DEMONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-DEMONS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-DEMONS-STELLA-STARTUP-DEMONS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-DEMONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupDemons") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DEMONS-TABLE* STRING-HASH-TABLE (NEW STRING-HASH-TABLE) :DOCUMENTATION \"Table containing all active and inactive demons, indexed
on their names.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CONSTRUCTOR-DEMONS* (LIST OF DEMON) NULL :DOCUMENTATION \"These demons trigger every time an active instance is created.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DESTRUCTOR-DEMONS* (LIST OF DEMON) NULL :DOCUMENTATION \"These demons trigger every time an active instance is destroyed.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *ALL-SLOTS-DEMONS* (LIST OF DEMON) NULL :DOCUMENTATION \"These demons trigger every time a slot value is modified.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *ALL-SLOTS-GUARD-DEMONS* (LIST OF DEMON) NULL :DOCUMENTATION \"These demons trigger every time a slot value is modified, and
cancel slot update when they return `false'.\")" NULL)
    (REGISTER-NATIVE-NAME SYM-DEMONS-STELLA-DEFDEMON
     KWD-DEMONS-COMMON-LISP KWD-DEMONS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CHANGE-MODULE-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST called by `in-module', applied to a
`module' argument.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CLEAR-MODULE-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST called by `clear-module', applied to a
`module' argument.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DESTROY-CONTEXT-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST called by `clear-module', applied to a
`module' argument.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *REDEFINE-RELATION-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST is called by `undefine-old-class'.  Each
hook function is passed a LIST of two RELATION objects; the first is the
old relation object and the second is the new (redefined) relation object.
The hook functions are expected to copy/transfer information from the
old relation to the new relation so that it won't be lost.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *FINALIZE-RELATION-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST is called by `finalize-one-class'
and `finalize-local-slot', applied to a RELATION argument.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *BLOCK-NATIVE-CLASS-CREATION-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST called by `create-native-class', applied to
a STELLA class.  Return value of TRUE blocks creation.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *STELLA-EXIT-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST of cleanup functions to be called upon exit from
the STELLA application or any point where such cleanup is required.  The
functions on this list should be highly tolerant of their invocation environment
and not assume any special state; that is, they should be no-ops if no special
cleanup is required.\")" NULL)))
  :VOID)
