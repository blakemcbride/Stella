;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; modules.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-MODULES-CLEAR NULL)
(CL:DEFVAR SGT-MODULES-STELLA-MODULE NULL)
(CL:DEFVAR KWD-MODULES-SYMBOL NULL)
(CL:DEFVAR KWD-MODULES-SURROGATE NULL)
(CL:DEFVAR KWD-MODULES-KEYWORD NULL)
(CL:DEFVAR SGT-MODULES-STELLA-F-GET-STELLA-MODULE-MEMO-TABLE-000 NULL)
(CL:DEFVAR SYM-MODULES-STELLA-NAME NULL)
(CL:DEFVAR SGT-MODULES-STELLA-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-MODULES-STELLA-SHADOWED-SURROGATES NULL)
(CL:DEFVAR KWD-MODULES-MODULE-UPDATE NULL)
(CL:DEFVAR SGT-MODULES-STELLA-CONS NULL)
(CL:DEFVAR SYM-MODULES-STELLA-TRUE NULL)
(CL:DEFVAR SGT-MODULES-STELLA-SYMBOL NULL)
(CL:DEFVAR KWD-MODULES-INCLUDES NULL)
(CL:DEFVAR KWD-MODULES-USES NULL)
(CL:DEFVAR KWD-MODULES-SHADOW NULL)
(CL:DEFVAR KWD-MODULES-DOCUMENTATION NULL)
(CL:DEFVAR KWD-MODULES-CASE-SENSITIVE? NULL)
(CL:DEFVAR KWD-MODULES-API? NULL)
(CL:DEFVAR SYM-MODULES-STELLA-API? NULL)
(CL:DEFVAR KWD-MODULES-LISP-PACKAGE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-MODULE-LISP-PACKAGE NULL)
(CL:DEFVAR KWD-MODULES-CPP-PACKAGE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-MODULE-CPP-PACKAGE NULL)
(CL:DEFVAR KWD-MODULES-JAVA-PACKAGE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-JAVA-PACKAGE NULL)
(CL:DEFVAR KWD-MODULES-JAVA-CATCHALL-CLASS NULL)
(CL:DEFVAR SYM-MODULES-STELLA-JAVA-FLOTSAM-CLASS NULL)
(CL:DEFVAR KWD-MODULES-NICKNAME NULL)
(CL:DEFVAR KWD-MODULES-CLEARABLE? NULL)
(CL:DEFVAR SYM-MODULES-STELLA-CLEARABLE? NULL)
(CL:DEFVAR KWD-MODULES-PROTECT-SURROGATES? NULL)
(CL:DEFVAR SYM-MODULES-STELLA-PROTECT-SURROGATES? NULL)
(CL:DEFVAR KWD-MODULES-CODE-ONLY? NULL)
(CL:DEFVAR SYM-MODULES-STELLA-CODE-ONLY? NULL)
(CL:DEFVAR KWD-MODULES-NAMESPACE? NULL)
(CL:DEFVAR SYM-MODULES-STELLA-NAMESPACE? NULL)
(CL:DEFVAR KWD-MODULES-REQUIRES NULL)
(CL:DEFVAR KWD-MODULES-DESTROY NULL)
(CL:DEFVAR KWD-MODULES-PRESERVE NULL)
(CL:DEFVAR KWD-MODULES-PREORDER NULL)
(CL:DEFVAR SGT-MODULES-STELLA-WORLD NULL)
(CL:DEFVAR KWD-MODULES-TOPDOWN NULL)
(CL:DEFVAR SYM-MODULES-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-DEFMODULE NULL)
(CL:DEFVAR KWD-MODULES-COMMON-LISP NULL)
(CL:DEFVAR KWD-MODULES-FUNCTION NULL)
(CL:DEFVAR SYM-MODULES-STELLA-IN-MODULE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-WORLD-NAME NULL)
(CL:DEFVAR KWD-MODULES-POSTORDER NULL)
(CL:DEFVAR KWD-MODULES-INORDER NULL)
(CL:DEFVAR SYM-MODULES-STELLA-LIST-MODULES NULL)
(CL:DEFVAR SGT-MODULES-STELLA-F-VISIBLE-MODULES-MEMO-TABLE-000 NULL)
(CL:DEFVAR SYM-MODULES-STELLA-CLEAR-MODULE NULL)
(CL:DEFVAR SYM-MODULES-STELLA-STARTUP-MODULES NULL)
(CL:DEFVAR SYM-MODULES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *CLEAR-MODULE-HOOKS* STANDARD-OUTPUT FALSE-WRAPPER
  NULL-STRING-WRAPPER TRUE-WRAPPER STANDARD-ERROR EOL
  *DESTROY-CONTEXT-HOOKS* *CONTEXT-NUMBER-COUNTER* *STELLA-MODULE*
  *CHANGE-MODULE-HOOKS* *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE
  NULL-CHARACTER MODULE-SEPARATOR-CHARACTER *ROOT-MODULE* NULL-INTEGER
  *MODULE* *CONTEXT* NIL))

;;; (DEFGLOBAL *SUBCONTEXT-REVISION-POLICY* ...)

(CL:DEFVAR *SUBCONTEXT-REVISION-POLICY* NULL
  "Controls actions reflexive transitive closure of
   subcontexts when a context is revised.
   Values are ':destroy' -- destroy subcontexts;
   ':clear' -- clear contents of subcontexts;
   ':preserve' -- don't disturb subcontexts.")

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF CONTEXT))
  (CL:RETURN-FROM PARENT-CONTEXTS NULL))

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF MODULE))
  (CL:RETURN-FROM PARENT-CONTEXTS
   (ALLOCATE-ITERATOR (%MODULE.PARENT-MODULES SELF))))

;;; (DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFMETHOD PARENT-CONTEXTS ((SELF WORLD))
  (CL:RETURN-FROM PARENT-CONTEXTS
   (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR
    (CONS (%WORLD.PARENT-CONTEXT SELF) NIL))))

;;; (DEFUN (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME CONTEXT INTEGER) ...)

(CL:DEFUN COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME (PATHNAME MODULE? SYMBOLNAME?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((CONTEXT
     (CL:IF
      (CL:EQL
       (CL:LET ((SELF PATHNAME) (POSITION 0))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))
       MODULE-SEPARATOR-CHARACTER)
      *ROOT-MODULE* NULL))
    (COMPONENTEND (CL:IF (CL:NOT (CL:EQ CONTEXT NULL)) 0 -1))
    (COMPONENTSTART NULL-INTEGER)
    (LASTCHARPOS (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH PATHNAME)))))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM COMPONENTEND COMPONENTSTART LASTCHARPOS))
   (CL:LOOP WHILE (CL:< COMPONENTEND LASTCHARPOS) DO
    (CL:SETQ COMPONENTSTART (CL:1+ COMPONENTEND))
    (CL:SETQ COMPONENTEND COMPONENTSTART)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 COMPONENTSTART)
      (UPPER-BOUND-000 LASTCHARPOS)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-000)
      (CL:IF
       (CL:NOT
        (CL:EQL
         (CL:LET ((SELF PATHNAME) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION)))
         MODULE-SEPARATOR-CHARACTER))
       (CL:SETQ COMPONENTEND (CL:1+ COMPONENTEND)) (CL:RETURN))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:WHEN (CL:AND SYMBOLNAME? (CL:> COMPONENTEND LASTCHARPOS))
     (CL:RETURN-FROM COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME
      (CL:VALUES
       (CL:IF (CL:NOT (CL:EQ CONTEXT NULL)) CONTEXT
        (CL:IF MODULE? *MODULE* *CONTEXT*))
       COMPONENTSTART)))
    (CL:COND
     ((CL:EQ CONTEXT NULL)
      (CL:LET*
       ((STARTSTRING
         (SUBSEQUENCE PATHNAME COMPONENTSTART COMPONENTEND)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STARTSTRING))
       (CL:SETQ CONTEXT (GET-STELLA-CONTEXT-SLOWLY STARTSTRING))))
     (CL:T
      (CL:LET* ((VALUE-000 NULL))
       (CL:LET*
        ((CHILD NULL)
         (ITER-001
          (%LIST.THE-CONS-LIST (%MODULE.CHILD-CONTEXTS CONTEXT))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ CHILD (%%VALUE ITER-001))
         (CL:LET* ((TEST-VALUE-000 CL:NIL))
          (CL:SETQ TEST-VALUE-000
           (CL:OR (CL:NOT MODULE?)
            (ISA? CHILD SGT-MODULES-STELLA-MODULE)))
          (CL:WHEN TEST-VALUE-000
           (CL:IF
            (COMPONENT-MATCH?
             (CL:IF MODULE? (%MODULE.MODULE-NAME CHILD)
              (CONTEXT-NAME CHILD))
             PATHNAME COMPONENTSTART COMPONENTEND)
            (CL:SETQ TEST-VALUE-000 CL:T)
            (CL:PROGN (CL:SETQ TEST-VALUE-000 MODULE?)
             (CL:WHEN TEST-VALUE-000
              (CL:SETQ TEST-VALUE-000
               (CL:NOT (CL:EQ (%MODULE.NICKNAMES CHILD) NULL)))
              (CL:WHEN TEST-VALUE-000
               (CL:LET* ((FOUND?-000 CL:NIL))
                (CL:LET*
                 ((NICKNAME NULL)
                  (ITER-002
                   (%LIST.THE-CONS-LIST (%MODULE.NICKNAMES CHILD))))
                 (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
                  (CL:SETQ NICKNAME (%%VALUE ITER-002))
                  (CL:WHEN
                   (COMPONENT-MATCH?
                    (%STRING-WRAPPER.WRAPPER-VALUE NICKNAME) PATHNAME
                    COMPONENTSTART COMPONENTEND)
                   (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
                  (CL:SETQ ITER-002 (%%REST ITER-002))))
                (CL:SETQ TEST-VALUE-000 FOUND?-000)))))))
          (CL:WHEN TEST-VALUE-000 (CL:SETQ VALUE-000 CHILD)
           (CL:RETURN)))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:SETQ CONTEXT VALUE-000))))
    (CL:WHEN (CL:EQ CONTEXT NULL) (CL:RETURN)))
   (CL:IF (CL:EQ CONTEXT NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "No context with name `" PATHNAME "'")
     (CL:ERROR
      (NEW-NO-SUCH-CONTEXT-EXCEPTION (THE-STRING-READER STREAM-000))))
    (CL:RETURN-FROM COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME
     (CL:VALUES CONTEXT NULL-INTEGER)))))

;;; (DEFUN (COMPONENT-MATCH? BOOLEAN) ...)

(CL:DEFUN COMPONENT-MATCH? (COMPONENT STRING START END)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMPONENT STRING)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE COMPONENT CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000
    (CL:NOT (CL:EQ COMPONENT STELLA::NULL-STRING)))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (CL:THE CL:FIXNUM (CL:LENGTH COMPONENT)) (CL:- END START)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((CHAR NULL-CHARACTER) (VECTOR-000 COMPONENT) (INDEX-000 0)
        (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000)))
        (I NULL-INTEGER) (ITER-000 START))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ CHAR
         (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:SETQ I ITER-000)
        (CL:WHEN
         (CL:NOT
          (CL:EQL CHAR
           (CL:LET ((SELF STRING) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION)))))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM COMPONENT-MATCH? VALUE-000))))

;;; (DEFUN (COMPUTE-MODULE-AND-BARE-NAME MODULE STRING) ...)

(CL:DEFUN COMPUTE-MODULE-AND-BARE-NAME (NAME)
  "Compute the module indicated by the STELLA name
`name' and return it.  Return the bare symbol name as the second
value.  `name' does not necessarily have to be qualified in which
case the current module is returned.  `name' is assumed to be the
printed representation of a STELLA symbol, surrogate or keyword."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE *MODULE*))
   (CL:LET*
    ((BARENAME STELLA::NULL-STRING) (MODULENAME STELLA::NULL-STRING)
     (KIND NULL))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BARENAME MODULENAME))
    (CL:MULTIPLE-VALUE-SETQ (BARENAME MODULENAME KIND)
     (PARSE-STELLA-NAME NAME CL:NIL))
    (CL:WHEN (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
     (CL:SETQ MODULE (GET-STELLA-MODULE MODULENAME CL:T)))
    (CL:COND
     ((CL:EQ KIND KWD-MODULES-SYMBOL)
      (CL:RETURN-FROM COMPUTE-MODULE-AND-BARE-NAME
       (CL:VALUES MODULE BARENAME)))
     ((CL:EQ KIND KWD-MODULES-SURROGATE)
      (CL:RETURN-FROM COMPUTE-MODULE-AND-BARE-NAME
       (CL:VALUES MODULE (CONCATENATE "@" BARENAME))))
     ((CL:EQ KIND KWD-MODULES-KEYWORD)
      (CL:RETURN-FROM COMPUTE-MODULE-AND-BARE-NAME
       (CL:VALUES MODULE (CONCATENATE ":" BARENAME))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" KIND "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (HELP-GET-STELLA-CONTEXT-OR-MODULE CONTEXT) ...)

(CL:DEFUN HELP-GET-STELLA-CONTEXT-OR-MODULE (PATHNAME MODULE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:IF (QUALIFIED-STELLA-NAME? PATHNAME)
   (CL:RETURN-FROM HELP-GET-STELLA-CONTEXT-OR-MODULE
    (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME PATHNAME MODULE? CL:NIL))
   (CL:RETURN-FROM HELP-GET-STELLA-CONTEXT-OR-MODULE
    (GET-STELLA-CONTEXT-SLOWLY PATHNAME))))

;;; (DEFUN (GET-STELLA-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-STELLA-CONTEXT (PATHNAME ERROR?)
  "Return the context located at `pathName', or `null'
if no such context exists.  If `error?' is `true', throw an exception
if no context is found, otherwise silently return `null'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:IF ERROR?
   (CL:RETURN-FROM GET-STELLA-CONTEXT
    (HELP-GET-STELLA-CONTEXT-OR-MODULE PATHNAME CL:NIL))
   (CL:HANDLER-CASE
    (CL:RETURN-FROM GET-STELLA-CONTEXT
     (HELP-GET-STELLA-CONTEXT-OR-MODULE PATHNAME CL:NIL))
    (NO-SUCH-CONTEXT-EXCEPTION ()
     (CL:RETURN-FROM GET-STELLA-CONTEXT NULL)))))

;;; (DEFUN (GET-STELLA-MODULE MODULE) ...)

(CL:DEFUN GET-STELLA-MODULE (PATHNAME ERROR?)
  "Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((WRAPPEDPATHNAME (%MAKE-STRING-WRAPPER)) (MODULE NULL))
   (CL:SETF (%STRING-WRAPPER.WRAPPER-VALUE WRAPPEDPATHNAME) PATHNAME)
   (CL:LET*
    ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
     (MEMOIZED-VALUE-000 NULL))
    (CL:WHEN *MEMOIZATION-ENABLED?*
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-MODULES-STELLA-F-GET-STELLA-MODULE-MEMO-TABLE-000))
     (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
      (INITIALIZE-MEMOIZATION-TABLE
       SGT-MODULES-STELLA-F-GET-STELLA-MODULE-MEMO-TABLE-000
       "(:MAX-VALUES 100 :TIMESTAMPS (:MODULE-UPDATE))")
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE.SURROGATE-VALUE
        SGT-MODULES-STELLA-F-GET-STELLA-MODULE-MEMO-TABLE-000)))
     (CL:SETQ MEMOIZED-ENTRY-000
      (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 WRAPPEDPATHNAME
       MEMOIZED-NULL-VALUE NULL NULL 0))
     (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
    (CL:COND
     ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
      (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
       (CL:SETQ MEMOIZED-VALUE-000 NULL)))
     (CL:T
      (CL:SETQ MEMOIZED-VALUE-000
       (HELP-GET-STELLA-MODULE PATHNAME CL:NIL))
      (CL:WHEN *MEMOIZATION-ENABLED?*
       (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
        (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
         MEMOIZED-VALUE-000)))))
    (CL:SETQ MODULE MEMOIZED-VALUE-000))
   (CL:WHEN (CL:AND (CL:EQ MODULE NULL) ERROR?)
    (HELP-GET-STELLA-MODULE PATHNAME CL:T))
   (CL:RETURN-FROM GET-STELLA-MODULE MODULE)))

;;; (DEFUN (HELP-GET-STELLA-MODULE MODULE) ...)

(CL:DEFUN HELP-GET-STELLA-MODULE (PATHNAME ERROR?)
  "Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:WHEN (STRING-EQL? PATHNAME (%MODULE.MODULE-FULL-NAME *MODULE*))
   (CL:RETURN-FROM HELP-GET-STELLA-MODULE *MODULE*))
  (CL:LET* ((CONTEXT NULL))
   (CL:IF ERROR?
    (CL:SETQ CONTEXT (HELP-GET-STELLA-CONTEXT-OR-MODULE PATHNAME CL:T))
    (CL:HANDLER-CASE
     (CL:SETQ CONTEXT
      (HELP-GET-STELLA-CONTEXT-OR-MODULE PATHNAME CL:T))
     (NO-SUCH-CONTEXT-EXCEPTION ()
      (CL:RETURN-FROM HELP-GET-STELLA-MODULE NULL))))
   (CL:COND
    ((ISA? CONTEXT SGT-MODULES-STELLA-MODULE)
     (CL:RETURN-FROM HELP-GET-STELLA-MODULE CONTEXT))
    (ERROR?
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Context `" CONTEXT "' is not a MODULE!")
      (CL:ERROR
       (NEW-NO-SUCH-CONTEXT-EXCEPTION
        (THE-STRING-READER STREAM-000)))))
    (CL:T (CL:RETURN-FROM HELP-GET-STELLA-MODULE NULL)))))

;;; (DEFUN (COERCE-TO-MODULE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  COERCE-TO-MODULE-NAME))
(CL:DEFUN COERCE-TO-MODULE-NAME (NAMESPEC WARN?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAMESPEC)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-TO-MODULE-NAME
       (%STRING-WRAPPER.WRAPPER-VALUE NAMESPEC))))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-MODULES-STELLA-MUTABLE-STRING-WRAPPER)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-TO-MODULE-NAME
       (CL:LET ((S (%MUTABLE-STRING-WRAPPER.WRAPPER-VALUE NAMESPEC)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
        (CL:THE CL:SIMPLE-STRING S)))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-TO-MODULE-NAME
       (%KEYWORD.SYMBOL-NAME NAMESPEC))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((MODULE (%SYMBOL.HOME-CONTEXT NAMESPEC)))
       (CL:COND
        ((CL:EQ MODULE NULL)
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME
          (%SYMBOL.SYMBOL-NAME NAMESPEC)))
        (CL:T
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME
          (VISIBLE-NAME NAMESPEC CL:NIL)))))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((MODULE (%SURROGATE.HOME-CONTEXT NAMESPEC)))
       (CL:COND
        ((CL:EQ MODULE NULL)
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME
          (%SURROGATE.SYMBOL-NAME NAMESPEC)))
        (CL:T
         (CL:RETURN-FROM COERCE-TO-MODULE-NAME
          (VISIBLE-NAME NAMESPEC CL:NIL)))))))
    (CL:T
     (CL:WHEN WARN? (CL:WARN "Illegal module name: `~A'" NAMESPEC))
     (CL:RETURN-FROM COERCE-TO-MODULE-NAME STELLA::NULL-STRING)))))

;;; (DEFUN (COERCE-TO-MODULE MODULE) ...)

(CL:DEFUN COERCE-TO-MODULE (OBJECT WARN?)
  (CL:WHEN (CL:EQ OBJECT NULL)
   (CL:RETURN-FROM COERCE-TO-MODULE *MODULE*))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE OBJECT) SGT-MODULES-STELLA-MODULE)
    (CL:PROGN (CL:RETURN-FROM COERCE-TO-MODULE OBJECT)))
   (CL:T
    (CL:LET* ((MODULENAME (COERCE-TO-MODULE-NAME OBJECT WARN?)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME))
     (CL:WHEN (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
      (CL:WHEN (QUALIFIED-STELLA-NAME? MODULENAME)
       (CL:RETURN-FROM COERCE-TO-MODULE
        (GET-STELLA-MODULE MODULENAME WARN?)))
      (CL:RETURN-FROM COERCE-TO-MODULE
       (GET-STELLA-MODULE MODULENAME WARN?)))
     (CL:RETURN-FROM COERCE-TO-MODULE NULL)))))

;;; (DEFUN (FIND-OR-CREATE-MODULE MODULE) ...)

(CL:DEFUN FIND-OR-CREATE-MODULE (PATHNAME)
  "Return a module located at `pathname' if one exists,
  otherwise create one"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (GET-STELLA-MODULE PATHNAME CL:NIL)))
   (CL:WHEN (CL:EQ MODULE NULL)
    (CL:SETQ MODULE (DEFINE-MODULE PATHNAME NIL)))
   (CL:RETURN-FROM FIND-OR-CREATE-MODULE MODULE)))

;;; (DEFUN (CHANGE-CURRENT-MODULE MODULE) ...)

(CL:DEFUN CHANGE-CURRENT-MODULE (MODULE)
  (CL:SETQ *MODULE* MODULE)
  (CL:SETQ *CONTEXT* MODULE)
  (RUN-HOOKS *CHANGE-MODULE-HOOKS* MODULE)
  (CL:RETURN-FROM CHANGE-CURRENT-MODULE MODULE))

;;; (DEFUN (CHANGE-CURRENT-CONTEXT CONTEXT) ...)

(CL:DEFUN CHANGE-CURRENT-CONTEXT (CONTEXT)
  (CL:WHEN (CL:NOT (CL:EQ (%CONTEXT.BASE-MODULE CONTEXT) *MODULE*))
   (CHANGE-CURRENT-MODULE (%CONTEXT.BASE-MODULE CONTEXT)))
  (CL:SETQ *CONTEXT* CONTEXT)
  (CL:RETURN-FROM CHANGE-CURRENT-CONTEXT CONTEXT))

;;; (DEFMETHOD (CHANGE-CONTEXT CONTEXT) ...)

(CL:DEFMETHOD CHANGE-CONTEXT ((CONTEXT CONTEXT))
  "Change the current context to be the context
'context'."
  (CL:IF (CL:EQ CONTEXT *CONTEXT*)
   (CL:RETURN-FROM CHANGE-CONTEXT CONTEXT)
   (CL:RETURN-FROM CHANGE-CONTEXT (CHANGE-CURRENT-CONTEXT CONTEXT))))

;;; (DEFMETHOD (CHANGE-CONTEXT CONTEXT) ...)

(CL:DEFMETHOD CHANGE-CONTEXT ((CONTEXTNAME CL:STRING))
  "Change the current context to be the context named
'contextName'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CONTEXTNAME))
  #+MCL
  (CL:CHECK-TYPE CONTEXTNAME CL:SIMPLE-STRING)
  (CL:LET* ((CONTEXT (GET-STELLA-CONTEXT CONTEXTNAME CL:T)))
   (CL:IF (CL:EQ CONTEXT NULL)
    (CL:RETURN-FROM CHANGE-CONTEXT *CONTEXT*)
    (CL:RETURN-FROM CHANGE-CONTEXT (CHANGE-CURRENT-CONTEXT CONTEXT)))))

;;; (DEFMETHOD (CHANGE-MODULE MODULE) ...)

(CL:DEFMETHOD CHANGE-MODULE ((MODULE MODULE))
  "Change the current module to be the module
'module'."
  (CL:RETURN-FROM CHANGE-MODULE (CHANGE-CURRENT-MODULE MODULE)))

;;; (DEFMETHOD (CHANGE-MODULE MODULE) ...)

(CL:DEFMETHOD CHANGE-MODULE ((MODULENAME CL:STRING))
  "Change the current module to be the module named
'moduleName'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME))
  #+MCL
  (CL:CHECK-TYPE MODULENAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE (GET-STELLA-MODULE MODULENAME CL:T)))
   (CL:IF (CL:EQ MODULE NULL) (CL:RETURN-FROM CHANGE-MODULE *MODULE*)
    (CL:RETURN-FROM CHANGE-MODULE (CHANGE-CURRENT-MODULE MODULE)))))

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((SELF CONTEXT))
  (CL:RETURN-FROM MULTIPLE-PARENTS? CL:NIL))

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((MODULE MODULE))
  "Return TRUE if 'module' has more than one parent."
  (CL:RETURN-FROM MULTIPLE-PARENTS?
   (CL:NOT (CL:EQ (REST (%MODULE.PARENT-MODULES MODULE)) NIL))))

;;; (DEFUN NORMALIZE-PARENT-MODULES ...)

(CL:DEFUN NORMALIZE-PARENT-MODULES (SELF)
  (CL:WHEN (CL:NOT (MULTIPLE-PARENTS? SELF))
   (CL:RETURN-FROM NORMALIZE-PARENT-MODULES))
  (CL:LET*
   ((PARENTS (%MODULE.PARENT-MODULES SELF))
    (RECOMPUTEFULLNAME? CL:NIL))
   (CL:LET*
    ((SUPERMODULE NULL) (ITER-000 (%LIST.THE-CONS-LIST PARENTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPERMODULE (%%VALUE ITER-000))
     (CL:LET*
      ((OTHERSUPERMODULE NULL)
       (ITER-001 (%LIST.THE-CONS-LIST PARENTS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ OTHERSUPERMODULE (%%VALUE ITER-001))
       (CL:WHEN (CL:NOT (CL:EQ OTHERSUPERMODULE SUPERMODULE))
        (CL:WHEN
         (MEMBER? (%MODULE.ALL-SUPER-CONTEXTS SUPERMODULE)
          OTHERSUPERMODULE)
         (REMOVE PARENTS OTHERSUPERMODULE)
         (REMOVE (%MODULE.CHILD-CONTEXTS OTHERSUPERMODULE) SELF)
         (CL:SETQ RECOMPUTEFULLNAME? CL:T)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN RECOMPUTEFULLNAME?
    (CL:SETF (%MODULE.MODULE-FULL-NAME SELF)
     (COMPUTE-FULL-NAME "" SELF))))
  :VOID)

;;; (DEFMETHOD INHERIT-SUPERCONTEXTS ...)

(CL:DEFMETHOD INHERIT-SUPERCONTEXTS ((CONTEXT CONTEXT))
  :VOID)

;;; (DEFMETHOD INHERIT-SUPERCONTEXTS ...)

(CL:DEFMETHOD INHERIT-SUPERCONTEXTS ((WORLD WORLD))
  (CL:LET* ((PARENT (%WORLD.PARENT-CONTEXT WORLD)))
   (CL:IF (CL:NOT (CL:EQ PARENT NULL))
    (CL:SETF (%WORLD.ALL-SUPER-CONTEXTS WORLD)
     (CONS PARENT (%CONTEXT.ALL-SUPER-CONTEXTS PARENT)))
    (CL:SETF (%WORLD.ALL-SUPER-CONTEXTS WORLD) NIL)))
  :VOID)

;;; (DEFMETHOD INHERIT-SUPERCONTEXTS ...)

(CL:DEFMETHOD INHERIT-SUPERCONTEXTS ((MODULE MODULE))
  (CL:WHEN (CL:NOT (MULTIPLE-PARENTS? MODULE))
   (CL:LET* ((ONLYPARENT (FIRST (%MODULE.PARENT-MODULES MODULE))))
    (CL:WHEN (CL:NOT (CL:EQ ONLYPARENT NULL))
     (CL:SETF (%MODULE.ALL-SUPER-CONTEXTS MODULE)
      (CONS ONLYPARENT (%MODULE.ALL-SUPER-CONTEXTS ONLYPARENT)))
     (CL:RETURN-FROM INHERIT-SUPERCONTEXTS))))
  (CL:LET* ((ALLSUPERCONTEXTS NIL) (SUBLIST NULL))
   (NORMALIZE-PARENT-MODULES MODULE)
   (REVERSE (%MODULE.PARENT-MODULES MODULE))
   (CL:LET*
    ((PARENT NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES MODULE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000)) (CL:SETQ SUBLIST NIL)
     (CL:LET*
      ((ANCESTOR NULL) (ITER-001 (%MODULE.ALL-SUPER-CONTEXTS PARENT))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ ANCESTOR (%%VALUE ITER-001))
       (CL:WHEN (CL:NOT (MEMBER? ALLSUPERCONTEXTS ANCESTOR))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS ANCESTOR NIL))
          (CL:IF (CL:EQ SUBLIST NIL) (CL:SETQ SUBLIST COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST SUBLIST COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ANCESTOR NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ SUBLIST (CONS PARENT SUBLIST))
     (CL:SETQ ALLSUPERCONTEXTS (CONCATENATE SUBLIST ALLSUPERCONTEXTS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%MODULE.ALL-SUPER-CONTEXTS MODULE) ALLSUPERCONTEXTS)
   (REVERSE (%MODULE.PARENT-MODULES MODULE)))
  :VOID)

;;; (DEFMETHOD UNINHERIT-SUPERCONTEXTS ...)

(CL:DEFMETHOD UNINHERIT-SUPERCONTEXTS ((CONTEXT CONTEXT))
  (CL:SETF (%CONTEXT.ALL-SUPER-CONTEXTS CONTEXT) NIL)
  :VOID)

;;; (DEFUN INHERIT-USED-MODULES ...)

(CL:DEFUN INHERIT-USED-MODULES (MODULE)
  (CL:LET* ((USEES (%MODULE.USES MODULE)))
   (CL:COND
    ((EMPTY? USEES)
     (CL:COND
      ((EMPTY? (%MODULE.PARENT-MODULES MODULE))
       (PUSH USEES *STELLA-MODULE*)
       (INSERT-NEW (%MODULE.USED-BY *STELLA-MODULE*) MODULE))
      (CL:T
       (CL:LET*
        ((PARENT NULL)
         (ITER-000
          (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES MODULE))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ PARENT (%%VALUE ITER-000))
         (CL:LET*
          ((PARENTUSEES NULL)
           (ITER-001 (%LIST.THE-CONS-LIST (%MODULE.USES PARENT))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ PARENTUSEES (%%VALUE ITER-001))
           (INSERT-NEW USEES PARENTUSEES)
           (INSERT-NEW (%MODULE.USED-BY PARENTUSEES) MODULE)
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (REVERSE USEES))))
    ((MEMBER? USEES MODULE) (REMOVE USEES MODULE)) (CL:T)))
  :VOID)

;;; (DEFUN UNINHERIT-USED-MODULES ...)

(CL:DEFUN UNINHERIT-USED-MODULES (MODULE)
  (CL:LET* ((USEES (%MODULE.USES MODULE)))
   (CL:COND ((EMPTY? USEES) (PUSH USEES MODULE))
    ((CL:=
      (STRING-SEARCH (%MODULE.STRINGIFIED-OPTIONS MODULE) ":USES " 0)
      NULL-INTEGER)
     (CL:LET* ((USEE NULL) (ITER-000 (%LIST.THE-CONS-LIST USEES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ USEE (%%VALUE ITER-000))
       (REMOVE (%MODULE.USED-BY USEE) MODULE)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CLEAR USEES))))
  :VOID)

;;; (DEFSPECIAL *SHADOWEDSURROGATES* ...)

(CL:DEFVAR *SHADOWEDSURROGATES* NULL
  "Holds list of symbols representing surrogates
to be shadowed during module finalization.")

;;; (DEFUN FINALIZE-MODULE ...)

(CL:DEFUN FINALIZE-MODULE (SELF)
  (INHERIT-SUPERCONTEXTS SELF)
  (INHERIT-USED-MODULES SELF)
  (CL:SETQ *CONTEXT-NUMBER-COUNTER* (CL:+ *CONTEXT-NUMBER-COUNTER* 2))
  (CL:SETF (%MODULE.CONTEXT-NUMBER SELF) *CONTEXT-NUMBER-COUNTER*)
  (CL:SETF (%MODULE.CARDINAL-MODULE SELF)
   (CL:IF (CL:EQ (PARENT-MODULE SELF) NULL) SELF
    (%MODULE.CARDINAL-MODULE (PARENT-MODULE SELF))))
  (CL:SETF (%MODULE.SYMBOL-OFFSET-TABLE SELF)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETF (%MODULE.SURROGATE-OFFSET-TABLE SELF)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:WHEN (CL:NOT (CL:EQ *SHADOWEDSURROGATES* NIL))
   (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
    SYM-MODULES-STELLA-SHADOWED-SURROGATES (NEW-LIST) NULL)
   (CL:LET* ((*MODULE* SELF)) (CL:DECLARE (CL:SPECIAL *MODULE*))
    (CL:LET* ((SYM NULL) (ITER-000 *SHADOWEDSURROGATES*))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SYM (%%VALUE ITER-000))
      (INSERT-LAST (SHADOWED-SURROGATES SELF)
       (SHADOW-SURROGATE (%SYMBOL.SYMBOL-NAME SYM)))
      (CL:SETQ ITER-000 (%%REST ITER-000))))))
  :VOID)

;;; (DEFUN FINALIZE-WORLD ...)

(CL:DEFUN FINALIZE-WORLD (SELF)
  (CL:LET* ((PARENTCONTEXT (%WORLD.PARENT-CONTEXT SELF)))
   (CL:SETF (%WORLD.ALL-SUPER-CONTEXTS SELF)
    (CONS PARENTCONTEXT (%CONTEXT.ALL-SUPER-CONTEXTS PARENTCONTEXT)))
   (CL:SETQ *CONTEXT-NUMBER-COUNTER* (CL:+ *CONTEXT-NUMBER-COUNTER* 2))
   (CL:SETF (%WORLD.CONTEXT-NUMBER SELF) *CONTEXT-NUMBER-COUNTER*))
  :VOID)

;;; (DEFMETHOD UNFINALIZE-MODULE ...)

(CL:DEFMETHOD UNFINALIZE-MODULE ((SELF MODULE))
  (UNINHERIT-SUPERCONTEXTS SELF)
  (UNINHERIT-USED-MODULES SELF)
  (CL:IF (CARDINAL-MODULE? SELF)
   (REMOVE (%MODULE.CHILD-CONTEXTS *ROOT-MODULE*) SELF)
   (CL:LET*
    ((PARENT NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000))
     (REMOVE (%MODULE.CHILD-CONTEXTS PARENT) SELF)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CLEAR (%MODULE.PARENT-MODULES SELF))
  (CL:WHEN (CL:NOT (CL:= (%MODULE.CONTEXT-NUMBER SELF) NULL-INTEGER))
   (CL:SETF (%MODULE.CONTEXT-NUMBER SELF)
    (CL:1- (%MODULE.CONTEXT-NUMBER SELF))))
  (CL:SETF (%MODULE.MODULE-FULL-NAME SELF) STELLA::NULL-STRING)
  (CL:SETF (%MODULE.CARDINAL-MODULE SELF) NULL)
  (CL:SETF (%MODULE.SYMBOL-OFFSET-TABLE SELF) NULL)
  (CL:SETF (%MODULE.SURROGATE-OFFSET-TABLE SELF) NULL)
  :VOID)

;;; (DEFMETHOD UNFINALIZE-WORLD ...)

(CL:DEFMETHOD UNFINALIZE-WORLD ((SELF WORLD))
  (REMOVE (%CONTEXT.CHILD-CONTEXTS (%WORLD.PARENT-CONTEXT SELF)) SELF)
  (CL:SETF (%WORLD.CONTEXT-NUMBER SELF)
   (CL:1- (%WORLD.CONTEXT-NUMBER SELF)))
  (CL:SETF (%WORLD.ALL-SUPER-CONTEXTS SELF) NULL)
  (CL:SETF (%WORLD.PARENT-CONTEXT SELF) NULL)
  :VOID)

;;; (DEFUN DESTROY-MODULE ...)

(CL:DEFUN DESTROY-MODULE (SELF)
  "Destroy the module 'self', and recursively destroy
all contexts that inherit 'self'."
  (CL:WHEN
   (CL:OR (CL:EQ SELF *ROOT-MODULE*) (CL:EQ SELF *STELLA-MODULE*))
   (CL:WARN "Can't destroy the root module or the STELLA module.")
   (CL:RETURN-FROM DESTROY-MODULE))
  (CLEAR-CONTEXT SELF)
  (HELP-DESTROY-MODULE SELF)
  :VOID)

;;; (DEFUN HELP-DESTROY-MODULE ...)

(CL:DEFUN HELP-DESTROY-MODULE (SELF)
  (CL:LET*
   ((CHILD NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (COPY (%MODULE.CHILD-CONTEXTS SELF)))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-000))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE CHILD) SGT-MODULES-STELLA-MODULE)
      (CL:PROGN (HELP-DESTROY-MODULE CHILD)))
     (CL:T (DESTROY-CONTEXT CHILD)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET* ((PARENTMODULE (PARENT-MODULE SELF)))
   (RUN-HOOKS *DESTROY-CONTEXT-HOOKS* SELF)
   (CL:WHEN (CL:EQ PARENTMODULE NULL)
    (CL:SETQ PARENTMODULE (%MODULE.CARDINAL-MODULE SELF)))
   (CL:WHEN (CL:EQ PARENTMODULE NULL)
    (CL:SETQ PARENTMODULE *STELLA-MODULE*))
   (UNFINALIZE-MODULE SELF)
   (BUMP-MEMOIZATION-TIMESTAMP KWD-MODULES-MODULE-UPDATE)
   (CL:WHEN (CL:EQ SELF *MODULE*) (CHANGE-MODULE PARENTMODULE)))
  :VOID)

;;; (DEFUN DESTROY-WORLD ...)

(CL:DEFUN DESTROY-WORLD (SELF)
  (CL:WHEN (NON-EMPTY? (%WORLD.CHILD-CONTEXTS SELF))
   (CL:LET*
    ((CHILD NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (COPY (%WORLD.CHILD-CONTEXTS SELF)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (DELETED? CHILD)) (DESTROY-WORLD CHILD))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CL:LET* ((PARENTCONTEXT (%WORLD.PARENT-CONTEXT SELF)))
   (RUN-HOOKS *DESTROY-CONTEXT-HOOKS* SELF) (UNFINALIZE-WORLD SELF)
   (CL:WHEN (CL:EQ SELF *CONTEXT*) (CL:SETQ *CONTEXT* PARENTCONTEXT)))
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF MODULE))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (DESTROY-MODULE SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF WORLD))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (DESTROY-WORLD SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF CL:STRING))
  "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((CONTEXT (GET-STELLA-CONTEXT SELF CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ CONTEXT NULL)) (DESTROY-CONTEXT CONTEXT)))
  :VOID)

;;; (DEFMETHOD DESTROY-CONTEXT ...)

(CL:DEFMETHOD DESTROY-CONTEXT ((SELF CONTEXT))
  "Make the translator happy."
  :VOID)

;;; (DEFUN LINK-TO-PARENT-MODULE ...)

(CL:DEFUN LINK-TO-PARENT-MODULE (SELF PARENT INSERT-FIRST?)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ PARENT *ROOT-MODULE*))
    (CL:NOT (MEMBER? (%MODULE.PARENT-MODULES SELF) PARENT)))
   (CL:IF INSERT-FIRST? (INSERT (%MODULE.PARENT-MODULES SELF) PARENT)
    (INSERT-LAST (%MODULE.PARENT-MODULES SELF) PARENT)))
  (INSERT-NEW (%MODULE.CHILD-CONTEXTS PARENT) SELF)
  :VOID)

;;; (DEFUN INCORPORATE-MODULE-NAME ...)

(CL:DEFUN INCORPORATE-MODULE-NAME (MODULE NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((PARENTMODULE NULL) (BARENAME STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BARENAME))
   (CL:IF (QUALIFIED-STELLA-NAME? NAME)
    (CL:PROGN
     (CL:MULTIPLE-VALUE-SETQ (PARENTMODULE BARENAME)
      (COMPUTE-MODULE-AND-BARE-NAME NAME))
     (CL:WHEN (CL:EQ PARENTMODULE NULL)
      (CL:WARN "Bad path name `~A' when defining the module `~A'" NAME
       BARENAME)
      (CL:RETURN-FROM INCORPORATE-MODULE-NAME))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:IF
       (CL:AND (CL:EQ PARENTMODULE *ROOT-MODULE*)
        (NON-EMPTY? (%MODULE.PARENT-MODULES MODULE)))
       (CL:SETQ TEST-VALUE-000 CL:T)
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((INCLUDEDMODULE NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES MODULE))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ INCLUDEDMODULE (%%VALUE ITER-000))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ INCLUDEDMODULE PARENTMODULE))
            (CL:OR (CL:EQ INCLUDEDMODULE PARENTMODULE)
             (MEMB? (%CONTEXT.ALL-SUPER-CONTEXTS INCLUDEDMODULE)
              PARENTMODULE)))
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000)))
      (CL:IF TEST-VALUE-000
       (CL:WARN
        "Bad path name `~A' when defining the module `~A',~%   since it points to a parent of an included module."
        NAME BARENAME)
       (LINK-TO-PARENT-MODULE MODULE PARENTMODULE CL:T))))
    (CL:PROGN
     (CL:WHEN (EMPTY? (%MODULE.PARENT-MODULES MODULE))
      (LINK-TO-PARENT-MODULE MODULE *ROOT-MODULE* CL:T))
     (CL:SETQ BARENAME NAME)))
   (CL:SETF (%MODULE.MODULE-NAME MODULE) BARENAME)
   (CL:SETF (%MODULE.MODULE-FULL-NAME MODULE)
    (COMPUTE-FULL-NAME "" MODULE)))
  :VOID)

;;; (DEFUN INCORPORATE-INCLUDES-MODULES ...)

(CL:DEFUN INCORPORATE-INCLUDES-MODULES (MODULE INCLUDEES)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE INCLUDEES)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-MODULES-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((NAME NULL) (ITER-000 INCLUDEES))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ NAME (%%VALUE ITER-000))
        (INCORPORATE-INCLUDES-MODULES MODULE NAME)
        (CL:SETQ ITER-000 (%%REST ITER-000))))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((INCLUDEEMODULE (COERCE-TO-MODULE INCLUDEES CL:T)))
       (CL:WHEN (CL:NOT (CL:EQ INCLUDEEMODULE NULL))
        (CL:WHEN
         (CL:NOT
          (MEMBER? (%MODULE.PARENT-MODULES MODULE) INCLUDEEMODULE))
         (INSERT-LAST (%MODULE.PARENT-MODULES MODULE) INCLUDEEMODULE))
        (INSERT-NEW (%MODULE.CHILD-CONTEXTS INCLUDEEMODULE) MODULE)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((INCLUDEEMODULE (COERCE-TO-MODULE INCLUDEES CL:T)))
       (CL:WHEN (CL:NOT (CL:EQ INCLUDEEMODULE NULL))
        (CL:WHEN
         (CL:NOT
          (MEMBER? (%MODULE.PARENT-MODULES MODULE) INCLUDEEMODULE))
         (INSERT-LAST (%MODULE.PARENT-MODULES MODULE) INCLUDEEMODULE))
        (INSERT-NEW (%MODULE.CHILD-CONTEXTS INCLUDEEMODULE) MODULE)))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal argument to ':includes' option`"
        (DE-UGLIFY-PARSE-TREE INCLUDEES) "'." EOL))))))
  :VOID)

;;; (DEFUN INCORPORATE-USES-MODULES ...)

(CL:DEFUN INCORPORATE-USES-MODULES (MODULE USEES)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE USEES)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-MODULES-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((NAME NULL) (ITER-000 USEES))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ NAME (%%VALUE ITER-000))
        (INCORPORATE-USES-MODULES MODULE NAME)
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:WHEN (EMPTY? (%MODULE.USES MODULE))
       (INSERT (%MODULE.USES MODULE) MODULE))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((USEEMODULE (COERCE-TO-MODULE USEES CL:T)))
       (CL:WHEN (CL:NOT (CL:EQ USEEMODULE NULL))
        (CL:WHEN (CL:NOT (MEMBER? (%MODULE.USES MODULE) USEEMODULE))
         (INSERT-LAST (%MODULE.USES MODULE) USEEMODULE))
        (INSERT-NEW (%MODULE.USED-BY USEEMODULE) MODULE)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((USEEMODULE (COERCE-TO-MODULE USEES CL:T)))
       (CL:WHEN (CL:NOT (CL:EQ USEEMODULE NULL))
        (CL:WHEN (CL:NOT (MEMBER? (%MODULE.USES MODULE) USEEMODULE))
         (INSERT-LAST (%MODULE.USES MODULE) USEEMODULE))
        (INSERT-NEW (%MODULE.USED-BY USEEMODULE) MODULE)))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal argument to ':uses' option ." EOL))))))
  :VOID)

;;; (DEFUN (TRUE-OPTION? BOOLEAN) ...)

(CL:DEFUN TRUE-OPTION? (VALUE)
  (CL:RETURN-FROM TRUE-OPTION?
   (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
    (EQL? VALUE TRUE-WRAPPER)
    (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
     (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))))

;;; (DEFUN INCORPORATE-MODULE-OPTIONS ...)

(CL:DEFUN INCORPORATE-MODULE-OPTIONS (SELF OPTIONS)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) OPTIONS)
   (CL:LET*
    ((PLIST
      (VET-OPTIONS SELF-000
       (GET-QUOTED-TREE
        "((:NICKNAME :INCLUDES :USES :DOCUMENTATION :SHADOW :CASE-SENSITIVE? :LISP-PACKAGE :CPP-PACKAGE :JAVA-PACKAGE :JAVA-CATCHALL-CLASS :API? :CLEARABLE? :PROTECT-SURROGATES? :CODE-ONLY? :NAMESPACE?) \"/STELLA\")"
        "/STELLA"))))
    (CL:LET*
     ((KEY NULL) (VALUE NULL)
      (ITER-000 (%PROPERTY-LIST.THE-PLIST PLIST)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
      (CL:LET* ((TEST-VALUE-000 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-MODULES-INCLUDES)
         (INCORPORATE-INCLUDES-MODULES SELF VALUE))
        ((CL:EQ TEST-VALUE-000 KWD-MODULES-USES)
         (INCORPORATE-USES-MODULES SELF VALUE))
        ((CL:EQ TEST-VALUE-000 KWD-MODULES-SHADOW)
         (CL:SETQ *SHADOWEDSURROGATES* VALUE))
        (CL:T (CL:SETQ VALUE (PERMANENT-COPY VALUE))
         (CL:LET* ((TEST-VALUE-001 KEY))
          (CL:COND
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-DOCUMENTATION)
            (CL:SETF (%MODULE.DOCUMENTATION SELF)
             (UNWRAP-STRING VALUE)))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-CASE-SENSITIVE?)
            (CL:SETF (%MODULE.CASE-SENSITIVE? SELF)
             (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
              (EQL? VALUE TRUE-WRAPPER)
              (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
               (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-API?)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-API?
             (CL:IF
              (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
               (EQL? VALUE TRUE-WRAPPER)
               (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
                (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))
              TRUE-WRAPPER FALSE-WRAPPER)
             FALSE-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-LISP-PACKAGE)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-MODULE-LISP-PACKAGE
             (WRAP-STRING (UNWRAP-STRING VALUE)) NULL-STRING-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-CPP-PACKAGE)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-MODULE-CPP-PACKAGE
             (WRAP-STRING (UNWRAP-STRING VALUE)) NULL-STRING-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-JAVA-PACKAGE)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-JAVA-PACKAGE
             (WRAP-STRING (UNWRAP-STRING VALUE)) NULL-STRING-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-JAVA-CATCHALL-CLASS)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-JAVA-FLOTSAM-CLASS
             (WRAP-STRING (UNWRAP-STRING VALUE)) NULL-STRING-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-NICKNAME)
            (CL:WHEN (CL:EQ (%MODULE.NICKNAMES SELF) NULL)
             (CL:SETF (%MODULE.NICKNAMES SELF) (NEW-LIST)))
            (INSERT (%MODULE.NICKNAMES SELF) VALUE))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-CLEARABLE?)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-CLEARABLE?
             (CL:IF
              (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
               (EQL? VALUE TRUE-WRAPPER)
               (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
                (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))
              TRUE-WRAPPER FALSE-WRAPPER)
             FALSE-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-PROTECT-SURROGATES?)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-PROTECT-SURROGATES?
             (CL:IF
              (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
               (EQL? VALUE TRUE-WRAPPER)
               (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
                (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))
              TRUE-WRAPPER FALSE-WRAPPER)
             FALSE-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-CODE-ONLY?)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-CODE-ONLY?
             (CL:IF
              (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
               (EQL? VALUE TRUE-WRAPPER)
               (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
                (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))
              TRUE-WRAPPER FALSE-WRAPPER)
             FALSE-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-NAMESPACE?)
            (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SELF)
             SYM-MODULES-STELLA-NAMESPACE?
             (CL:IF
              (CL:OR (CL:EQ VALUE SYM-MODULES-STELLA-TRUE)
               (EQL? VALUE TRUE-WRAPPER)
               (CL:AND (ISA? VALUE SGT-MODULES-STELLA-SYMBOL)
                (STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")))
              TRUE-WRAPPER FALSE-WRAPPER)
             FALSE-WRAPPER))
           ((CL:EQ TEST-VALUE-001 KWD-MODULES-REQUIRES)
            (CL:SETF (%MODULE.REQUIRES SELF) VALUE))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              TEST-VALUE-001 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-000))))))))))
      (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
    (FREE PLIST)))
  :VOID)

;;; (DEFUN UNDEFINE-MODULE ...)

(CL:DEFUN UNDEFINE-MODULE (OLDMODULE NEWMODULE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Redefining the module `" (CONTEXT-NAME OLDMODULE) "'" EOL)
  (CL:COND
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-DESTROY)
    (DESTROY-CONTEXT OLDMODULE) (CL:RETURN-FROM UNDEFINE-MODULE))
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-PRESERVE))
   ((CL:EQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-CLEAR)
    (CL:LET*
     ((C NULL)
      (ITER-000 (ALL-SUBCONTEXTS OLDMODULE KWD-MODULES-PREORDER)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ C (%ALL-PURPOSE-ITERATOR.VALUE ITER-000))
      (CLEAR-CONTEXT C))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *SUBCONTEXT-REVISION-POLICY* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:IF (CARDINAL-MODULE? OLDMODULE)
   (REMOVE (%MODULE.CHILD-CONTEXTS *ROOT-MODULE*) OLDMODULE)
   (CL:LET*
    ((P NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES OLDMODULE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-001))
     (REMOVE (%MODULE.CHILD-CONTEXTS P) OLDMODULE)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  (CL:LET*
   ((C NULL)
    (ITER-002
     (%LIST.THE-CONS-LIST (%MODULE.CHILD-CONTEXTS OLDMODULE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
    (CL:SETQ C (%%VALUE ITER-002))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE C)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-MODULES-STELLA-MODULE)
       (CL:PROGN
        (SUBSTITUTE (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES C))
         NEWMODULE OLDMODULE)))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-MODULES-STELLA-WORLD)
       (CL:PROGN (CL:SETF (%WORLD.PARENT-CONTEXT C) NEWMODULE)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:SETQ ITER-002 (%%REST ITER-002))))
  (CL:SETF (%LIST.THE-CONS-LIST (%MODULE.CHILD-CONTEXTS NEWMODULE))
   (%LIST.THE-CONS-LIST (%MODULE.CHILD-CONTEXTS OLDMODULE)))
  (CL:SETF (%LIST.THE-CONS-LIST (%MODULE.CHILD-CONTEXTS OLDMODULE)) NIL)
  (CL:SETF (%MODULE.SURROGATE-VALUE-INVERSE OLDMODULE) NULL)
  (UNFINALIZE-MODULE OLDMODULE)
  (FREE OLDMODULE)
  :VOID)

;;; (DEFGLOBAL *DEFINE-MODULE-HOOKS* ...)

(CL:DEFVAR *DEFINE-MODULE-HOOKS* NULL
  "HOOK-LIST called by 'define-module', applied to a
'module' argument.")

;;; (DEFGLOBAL *MODULE-NON-STRUCTURAL-OPTIONS* ...)

(CL:DEFVAR *MODULE-NON-STRUCTURAL-OPTIONS* NULL
  "List of non-structural options for Module definitions.
Used in testing for module changes and in updating non-structurally changed
modules.")

;;; (DEFUN (DEFINE-MODULE MODULE) ...)

(CL:DEFUN DEFINE-MODULE (NAME OPTIONS)
  "Define or redefine a module named 'name' having the
options 'options'.  Return the new module."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((*SHADOWEDSURROGATES* NIL))
   (CL:DECLARE (CL:SPECIAL *SHADOWEDSURROGATES*))
   (CL:LET*
    ((MODULE NULL) (STRINGIFIEDOPTIONS (STRINGIFY OPTIONS))
     (OLDMODULE NULL))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDOPTIONS))
    (CL:SETQ OLDMODULE (GET-STELLA-MODULE NAME CL:NIL))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ OLDMODULE NULL))
      (IDENTICAL-MODULE-STRUCTURE? OLDMODULE NULL STRINGIFIEDOPTIONS))
     (UPDATE-NON-STRUCTURAL-MODULE-OPTIONS OLDMODULE NULL
      STRINGIFIEDOPTIONS)
     (CL:RETURN-FROM DEFINE-MODULE OLDMODULE))
    (CL:SETQ MODULE (NEW-MODULE))
    (CL:SETF (%MODULE.STRINGIFIED-OPTIONS MODULE) STRINGIFIEDOPTIONS)
    (INCORPORATE-MODULE-OPTIONS MODULE OPTIONS)
    (INCORPORATE-MODULE-NAME MODULE NAME)
    (CL:SETF (%MODULE.BASE-MODULE MODULE) MODULE)
    (CL:WHEN (CL:NOT (CL:EQ OLDMODULE NULL))
     (CL:WHEN
      (IDENTICAL-MODULE-STRUCTURE? OLDMODULE MODULE
       STELLA::NULL-STRING)
      (UPDATE-NON-STRUCTURAL-MODULE-OPTIONS OLDMODULE MODULE
       STELLA::NULL-STRING)
      (UNFINALIZE-MODULE MODULE)
      (CL:RETURN-FROM DEFINE-MODULE OLDMODULE))
     (CL:WHEN (CL:EQ OLDMODULE *MODULE*)
      (CL:WARN "Can't define a module inside of itself.")
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Skipping redefinition of module " NAME "." EOL)
      (UNFINALIZE-MODULE MODULE)
      (CL:RETURN-FROM DEFINE-MODULE OLDMODULE))
     (UNDEFINE-MODULE OLDMODULE MODULE))
    (FINALIZE-MODULE MODULE)
    (CL:WHEN (CL:NOT (CL:EQ OLDMODULE NULL))
     (CL:LET*
      ((C NULL)
       (ITER-000 (ALL-SUBCONTEXTS MODULE KWD-MODULES-TOPDOWN)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ C (%ALL-PURPOSE-ITERATOR.VALUE ITER-000))
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE C)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-000 SGT-MODULES-STELLA-MODULE)
          (CL:PROGN
           (CL:WHEN (EMPTY? (%MODULE.USES C))
            (CL:SETF (%MODULE.USES C) (LIST C)))
           (FINALIZE-MODULE C)))
         ((SUBTYPE-OF? TEST-VALUE-000 SGT-MODULES-STELLA-WORLD)
          (CL:PROGN (FINALIZE-WORLD C)))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-000))))))))))
    (BUMP-MEMOIZATION-TIMESTAMP KWD-MODULES-MODULE-UPDATE)
    (RUN-HOOKS *DEFINE-MODULE-HOOKS* MODULE)
    (CL:RETURN-FROM DEFINE-MODULE MODULE))))

;;; (DEFUN UPDATE-NON-STRUCTURAL-MODULE-OPTIONS ...)

(CL:DEFUN UPDATE-NON-STRUCTURAL-MODULE-OPTIONS (OLDMODULE NEWMODULE NEWOPTIONS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NEWOPTIONS))
  #+MCL
  (CL:CHECK-TYPE NEWOPTIONS CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ NEWOPTIONS STELLA::NULL-STRING)
   (CL:SETQ NEWOPTIONS (%MODULE.STRINGIFIED-OPTIONS NEWMODULE)))
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
    (READ-S-EXPRESSION-FROM-STRING
     (%MODULE.STRINGIFIED-OPTIONS OLDMODULE)))
   (CL:LET* ((OLDPLIST SELF-000))
    (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
     (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001)
      (READ-S-EXPRESSION-FROM-STRING NEWOPTIONS))
     (CL:LET*
      ((NEWPLIST SELF-001) (OLDVALUE NULL) (NEWVALUE NULL)
       (CHANGED-VALUES NIL))
      (CL:LET*
       ((OPTION NULL) (ITER-000 *MODULE-NON-STRUCTURAL-OPTIONS*))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ OPTION (%%VALUE ITER-000))
        (CL:SETQ OLDVALUE (LOOKUP OLDPLIST OPTION))
        (CL:SETQ NEWVALUE (LOOKUP NEWPLIST OPTION))
        (CL:WHEN (CL:NOT (EQL? OLDVALUE NEWVALUE))
         (CL:IF (CL:NOT (CL:EQ NEWVALUE NULL))
          (CL:SETQ CHANGED-VALUES (CONS NEWVALUE CHANGED-VALUES))
          (CL:PROGN
           (CL:WHEN (CL:EQ NEWMODULE NULL)
            (CL:SETQ NEWMODULE (NEW-MODULE)))
           (CL:SETQ CHANGED-VALUES
            (CONS
             (READ-SLOT-VALUE NEWMODULE
              (LOOKUP-SLOT-FROM-OPTION-KEYWORD (PRIMARY-TYPE NEWMODULE)
               OPTION))
             CHANGED-VALUES))))
         (CL:SETQ CHANGED-VALUES (CONS OPTION CHANGED-VALUES)))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:WHEN (CL:NOT (CL:EQ CHANGED-VALUES NIL))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Updating module `" OLDMODULE "'" EOL)
       (INCORPORATE-MODULE-OPTIONS OLDMODULE CHANGED-VALUES)
       (CL:SETF (%MODULE.STRINGIFIED-OPTIONS OLDMODULE) NEWOPTIONS))))))
  :VOID)

;;; (DEFUN (IDENTICAL-MODULE-STRUCTURE? BOOLEAN) ...)

(CL:DEFUN IDENTICAL-MODULE-STRUCTURE? (OLDMODULE NEWMODULE NEWOPTIONS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NEWOPTIONS))
  #+MCL
  (CL:CHECK-TYPE NEWOPTIONS CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ NEWMODULE NULL))
    (CL:NOT
     (STRING-EQL? (%MODULE.MODULE-FULL-NAME OLDMODULE)
      (%MODULE.MODULE-FULL-NAME NEWMODULE))))
   (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL))
  (CL:LET* ((OLDOPTIONS (%MODULE.STRINGIFIED-OPTIONS OLDMODULE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OLDOPTIONS))
   (CL:SETQ NEWOPTIONS
    (CL:IF (CL:EQ NEWMODULE NULL) NEWOPTIONS
     (%MODULE.STRINGIFIED-OPTIONS NEWMODULE)))
   (CL:WHEN (CL:EQ NEWOPTIONS STELLA::NULL-STRING)
    (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL))
   (CL:WHEN (EQL-EXCEPT-IN-WHITESPACE? OLDOPTIONS NEWOPTIONS)
    (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:T))
   (CL:WHEN
    (CL:AND
     (CL:= (STRING-SEARCH OLDOPTIONS ":INCLUDES" 0) NULL-INTEGER)
     (CL:= (STRING-SEARCH NEWOPTIONS ":INCLUDES" 0) NULL-INTEGER))
    (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ NEWMODULE NULL))
     (EQUAL-CONS-TREES?
      (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES OLDMODULE))
      (%LIST.THE-CONS-LIST (%MODULE.PARENT-MODULES NEWMODULE))))
    (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
     (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
      (READ-S-EXPRESSION-FROM-STRING OLDOPTIONS))
     (CL:LET* ((OLDPLIST SELF-000))
      (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
       (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001)
        (READ-S-EXPRESSION-FROM-STRING NEWOPTIONS))
       (CL:LET* ((NEWPLIST SELF-001))
        (REMOVE-AT OLDPLIST KWD-MODULES-INCLUDES)
        (REMOVE-AT NEWPLIST KWD-MODULES-INCLUDES)
        (CL:LET*
         ((KEY NULL) (VALUE NULL)
          (ITER-000 (%PROPERTY-LIST.THE-PLIST OLDPLIST)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ KEY (%%VALUE ITER-000))
          (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
          (CL:WHEN
           (CL:NOT (MEMBER? *MODULE-NON-STRUCTURAL-OPTIONS* KEY))
           (CL:WHEN
            (CL:NOT (EQUAL-CONS-TREES? VALUE (LOOKUP NEWPLIST KEY)))
            (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL)))
          (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
        (CL:LET*
         ((KEY NULL) (VALUE NULL)
          (ITER-001 (%PROPERTY-LIST.THE-PLIST NEWPLIST)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ KEY (%%VALUE ITER-001))
          (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
          (CL:WHEN
           (CL:NOT (MEMBER? *MODULE-NON-STRUCTURAL-OPTIONS* KEY))
           (CL:WHEN
            (CL:NOT (EQUAL-CONS-TREES? VALUE (LOOKUP OLDPLIST KEY)))
            (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL)))
          (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
        (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:T))))))
   (CL:RETURN-FROM IDENTICAL-MODULE-STRUCTURE? CL:NIL)))

;;; (DEFUN (DEFINE-MODULE-FROM-STRINGIFIED-SOURCE MODULE) ...)

(CL:DEFUN DEFINE-MODULE-FROM-STRINGIFIED-SOURCE (NAME STRINGIFIEDOPTIONS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME STRINGIFIEDOPTIONS))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDOPTIONS CL:SIMPLE-STRING)
  (CL:RETURN-FROM DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
   (DEFINE-MODULE NAME
    (READ-S-EXPRESSION-FROM-STRING STRINGIFIEDOPTIONS))))

;;; (DEFUN (YIELD-DEFINE-MODULE CONS) ...)

(CL:DEFUN YIELD-DEFINE-MODULE (MODULE)
  (CL:RETURN-FROM YIELD-DEFINE-MODULE
   (LIST* SYM-MODULES-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
    (WRAP-STRING (%MODULE.MODULE-FULL-NAME MODULE))
    (CONS
     (YIELD-STRING-CONSTANT-TREE (%MODULE.STRINGIFIED-OPTIONS MODULE))
     NIL))))

;;; (DEFUN DEFMODULE ...)

(CL:DEFUN %DEFMODULE (NAME OPTIONS)
  "Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
	
`name' can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.

The above discussion of `:includes' and `:uses' semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module 'A' is inherited directly or
indirectly via `:includes' specification(s) by a submodule 'B', then all
definitions and facts asserted in 'A' are visible in 'B'. This is not the
cases for `:uses'; the `:uses' options does not impact inheritance of
propositions at all.

The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for
`name' become the new module's parents. If no `:uses' option was
supplied, the new module will use the `STELLA' module by default,
otherwise, it will use the set of specified modules.

If `:case-sensitive?' is supplied as TRUE, symbols in the module
will be interned case-sensitively, otherwise (the default), they
will be converted to uppercase before they get interned.  That
means that any reference from inside a case-sensitive module to a
non-case-sensitive module will have to use uppercase names for
symbols in the non-case-sensitive module.  The standard system
modules are all NOT case sensitive.

Modules can shadow definitions of functions and classes inherited
from parents or used modules. Shadowing is done automatically,
but generates a warning unless the shadowed type or function name
is listed in the `:shadow' option of the module definition .

Examples:
	 
  (defmodule \"PL-KERNEL/PL-USER\"
    :uses (\"LOGIC\" \"STELLA\")
    :package \"PL-USER\")

  (defmodule PL-USER/GENEALOGY)
	
The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords `:lisp-package', `:java-package', and `:cpp-package' specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the `STELLA' package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions `synchronized'.
"
  (CL:LET* ((MODULENAME (COERCE-TO-MODULE-NAME NAME CL:T)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME))
   (CL:WHEN (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
    (DEFINE-MODULE MODULENAME OPTIONS)))
  :VOID)

(CL:DEFUN DEFMODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFMODULE (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))
  :VOID)

(CL:DEFMACRO DEFMODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
	
`name' can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.

The above discussion of `:includes' and `:uses' semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module 'A' is inherited directly or
indirectly via `:includes' specification(s) by a submodule 'B', then all
definitions and facts asserted in 'A' are visible in 'B'. This is not the
cases for `:uses'; the `:uses' options does not impact inheritance of
propositions at all.

The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for
`name' become the new module's parents. If no `:uses' option was
supplied, the new module will use the `STELLA' module by default,
otherwise, it will use the set of specified modules.

If `:case-sensitive?' is supplied as TRUE, symbols in the module
will be interned case-sensitively, otherwise (the default), they
will be converted to uppercase before they get interned.  That
means that any reference from inside a case-sensitive module to a
non-case-sensitive module will have to use uppercase names for
symbols in the non-case-sensitive module.  The standard system
modules are all NOT case sensitive.

Modules can shadow definitions of functions and classes inherited
from parents or used modules. Shadowing is done automatically,
but generates a warning unless the shadowed type or function name
is listed in the `:shadow' option of the module definition .

Examples:
	 
  (defmodule \"PL-KERNEL/PL-USER\"
    :uses (\"LOGIC\" \"STELLA\")
    :package \"PL-USER\")

  (defmodule PL-USER/GENEALOGY)
	
The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords `:lisp-package', `:java-package', and `:cpp-package' specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the `STELLA' package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions `synchronized'.
"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DEFMODULE|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFMODULE)))

;;; (DEFUN (IN-MODULE MODULE) ...)

(CL:DEFUN %IN-MODULE (NAME)
  "Change the current module to the module named `name'."
  (CL:LET*
   ((MODULENAME (COERCE-TO-MODULE-NAME NAME CL:T))
    (MODULE
     (CL:IF (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
      (GET-STELLA-MODULE MODULENAME CL:NIL) NULL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME))
   (CL:COND
    ((CL:NOT (CL:EQ MODULE NULL)) (CL:SETQ *MODULE* MODULE)
     (CL:SETQ *CONTEXT* MODULE))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Illegal or undefined module: `" NAME "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM %IN-MODULE *MODULE*)))

(CL:DEFMACRO IN-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Change the current module to the module named `name'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/IN-MODULE|)) (CL:MACRO-FUNCTION (CL:QUOTE IN-MODULE)))

;;; (DEFUN (CREATE-WORLD WORLD) ...)

(CL:DEFUN CREATE-WORLD (PARENTCONTEXT NAME)
  "Create a new world below the world or module 'parentContext'.
Optionally, specify a name."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((WORLD (NEW-WORLD)))
   (CL:WHEN (CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
    (SET-DYNAMIC-SLOT-VALUE (%WORLD.DYNAMIC-SLOTS WORLD)
     SYM-MODULES-STELLA-WORLD-NAME (WRAP-STRING NAME)
     NULL-STRING-WRAPPER)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SIBLING NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS PARENTCONTEXT))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SIBLING (%%VALUE ITER-000))
       (CL:WHEN (STRING-EQL? (CONTEXT-NAME SIBLING) NAME)
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN FOUND?-000
      (CL:WARN
       "Can't create a world named `~A' because a sibling already has that name."
       NAME)
      (CL:RETURN-FROM CREATE-WORLD NULL))))
   (CL:SETF (%WORLD.PARENT-CONTEXT WORLD) PARENTCONTEXT)
   (INSERT (%CONTEXT.CHILD-CONTEXTS PARENTCONTEXT) WORLD)
   (CL:SETF (%WORLD.BASE-MODULE WORLD)
    (%CONTEXT.BASE-MODULE PARENTCONTEXT))
   (FINALIZE-WORLD WORLD) (CL:RETURN-FROM CREATE-WORLD WORLD)))

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((WORLD WORLD))
  "Return FALSE always, since worlds never have more than one parent."
  (CL:RETURN-FROM MULTIPLE-PARENTS? CL:NIL))

;;; (DEFUN (PUSH-WORLD WORLD) ...)

(CL:DEFUN PUSH-WORLD ()
  "Spawn a new world that is a child of the current context,
and change the current context to the new world."
  (CL:RETURN-FROM PUSH-WORLD
   (CL:SETQ *CONTEXT* (CREATE-WORLD *CONTEXT* STELLA::NULL-STRING))))

;;; (DEFUN (POP-WORLD CONTEXT) ...)

(CL:DEFUN POP-WORLD ()
  "Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world."
  (CL:WHEN (CL:NOT (CL:EQ *CONTEXT* *MODULE*))
   (CL:LET* ((WORLD *CONTEXT*))
    (CL:SETQ *CONTEXT* (%WORLD.PARENT-CONTEXT WORLD))
    (DESTROY-WORLD WORLD)))
  (CL:RETURN-FROM POP-WORLD *CONTEXT*))

;;; (DEFUN (ALL-SUBCONTEXTS (ALL-PURPOSE-ITERATOR OF CONTEXT)) ...)

(CL:DEFUN ALL-SUBCONTEXTS (CONTEXT TRAVERSAL)
  "Return an iterator that generates all subcontexts of
'self' (not including 'self') in the order specified by 'traversal' (one
of :preorder, :inorder, :postorder or :topdown)."
  (CL:LET*
   ((CONTEXTSITERATOR (NEW-ALL-PURPOSE-ITERATOR)) (SUBCONTEXTS NIL))
   (CL:LET*
    ((CHILD NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS CONTEXT)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS CHILD NIL))
       (CL:IF (CL:EQ SUBCONTEXTS NIL) (CL:SETQ SUBCONTEXTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST SUBCONTEXTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CHILD NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:EQ TRAVERSAL KWD-MODULES-POSTORDER)
    (CL:SETQ SUBCONTEXTS (REVERSE SUBCONTEXTS)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST CONTEXTSITERATOR)
    SUBCONTEXTS)
   (CL:IF (CL:EQ TRAVERSAL KWD-MODULES-TOPDOWN)
    (CL:PROGN
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT CONTEXTSITERATOR)
      CONTEXT)
     (CL:SETF
      (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE CONTEXTSITERATOR)
      (CL:FUNCTION ALL-TOPDOWN-SUBCONTEXTS-NEXT?)))
    (CL:PROGN
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT CONTEXTSITERATOR)
      TRAVERSAL)
     (CL:SETF
      (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE CONTEXTSITERATOR)
      (CL:FUNCTION ALL-SUBCONTEXTS-NEXT?))))
   (CL:RETURN-FROM ALL-SUBCONTEXTS CONTEXTSITERATOR)))

;;; (DEFUN (ALL-SUBCONTEXTS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SUBCONTEXTS-NEXT? (SELF)
  (CL:LET*
   ((TRAVERSAL (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT SELF))
    (REMAININGCONTEXTS (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF))
    (THISCONTEXT NULL) (SUBCONTEXTS NIL)
    (BEENTHERE (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-OBJECT SELF)))
   (CL:WHEN (CL:EQ REMAININGCONTEXTS NIL)
    (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) NULL)
    (CL:RETURN-FROM ALL-SUBCONTEXTS-NEXT? CL:NIL))
   (CL:WHEN (CL:EQ BEENTHERE NULL) (CL:SETQ BEENTHERE (NEW-HASH-SET))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-OBJECT SELF)
     BEENTHERE)
    (CL:LET* ((CTXT NULL) (ITER-000 REMAININGCONTEXTS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ CTXT (%%VALUE ITER-000)) (INSERT BEENTHERE CTXT)
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:SETQ THISCONTEXT (%%VALUE REMAININGCONTEXTS))
   (CL:SETQ REMAININGCONTEXTS (%%REST REMAININGCONTEXTS))
   (CL:LET*
    ((CHILD NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS THISCONTEXT)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-001))
     (CL:WHEN (CL:NOT (MEMBER? BEENTHERE CHILD))
      (INSERT BEENTHERE CHILD)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS CHILD NIL))
        (CL:IF (CL:EQ SUBCONTEXTS NIL)
         (CL:SETQ SUBCONTEXTS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SUBCONTEXTS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CHILD NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:IF (CL:EQ SUBCONTEXTS NIL)
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     REMAININGCONTEXTS)
    (CL:COND
     ((CL:EQ TRAVERSAL KWD-MODULES-PREORDER)
      (CL:SETF (%%REST (LAST-CONS SUBCONTEXTS)) REMAININGCONTEXTS)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
       SUBCONTEXTS))
     ((CL:EQ TRAVERSAL KWD-MODULES-POSTORDER)
      (CL:SETQ SUBCONTEXTS (REVERSE SUBCONTEXTS))
      (CL:SETF (%%REST (LAST-CONS SUBCONTEXTS)) REMAININGCONTEXTS)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
       SUBCONTEXTS))
     ((CL:EQ TRAVERSAL KWD-MODULES-INORDER)
      (CL:COND
       ((CL:EQ REMAININGCONTEXTS NIL)
        (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
         SUBCONTEXTS))
       (CL:T
        (CL:SETF (%%REST (LAST-CONS REMAININGCONTEXTS)) SUBCONTEXTS)
        (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
         REMAININGCONTEXTS))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TRAVERSAL "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) THISCONTEXT)
   (CL:RETURN-FROM ALL-SUBCONTEXTS-NEXT? CL:T)))

;;; (DEFUN (ALL-TOPDOWN-SUBCONTEXTS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-TOPDOWN-SUBCONTEXTS-NEXT? (SELF)
  (CL:LET*
   ((REMAININGCONTEXTS (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF))
    (THISCONTEXT NULL) (SUBCONTEXTS NIL)
    (BEENTHERE (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-OBJECT SELF)))
   (CL:WHEN (CL:EQ REMAININGCONTEXTS NIL)
    (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) NULL)
    (CL:RETURN-FROM ALL-TOPDOWN-SUBCONTEXTS-NEXT? CL:NIL))
   (CL:WHEN (CL:EQ BEENTHERE NULL) (CL:SETQ BEENTHERE (NEW-HASH-TABLE))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-OBJECT SELF)
     BEENTHERE)
    (CL:LET*
     ((SUB NULL)
      (ITER-000
       (ALL-SUBCONTEXTS (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT SELF)
        KWD-MODULES-PREORDER)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ SUB (%ALL-PURPOSE-ITERATOR.VALUE ITER-000))
      (INSERT-AT BEENTHERE SUB FALSE-WRAPPER))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ REMAININGCONTEXTS NIL)) DO
    (CL:SETQ THISCONTEXT (%%VALUE REMAININGCONTEXTS))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((P NULL) (ITER-001 (PARENT-CONTEXTS THISCONTEXT)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO
       (CL:SETQ P (%ITERATOR.VALUE ITER-001))
       (CL:WHEN (EQL? (LOOKUP BEENTHERE P) FALSE-WRAPPER)
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
     (CL:WHEN ALWAYS?-000 (CL:RETURN)))
    (CL:SETQ REMAININGCONTEXTS (%%REST REMAININGCONTEXTS)))
   (CL:IF (CL:EQ REMAININGCONTEXTS NIL)
    (CL:PROGN (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) NULL)
     (CL:RETURN-FROM ALL-TOPDOWN-SUBCONTEXTS-NEXT? CL:NIL))
    (CL:SETQ REMAININGCONTEXTS (%%REST REMAININGCONTEXTS)))
   (INSERT-AT BEENTHERE THISCONTEXT TRUE-WRAPPER)
   (CL:LET*
    ((CHILD NULL)
     (ITER-002
      (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS THISCONTEXT)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-002))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS CHILD NIL))
       (CL:IF (CL:EQ SUBCONTEXTS NIL) (CL:SETQ SUBCONTEXTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST SUBCONTEXTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CHILD NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:COND
    ((CL:EQ REMAININGCONTEXTS NIL)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
      SUBCONTEXTS))
    ((CL:EQ SUBCONTEXTS NIL)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
      REMAININGCONTEXTS))
    (CL:T (CL:SETF (%%REST (LAST-CONS REMAININGCONTEXTS)) SUBCONTEXTS)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
      REMAININGCONTEXTS)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) THISCONTEXT)
   (CL:RETURN-FROM ALL-TOPDOWN-SUBCONTEXTS-NEXT? CL:T)))

;;; (DEFUN (ALL-CONTEXTS (ITERATOR OF CONTEXT)) ...)

(CL:DEFUN ALL-CONTEXTS ()
  "Return an iterator that generates all contexts."
  (CL:LET*
   ((ITERATOR (ALL-SUBCONTEXTS *ROOT-MODULE* KWD-MODULES-PREORDER)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    (CONS *ROOT-MODULE* NIL))
   (CL:RETURN-FROM ALL-CONTEXTS ITERATOR)))

;;; (DEFUN (FILTER-MODULE? BOOLEAN) ...)

(CL:DEFUN FILTER-MODULE? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-MODULE?
   (CL:EQ (PRIMARY-TYPE SELF) SGT-MODULES-STELLA-MODULE)))

;;; (DEFUN (ALL-MODULES (ITERATOR OF MODULE)) ...)

(CL:DEFUN ALL-MODULES ()
  "Return an iterator that generates all modules."
  (CL:LET*
   ((CONTEXTSITERATOR (ALL-CONTEXTS))
    (ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.FIRST-ITERATION? ITERATOR) CL:T)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ITERATOR)
    CONTEXTSITERATOR)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-MODULE?))
   (CL:RETURN-FROM ALL-MODULES ITERATOR)))

;;; (DEFUN (LIST-MODULES (CONS OF MODULE)) ...)

(CL:DEFUN %LIST-MODULES (KB-ONLY?)
  "Returns a cons of all modules defined in PowerLoom.  If `kb-only?'
is `true', then any modules which are code only or just namespaces are not returned."
  (CL:IF KB-ONLY?
   (CL:LET* ((VALUE-000 NIL))
    (CL:LET* ((M NULL) (ITER-000 (ALL-MODULES)) (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ M (%ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (CL:AND
        (CL:NOT
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS M)
           SYM-MODULES-STELLA-CODE-ONLY? FALSE-WRAPPER)))
        (CL:NOT
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS M)
           SYM-MODULES-STELLA-NAMESPACE? FALSE-WRAPPER))))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS M NIL))
         (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS M NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    (CL:LET* ((VALUE-001 VALUE-000))
     (CL:RETURN-FROM %LIST-MODULES VALUE-001)))
   (CL:LET* ((VALUE-002 NIL))
    (CL:LET* ((M NULL) (ITER-001 (ALL-MODULES)) (COLLECT-001 NULL))
     (CL:LOOP WHILE (NEXT? ITER-001) DO
      (CL:SETQ M (%ITERATOR.VALUE ITER-001))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS M NIL))
        (CL:IF (CL:EQ VALUE-002 NIL) (CL:SETQ VALUE-002 COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST VALUE-002 COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS M NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
    (CL:LET* ((VALUE-003 VALUE-002))
     (CL:RETURN-FROM %LIST-MODULES VALUE-003)))))

(CL:DEFUN LIST-MODULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM LIST-MODULES-EVALUATOR-WRAPPER
   (%LIST-MODULES (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO LIST-MODULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Returns a cons of all modules defined in PowerLoom.  If `kb-only?'
is `true', then any modules which are code only or just namespaces are not returned."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LIST-MODULES|)) (CL:MACRO-FUNCTION (CL:QUOTE LIST-MODULES)))

;;; (DEFUN (ALL-INCLUDED-MODULES (ITERATOR OF MODULE)) ...)

(CL:DEFUN ALL-INCLUDED-MODULES (SELF)
  "Generate a sequence of all modules included
by 'self', inclusive, starting from the highest ancestor and working
down to 'self' (which is last)."
  (CL:LET* ((COPY (COPY-CONS-LIST (%MODULE.ALL-SUPER-CONTEXTS SELF))))
   (CL:SETQ COPY (CONS SELF COPY))
   (CL:RETURN-FROM ALL-INCLUDED-MODULES
    (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (REVERSE COPY)))))

;;; (DEFUN (VISIBLE-MODULES (CONS OF MODULE)) ...)

(CL:DEFUN VISIBLE-MODULES (FROM)
  "Return a list of all modules visible from module `from' (or `*module*'
if `from' is NULL.  The generated modules are generated from most to
least-specific and will start with the module `from'."
  (CL:WHEN (CL:EQ FROM NULL) (CL:SETQ FROM *MODULE*))
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-MODULES-STELLA-F-VISIBLE-MODULES-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-MODULES-STELLA-F-VISIBLE-MODULES-MEMO-TABLE-000
      "(:MAX-VALUES 50 :TIMESTAMPS (:MODULE-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-MODULES-STELLA-F-VISIBLE-MODULES-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 FROM MEMOIZED-NULL-VALUE
      NULL NULL -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000 (HELP-MEMOIZE-VISIBLE-MODULES FROM))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (CL:RETURN-FROM VISIBLE-MODULES VALUE-000))))

;;; (DEFUN (HELP-MEMOIZE-VISIBLE-MODULES (CONS OF MODULE)) ...)

(CL:DEFUN HELP-MEMOIZE-VISIBLE-MODULES (FROM)
  (CL:LET* ((VISIBLEMODULES NIL))
   (CL:SETQ VISIBLEMODULES (CONS FROM VISIBLEMODULES))
   (CL:LET* ((SUPER NULL) (ITER-000 (%MODULE.ALL-SUPER-CONTEXTS FROM)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:SETQ VISIBLEMODULES (CONS SUPER VISIBLEMODULES))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((USEE NULL) (ITER-001 (%LIST.THE-CONS-LIST (%MODULE.USES FROM))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ USEE (%%VALUE ITER-001))
     (CL:WHEN (CL:NOT (MEMB? VISIBLEMODULES USEE))
      (CL:SETQ VISIBLEMODULES (CONS USEE VISIBLEMODULES)))
     (CL:LET*
      ((USEESUPER NULL) (ITER-002 (%MODULE.ALL-SUPER-CONTEXTS USEE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ USEESUPER (%%VALUE ITER-002))
       (CL:WHEN (CL:NOT (MEMB? VISIBLEMODULES USEESUPER))
        (CL:SETQ VISIBLEMODULES (CONS USEESUPER VISIBLEMODULES)))
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:RETURN-FROM HELP-MEMOIZE-VISIBLE-MODULES
    (REVERSE VISIBLEMODULES))))

;;; (DEFUN (CARDINAL-MODULE? BOOLEAN) ...)

(CL:DEFUN CARDINAL-MODULE? (SELF)
  (CL:RETURN-FROM CARDINAL-MODULE?
   (CL:EQ (%MODULE.CARDINAL-MODULE SELF) SELF)))

;;; (DEFUN (VISIBLE-FROM? BOOLEAN) ...)

(CL:DEFUN VISIBLE-FROM? (VIEWEDCONTEXT FROMCONTEXT)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (CL:EQ VIEWEDCONTEXT FROMCONTEXT)
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:IF
     (MEMB? (%CONTEXT.ALL-SUPER-CONTEXTS FROMCONTEXT) VIEWEDCONTEXT)
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((USESMODULE NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST
          (CL:IF (ISA? FROMCONTEXT SGT-MODULES-STELLA-MODULE)
           (%MODULE.USES FROMCONTEXT)
           (%MODULE.USES (%CONTEXT.BASE-MODULE FROMCONTEXT))))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ USESMODULE (%%VALUE ITER-000))
        (CL:WHEN
         (CL:OR (CL:EQ VIEWEDCONTEXT USESMODULE)
          (MEMB? (%MODULE.ALL-SUPER-CONTEXTS USESMODULE)
           VIEWEDCONTEXT))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM VISIBLE-FROM? VALUE-000))))

;;; (DEFUN CLEAR-ONE-CONTEXT ...)

(CL:DEFUN CLEAR-ONE-CONTEXT (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-MODULES-STELLA-MODULE)
    (CL:PROGN
     (CL:WHEN (CL:NOT (CLEARABLE? SELF))
      (CL:WARN "Module `~A' cannot be cleared!"
       (%MODULE.MODULE-FULL-NAME SELF))
      (CL:RETURN-FROM CLEAR-ONE-CONTEXT))
     (RUN-HOOKS *CLEAR-MODULE-HOOKS* SELF)
     (CL:LET* ((FUNCTION NULL) (ITER-000 (ALL-FUNCTIONS SELF CL:T)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ FUNCTION (%ITERATOR.VALUE ITER-000))
       (DESTROY-FUNCTION FUNCTION)))
     (CL:LET* ((VARIABLE NULL) (ITER-001 (ALL-VARIABLES SELF CL:T)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO
       (CL:SETQ VARIABLE (%ITERATOR.VALUE ITER-001))
       (DESTROY-GLOBAL-VARIABLE VARIABLE)))
     (CL:LET* ((CLASS NULL) (ITER-002 (ALL-CLASSES SELF CL:T)))
      (CL:LOOP WHILE (NEXT? ITER-002) DO
       (CL:SETQ CLASS (%ITERATOR.VALUE ITER-002))
       (DESTROY-CLASS CLASS)))
     (CL:LET* ((SURROGATE NULL) (ITER-003 (ALL-SURROGATES SELF CL:T)))
      (CL:LOOP WHILE (NEXT? ITER-003) DO
       (CL:SETQ SURROGATE (%ITERATOR.VALUE ITER-003))
       (CL:IF (PROTECT-SURROGATES? SELF)
        (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL)
        (UNINTERN-SURROGATE SURROGATE))))
     (CL:WHEN (CL:NOT (PROTECT-SURROGATES? SELF))
      (CL:LET* ((SYMBOL NULL) (ITER-004 (ALL-SYMBOLS SELF CL:T)))
       (CL:LOOP WHILE (NEXT? ITER-004) DO
        (CL:SETQ SYMBOL (%ITERATOR.VALUE ITER-004))
        (UNINTERN-SYMBOL SYMBOL))))
     (CL:LET* ((*MODULE* SELF)) (CL:DECLARE (CL:SPECIAL *MODULE*))
      (CL:LET* ((IT (ALLOCATE-ITERATOR (SHADOWED-SURROGATES SELF))))
       (CL:LOOP WHILE (NEXT? IT) DO
        (VALUE-SETTER IT
         (SHADOW-SURROGATE
          (%SURROGATE.SYMBOL-NAME (%LIST-ITERATOR.VALUE IT)))))))
     (BUMP-MEMOIZATION-TIMESTAMP KWD-MODULES-MODULE-UPDATE)))
   (CL:T))
  :VOID)

;;; (DEFUN HELP-CLEAR-CONTEXT ...)

(CL:DEFUN HELP-CLEAR-CONTEXT (SELF)
  (CL:LET*
   ((CHILD NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (%CONTEXT.CHILD-CONTEXTS SELF))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-000)) (HELP-CLEAR-CONTEXT CHILD)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CLEAR-ONE-CONTEXT SELF)
  :VOID)

;;; (DEFUN CLEAR-CONTEXT ...)

(CL:DEFUN CLEAR-CONTEXT (SELF)
  "Destroy all objects belonging to 'self' or any of its subcontexts."
  (HELP-CLEAR-CONTEXT SELF)
  (FINALIZE-CLASSES-AND-SLOTS)
  :VOID)

;;; (DEFUN CALL-CLEAR-MODULE ...)

(CL:DEFUN CALL-CLEAR-MODULE (NAME)
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (CL:LET*
   ((ARGLIST NAME) (MODULE (COERCE-TO-MODULE (%%VALUE ARGLIST) CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
    (CL:WHEN
     (CL:OR (CL:NOT (CL:EQ ARGLIST NIL))
      (Y-OR-N?
       (CONCATENATE "Really clear module "
        (CONCATENATE (%MODULE.MODULE-FULL-NAME MODULE) "? "))))
     (CLEAR-CONTEXT MODULE))))
  :VOID)

(CL:DEFUN CALL-CLEAR-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CALL-CLEAR-MODULE ARGUMENTS)
  :VOID)

;;; (DEFUN CLEAR-MODULE ...)

(CL:DEFUN %CLEAR-MODULE (NAME)
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (CL:IF (CL:= (LENGTH NAME) 0) (CALL-CLEAR-MODULE NIL)
   (CALL-CLEAR-MODULE (CONS-LIST (%%VALUE NAME))))
  :VOID)

(CL:DEFUN CLEAR-MODULE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLEAR-MODULE ARGUMENTS)
  :VOID)

(CL:DEFMACRO CLEAR-MODULE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/CLEAR-MODULE|)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-MODULE)))

(CL:DEFUN HELP-STARTUP-MODULES1 ()
  (CL:PROGN
   (CL:SETQ KWD-MODULES-CLEAR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR" NULL 2))
   (CL:SETQ SGT-MODULES-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
   (CL:SETQ KWD-MODULES-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 2))
   (CL:SETQ KWD-MODULES-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 2))
   (CL:SETQ KWD-MODULES-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 2))
   (CL:SETQ SGT-MODULES-STELLA-F-GET-STELLA-MODULE-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-GET-STELLA-MODULE-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SYM-MODULES-STELLA-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 0))
   (CL:SETQ SGT-MODULES-STELLA-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-MODULES-STELLA-SHADOWED-SURROGATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOWED-SURROGATES" NULL 0))
   (CL:SETQ KWD-MODULES-MODULE-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-UPDATE" NULL 2))
   (CL:SETQ SGT-MODULES-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SYM-MODULES-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SGT-MODULES-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ KWD-MODULES-INCLUDES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDES" NULL 2))
   (CL:SETQ KWD-MODULES-USES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USES" NULL 2))
   (CL:SETQ KWD-MODULES-SHADOW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOW" NULL 2))
   (CL:SETQ KWD-MODULES-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-MODULES-CASE-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?" NULL 2))
   (CL:SETQ KWD-MODULES-API?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "API?" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-API?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "API?" NULL 0))
   (CL:SETQ KWD-MODULES-LISP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-PACKAGE" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-MODULE-LISP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-LISP-PACKAGE" NULL 0))
   (CL:SETQ KWD-MODULES-CPP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-PACKAGE" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-MODULE-CPP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-CPP-PACKAGE" NULL 0))
   (CL:SETQ KWD-MODULES-JAVA-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-PACKAGE" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-JAVA-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-PACKAGE" NULL 0))
   (CL:SETQ KWD-MODULES-JAVA-CATCHALL-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-CATCHALL-CLASS" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-JAVA-FLOTSAM-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-FLOTSAM-CLASS" NULL 0))
   (CL:SETQ KWD-MODULES-NICKNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NICKNAME" NULL 2))
   (CL:SETQ KWD-MODULES-CLEARABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-CLEARABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?" NULL 0))
   (CL:SETQ KWD-MODULES-PROTECT-SURROGATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTECT-SURROGATES?" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-PROTECT-SURROGATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTECT-SURROGATES?" NULL 0))
   (CL:SETQ KWD-MODULES-CODE-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-ONLY?" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-CODE-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-ONLY?" NULL 0))
   (CL:SETQ KWD-MODULES-NAMESPACE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMESPACE?" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-NAMESPACE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMESPACE?" NULL 0))
   (CL:SETQ KWD-MODULES-REQUIRES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRES" NULL 2))
   (CL:SETQ KWD-MODULES-DESTROY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTROY" NULL 2))
   (CL:SETQ KWD-MODULES-PRESERVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRESERVE" NULL 2))
   (CL:SETQ KWD-MODULES-PREORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREORDER" NULL 2))
   (CL:SETQ SGT-MODULES-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" NULL 1))
   (CL:SETQ KWD-MODULES-TOPDOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOPDOWN" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DEFINE-MODULE-FROM-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ SYM-MODULES-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
   (CL:SETQ KWD-MODULES-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-MODULES-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-MODULE" NULL 0))
   (CL:SETQ SYM-MODULES-STELLA-WORLD-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD-NAME" NULL 0))
   (CL:SETQ KWD-MODULES-POSTORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSTORDER" NULL 2))
   (CL:SETQ KWD-MODULES-INORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INORDER" NULL 2))
   (CL:SETQ SYM-MODULES-STELLA-LIST-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-MODULES" NULL 0))
   (CL:SETQ SGT-MODULES-STELLA-F-VISIBLE-MODULES-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-VISIBLE-MODULES-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SYM-MODULES-STELLA-CLEAR-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-MODULE" NULL 0))
   (CL:SETQ SYM-MODULES-STELLA-STARTUP-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-MODULES" NULL 0))
   (CL:SETQ SYM-MODULES-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-MODULES2 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF CONTEXT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PARENT-CONTEXTS)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF MODULE)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION PARENT-CONTEXTS)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PARENT-CONTEXTS (ITERATOR OF CONTEXT)) ((SELF WORLD)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION PARENT-CONTEXTS)) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME"
    "(DEFUN (COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME CONTEXT INTEGER) ((PATHNAME STRING) (MODULE? BOOLEAN) (SYMBOLNAME? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-CONTEXT-OR-MODULE-FROM-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPONENT-MATCH?"
    "(DEFUN (COMPONENT-MATCH? BOOLEAN) ((COMPONENT STRING) (STRING STRING) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION COMPONENT-MATCH?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MODULE-AND-BARE-NAME"
    "(DEFUN (COMPUTE-MODULE-AND-BARE-NAME MODULE STRING) ((NAME STRING)) :DOCUMENTATION \"Compute the module indicated by the STELLA name
`name' and return it.  Return the bare symbol name as the second
value.  `name' does not necessarily have to be qualified in which
case the current module is returned.  `name' is assumed to be the
printed representation of a STELLA symbol, surrogate or keyword.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COMPUTE-MODULE-AND-BARE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-STELLA-CONTEXT-OR-MODULE"
    "(DEFUN (HELP-GET-STELLA-CONTEXT-OR-MODULE CONTEXT) ((PATHNAME STRING) (MODULE? BOOLEAN)))"
    (CL:FUNCTION HELP-GET-STELLA-CONTEXT-OR-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-STELLA-CONTEXT"
    "(DEFUN (GET-STELLA-CONTEXT CONTEXT) ((PATHNAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the context located at `pathName', or `null'
if no such context exists.  If `error?' is `true', throw an exception
if no context is found, otherwise silently return `null'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-STELLA-CONTEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-STELLA-MODULE"
    "(DEFUN (GET-STELLA-MODULE MODULE) ((PATHNAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found.\" :PUBLIC? TRUE)" (CL:FUNCTION GET-STELLA-MODULE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-STELLA-MODULE"
    "(DEFUN (HELP-GET-STELLA-MODULE MODULE) ((PATHNAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found.\" :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-GET-STELLA-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-MODULE-NAME"
    "(DEFUN (COERCE-TO-MODULE-NAME STRING) ((NAMESPEC NAME) (WARN? BOOLEAN)))"
    (CL:FUNCTION COERCE-TO-MODULE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-MODULE"
    "(DEFUN (COERCE-TO-MODULE MODULE) ((OBJECT OBJECT) (WARN? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-OR-CREATE-MODULE"
    "(DEFUN (FIND-OR-CREATE-MODULE MODULE) ((PATHNAME STRING)) :DOCUMENTATION \"Return a module located at `pathname' if one exists,
  otherwise create one\")" (CL:FUNCTION FIND-OR-CREATE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CHANGE-CURRENT-MODULE"
    "(DEFUN (CHANGE-CURRENT-MODULE MODULE) ((MODULE MODULE)))"
    (CL:FUNCTION CHANGE-CURRENT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CHANGE-CURRENT-CONTEXT"
    "(DEFUN (CHANGE-CURRENT-CONTEXT CONTEXT) ((CONTEXT CONTEXT)))"
    (CL:FUNCTION CHANGE-CURRENT-CONTEXT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CHANGE-CONTEXT CONTEXT) ((CONTEXT CONTEXT)) :DOCUMENTATION \"Change the current context to be the context
'context'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CHANGE-CONTEXT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CHANGE-CONTEXT CONTEXT) ((CONTEXTNAME STRING)) :DOCUMENTATION \"Change the current context to be the context named
'contextName'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CHANGE-CONTEXT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CHANGE-MODULE MODULE) ((MODULE MODULE)) :DOCUMENTATION \"Change the current module to be the module
'module'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CHANGE-MODULE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CHANGE-MODULE MODULE) ((MODULENAME STRING)) :DOCUMENTATION \"Change the current module to be the module named
'moduleName'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CHANGE-MODULE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((SELF CONTEXT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION MULTIPLE-PARENTS?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((MODULE MODULE)) :DOCUMENTATION \"Return TRUE if 'module' has more than one parent.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION MULTIPLE-PARENTS?)) NULL)
   (DEFINE-FUNCTION-OBJECT "NORMALIZE-PARENT-MODULES"
    "(DEFUN NORMALIZE-PARENT-MODULES ((SELF MODULE)))"
    (CL:FUNCTION NORMALIZE-PARENT-MODULES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INHERIT-SUPERCONTEXTS ((CONTEXT CONTEXT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION INHERIT-SUPERCONTEXTS)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INHERIT-SUPERCONTEXTS ((WORLD WORLD)))"
    (WRAP-METHOD-CODE (CL:FUNCTION INHERIT-SUPERCONTEXTS)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INHERIT-SUPERCONTEXTS ((MODULE MODULE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION INHERIT-SUPERCONTEXTS)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNINHERIT-SUPERCONTEXTS ((CONTEXT CONTEXT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION UNINHERIT-SUPERCONTEXTS)) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-USED-MODULES"
    "(DEFUN INHERIT-USED-MODULES ((MODULE MODULE)))"
    (CL:FUNCTION INHERIT-USED-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNINHERIT-USED-MODULES"
    "(DEFUN UNINHERIT-USED-MODULES ((MODULE MODULE)))"
    (CL:FUNCTION UNINHERIT-USED-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-MODULE"
    "(DEFUN FINALIZE-MODULE ((SELF MODULE)))"
    (CL:FUNCTION FINALIZE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-WORLD"
    "(DEFUN FINALIZE-WORLD ((SELF WORLD)))"
    (CL:FUNCTION FINALIZE-WORLD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNFINALIZE-MODULE ((SELF MODULE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION UNFINALIZE-MODULE)) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD UNFINALIZE-WORLD ((SELF WORLD)))"
    (WRAP-METHOD-CODE (CL:FUNCTION UNFINALIZE-WORLD)) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-MODULE"
    "(DEFUN DESTROY-MODULE ((SELF MODULE)) :DOCUMENTATION \"Destroy the module 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DESTROY-MODULE"
    "(DEFUN HELP-DESTROY-MODULE ((SELF MODULE)))"
    (CL:FUNCTION HELP-DESTROY-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-WORLD"
    "(DEFUN DESTROY-WORLD ((SELF WORLD)) :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-WORLD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CONTEXT ((SELF MODULE)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESTROY-CONTEXT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CONTEXT ((SELF WORLD)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESTROY-CONTEXT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CONTEXT ((SELF STRING)) :DOCUMENTATION \"Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESTROY-CONTEXT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CONTEXT ((SELF CONTEXT)) :PUBLIC? TRUE :DOCUMENTATION \"Make the translator happy.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION DESTROY-CONTEXT)) NULL)
   (DEFINE-FUNCTION-OBJECT "LINK-TO-PARENT-MODULE"
    "(DEFUN LINK-TO-PARENT-MODULE ((SELF MODULE) (PARENT MODULE) (INSERT-FIRST? BOOLEAN)))"
    (CL:FUNCTION LINK-TO-PARENT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-MODULE-NAME"
    "(DEFUN INCORPORATE-MODULE-NAME ((MODULE MODULE) (NAME STRING)))"
    (CL:FUNCTION INCORPORATE-MODULE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-INCLUDES-MODULES"
    "(DEFUN INCORPORATE-INCLUDES-MODULES ((MODULE MODULE) (INCLUDEES OBJECT)))"
    (CL:FUNCTION INCORPORATE-INCLUDES-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-USES-MODULES"
    "(DEFUN INCORPORATE-USES-MODULES ((MODULE MODULE) (USEES OBJECT)))"
    (CL:FUNCTION INCORPORATE-USES-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-OPTION?"
    "(DEFUN (TRUE-OPTION? BOOLEAN) ((VALUE OBJECT)) :GLOBALLY-INLINE? TRUE (RETURN (OR (EQL? VALUE (QUOTE TRUE)) (EQL? VALUE TRUE-WRAPPER) (AND (ISA? VALUE @SYMBOL) (STRING-EQUAL? (SYMBOL-NAME (CAST VALUE SYMBOL)) \"TRUE\")))))"
    (CL:FUNCTION TRUE-OPTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-MODULE-OPTIONS"
    "(DEFUN INCORPORATE-MODULE-OPTIONS ((SELF MODULE) (OPTIONS CONS)))"
    (CL:FUNCTION INCORPORATE-MODULE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNDEFINE-MODULE"
    "(DEFUN UNDEFINE-MODULE ((OLDMODULE MODULE) (NEWMODULE MODULE)))"
    (CL:FUNCTION UNDEFINE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-MODULE"
    "(DEFUN (DEFINE-MODULE MODULE) ((NAME STRING) (OPTIONS CONS)) :DOCUMENTATION \"Define or redefine a module named 'name' having the
options 'options'.  Return the new module.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION DEFINE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPDATE-NON-STRUCTURAL-MODULE-OPTIONS"
    "(DEFUN UPDATE-NON-STRUCTURAL-MODULE-OPTIONS ((OLDMODULE MODULE) (NEWMODULE MODULE) (NEWOPTIONS STRING)))"
    (CL:FUNCTION UPDATE-NON-STRUCTURAL-MODULE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "IDENTICAL-MODULE-STRUCTURE?"
    "(DEFUN (IDENTICAL-MODULE-STRUCTURE? BOOLEAN) ((OLDMODULE MODULE) (NEWMODULE MODULE) (NEWOPTIONS STRING)))"
    (CL:FUNCTION IDENTICAL-MODULE-STRUCTURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-MODULE-FROM-STRINGIFIED-SOURCE"
    "(DEFUN (DEFINE-MODULE-FROM-STRINGIFIED-SOURCE MODULE) ((NAME STRING) (STRINGIFIEDOPTIONS STRING)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION DEFINE-MODULE-FROM-STRINGIFIED-SOURCE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-DEFINE-MODULE"
    "(DEFUN (YIELD-DEFINE-MODULE CONS) ((MODULE MODULE)))"
    (CL:FUNCTION YIELD-DEFINE-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFMODULE"
    (CONCATENATE
     "(DEFUN DEFMODULE ((NAME NAME) |&REST| (OPTIONS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
	
`name' can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.

The above discussion of `:includes' and `:uses' semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module 'A' is inherited directly or
indirectly via `:includes' specification(s) by a submodule 'B', then all
definitions and facts asserted in 'A' are visible in 'B'. This is not the
cases for `:uses'; the `:uses' options does not impact inheritance of
propositions at all.

The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for
`name' become the new module's parents. If no `:uses' option was
supplied, the new module will use the `STELLA' module by default,
otherwise, it will use the set of specified modules.

If `:case-sensitive?' is supplied as TRUE, symbols in the module
will be interned case-sensitively, otherwise (the default), they
will be converted to uppercase before they get interned.  That
means that any reference from inside a case-sensitive module to a
non-case-sensitive module will have to use uppercase names for
symbols in the non-case-sensitive module.  The standard system
modules are all NOT case sensitive.

Modules can shadow definitions of functions and classes inherited
from parents or used modules. Shadowing is done automatically,
but generates a warning unless the shadowed type or function name
is listed in the `:shadow' option of the module definition .

Examples:
	 
  (defmodule \\\"PL-KERNEL/PL-USER\\\"
    :uses (\\\"LOGIC\\\" \\\"STELLA\\\")
    :package \\\"PL-USER\\\")

  (defmodule PL-USER/GENEALOGY)
	
The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords `:lisp-package', `:java-package', and `:cpp-package' specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the `STELLA' package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
co"
     "ntain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions `synchronized'.
\")")
    (CL:FUNCTION %DEFMODULE) (CL:FUNCTION DEFMODULE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "IN-MODULE"
    "(DEFUN (IN-MODULE MODULE) ((NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :LISP-MACRO? TRUE :DOCUMENTATION \"Change the current module to the module named `name'.\")"
    (CL:FUNCTION %IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-WORLD"
    "(DEFUN (CREATE-WORLD WORLD) ((PARENTCONTEXT CONTEXT) (NAME STRING)) :DOCUMENTATION \"Create a new world below the world or module 'parentContext'.
Optionally, specify a name.\" :PUBLIC? TRUE :INLINE FINALIZE-WORLD)"
    (CL:FUNCTION CREATE-WORLD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((WORLD WORLD)) :DOCUMENTATION \"Return FALSE always, since worlds never have more than one parent.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION MULTIPLE-PARENTS?)) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-WORLD"
    "(DEFUN (PUSH-WORLD WORLD) () :DOCUMENTATION \"Spawn a new world that is a child of the current context,
and change the current context to the new world.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION PUSH-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-WORLD"
    "(DEFUN (POP-WORLD CONTEXT) () :DOCUMENTATION \"Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION POP-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUBCONTEXTS"
    "(DEFUN (ALL-SUBCONTEXTS (ALL-PURPOSE-ITERATOR OF CONTEXT)) ((CONTEXT CONTEXT) (TRAVERSAL KEYWORD)) :DOCUMENTATION \"Return an iterator that generates all subcontexts of
'self' (not including 'self') in the order specified by 'traversal' (one
of :preorder, :inorder, :postorder or :topdown).\")"
    (CL:FUNCTION ALL-SUBCONTEXTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUBCONTEXTS-NEXT?"
    "(DEFUN (ALL-SUBCONTEXTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-SUBCONTEXTS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TOPDOWN-SUBCONTEXTS-NEXT?"
    "(DEFUN (ALL-TOPDOWN-SUBCONTEXTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-TOPDOWN-SUBCONTEXTS-NEXT?) NULL))
  :VOID)

(CL:DEFUN STARTUP-MODULES ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-MODULES1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *SUBCONTEXT-REVISION-POLICY* KWD-MODULES-CLEAR)
    (CL:SETQ *DEFINE-MODULE-HOOKS* (NEW-HOOK-LIST))
    (CL:SETQ *MODULE-NON-STRUCTURAL-OPTIONS*
     (CONS KWD-MODULES-DOCUMENTATION NIL)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE NAME OBJECT)"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-MODULES2)
    (DEFINE-FUNCTION-OBJECT "ALL-CONTEXTS"
     "(DEFUN (ALL-CONTEXTS (ITERATOR OF CONTEXT)) () :PUBLIC? TRUE :DOCUMENTATION \"Return an iterator that generates all contexts.\")"
     (CL:FUNCTION ALL-CONTEXTS) NULL)
    (DEFINE-FUNCTION-OBJECT "FILTER-MODULE?"
     "(DEFUN (FILTER-MODULE? BOOLEAN) ((SELF OBJECT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
     (CL:FUNCTION FILTER-MODULE?) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-MODULES"
     "(DEFUN (ALL-MODULES (ITERATOR OF MODULE)) () :PUBLIC? TRUE :DOCUMENTATION \"Return an iterator that generates all modules.\")"
     (CL:FUNCTION ALL-MODULES) NULL)
    (DEFINE-FUNCTION-OBJECT "LIST-MODULES"
     "(DEFUN (LIST-MODULES (CONS OF MODULE)) ((KB-ONLY? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"Returns a cons of all modules defined in PowerLoom.  If `kb-only?'
is `true', then any modules which are code only or just namespaces are not returned.\")"
     (CL:FUNCTION %LIST-MODULES)
     (CL:FUNCTION LIST-MODULES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "ALL-INCLUDED-MODULES"
     "(DEFUN (ALL-INCLUDED-MODULES (ITERATOR OF MODULE)) ((SELF MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a sequence of all modules included
by 'self', inclusive, starting from the highest ancestor and working
down to 'self' (which is last).\")" (CL:FUNCTION ALL-INCLUDED-MODULES)
     NULL)
    (DEFINE-FUNCTION-OBJECT "VISIBLE-MODULES"
     "(DEFUN (VISIBLE-MODULES (CONS OF MODULE)) ((FROM MODULE)) :DOCUMENTATION \"Return a list of all modules visible from module `from' (or `*module*'
if `from' is NULL.  The generated modules are generated from most to
least-specific and will start with the module `from'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION VISIBLE-MODULES) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-VISIBLE-MODULES"
     "(DEFUN (HELP-MEMOIZE-VISIBLE-MODULES (CONS OF MODULE)) ((FROM MODULE)))"
     (CL:FUNCTION HELP-MEMOIZE-VISIBLE-MODULES) NULL)
    (DEFINE-FUNCTION-OBJECT "CARDINAL-MODULE?"
     "(DEFUN (CARDINAL-MODULE? BOOLEAN) ((SELF MODULE)))"
     (CL:FUNCTION CARDINAL-MODULE?) NULL)
    (DEFINE-FUNCTION-OBJECT "VISIBLE-FROM?"
     "(DEFUN (VISIBLE-FROM? BOOLEAN) ((VIEWEDCONTEXT CONTEXT) (FROMCONTEXT CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION VISIBLE-FROM?) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-ONE-CONTEXT"
     "(DEFUN CLEAR-ONE-CONTEXT ((SELF CONTEXT)))"
     (CL:FUNCTION CLEAR-ONE-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-CLEAR-CONTEXT"
     "(DEFUN HELP-CLEAR-CONTEXT ((SELF CONTEXT)))"
     (CL:FUNCTION HELP-CLEAR-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-CONTEXT"
     "(DEFUN CLEAR-CONTEXT ((SELF CONTEXT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy all objects belonging to 'self' or any of its subcontexts.\")"
     (CL:FUNCTION CLEAR-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "CALL-CLEAR-MODULE"
     "(DEFUN CALL-CLEAR-MODULE (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? TRUE :LISP-MACRO? FALSE :DOCUMENTATION \"Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.\")" (CL:FUNCTION CALL-CLEAR-MODULE)
     (CL:FUNCTION CALL-CLEAR-MODULE-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "CLEAR-MODULE"
     "(DEFUN CLEAR-MODULE (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.\")" (CL:FUNCTION %CLEAR-MODULE)
     (CL:FUNCTION CLEAR-MODULE-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-MODULES"
     "(DEFUN STARTUP-MODULES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-MODULES) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-MODULES-STELLA-STARTUP-MODULES)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-MODULES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupModules") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *SUBCONTEXT-REVISION-POLICY* KEYWORD :CLEAR :DOCUMENTATION \"Controls actions reflexive transitive closure of
   subcontexts when a context is revised.
   Values are ':destroy' -- destroy subcontexts;
   ':clear' -- clear contents of subcontexts;
   ':preserve' -- don't disturb subcontexts.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *SHADOWEDSURROGATES* (CONS OF SYMBOL) NULL :DOCUMENTATION \"Holds list of symbols representing surrogates
to be shadowed during module finalization.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DEFINE-MODULE-HOOKS* HOOK-LIST (NEW HOOK-LIST) :DOCUMENTATION \"HOOK-LIST called by 'define-module', applied to a
'module' argument.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *MODULE-NON-STRUCTURAL-OPTIONS* (CONS OF KEYWORD) (BQUOTE (:DOCUMENTATION)) :PUBLIC? FALSE :DOCUMENTATION \"List of non-structural options for Module definitions.
Used in testing for module changes and in updating non-structurally changed
modules.\")" NULL)
    (REGISTER-NATIVE-NAME SYM-MODULES-STELLA-DEFMODULE
     KWD-MODULES-COMMON-LISP KWD-MODULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-MODULES-STELLA-IN-MODULE
     KWD-MODULES-COMMON-LISP KWD-MODULES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-MODULES-STELLA-LIST-MODULES
     KWD-MODULES-COMMON-LISP KWD-MODULES-FUNCTION)
    (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS *ROOT-MODULE*)
     SYM-MODULES-STELLA-CLEARABLE? FALSE-WRAPPER FALSE-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS *STELLA-MODULE*)
     SYM-MODULES-STELLA-CLEARABLE? FALSE-WRAPPER FALSE-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE
     (%MODULE.DYNAMIC-SLOTS *COMMON-LISP-MODULE*)
     SYM-MODULES-STELLA-CLEARABLE? FALSE-WRAPPER FALSE-WRAPPER)
    (REGISTER-NATIVE-NAME SYM-MODULES-STELLA-CLEAR-MODULE
     KWD-MODULES-COMMON-LISP KWD-MODULES-FUNCTION)))
  :VOID)
