;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; systems.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-SYSTEMS-STELLA-SET-LOAD-PATH NULL)
(CL:DEFVAR KWD-SYSTEMS-COMMON-LISP NULL)
(CL:DEFVAR KWD-SYSTEMS-FUNCTION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ADD-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DROP-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-FIND-FILE-IN-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-TRUE NULL)
(CL:DEFVAR KWD-SYSTEMS-TRUE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-FALSE NULL)
(CL:DEFVAR KWD-SYSTEMS-FALSE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-INTEGER NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-STRING NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-KEYWORD NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-SYMBOL NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-MODULE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-CONS NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-LIST NULL)
(CL:DEFVAR KWD-SYSTEMS-OPTIONS NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-IDENTITY NULL)
(CL:DEFVAR KWD-SYSTEMS-DEFINE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-IN-MODULE NULL)
(CL:DEFVAR KWD-SYSTEMS-FINALIZE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFMODULE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFSYSTEM NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFCLASS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFSLOT NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFMETHOD NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-FILE NULL)
(CL:DEFVAR KWD-SYSTEMS-DOCUMENTATION NULL)
(CL:DEFVAR KWD-SYSTEMS-PUBLIC? NULL)
(CL:DEFVAR KWD-SYSTEMS-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-REQUIRED-SYSTEMS NULL)
(CL:DEFVAR KWD-SYSTEMS-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-LOAD-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-LANGUAGE NULL)
(CL:DEFVAR KWD-SYSTEMS-MAKE-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-CPP-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-JAVA-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-DATA-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-PREPROCESSED-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-CARDINAL-MODULE NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-BINARY-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-BANNER NULL)
(CL:DEFVAR KWD-SYSTEMS-COPYRIGHT-HEADER NULL)
(CL:DEFVAR KWD-SYSTEMS-PRODUCTION-SETTINGS NULL)
(CL:DEFVAR KWD-SYSTEMS-DEVELOPMENT-SETTINGS NULL)
(CL:DEFVAR KWD-SYSTEMS-FINALIZATION-FUNCTION NULL)
(CL:DEFVAR KWD-SYSTEMS-JAVA NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP NULL)
(CL:DEFVAR KWD-SYSTEMS-CPP NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP-BINARY NULL)
(CL:DEFVAR KWD-SYSTEMS-TWO-PASS? NULL)
(CL:DEFVAR KWD-SYSTEMS-DEVELOPMENT-SETTINGS? NULL)
(CL:DEFVAR KWD-SYSTEMS-PRODUCTION-SETTINGS? NULL)
(CL:DEFVAR KWD-SYSTEMS-FORCE-TRANSLATION? NULL)
(CL:DEFVAR KWD-SYSTEMS-FORCE-RECOMPILATION? NULL)
(CL:DEFVAR KWD-SYSTEMS-LOAD-SYSTEM? NULL)
(CL:DEFVAR KWD-SYSTEMS-STARTUP? NULL)
(CL:DEFVAR KWD-SYSTEMS-RECURSIVE? NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-FILE-NAME NULL)
(CL:DEFVAR KWD-SYSTEMS-PROCESSED NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-MAKE-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-SYSTEMS-STELLA NULL)
(CL:DEFVAR KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-SYSTEM NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR KWD-SYSTEMS-EARLY-INITS NULL)
(CL:DEFVAR KWD-SYSTEMS-MODULES NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PHASE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-IN NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-INTERVAL NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER NULL)
(CL:DEFVAR KWD-SYSTEMS-FINAL NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DO NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE* NULL)
(CL:DEFVAR KWD-SYSTEMS-DAYS NULL)
(CL:DEFVAR KWD-SYSTEMS-HOURS NULL)
(CL:DEFVAR KWD-SYSTEMS-MINUTES NULL)
(CL:DEFVAR KWD-SYSTEMS-SECONDS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SYSTEM-VERSION NULL)
(CL:DEFVAR KWD-SYSTEMS-SET NULL)
(CL:DEFVAR KWD-SYSTEMS-WHITE-SPACE NULL)
(CL:DEFVAR KWD-SYSTEMS-ADD NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIGURATION-TABLE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE NULL)
(CL:DEFVAR KWD-SYSTEMS-CLEAR NULL)
(CL:DEFVAR KWD-SYSTEMS-REMOVE NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-DIRECTORY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIGURE-STELLA NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-GET-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SET-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-LONG-INTEGER NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-TEST-PROPERTY-DEMON NULL)
(CL:DEFVAR KWD-SYSTEMS-ERROR NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-CMD-LINE-OPTION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-KEYS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-VALUE-TYPE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-MULTI-VALUED? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-N-ARGUMENTS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFAULT-VALUE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ERROR-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY2 NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY3 NULL)
(CL:DEFVAR KWD-SYSTEMS-KEYS NULL)
(CL:DEFVAR KWD-SYSTEMS-VALUE-TYPE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-TYPE NULL)
(CL:DEFVAR KWD-SYSTEMS-MULTI-VALUED? NULL)
(CL:DEFVAR KWD-SYSTEMS-N-ARGUMENTS NULL)
(CL:DEFVAR KWD-SYSTEMS-DEFAULT-VALUE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-OBJECT NULL)
(CL:DEFVAR KWD-SYSTEMS-PROPERTY NULL)
(CL:DEFVAR KWD-SYSTEMS-HANDLER NULL)
(CL:DEFVAR KWD-SYSTEMS-ERROR-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-WARN NULL)
(CL:DEFVAR KWD-SYSTEMS-IGNORE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *CHARACTER-TYPE-TABLE* *STELLA-MODULE*
  *FUNCTION-LOOKUP-TABLE* *CURRENT-STELLA-FEATURES*
  *TRANSLATOROUTPUTLANGUAGE* NIL-LIST *CURRENT-SYSTEM-ACTION*
  STANDARD-WARNING *DEFAULTROOTSOURCEDIRECTORY*
  *DEFAULTROOTNATIVEDIRECTORY* *DEFAULTROOTBINARYDIRECTORY*
  NULL-STRING-WRAPPER *CURRENTFILENAME* *MODULE* *TRANSLATIONUNITS*
  *EVALUATIONTREE* *EVALUATIONPARENTTREE* *TRANSLATIONPHASE*
  *CURRENTSYSTEMDEFINITION* STANDARD-OUTPUT EOL MOST-POSITIVE-INTEGER
  NULL-FLOAT TRUE-WRAPPER FALSE-WRAPPER NIL NULL-INTEGER))

;;; (DEFGLOBAL *FILE-LOAD-PATH* ...)

(CL:DEFVAR *FILE-LOAD-PATH* NULL)

;;; (DEFUN (PARSE-DIRECTORY-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN PARSE-DIRECTORY-PATH (PATH)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:LET*
   ((SEPARATOR #\|) (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH PATH)))
    (START 0) (END 0) (PARSEDPATH NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH START END))
   (CL:LOOP (CL:SETQ END (POSITION PATH SEPARATOR START))
    (CL:SETQ PARSEDPATH
     (CONS
      (WRAP-STRING
       (FILE-NAME-AS-DIRECTORY (SUBSEQUENCE PATH START END)))
      PARSEDPATH))
    (CL:IF
     (CL:AND (CL:NOT (CL:= END NULL-INTEGER))
      (CL:< END (CL:1- LENGTH)))
     (CL:SETQ START (CL:1+ END)) (CL:RETURN)))
   (CL:RETURN-FROM PARSE-DIRECTORY-PATH (REVERSE PARSEDPATH))))

;;; (DEFUN (SET-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %SET-LOAD-PATH (PATH)
  "Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH* (PARSE-DIRECTORY-PATH PATH))
  (CL:RETURN-FROM %SET-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN SET-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM SET-LOAD-PATH-EVALUATOR-WRAPPER
   (%SET-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO SET-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-LOAD-PATH)))

;;; (DEFUN (GET-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN GET-LOAD-PATH ()
  "Return the current STELLA load path."
  (CL:RETURN-FROM GET-LOAD-PATH *FILE-LOAD-PATH*))

;;; (DEFUN (PUSH-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %PUSH-LOAD-PATH (PATH)
  "Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH*
   (CONCATENATE (PARSE-DIRECTORY-PATH PATH) *FILE-LOAD-PATH*))
  (CL:RETURN-FROM %PUSH-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN PUSH-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM PUSH-LOAD-PATH-EVALUATOR-WRAPPER
   (%PUSH-LOAD-PATH
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO PUSH-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/PUSH-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE PUSH-LOAD-PATH)))

;;; (DEFUN (POP-LOAD-PATH STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) POP-LOAD-PATH))
(CL:DEFUN POP-LOAD-PATH ()
  "Remove the first element from the STELLA load path
and return the removed element."
  (CL:LET* ((HEAD-000 (%%VALUE *FILE-LOAD-PATH*)))
   (CL:SETQ *FILE-LOAD-PATH* (%%REST *FILE-LOAD-PATH*))
   (CL:LET* ((VALUE-000 HEAD-000))
    (CL:RETURN-FROM POP-LOAD-PATH
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE-000)))))

(CL:DEFUN POP-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:LET* ((RESULT (POP-LOAD-PATH)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT STELLA::NULL-STRING))
    (CL:RETURN-FROM POP-LOAD-PATH-EVALUATOR-WRAPPER
     (WRAP-STRING RESULT))
    (CL:RETURN-FROM POP-LOAD-PATH-EVALUATOR-WRAPPER NULL))))

;;; (DEFUN (ADD-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %ADD-LOAD-PATH (PATH)
  "Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH*
   (CONCATENATE *FILE-LOAD-PATH* (PARSE-DIRECTORY-PATH PATH)))
  (CL:RETURN-FROM %ADD-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN ADD-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM ADD-LOAD-PATH-EVALUATOR-WRAPPER
   (%ADD-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO ADD-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ADD-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-LOAD-PATH)))

;;; (DEFUN (DROP-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %DROP-LOAD-PATH (PATH)
  "Remove the directories listed in the |-separated
`path' from the PowerLoom load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:LET* ((DIR NULL) (ITER-000 (PARSE-DIRECTORY-PATH PATH)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ DIR (%%VALUE ITER-000))
    (CL:SETQ *FILE-LOAD-PATH* (REMOVE *FILE-LOAD-PATH* DIR))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM %DROP-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN DROP-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DROP-LOAD-PATH-EVALUATOR-WRAPPER
   (%DROP-LOAD-PATH
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO DROP-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Remove the directories listed in the |-separated
`path' from the PowerLoom load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DROP-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE DROP-LOAD-PATH)))

;;; (DEFGLOBAL *STELLA-FILE-EXTENSIONS* ...)

(CL:DEFVAR *STELLA-FILE-EXTENSIONS* NULL
  "File extensions to append by default when a
file is looked up by `find-file-in-load-path'.")

;;; (DEFUN (FIND-FILE-IN-LOAD-PATH STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  %FIND-FILE-IN-LOAD-PATH))
(CL:DEFUN %FIND-FILE-IN-LOAD-PATH (FILE EXTENSIONS)
  "Try to find `file' in the current load path and, if found,
return its full name.  If `file' can't be found literally, try to find it
with any of the listed `extensions' added.  If `extensions' is NULL it defaults
to `*stella-file-extensions*', therefore, to not default to any extensions
the value has to be supplied as NIL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((EXPANDEDFILE FILE))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPANDEDFILE))
   (CL:WHEN (CL:EQ EXTENSIONS NULL)
    (CL:SETQ EXTENSIONS *STELLA-FILE-EXTENSIONS*))
   (CL:LET*
    ((DIR NULL) (ITER-000 (CONS (WRAP-STRING "") *FILE-LOAD-PATH*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-000))
     (CL:HANDLER-CASE
      (CL:PROGN
       (CL:SETQ EXPANDEDFILE (CONCATENATE (UNWRAP-STRING DIR) FILE))
       (CL:WHEN (PROBE-FILE? EXPANDEDFILE)
        (CL:RETURN-FROM %FIND-FILE-IN-LOAD-PATH EXPANDEDFILE))
       (CL:LET* ((EXT NULL) (ITER-001 EXTENSIONS))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ EXT (%%VALUE ITER-001))
         (CL:SETQ EXPANDEDFILE
          (CONCATENATE (UNWRAP-STRING DIR) FILE
           (%STRING-WRAPPER.WRAPPER-VALUE EXT)))
         (CL:WHEN (PROBE-FILE? EXPANDEDFILE)
          (CL:RETURN-FROM %FIND-FILE-IN-LOAD-PATH EXPANDEDFILE))
         (CL:SETQ ITER-001 (%%REST ITER-001)))))
      (CL:CONDITION (E) (CL:SETQ E E)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM %FIND-FILE-IN-LOAD-PATH STELLA::NULL-STRING)))

(CL:DEFUN FIND-FILE-IN-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%FIND-FILE-IN-LOAD-PATH
      (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT STELLA::NULL-STRING))
    (CL:RETURN-FROM FIND-FILE-IN-LOAD-PATH-EVALUATOR-WRAPPER
     (WRAP-STRING RESULT))
    (CL:RETURN-FROM FIND-FILE-IN-LOAD-PATH-EVALUATOR-WRAPPER NULL))))

(CL:DEFMACRO FIND-FILE-IN-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Try to find `file' in the current load path and, if found,
return its full name.  If `file' can't be found literally, try to find it
with any of the listed `extensions' added.  If `extensions' is NULL it defaults
to `*stella-file-extensions*', therefore, to not default to any extensions
the value has to be supplied as NIL."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/FIND-FILE-IN-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE FIND-FILE-IN-LOAD-PATH)))

;;; (DEFUN (COERCE-VALUE-TO-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN COERCE-VALUE-TO-BOOLEAN (VALUE ERROR?)
  "Return the boolean object represented by `value'.  Return NULL
if coercion is not possible or raise an error if `error?' is TRUE."
  (CL:COND
   ((CL:OR (CL:EQ VALUE SYM-SYSTEMS-STELLA-TRUE)
     (CL:EQ VALUE KWD-SYSTEMS-TRUE))
    (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
   ((CL:OR (CL:EQ VALUE SYM-SYSTEMS-STELLA-FALSE)
     (CL:EQ VALUE KWD-SYSTEMS-FALSE))
    (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
       ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "FALSE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME VALUE) "TRUE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
       ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME VALUE) "FALSE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((STRING-EQUAL? (%STRING-WRAPPER.WRAPPER-VALUE VALUE) "TRUE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
       ((STRING-EQUAL? (%STRING-WRAPPER.WRAPPER-VALUE VALUE) "FALSE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))))
    ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN VALUE)))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-boolean: can't coerce `" VALUE "' of type `"
     (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (PRIMARY-TYPE VALUE)
      SGT-SYSTEMS-STELLA-UNKNOWN)
     "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN NULL)))

;;; (DEFUN (COERCE-TO-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN COERCE-TO-BOOLEAN (OBJECT)
  "Return the boolean object represented by `object'.
Return NULL if coercion is not possible."
  (CL:RETURN-FROM COERCE-TO-BOOLEAN
   (COERCE-VALUE-TO-BOOLEAN OBJECT CL:NIL)))

;;; (DEFUN (COERCE-VALUE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  COERCE-VALUE-TO-STRING))
(CL:DEFUN COERCE-VALUE-TO-STRING (VALUE ERROR?)
  "Coerce `value' into a string if possible, return NULL
otherwise or raise an error if `error?' is true."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (%GENERALIZED-SYMBOL.SYMBOL-NAME VALUE))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (INTEGER-TO-STRING
        (CL:TRUNCATE (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (INTEGER-TO-STRING
        (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (FLOAT-TO-STRING (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-string: don't know how to coerce `" VALUE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-STRING STELLA::NULL-STRING)))

;;; (DEFUN (COERCE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) COERCE-TO-STRING))
(CL:DEFUN COERCE-TO-STRING (OBJECT)
  "Coerce `object' into a string.  If no standard coercion
is possible, simply stringify `object'."
  (CL:LET* ((STRING (COERCE-VALUE-TO-STRING OBJECT CL:NIL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:WHEN (CL:EQ STRING STELLA::NULL-STRING)
    (CL:SETQ STRING (STRINGIFY OBJECT)))
   (CL:RETURN-FROM COERCE-TO-STRING STRING)))

;;; (DEFUN (COERCE-VALUE-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT)
  COERCE-VALUE-TO-FLOAT))
(CL:DEFUN COERCE-VALUE-TO-FLOAT (VALUE ERROR?)
  "Coerce `value' to a float value if possible, return
NULL otherwise or raise an error if `error?' is true."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (CL:* (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE) 1.0d0))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (CL:* (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE) 1.0d0))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-float: don't know how to coerce `" VALUE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT NULL-FLOAT)))

;;; (DEFUN (COERCE-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) COERCE-TO-FLOAT))
(CL:DEFUN COERCE-TO-FLOAT (OBJECT)
  "Coerce `number' to a float value or NULL if not possible."
  (CL:RETURN-FROM COERCE-TO-FLOAT (COERCE-VALUE-TO-FLOAT OBJECT CL:NIL)))

;;; (DEFUN (COERCE-VALUE-TO-TYPE OBJECT) ...)

(CL:DEFUN COERCE-VALUE-TO-TYPE (VALUE TYPE ERROR?)
  "Coerce `value' to `type'.  Return NULL if not possible
or raise an error if `error?' is TRUE."
  (CL:COND
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-INTEGER)
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (WRAP-INTEGER (FLOOR (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))))
      ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN
         (CL:AND
          (CL:>= (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)
           NULL-INTEGER)
          (CL:<= (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)
           MOST-POSITIVE-INTEGER))
         (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-FLOAT)
    (CL:LET* ((VAL (COERCE-VALUE-TO-FLOAT VALUE ERROR?)))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VAL))
     (CL:IF (CL:NOT (CL:= VAL NULL-FLOAT))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (WRAP-FLOAT VAL))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE NULL))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-NUMBER)
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-STRING)
    (CL:LET* ((VAL (COERCE-VALUE-TO-STRING VALUE ERROR?)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VAL))
     (CL:IF (CL:NOT (CL:EQ VAL STELLA::NULL-STRING))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (WRAP-STRING VAL))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE NULL))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-KEYWORD)
    (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-002
        SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (KEYWORDIFY VALUE))))
      ((SUBTYPE-OF-STRING? TEST-VALUE-002)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (KEYWORDIFY VALUE))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-SYMBOL)
    (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-SYMBOL (%KEYWORD.SYMBOL-NAME VALUE)))))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-DERIVED-SYMBOL VALUE
          (%SURROGATE.SYMBOL-NAME VALUE)))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-003)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-STRING? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-SYMBOL (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-BOOLEAN)
    (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
     (COERCE-VALUE-TO-BOOLEAN VALUE ERROR?)))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-MODULE)
    (CL:LET* ((MODULE (COERCE-TO-MODULE VALUE CL:NIL)))
     (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE MODULE))))
   (CL:T
    (CL:COND
     ((CL:EQ TYPE NULL) (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))
     ((ISA? VALUE TYPE) (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))
     ((ISA? VALUE (TYPE-TO-WRAPPED-TYPE TYPE))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-type: don't know how to coerce `" VALUE
     "' to type `" TYPE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-TYPE NULL)))

;;; (DEFUN (COERCE-OPTION-VALUE OBJECT) ...)

(CL:DEFUN COERCE-OPTION-VALUE (VALUE TYPE)
  "Coerce `value' to `type'.  Return NULL if not possible."
  (CL:RETURN-FROM COERCE-OPTION-VALUE
   (COERCE-VALUE-TO-TYPE VALUE TYPE CL:NIL)))

;;; (DEFUN (VET-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN VET-OPTIONS (PLIST LEGALOPTIONS)
  (CL:LET* ((PROPERTYLIST NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE PLIST)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-PROPERTY-LIST)
      (CL:PROGN (CL:SETQ PROPERTYLIST PLIST)))
     ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) PLIST)
        (CL:SETQ PROPERTYLIST SELF-000))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-LIST)
      (CL:PROGN
       (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001)
         (%LIST.THE-CONS-LIST PLIST))
        (CL:SETQ PROPERTYLIST SELF-001))))
     (CL:T (CL:WARN "Illegal argument passed to 'vet-options'")
      (CL:RETURN-FROM VET-OPTIONS (NEW-PROPERTY-LIST)))))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:WHEN
      (CL:OR (CL:NOT (STELLA-OBJECT? KEY)) (CL:NOT (KEYWORD? KEY))
       (CL:AND (CL:NOT (CL:EQ LEGALOPTIONS NULL))
        (CL:NOT (MEMBER? LEGALOPTIONS KEY))))
      (CL:SETQ VALUE VALUE)
      (CL:WHEN (CL:NOT (STELLA-OBJECT? KEY))
       (CL:LET* ((NEWPLIST (NEW-PROPERTY-LIST)))
        (CL:LET*
         ((KEY NULL) (VALUE NULL)
          (ITER-001 (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ KEY (%%VALUE ITER-001))
          (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
          (INSERT-AT NEWPLIST (STELLIFY KEY) (STELLIFY VALUE))
          (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)
         (%PROPERTY-LIST.THE-PLIST NEWPLIST)))
       (VET-OPTIONS PROPERTYLIST LEGALOPTIONS)
       (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST))
      (REMOVE-AT PROPERTYLIST KEY)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Skipping illegal option: `" KEY "'" EOL EOL)
      (CL:IF (KEYWORD? KEY)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   Legal options are: `" LEGALOPTIONS "'" EOL EOL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   Option must be a keyword." EOL))
      (VET-OPTIONS PROPERTYLIST LEGALOPTIONS)
      (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST)))

;;; (DEFUN (PARSE-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN PARSE-OPTIONS (OPTIONS |LEGALOPTIONS&TYPES| COERCIONERROR? ALLOWOTHERKEYS?)
  "Parse `options', check their validity according to
`legalOptions&Types' and return the result as a PROPERTY-LIST.
`legalOptions&Types' has to either be NULL or a flat list of legal
<keyword> <coercionType> pairs.  A type specifcation of @IDENTITY
means don't perform any coercion.
If `coercionError?' is TRUE, raise an error if a coercion failed.
If `allowOtherKeys?' is TRUE options other than those specified in
`legalOptions&Types' are allowed but won't be coerced since we don't
know their type.  A special implicit :options keyword that does not
need to be declared can be used to pass in an already parsed options
list from a caller, which will then be analyzed and used instead."
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) |LEGALOPTIONS&TYPES|)
   (CL:LET*
    ((LEGALOPTIONS SELF-000) (PARSEDOPTIONS NULL) (PASSEDOPTIONS NULL)
     (TYPE NULL) (COERCEDVALUE NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPTIONS)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH OPTIONS)))
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "Odd-length options list: `" OPTIONS "'")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
        (CL:LET* ((SELF-003 (NEW-PROPERTY-LIST)))
         (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-003) OPTIONS)
         (CL:SETQ PARSEDOPTIONS SELF-003))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-PROPERTY-LIST)
       (CL:PROGN (CL:SETQ PARSEDOPTIONS OPTIONS)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "Illegal options specification: `" OPTIONS "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:SETQ PASSEDOPTIONS (LOOKUP PARSEDOPTIONS KWD-SYSTEMS-OPTIONS))
    (CL:WHEN (CL:NOT (CL:EQ PASSEDOPTIONS NULL))
     (CL:RETURN-FROM PARSE-OPTIONS
      (PARSE-OPTIONS PASSEDOPTIONS |LEGALOPTIONS&TYPES| COERCIONERROR?
       ALLOWOTHERKEYS?)))
    (CL:WHEN (CL:NOT (CL:EQ LEGALOPTIONS NULL))
     (CL:LET*
      ((KEY NULL) (VALUE NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST PARSEDOPTIONS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:SETQ TYPE (LOOKUP LEGALOPTIONS KEY))
       (CL:WHEN (CL:AND (CL:EQ TYPE NULL) (CL:NOT ALLOWOTHERKEYS?))
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
          "Illegal option: `" KEY "'")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
       (CL:WHEN
        (CL:NOT
         (CL:OR (CL:EQ TYPE SGT-SYSTEMS-STELLA-IDENTITY)
          (CL:EQ VALUE NULL)))
        (CL:SETQ COERCEDVALUE
         (COERCE-VALUE-TO-TYPE VALUE TYPE COERCIONERROR?))
        (INSERT-AT PARSEDOPTIONS KEY COERCEDVALUE))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))))
    (CL:RETURN-FROM PARSE-OPTIONS PARSEDOPTIONS))))

;;; (DEFSPECIAL *CURRENTLOADFILE* ...)

(CL:DEFVAR *CURRENTLOADFILE* STELLA::NULL-STRING
  "Full pathname of file that is currently being loaded (or similar).")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CURRENTLOADFILE*))

;;; (DEFUN (EVALUATE-COMMAND OBJECT) ...)

(CL:DEFUN EVALUATE-COMMAND (COMMAND FINALIZE?)
  (CL:LET*
   ((*TRANSLATIONERRORS* 0) (*TRANSLATIONWARNINGS* 0)
    (*TRANSLATIONNOTES* 0) (*IGNORETRANSLATIONERRORS?* CL:NIL)
    (*TRANSLATIONUNITS* NULL) (*TRANSLATIONPHASE* KWD-SYSTEMS-DEFINE)
    (*EVALUATIONTREE* NULL))
   (CL:DECLARE
    (CL:SPECIAL *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
     *TRANSLATIONNOTES* *IGNORETRANSLATIONERRORS?* *TRANSLATIONUNITS*
     *TRANSLATIONPHASE* *EVALUATIONTREE*))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
     *TRANSLATIONNOTES*))
   (CL:LET* ((OPERATOR NULL) (RESULT NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COMMAND)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
       (CL:PROGN (CL:SETQ OPERATOR (%%VALUE COMMAND))
        (CL:COND
         ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
          (CL:PROGN
           (CL:COND
            ((CL:EQ OPERATOR SYM-SYSTEMS-STELLA-IN-MODULE)
             (HANDLE-IN-MODULE-TREE COMMAND CL:NIL CL:NIL))
            (CL:T
             (CL:COND
              ((DECLARATION-TREE? COMMAND)
               (CL:SETQ *TRANSLATIONUNITS* (LIST))
               (WALK-TOP-LEVEL-TREE COMMAND CL:NIL)
               (CL:CASE (LENGTH (REVERSE *TRANSLATIONUNITS*))
                (0
                 (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "While evaluating '" *EVALUATIONTREE*)
                  (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
                   (%%PRINT-STREAM
                    (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                    EOL "' inside '" *EVALUATIONPARENTTREE*))
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "':" EOL)
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "Couldn't translate `" COMMAND "'")
                  (CL:ERROR
                   (NEW-EVALUATION-EXCEPTION
                    (THE-STRING-READER STREAM-000)))))
                (1
                 (CL:SETQ RESULT
                  (%TRANSLATION-UNIT.THE-OBJECT
                   (FIRST *TRANSLATIONUNITS*))))
                (CL:OTHERWISE
                 (CL:LET* ((RESULTS NIL))
                  (CL:LET*
                   ((UNIT NULL)
                    (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*))
                    (COLLECT-000 NULL))
                   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
                    (CL:SETQ UNIT (%%VALUE ITER-000))
                    (CL:IF (CL:EQ COLLECT-000 NULL)
                     (CL:PROGN
                      (CL:SETQ COLLECT-000
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:IF (CL:EQ RESULTS NIL)
                       (CL:SETQ RESULTS COLLECT-000)
                       (ADD-CONS-TO-END-OF-CONS-LIST RESULTS
                        COLLECT-000)))
                     (CL:PROGN
                      (CL:SETF (%%REST COLLECT-000)
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
                    (CL:SETQ ITER-000 (%%REST ITER-000))))
                  (CL:SETQ RESULT RESULTS)))))
              ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME OPERATOR)
                "in-package"))
              (CL:T (%EVALUATE COMMAND)))))))
         (CL:T (%EVALUATE COMMAND)))))
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      (CL:T (%EVALUATE COMMAND))))
    (CL:WHEN (CL:AND (CL:NOT (TRANSLATION-ERRORS?)) FINALIZE?)
     (CL:SETQ *TRANSLATIONPHASE* KWD-SYSTEMS-FINALIZE)
     (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
      (RUN-SYSTEM-FINALIZATION *CURRENTSYSTEMDEFINITION*)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Can't run finalization because *currentSystemDefinition* is not set."
       EOL)))
    (CL:RETURN-FROM EVALUATE-COMMAND RESULT))))

;;; (DEFUN LOAD-FILE ...)

(CL:DEFUN %LOAD-FILE (FILE)
  "Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((TEMP-000 (%FIND-FILE-IN-LOAD-PATH FILE NULL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
   (CL:SETQ FILE
    (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING)) TEMP-000
     FILE)))
  (ENSURE-FILE-EXISTS FILE "load-file")
  (CL:LET*
   ((TOPLEVELINVOCATION? (CL:EQ *CURRENTFILENAME* STELLA::NULL-STRING))
    (SKIPCOMMAND? CL:NIL) (SEENINMODULE? CL:NIL) (COMMANDS NIL)
    (INPUTSTREAM NULL))
   (CL:UNWIND-PROTECT
    (CL:LET*
     ((*CURRENTLOADFILE* FILE)
      (*CURRENTFILENAME* (FILE-BASE-NAME FILE)))
     (CL:DECLARE (CL:SPECIAL *CURRENTLOADFILE* *CURRENTFILENAME*))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-STRING *CURRENTLOADFILE* *CURRENTFILENAME*))
     (CL:SETQ INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE))
     (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET* ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
        (CL:TAGBODY
         (CL:COND
          ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
           (CL:PROGN
            (CL:MULTIPLE-VALUE-SETQ (SKIPCOMMAND? SEENINMODULE?)
             (HANDLE-IN-MODULE-TREE TREE SEENINMODULE? CL:T))
            (CL:WHEN SKIPCOMMAND? (CL:GO :CONTINUE))
            (CL:LET* ((OPERATOR (%%VALUE TREE)))
             (CL:COND
              ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
               (CL:PROGN
                (CL:COND
                 ((CL:OR (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFMODULE)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFSYSTEM)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFCLASS)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFSLOT)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFUN)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFMETHOD))
                  (EVALUATE-COMMAND TREE CL:NIL))
                 (CL:T
                  (CL:IF
                   (CL:NOT (CL:EQ (LOOKUP-COMMAND OPERATOR) NULL))
                   (CL:SETQ COMMANDS (CONS TREE COMMANDS))
                   (EVALUATE-COMMAND TREE CL:NIL))))))
              (CL:T (EVALUATE-COMMAND TREE CL:NIL))))))
          (CL:T (EVALUATE-COMMAND TREE CL:NIL)))
         :CONTINUE)))
      (CL:LET* ((*TRANSLATIONPHASE* KWD-SYSTEMS-FINALIZE))
       (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
       (RUN-SYSTEM-FINALIZATION *CURRENTSYSTEMDEFINITION*))
      (CL:LET*
       ((FINALIZE? (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))))
       (CL:LET* ((TREE NULL) (ITER-001 (REVERSE COMMANDS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ TREE (%%VALUE ITER-001))
         (EVALUATE-COMMAND TREE FINALIZE?)
         (CL:SETQ ITER-001 (%%REST ITER-001)))))))
    (CL:WHEN TOPLEVELINVOCATION? (SWEEP-TRANSIENTS))
    (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
  :VOID)

(CL:DEFUN LOAD-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LOAD-FILE (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO LOAD-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-FILE)))

;;; (DEFGLOBAL *SYSTEMDEFINITIONS* ...)

(CL:DEFVAR *SYSTEMDEFINITIONS* NULL
  "A list of all defined systems.")

;;; (DEFUN (MAKE-SYSTEM-DEFINITION-FILE-NAME FILE-NAME) ...)

(CL:DEFUN MAKE-SYSTEM-DEFINITION-FILE-NAME (NAME)
  "Make a canonical system definition file name for a system named `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM MAKE-SYSTEM-DEFINITION-FILE-NAME
   (CONCATENATE (STRING-DOWNCASE NAME) "-system.ste")))

;;; (DEFUN (BUILD-STELLA-SYSTEMS-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN BUILD-STELLA-SYSTEMS-PATH ()
  (CL:LET*
   ((EXPLICITPATHVALUE
     (%GETENV "STELLA_SYSTEMS_PATH" (CONS-LIST (WRAP-STRING ":"))))
    (EXPLICITPATH (NEW-LIST)) (IMPLICITPATH (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPLICITPATHVALUE))
   (CL:LET*
    ((DIR NULL) (ITER-000 (SPLIT-STRING EXPLICITPATHVALUE #\:)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (BLANK-STRING? (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
      (INSERT-NEW EXPLICITPATH DIR))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE EXPLICITPATH)
   (CL:WHEN
    (CL:AND (NON-EMPTY? EXPLICITPATH)
     (CL:NOT (STARTS-WITH? EXPLICITPATHVALUE ":" 0))
     (CL:NOT (ENDS-WITH? EXPLICITPATHVALUE ":" NULL-INTEGER)))
    (CL:RETURN-FROM BUILD-STELLA-SYSTEMS-PATH (CONSIFY EXPLICITPATH)))
   (INSERT-NEW IMPLICITPATH
    (WRAP-STRING
     (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE (ROOT-SOURCE-DIRECTORY))))
   (INSERT-NEW IMPLICITPATH
    (WRAP-STRING
     (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE (ROOT-NATIVE-DIRECTORY))))
   (INSERT-NEW IMPLICITPATH
    (WRAP-STRING
     (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE (ROOT-BINARY-DIRECTORY))))
   (CL:LET* ((DIR NULL) (ITER-001 (SYSTEM-DEFINITION-DIRECTORIES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-001)) (INSERT-NEW IMPLICITPATH DIR)
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((SYS NULL) (ITER-002 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ SYS (%%VALUE ITER-002))
     (INSERT-NEW IMPLICITPATH
      (WRAP-STRING (FIND-SYSTEM-ROOT-DIRECTORY SYS)))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:WHEN (EMPTY? EXPLICITPATH)
    (CL:LET*
     ((DIR NULL) (ITER-003 (%LIST.THE-CONS-LIST (COPY IMPLICITPATH))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ DIR (%%VALUE ITER-003))
      (CL:WHEN
       (CL:AND
        (CL:NOT (BLANK-STRING? (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
        (PROBE-DIRECTORY? (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
       (CL:LET*
        ((SYSTEMPARENTDIR
          (DIRECTORY-PARENT-DIRECTORY
           (%STRING-WRAPPER.WRAPPER-VALUE DIR) 1))
         (SYSTEMPARENTDIRFILES
          (%LIST-DIRECTORY-FILES SYSTEMPARENTDIR)))
        (CL:LET* ((DIR NULL) (ITER-004 SYSTEMPARENTDIRFILES))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:SETQ DIR (%%VALUE ITER-004))
          (CL:SETQ DIR
           (WRAP-STRING
            (FILE-NAME-AS-DIRECTORY
             (CONCATENATE-FILE-NAMES SYSTEMPARENTDIR
              (%STRING-WRAPPER.WRAPPER-VALUE DIR)))))
          (CL:WHEN
           (CL:AND (PROBE-FILE? (%STRING-WRAPPER.WRAPPER-VALUE DIR))
            (TOP-LEVEL-STELLA-SYSTEM-DIRECTORY?
             (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
           (INSERT-NEW IMPLICITPATH DIR))
          (CL:SETQ ITER-004 (%%REST ITER-004))))))
      (CL:SETQ ITER-003 (%%REST ITER-003)))))
   (REMOVE (REVERSE IMPLICITPATH) NULL-STRING-WRAPPER)
   (CL:IF (STARTS-WITH? EXPLICITPATHVALUE ":" 0)
    (CL:RETURN-FROM BUILD-STELLA-SYSTEMS-PATH
     (CONSIFY (CONCATENATE IMPLICITPATH EXPLICITPATH)))
    (CL:RETURN-FROM BUILD-STELLA-SYSTEMS-PATH
     (CONSIFY (CONCATENATE EXPLICITPATH IMPLICITPATH))))))

;;; (DEFUN (FIND-SYSTEM-DEFINITION-FILE FILE-NAME) ...)

(CL:DEFUN FIND-SYSTEM-DEFINITION-FILE (NAME)
  "Try to find an existing system definition file for a system named `name'
in the current STELLA_SYSTEMS_PATH or built-in implicit systems path.  Return NULL if no
such definition file can be found.  See `build-stella-systems-path' on where it looks."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((SYSTEMFILENAME (MAKE-SYSTEM-DEFINITION-FILE-NAME NAME))
    (SYSTEMFILE STELLA::NULL-STRING)
    (RELATIVESYSTEMDIRS
     (CONS-LIST (WRAP-STRING "") (WRAP-STRING "systems")
      (WRAP-STRING (CONCATENATE-FILE-NAMES "sources" "systems")))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMFILE))
   (CL:LET* ((DIR NULL) (ITER-000 (BUILD-STELLA-SYSTEMS-PATH)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND
       (CL:NOT (BLANK-STRING? (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
       (PROBE-DIRECTORY? (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
      (CL:LET* ((SUBDIR NULL) (ITER-001 RELATIVESYSTEMDIRS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ SUBDIR (%%VALUE ITER-001))
        (CL:SETQ SYSTEMFILE
         (CONCATENATE-FILE-NAMES (%STRING-WRAPPER.WRAPPER-VALUE DIR)
          (%STRING-WRAPPER.WRAPPER-VALUE SUBDIR) SYSTEMFILENAME))
        (CL:WHEN (PROBE-FILE? SYSTEMFILE)
         (CL:RETURN-FROM FIND-SYSTEM-DEFINITION-FILE SYSTEMFILE))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM FIND-SYSTEM-DEFINITION-FILE STELLA::NULL-STRING)))

;;; (DEFUN (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE FILE-NAME) ...)

(CL:DEFUN FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE (SYSDEFFILE)
  "Given a system definition file `sysDefFile' try to determine the root directory
of the STELLA installation containing this system by looking for top-level native directories."
  (CL:LET*
   ((DIRECTORY (FILE-NAME-DIRECTORY SYSDEFFILE)) (PARENT DIRECTORY))
   (CL:LET* ((LEVEL NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 4))
    (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ LEVEL ITER-000)
     (CL:SETQ PARENT (DIRECTORY-PARENT-DIRECTORY DIRECTORY LEVEL))
     (CL:WHEN (TOP-LEVEL-STELLA-SYSTEM-DIRECTORY? PARENT)
      (CL:RETURN-FROM FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE PARENT))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE
    STELLA::NULL-STRING)))

;;; (DEFUN (FIND-SYSTEM-ROOT-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FIND-SYSTEM-ROOT-DIRECTORY (SYSTEM)
  "Given a system definition `system' try to determine the root directory
of the STELLA installation containing this system based on its definition file."
  (CL:LET* ((SYSDEFFILE (%SYSTEM-DEFINITION.DEFINITION-FILE SYSTEM)))
   (CL:IF (CL:NOT (CL:EQ SYSDEFFILE STELLA::NULL-STRING))
    (CL:RETURN-FROM FIND-SYSTEM-ROOT-DIRECTORY
     (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE SYSDEFFILE))
    (CL:RETURN-FROM FIND-SYSTEM-ROOT-DIRECTORY STELLA::NULL-STRING))))

;;; (DEFUN COMPUTE-SYSTEM-ROOT-DIRECTORIES ...)

(CL:DEFUN COMPUTE-SYSTEM-ROOT-DIRECTORIES (SYSTEM)
  "Compute any root directories for sources, native and Lisp binary directories
in case they were not explicitly specified in `system's definition.  Raises an error in case
any of those root directories is missing and can't be computed."
  (CL:LET* ((SYSTEMROOTDIR (FIND-SYSTEM-ROOT-DIRECTORY SYSTEM)))
   (CL:WHEN (CL:NOT (CL:EQ SYSTEMROOTDIR STELLA::NULL-STRING))
    (CL:LET* ((VALUE-000 NULL))
     (CL:LET*
      ((SYS NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN
        (STRING-EQL? (FIND-SYSTEM-ROOT-DIRECTORY SYS) SYSTEMROOTDIR)
        (CL:SETQ VALUE-000 SYS) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET* ((TEMP-000 VALUE-000))
      (CL:LET*
       ((REFERENCESYSTEM
         (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 SYSTEM)))
       (CL:LET*
        ((TEMP-001
          (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY REFERENCESYSTEM)))
        (CL:LET*
         ((ROOTSOURCEDEFAULT
           (CL:IF (CL:NOT (CL:EQ TEMP-001 STELLA::NULL-STRING))
            TEMP-001
            (CONCATENATE-FILE-NAMES SYSTEMROOTDIR
             (RELATIVE-UNLOGICALIZE-PATHNAME
              *DEFAULTROOTSOURCEDIRECTORY*)))))
         (CL:LET*
          ((TEMP-002
            (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY
             REFERENCESYSTEM)))
          (CL:LET*
           ((ROOTNATIVEDEFAULT
             (TRANSLATE-LOGICAL-PATHNAME
              (CL:IF (CL:NOT (CL:EQ TEMP-002 STELLA::NULL-STRING))
               TEMP-002
               (CONCATENATE-FILE-NAMES SYSTEMROOTDIR
                (RELATIVE-UNLOGICALIZE-PATHNAME
                 *DEFAULTROOTNATIVEDIRECTORY*))))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ROOTNATIVEDEFAULT))
           (CL:LET*
            ((TEMP-003
              (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY
               REFERENCESYSTEM)))
            (CL:LET*
             ((ROOTBINARYDEFAULT
               (TRANSLATE-LOGICAL-PATHNAME
                (CL:IF (CL:NOT (CL:EQ TEMP-003 STELLA::NULL-STRING))
                 TEMP-003
                 (CONCATENATE-FILE-NAMES SYSTEMROOTDIR
                  (RELATIVE-UNLOGICALIZE-PATHNAME
                   *DEFAULTROOTBINARYDIRECTORY*))))))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ROOTBINARYDEFAULT))
             (CL:LET*
              ((*DEFAULTROOTSOURCEDIRECTORY* ROOTSOURCEDEFAULT)
               (*DEFAULTROOTNATIVEDIRECTORY* ROOTNATIVEDEFAULT)
               (*DEFAULTROOTBINARYDIRECTORY* ROOTBINARYDEFAULT))
              (CL:DECLARE
               (CL:SPECIAL *DEFAULTROOTSOURCEDIRECTORY*
                *DEFAULTROOTNATIVEDIRECTORY*
                *DEFAULTROOTBINARYDIRECTORY*))
              (CL:DECLARE
               (CL:TYPE CL:SIMPLE-STRING *DEFAULTROOTSOURCEDIRECTORY*
                *DEFAULTROOTNATIVEDIRECTORY*
                *DEFAULTROOTBINARYDIRECTORY*))
              (CL:WHEN
               (CL:EQ (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY SYSTEM)
                STELLA::NULL-STRING)
               (CL:SETF
                (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY SYSTEM)
                (ROOT-SOURCE-DIRECTORY)))
              (CL:WHEN
               (CL:EQ (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY SYSTEM)
                STELLA::NULL-STRING)
               (CL:SETF
                (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY SYSTEM)
                (ROOT-NATIVE-DIRECTORY)))
              (CL:WHEN
               (CL:EQ (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY SYSTEM)
                STELLA::NULL-STRING)
               (CL:SETF
                (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY SYSTEM)
                (ROOT-BINARY-DIRECTORY))))))))))))))
   (CL:WHEN
    (CL:OR
     (CL:EQ (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY SYSTEM)
      STELLA::NULL-STRING)
     (CL:EQ (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY SYSTEM)
      STELLA::NULL-STRING)
     (CL:EQ (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY SYSTEM)
      STELLA::NULL-STRING))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Failed to define or compute one or more of `"
      (%SYSTEM-DEFINITION.NAME SYSTEM) "''s root directories")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN (PARSE-LIST-OF-FILE-PATHS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN PARSE-LIST-OF-FILE-PATHS (FILES)
  (CL:LET* ((STRINGS NIL))
   (CL:LET* ((FILESPEC NULL) (ITER-000 FILES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FILESPEC (%%VALUE ITER-000))
     (CL:SETQ STRINGS
      (CONS (WRAP-STRING (IMPLODE-PATHNAME FILESPEC)) STRINGS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM PARSE-LIST-OF-FILE-PATHS (REVERSE STRINGS))))

;;; (DEFUN (DEFINE-SYSTEM SYSTEM-DEFINITION) ...)

(CL:DEFUN DEFINE-SYSTEM (NAME OPTIONS)
  (CL:LET* ((STRINGNAME STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGNAME))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ STRINGNAME (%STRING-WRAPPER.WRAPPER-VALUE NAME))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ STRINGNAME
        (STRING-DOWNCASE (%SYMBOL.SYMBOL-NAME NAME)))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Illegal system name: " NAME)
      (CL:RETURN-FROM DEFINE-SYSTEM NULL))))
   (CL:LET* ((SELF-000 (NEW-SYSTEM-DEFINITION)))
    (CL:SETF (%SYSTEM-DEFINITION.NAME SELF-000) STRINGNAME)
    (CL:SETF (%SYSTEM-DEFINITION.DEFINITION-FILE SELF-000)
     *CURRENTLOADFILE*)
    (CL:LET* ((SYSTEM SELF-000))
     (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
      (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001) OPTIONS)
      (CL:LET* ((PLIST SELF-001))
       (CL:LET* ((VALUE-000 NULL))
        (CL:LET*
         ((S NULL)
          (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ S (%%VALUE ITER-000))
          (CL:WHEN (STRING-EQL? (%SYSTEM-DEFINITION.NAME S) STRINGNAME)
           (CL:SETQ VALUE-000 S) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:LET* ((OLDSYSTEM VALUE-000))
         (CL:LET*
          ((KEY NULL) (VALUE NULL)
           (ITER-001 (%PROPERTY-LIST.THE-PLIST PLIST)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ KEY (%%VALUE ITER-001))
           (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
           (CL:LET* ((TEST-VALUE-001 KEY))
            (CL:COND
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DIRECTORY)
              (CL:SETF (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
               (IMPLODE-PATHNAME VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-REQUIRED-SYSTEMS)
              (CL:SETF (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM)
               VALUE)
              (CL:LET* ((SYS NULL) (ITER-002 VALUE))
               (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
                (CL:SETQ SYS (%%VALUE ITER-002))
                (GET-SYSTEM-DEFINITION
                 (%STRING-WRAPPER.WRAPPER-VALUE SYS) CL:T)
                (CL:WHEN
                 (CL:NOT
                  (SYSTEM-LOADED-OR-STARTED-UP?
                   (%STRING-WRAPPER.WRAPPER-VALUE SYS)))
                 (CL:LET*
                  ((CURRENTOPTIONS
                    (COPY
                     (CL:IF
                      (CL:NOT (CL:EQ *CURRENT-SYSTEM-ACTION* NULL))
                      *CURRENT-SYSTEM-ACTION* (NEW-PROPERTY-LIST))))
                   (CURRENTACTION
                    (LOOKUP-WITH-DEFAULT CURRENTOPTIONS
                     KWD-SYSTEMS-ACTION KWD-SYSTEMS-LOAD-SYSTEM))
                   (CURRENTLANGUAGE
                    (LOOKUP-WITH-DEFAULT CURRENTOPTIONS
                     KWD-SYSTEMS-LANGUAGE (RUNNING-IN-LANGUAGE))))
                  (INSERT-AT CURRENTOPTIONS KWD-SYSTEMS-ACTION
                   CURRENTACTION)
                  (INSERT-AT CURRENTOPTIONS KWD-SYSTEMS-LANGUAGE
                   CURRENTLANGUAGE)
                  (CL:COND
                   ((CL:EQ CURRENTACTION KWD-SYSTEMS-MAKE-SYSTEM)
                    (%%PRINT-STREAM
                     (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
                     "Making required system `" (UNWRAP-STRING SYS) "'"
                     EOL)
                    (%MAKE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE SYS)
                     (CONS-LIST KWD-SYSTEMS-OPTIONS CURRENTOPTIONS)))
                   (CL:T
                    (%%PRINT-STREAM
                     (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
                     "Loading required system `" (UNWRAP-STRING SYS)
                     "'" EOL)
                    (%LOAD-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE SYS)
                     (CONS-LIST KWD-SYSTEMS-OPTIONS
                      CURRENTOPTIONS))))))
                (CL:SETQ ITER-002 (%%REST ITER-002)))))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-LISP-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-CPP-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-JAVA-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DATA-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.DATA-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-PREPROCESSED-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.PREPROCESSED-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-CARDINAL-MODULE)
              (CL:SETF (%SYSTEM-DEFINITION.CARDINAL-MODULE SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-BINARY-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:OR (CL:EQ TEST-VALUE-001 KWD-SYSTEMS-BANNER)
               (CL:EQ TEST-VALUE-001 KWD-SYSTEMS-COPYRIGHT-HEADER))
              (CL:SETF (%SYSTEM-DEFINITION.BANNER SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-PRODUCTION-SETTINGS)
              (CL:SETF (%SYSTEM-DEFINITION.PRODUCTION-SETTINGS SYSTEM)
               VALUE))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DEVELOPMENT-SETTINGS)
              (CL:SETF (%SYSTEM-DEFINITION.DEVELOPMENT-SETTINGS SYSTEM)
               VALUE))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-FINALIZATION-FUNCTION)
              (CL:SETF
               (%SYSTEM-DEFINITION.FINALIZATION-FUNCTION SYSTEM)
               VALUE))
             (CL:T
              (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? SYSTEM KEY VALUE))
               (CL:LET* ((*PRINTREADABLY?* CL:T))
                (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                (SIGNAL-TRANSLATION-WARNING)
                (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
                 (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
                 (%%PRINT-STREAM
                  (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
                  " Skipping invalid system option `"
                  (DE-UGLIFY-PARSE-TREE KEY)
                  "' in the definition of system `"
                  (DE-UGLIFY-PARSE-TREE (WRAP-STRING STRINGNAME)) "'."
                  EOL)))))))
           (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
         (CL:WHEN
          (CL:EQ (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
           STELLA::NULL-STRING)
          (CL:SETF (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
           (%SYSTEM-DEFINITION.NAME SYSTEM)))
         (COMPUTE-SYSTEM-ROOT-DIRECTORIES SYSTEM)
         (PUSH *SYSTEMDEFINITIONS* SYSTEM)
         (CL:WHEN (CL:NOT (CL:EQ OLDSYSTEM NULL))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Redefining system `" (%SYSTEM-DEFINITION.NAME SYSTEM) "'"
           EOL EOL)
          (REMOVE *SYSTEMDEFINITIONS* OLDSYSTEM))
         (CL:RETURN-FROM DEFINE-SYSTEM SYSTEM)))))))))

;;; (DEFUN (DEFSYSTEM SYSTEM-DEFINITION) ...)

(CL:DEFUN %DEFSYSTEM (NAME OPTIONS)
  "Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java"
  (CL:RETURN-FROM %DEFSYSTEM (DEFINE-SYSTEM NAME OPTIONS)))

(CL:DEFUN DEFSYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DEFSYSTEM-EVALUATOR-WRAPPER
   (%DEFSYSTEM (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))))

(CL:DEFMACRO DEFSYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DEFSYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFSYSTEM)))

;;; (DEFUN (GET-SYSTEM-DEFINITION SYSTEM-DEFINITION) ...)

(CL:DEFUN GET-SYSTEM-DEFINITION (NAME ERROR?)
  "Return a system named 'name'.  If no such system is currently defined,
look for a system definition file for `name' in standard locations and try to load it.
If no matching system could be found or loaded and `error?' is true, raise an error,
otherwise, simply return NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((S NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ S (%%VALUE ITER-000))
     (CL:WHEN (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME S) NAME)
      (CL:SETQ VALUE-000 S) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((SYSTEM VALUE-000))
    (CL:WHEN (CL:EQ SYSTEM NULL)
     (CL:LET* ((SYSTEMFILE (FIND-SYSTEM-DEFINITION-FILE NAME)))
      (CL:WHEN (CL:EQ SYSTEMFILE STELLA::NULL-STRING)
       (CL:WHEN ERROR?
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "Cannot define system `" NAME
          "' since its system definition file cannot be found")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
       (CL:RETURN-FROM GET-SYSTEM-DEFINITION NULL))
      (%LOAD-FILE SYSTEMFILE)
      (CL:LET* ((VALUE-001 NULL))
       (CL:LET*
        ((S NULL) (ITER-001 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ S (%%VALUE ITER-001))
         (CL:WHEN (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME S) NAME)
          (CL:SETQ VALUE-001 S) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:SETQ SYSTEM VALUE-001))
      (CL:WHEN (CL:AND (CL:EQ SYSTEM NULL) ERROR?)
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "Cannot find a system definition for system `" NAME
         "' within file `" SYSTEMFILE "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:RETURN-FROM GET-SYSTEM-DEFINITION SYSTEM))))

;;; (DEFUN (GET-CARDINAL-MODULE MODULE) ...)

(CL:DEFUN GET-CARDINAL-MODULE (SYSTEM)
  (CL:LET*
   ((NAME (%SYSTEM-DEFINITION.CARDINAL-MODULE SYSTEM)) (MODULE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
    (CL:SETQ MODULE (GET-STELLA-MODULE NAME CL:NIL))
    (CL:WHEN (CL:EQ MODULE NULL)
     (CL:SETQ MODULE (GET-STELLA-MODULE (STRING-UPCASE NAME) CL:NIL))))
   (CL:WHEN (CL:EQ MODULE NULL)
    (CL:WARN "No cardinal module defined for system: `~A'~%" SYSTEM))
   (CL:RETURN-FROM GET-CARDINAL-MODULE MODULE)))

;;; (DEFUN HELP-GET-SYSTEM-FILES ...)

(CL:DEFUN HELP-GET-SYSTEM-FILES (FILENAME COLLECTION PROBEFILE?)
  (CL:WHEN (CL:OR (CL:NOT PROBEFILE?) (PROBE-FILE? FILENAME))
   (PUSH COLLECTION (WRAP-STRING FILENAME)))
  :VOID)

;;; (DEFUN (GET-SYSTEM-FILES (LIST OF STRING-WRAPPER)) ...)

(CL:DEFUN GET-SYSTEM-FILES (SYSTEM TYPE PROBEFILES?)
  (CL:LET* ((FILES (NEW-LIST)) (FILENAME STELLA::NULL-STRING))
   (CL:LET*
    ((*CURRENTSYSTEMDEFINITION*
      (GET-SYSTEM-DEFINITION (%SYSTEM-DEFINITION.NAME SYSTEM) CL:T))
     (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
    (CL:DECLARE
     (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
      *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:PROGN
     (CL:LET*
      ((F NULL)
       (ITER-000 (%SYSTEM-DEFINITION.FILES *CURRENTSYSTEMDEFINITION*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ F (%%VALUE ITER-000))
       (CL:COND
        ((CL:EQ TYPE KWD-SYSTEMS-JAVA)
         (CL:SETQ FILENAME
          (%STRING-WRAPPER.WRAPPER-VALUE
           (JAVA-TRANSLATE-CLASS-NAMESTRING
            (WRAP-STRING
             (CONCATENATE "_STARTUP-"
              (STRING-UPCASE (%STRING-WRAPPER.WRAPPER-VALUE F))))))))
        (CL:T
         (CL:SETQ FILENAME
          (MAKE-FILE-NAME-FROM-RELATIVE-PATH F TYPE))))
       (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:COND
      ((CL:EQ TYPE KWD-SYSTEMS-JAVA)
       (CL:WHEN
        (CL:EQ (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*) NULL)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "No cardinal module defined for system `"
         (%SYSTEM-DEFINITION.NAME SYSTEM) "'" EOL EOL)
        (CL:RETURN-FROM GET-SYSTEM-FILES NIL-LIST))
       (CL:LET*
        ((CLASS NULL)
         (ITER-001
          (ALL-CLASSES (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*)
           CL:T)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ CLASS (%ITERATOR.VALUE ITER-001))
         (CL:SETQ FILENAME
          (JAVA-MAKE-CODE-OUTPUT-FILE-NAME CLASS CL:NIL))
         (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?)))
       (CL:SETQ FILENAME
        (JAVA-MAKE-CODE-OUTPUT-FILE-NAME
         (JAVA-YIELD-FLOTSAM-CLASS-NAME
          (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))
         CL:NIL))
       (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?))
      (CL:T))))
   (CL:RETURN-FROM GET-SYSTEM-FILES FILES)))

;;; (DEFUN CLEAN-SYSTEM ...)

(CL:DEFUN CLEAN-SYSTEM (SYSTEMNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((SYSTEM (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T)))
   (CL:LET*
    ((F NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-LISP CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-000))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((F NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-JAVA CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-001))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((F NULL)
     (ITER-002
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-CPP CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-002))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:LET*
    ((F NULL)
     (ITER-003
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-LISP-BINARY CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-003))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-003 (%%REST ITER-003)))))
  :VOID)

;;; (DEFUN COMPUTE-OPTIMIZATION-LEVELS ...)

(CL:DEFUN COMPUTE-OPTIMIZATION-LEVELS (SYSTEM PRODUCTIONMODE?)
  (CL:LET* ((SETTINGS NULL))
   (CL:IF PRODUCTIONMODE?
    (CL:SETQ SETTINGS (%SYSTEM-DEFINITION.PRODUCTION-SETTINGS SYSTEM))
    (CL:SETQ SETTINGS
     (%SYSTEM-DEFINITION.DEVELOPMENT-SETTINGS SYSTEM)))
   (CL:WHEN (CL:EQ SETTINGS NULL)
    (CL:SETQ SETTINGS
     (GET-QUOTED-TREE "((3 2 3 3) \"/STELLA\")" "/STELLA")))
   (SET-OPTIMIZATION-LEVELS
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 0))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 1))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 2))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 3))))
  :VOID)

;;; (DEFSPECIAL *CURRENT-SYSTEM-ACTION* ...)

(CL:DEFVAR *CURRENT-SYSTEM-ACTION* NULL
  "Holds the action and options of the current system action
such as :make-system, :load-system or :translate-system.  This is used to
perform the appropriate actions on required systems in `define-system'.")

;;; (DEFUN (MAKE-SYSTEM BOOLEAN) ...)

(CL:DEFUN %MAKE-SYSTEM (SYSTEMNAME |LANGUAGE&OPTIONS|)
  "Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `make-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((OPTIONS |LANGUAGE&OPTIONS|))
   (CL:WHEN
    (CL:NOT
     (MEMBER?
      (GET-QUOTED-TREE "((:COMMON-LISP :CPP :JAVA) \"/STELLA\")"
       "/STELLA")
      (%%VALUE OPTIONS)))
    (CL:SETQ OPTIONS (CONS (RUNNING-IN-LANGUAGE) OPTIONS)))
   (CL:LET*
    ((THEOPTIONS
      (PARSE-OPTIONS (%%REST OPTIONS)
       (LIST* KWD-SYSTEMS-TWO-PASS? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-DEVELOPMENT-SETTINGS? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-PRODUCTION-SETTINGS? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-FORCE-TRANSLATION? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-FORCE-RECOMPILATION? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-LOAD-SYSTEM? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-STARTUP? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-RECURSIVE? SGT-SYSTEMS-STELLA-BOOLEAN
        KWD-SYSTEMS-LANGUAGE SGT-SYSTEMS-STELLA-KEYWORD
        KWD-SYSTEMS-ACTION SGT-SYSTEMS-STELLA-KEYWORD
        KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY SGT-SYSTEMS-STELLA-FILE-NAME
        KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY SGT-SYSTEMS-STELLA-FILE-NAME
        KWD-SYSTEMS-ROOT-BINARY-DIRECTORY SGT-SYSTEMS-STELLA-FILE-NAME
        KWD-SYSTEMS-PROCESSED SGT-SYSTEMS-STELLA-LIST NIL)
       CL:T CL:NIL))
     (LANGUAGE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-LANGUAGE
       (%%VALUE OPTIONS)))
     (TWOPASS?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-TWO-PASS?
        (CL:IF (CL:NOT (SYSTEM-LOADED-OR-STARTED-UP? SYSTEMNAME))
         TRUE-WRAPPER FALSE-WRAPPER))))
     (PRODUCTIONSETTINGS?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-PRODUCTION-SETTINGS?
        TRUE-WRAPPER)))
     (DEVELOPMENTSETTINGS?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS
        KWD-SYSTEMS-DEVELOPMENT-SETTINGS?
        (CL:IF (CL:NOT PRODUCTIONSETTINGS?) TRUE-WRAPPER
         FALSE-WRAPPER))))
     (FORCETRANSLATION?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-FORCE-TRANSLATION?
        FALSE-WRAPPER)))
     (FORCERECOMPILATION?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-FORCE-RECOMPILATION?
        FALSE-WRAPPER)))
     (LOADSYSTEM?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-LOAD-SYSTEM?
        (CL:IF (CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP) TRUE-WRAPPER
         FALSE-WRAPPER))))
     (RECURSIVE?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-RECURSIVE?
        FALSE-WRAPPER)))
     (PROCESSED
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-PROCESSED (LIST)))
     (STARTUPSYSTEM?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-STARTUP?
        (CL:IF (CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP) TRUE-WRAPPER
         FALSE-WRAPPER))))
     (ACTION
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-ACTION
       KWD-SYSTEMS-MAKE-SYSTEM))
     (UPDATEDSYSTEM? CL:NIL))
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-LANGUAGE LANGUAGE)
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-ACTION ACTION)
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-PROCESSED PROCESSED)
    (CL:LET* ((*CURRENT-SYSTEM-ACTION* THEOPTIONS))
     (CL:DECLARE (CL:SPECIAL *CURRENT-SYSTEM-ACTION*))
     (CL:LET*
      ((*CURRENTSYSTEMDEFINITION*
        (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
       (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
        (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
      (CL:DECLARE
       (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
        *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:DECLARE
       (CL:TYPE CL:SIMPLE-STRING
        *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:PROGN (INSERT-NEW PROCESSED (WRAP-STRING SYSTEMNAME))
       (CL:WHEN
        (CL:AND RECURSIVE?
         (CL:NOT
          (CL:EQ
           (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
            *CURRENTSYSTEMDEFINITION*)
           NULL)))
        (CL:LET*
         ((REQSYS NULL)
          (ITER-000
           (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
            *CURRENTSYSTEMDEFINITION*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ REQSYS (%%VALUE ITER-000))
          (CL:WHEN (CL:NOT (MEMBER? PROCESSED REQSYS))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "Making required system `" (UNWRAP-STRING REQSYS) "'" EOL)
           (%MAKE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE REQSYS)
            (CONS-LIST KWD-SYSTEMS-OPTIONS THEOPTIONS)))
          (CL:SETQ ITER-000 (%%REST ITER-000)))))
       (CL:WHEN
        (CL:OR FORCERECOMPILATION?
         (CL:AND (CL:NOT (SYSTEM-LOADED-OR-STARTED-UP? SYSTEMNAME))
          (CL:OR FORCETRANSLATION?
           (SYSTEM-NEEDS-TRANSLATION? SYSTEMNAME LANGUAGE))))
        (LOAD-PREPROCESSED-FILES SYSTEMNAME))
       (CL:SETQ UPDATEDSYSTEM?
        (%TRANSLATE-SYSTEM SYSTEMNAME
         (CONS-LIST LANGUAGE KWD-SYSTEMS-TWO-PASS?
          (CL:IF TWOPASS? TRUE-WRAPPER FALSE-WRAPPER)
          KWD-SYSTEMS-FORCE-TRANSLATION?
          (CL:IF FORCETRANSLATION? TRUE-WRAPPER FALSE-WRAPPER)
          KWD-SYSTEMS-DEVELOPMENT-SETTINGS?
          (CL:IF DEVELOPMENTSETTINGS? TRUE-WRAPPER FALSE-WRAPPER)
          KWD-SYSTEMS-RECURSIVE?
          (CL:IF RECURSIVE? TRUE-WRAPPER FALSE-WRAPPER)
          KWD-SYSTEMS-PROCESSED
          (LOOKUP THEOPTIONS KWD-SYSTEMS-PROCESSED)
          KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY
          (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY)
          KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY
          (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY)
          KWD-SYSTEMS-ROOT-BINARY-DIRECTORY
          (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-BINARY-DIRECTORY))))
       (CL:WHEN
        (CL:AND LOADSYSTEM?
         (%LOAD-SYSTEM SYSTEMNAME
          (CONS-LIST LANGUAGE KWD-SYSTEMS-FORCE-RECOMPILATION?
           (CL:IF FORCERECOMPILATION? TRUE-WRAPPER FALSE-WRAPPER)
           KWD-SYSTEMS-STARTUP?
           (CL:IF STARTUPSYSTEM? TRUE-WRAPPER FALSE-WRAPPER)
           KWD-SYSTEMS-RECURSIVE?
           (CL:IF RECURSIVE? TRUE-WRAPPER FALSE-WRAPPER)
           KWD-SYSTEMS-PROCESSED
           (LOOKUP THEOPTIONS KWD-SYSTEMS-PROCESSED)
           KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY
           (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY)
           KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY
           (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY)
           KWD-SYSTEMS-ROOT-BINARY-DIRECTORY
           (LOOKUP THEOPTIONS KWD-SYSTEMS-ROOT-BINARY-DIRECTORY))))
        (CL:SETQ UPDATEDSYSTEM? CL:T)))))
    (CL:RETURN-FROM %MAKE-SYSTEM UPDATEDSYSTEM?))))

(CL:DEFUN MAKE-SYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM MAKE-SYSTEM-EVALUATOR-WRAPPER
   (CL:IF
    (%MAKE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
     (%%REST ARGUMENTS))
    TRUE-WRAPPER FALSE-WRAPPER)))

(CL:DEFMACRO MAKE-SYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `make-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/MAKE-SYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE MAKE-SYSTEM)))

;;; (DEFUN RUN-SYSTEM-FINALIZATION ...)

(CL:DEFUN RUN-SYSTEM-FINALIZATION (SYSTEM)
  (CL:SETQ SYSTEM SYSTEM)
  (CL:LET* ((FNNAME STELLA::NULL-STRING) (FINALIZATIONFN NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FNNAME))
   (CL:WHEN (CL:NOT (CL:EQ FNNAME STELLA::NULL-STRING))
    (CL:SETQ FINALIZATIONFN (LOOKUP-FUNCTION-BY-NAME FNNAME)))
   (CL:WHEN (CL:NOT (CL:EQ FINALIZATIONFN NULL))
    (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE FINALIZATIONFN))))
  :VOID)

;;; (DEFUN (SYSTEM-DEFINITION-SOURCE-FILES (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN SYSTEM-DEFINITION-SOURCE-FILES (SYSTEM)
  (CL:LET* ((FILES (COPY-CONS-LIST (%SYSTEM-DEFINITION.FILES SYSTEM))))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-JAVA)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-CPP)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM SYSTEM-DEFINITION-SOURCE-FILES FILES)))

;;; (DEFUN (FILES-PLUS-SYSTEM-STARTUP (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN FILES-PLUS-SYSTEM-STARTUP (FILES)
  (CL:RETURN-FROM FILES-PLUS-SYSTEM-STARTUP
   (CONCATENATE FILES
    (CONS-LIST (WRAP-STRING (SYSTEM-STARTUP-FILE-NAME NULL))))))

;;; (DEFUN (SYSTEM-DEFINITION-NATIVE-FILES (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN SYSTEM-DEFINITION-NATIVE-FILES (SYSTEM)
  (CL:LET* ((FILES (COPY-CONS-LIST (%SYSTEM-DEFINITION.FILES SYSTEM))))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:WHEN
      (MEMB? *CURRENT-STELLA-FEATURES*
       KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS)
      (CL:SETQ FILES
       (CONS
        (WRAP-STRING
         (CL-YIELD-STRUCT-CLASS-FILE-NAME
          (%SYSTEM-DEFINITION.NAME SYSTEM)))
        FILES))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-JAVA)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-CPP)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM SYSTEM-DEFINITION-NATIVE-FILES FILES)))

;;; (DEFUN (SYSTEM-LOADED? BOOLEAN) ...)

(CL:DEFUN SYSTEM-LOADED? (NAME)
  "Return `true' if system `name' has been loaded."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (STRING-EQUAL? NAME "STELLA") (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SYS NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYS) NAME)
         (%SYSTEM-DEFINITION.LOADED? SYS))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM SYSTEM-LOADED? VALUE-000))))

;;; (DEFUN (SYSTEM-LOADED-OR-STARTED-UP? BOOLEAN) ...)

(CL:DEFUN SYSTEM-LOADED-OR-STARTED-UP? (NAME)
  "Return `true' if system `name' has either been loaded
or initialized with its startup function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (STRING-EQUAL? NAME "STELLA") (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SYS NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYS) NAME)
         (CL:OR (%SYSTEM-DEFINITION.LOADED? SYS)
          (SYSTEM-STARTED-UP? (%SYSTEM-DEFINITION.NAME SYS)
           (%SYSTEM-DEFINITION.CARDINAL-MODULE SYS))))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM SYSTEM-LOADED-OR-STARTED-UP? VALUE-000))))

;;; (DEFUN CLEAR-SYSTEM ...)

(CL:DEFUN CLEAR-SYSTEM (NAME)
  "Clears out the system definition named `name'.  If
`name' is `null', then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:IF (CL:EQ NAME STELLA::NULL-STRING)
   (CL:SETQ *SYSTEMDEFINITIONS* (NEW-LIST))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((S NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ S (%%VALUE ITER-000))
      (CL:WHEN (STRING-EQL? (%SYSTEM-DEFINITION.NAME S) NAME)
       (CL:SETQ VALUE-000 S) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((SYS VALUE-000))
     (CL:WHEN (CL:NOT (CL:EQ SYS NULL))
      (REMOVE *SYSTEMDEFINITIONS* SYS)))))
  :VOID)

;;; (DEFUN LOAD-PREPROCESSED-FILES ...)

(CL:DEFUN LOAD-PREPROCESSED-FILES (SYSTEMNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:OR (CL:NOT (RUNNING-AS-LISP?))
    (CL:EQ
     (%SYSTEM-DEFINITION.PREPROCESSED-FILES
      (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
     NULL))
   (CL:RETURN-FROM LOAD-PREPROCESSED-FILES))
  (CL:LET* ((*TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP))
   (CL:DECLARE (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE*))
   (CL:LET*
    ((*CURRENTSYSTEMDEFINITION*
      (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
     (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
    (CL:DECLARE
     (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
      *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:PROGN
     (CL:LET* ((PREPROCESSEDFILES NIL))
      (CL:LET*
       ((F NULL)
        (ITER-000
         (%SYSTEM-DEFINITION.PREPROCESSED-FILES
          *CURRENTSYSTEMDEFINITION*))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ F (%%VALUE ITER-000))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS
            (WRAP-STRING
             (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
              KWD-SYSTEMS-STELLA CL:T))
            NIL))
          (CL:IF (CL:EQ PREPROCESSEDFILES NIL)
           (CL:SETQ PREPROCESSEDFILES COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST PREPROCESSEDFILES
            COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS
            (WRAP-STRING
             (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
              KWD-SYSTEMS-STELLA CL:T))
            NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:LET*
       ((*CURRENT-STELLA-FEATURES* (COPY *CURRENT-STELLA-FEATURES*)))
       (CL:DECLARE (CL:SPECIAL *CURRENT-STELLA-FEATURES*))
       (%UNSET-STELLA-FEATURE
        (CONS-LIST KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS))
       (CL:LET* ((F NULL) (ITER-001 PREPROCESSEDFILES))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ F (%%VALUE ITER-001))
         (TRANSLATE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F)
          *TRANSLATOROUTPUTLANGUAGE* CL:NIL)
         (CL:SETQ ITER-001 (%%REST ITER-001)))))
      (COMPILE-AND-LOAD-FILES
       (%SYSTEM-DEFINITION.PREPROCESSED-FILES
        *CURRENTSYSTEMDEFINITION*)
       *TRANSLATOROUTPUTLANGUAGE* CL:NIL)
      (CL:WHEN
       (MEMB? *CURRENT-STELLA-FEATURES*
        KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS)
       (CL:LET*
        ((F NULL)
         (ITER-002
          (%SYSTEM-DEFINITION.PREPROCESSED-FILES
           *CURRENTSYSTEMDEFINITION*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
         (CL:SETQ F (%%VALUE ITER-002))
         (DELETE-FILE
          (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
           KWD-SYSTEMS-LISP CL:T))
         (CL:SETQ ITER-002 (%%REST ITER-002)))))
      (CL:LET*
       ((STARTUPFN NULL)
        (ITER-003
         (STARTUP-NAMES-FROM-FILES
          (%SYSTEM-DEFINITION.PREPROCESSED-FILES
           *CURRENTSYSTEMDEFINITION*))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:SETQ STARTUPFN (%%VALUE ITER-003))
        (CL:funcall (lispify startupFn))
        (CL:SETQ ITER-003 (%%REST ITER-003))))))))
  :VOID)

;;; (DEFUN (LOAD-SYSTEM BOOLEAN) ...)

(CL:DEFUN %LOAD-SYSTEM (SYSTEMNAME |LANGUAGE&OPTIONS|)
  "Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `load-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((OPTIONS |LANGUAGE&OPTIONS|))
   (CL:WHEN
    (CL:NOT
     (MEMBER?
      (GET-QUOTED-TREE "((:COMMON-LISP :CPP :JAVA) \"/STELLA\")"
       "/STELLA")
      (%%VALUE OPTIONS)))
    (CL:SETQ OPTIONS (CONS (RUNNING-IN-LANGUAGE) OPTIONS)))
   (CL:LET*
    ((THEOPTIONS
      (PARSE-OPTIONS (%%REST OPTIONS)
       (LIST* KWD-SYSTEMS-FORCE-RECOMPILATION?
        SGT-SYSTEMS-STELLA-BOOLEAN KWD-SYSTEMS-STARTUP?
        SGT-SYSTEMS-STELLA-BOOLEAN KWD-SYSTEMS-RECURSIVE?
        SGT-SYSTEMS-STELLA-BOOLEAN KWD-SYSTEMS-LANGUAGE
        SGT-SYSTEMS-STELLA-KEYWORD KWD-SYSTEMS-ACTION
        SGT-SYSTEMS-STELLA-KEYWORD KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY
        SGT-SYSTEMS-STELLA-FILE-NAME KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY
        SGT-SYSTEMS-STELLA-FILE-NAME KWD-SYSTEMS-ROOT-BINARY-DIRECTORY
        SGT-SYSTEMS-STELLA-FILE-NAME KWD-SYSTEMS-PROCESSED
        SGT-SYSTEMS-STELLA-LIST NIL)
       CL:T CL:T))
     (LANGUAGE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-LANGUAGE
       (%%VALUE OPTIONS)))
     (FORCERECOMPILATION?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-FORCE-RECOMPILATION?
        FALSE-WRAPPER)))
     (STARTUPSYSTEM?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-STARTUP?
        TRUE-WRAPPER)))
     (RECURSIVE?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-RECURSIVE?
        FALSE-WRAPPER)))
     (PROCESSED
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-PROCESSED (LIST)))
     (ACTION
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-ACTION
       KWD-SYSTEMS-LOAD-SYSTEM))
     (TRANSLATEDFILE? CL:NIL))
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-LANGUAGE LANGUAGE)
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-ACTION ACTION)
    (INSERT-AT THEOPTIONS KWD-SYSTEMS-PROCESSED PROCESSED)
    (CL:LET* ((*CURRENT-SYSTEM-ACTION* THEOPTIONS))
     (CL:DECLARE (CL:SPECIAL *CURRENT-SYSTEM-ACTION*))
     (CL:LET*
      ((*CURRENTSYSTEMDEFINITION*
        (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
       (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
        (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
      (CL:DECLARE
       (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
        *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:DECLARE
       (CL:TYPE CL:SIMPLE-STRING
        *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
      (CL:PROGN
       (CL:WHEN (%SYSTEM-DEFINITION.LOADED? *CURRENTSYSTEMDEFINITION*)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Loading system `" SYSTEMNAME "' over top of itself" EOL))
       (INSERT-NEW PROCESSED (WRAP-STRING SYSTEMNAME))
       (CL:WHEN
        (CL:AND RECURSIVE?
         (CL:NOT
          (CL:EQ
           (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
            *CURRENTSYSTEMDEFINITION*)
           NULL)))
        (CL:LET*
         ((REQSYS NULL)
          (ITER-000
           (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
            *CURRENTSYSTEMDEFINITION*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ REQSYS (%%VALUE ITER-000))
          (CL:WHEN (CL:NOT (MEMBER? PROCESSED REQSYS))
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
            "Loading required system `" (UNWRAP-STRING REQSYS) "'" EOL)
           (%LOAD-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE REQSYS)
            (CONS-LIST KWD-SYSTEMS-OPTIONS THEOPTIONS)))
          (CL:SETQ ITER-000 (%%REST ITER-000)))))
       (CL:WHEN (RUNNING-AS-LISP?)
        (CL:SETQ TRANSLATEDFILE?
         (COMPILE-AND-LOAD-FILES
          (FILES-PLUS-SYSTEM-STARTUP
           (SYSTEM-DEFINITION-NATIVE-FILES *CURRENTSYSTEMDEFINITION*))
          LANGUAGE FORCERECOMPILATION?)))
       (CL:SETF (%SYSTEM-DEFINITION.LOADED? *CURRENTSYSTEMDEFINITION*)
        CL:T)
       (CL:WHEN STARTUPSYSTEM?
        (RUN-SYSTEM-STARTUP-FUNCTION *CURRENTSYSTEMDEFINITION*))))
     (CL:RETURN-FROM %LOAD-SYSTEM TRANSLATEDFILE?)))))

(CL:DEFUN LOAD-SYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM LOAD-SYSTEM-EVALUATOR-WRAPPER
   (CL:IF
    (%LOAD-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
     (%%REST ARGUMENTS))
    TRUE-WRAPPER FALSE-WRAPPER)))

(CL:DEFMACRO LOAD-SYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `load-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-SYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-SYSTEM)))

;;; (DEFUN (COMPILE-AND-LOAD-FILES BOOLEAN) ...)

(CL:DEFUN COMPILE-AND-LOAD-FILES (FILES LANGUAGE FORCERECOMPILATION?)
  (CL:COND
   ((CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP)
    (CL:RETURN-FROM COMPILE-AND-LOAD-FILES
     (CL-COMPILE-AND-LOAD-FILES FILES CL:T FORCERECOMPILATION?)))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "'compile-and-load-files' NOT IMPLEMENTED FOR " LANGUAGE EOL)
    (CL:RETURN-FROM COMPILE-AND-LOAD-FILES CL:NIL))))

;;; (DEFUN RUN-SYSTEM-STARTUP-FUNCTION ...)

(CL:DEFUN RUN-SYSTEM-STARTUP-FUNCTION (SYSTEM)
  (CL:LET* ((STARTUPFNSYMBOL (SYSTEM-STARTUP-FUNCTION-SYMBOL SYSTEM)))
   (CL:FUNCALL (LISPIFY STARTUPFNSYMBOL)))
  :VOID)

;;; (DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ...)

(CL:DEFMETHOD SYSTEM-STARTUP-FUNCTION-NAME ((SYSTEM SYSTEM-DEFINITION))
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-NAME
   (SYSTEM-STARTUP-FUNCTION-NAME (%SYSTEM-DEFINITION.NAME SYSTEM))))

;;; (DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ...)

(CL:DEFMETHOD SYSTEM-STARTUP-FUNCTION-NAME ((SYSTEMNAME CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-NAME
   (CONCATENATE "STARTUP-" (STRING-UPCASE SYSTEMNAME) "-SYSTEM")))

;;; (DEFUN (SYSTEM-STARTUP-FUNCTION-SYMBOL SYMBOL) ...)

(CL:DEFUN SYSTEM-STARTUP-FUNCTION-SYMBOL (SYSTEM)
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-SYMBOL
   (INTERN-SYMBOL-IN-MODULE (SYSTEM-STARTUP-FUNCTION-NAME SYSTEM)
    (GET-CARDINAL-MODULE SYSTEM) CL:T)))

;;; (DEFUN (STARTUP-NAME-FROM-FILE SYMBOL) ...)

(CL:DEFUN STARTUP-NAME-FROM-FILE (FILE)
  (CL:WHEN
   (CL:NOT (PROBE-FILE? (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "STELLA source file `"
     (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T) "' does not exist")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((LONGNAME (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T))
    (SAVEDMODULE *MODULE*) (SEENINMODULE? CL:NIL) (UNUSED? CL:NIL)
    (STARTUPFNNAME NULL))
   (CL:LET* ((INPUTSTREAM NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ INPUTSTREAM (OPEN-INPUT-FILE LONGNAME))
      (CL:LET* ((*TRANSIENTOBJECTS?* CL:T))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:LET* ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM)))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
         (CL:LET* ((*TRANSIENTOBJECTS?* CL:NIL))
          (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
          (CL:COND
           ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
            (CL:PROGN
             (CL:MULTIPLE-VALUE-SETQ (UNUSED? SEENINMODULE?)
              (HANDLE-IN-MODULE-TREE TREE SEENINMODULE? CL:T))
             (CL:SETQ UNUSED? UNUSED?)
             (CL:WHEN SEENINMODULE?
              (CL:SETQ STARTUPFNNAME
               (YIELD-STARTUP-FUNCTION-NAME FILE))
              (CHANGE-MODULE SAVEDMODULE)
              (CL:RETURN-FROM STARTUP-NAME-FROM-FILE STARTUPFNNAME))))
           (CL:T)))))))
     (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
   (CL:WARN "Missing IN-MODULE declaration for file `~A'~%" FILE))
  (CL:RETURN-FROM STARTUP-NAME-FROM-FILE NULL))

;;; (DEFUN (STARTUP-NAMES-FROM-FILES (CONS OF SYMBOL)) ...)

(CL:DEFUN STARTUP-NAMES-FROM-FILES (FILES)
  (CL:LET* ((NAMES NIL))
   (CL:LET* ((F NULL) (ITER-000 FILES) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
         NIL))
       (CL:IF (CL:EQ NAMES NIL) (CL:SETQ NAMES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST NAMES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM STARTUP-NAMES-FROM-FILES NAMES)))

;;; (DEFUN (SYSTEM-STARTUP-FILE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  SYSTEM-STARTUP-FILE-NAME))
(CL:DEFUN SYSTEM-STARTUP-FILE-NAME (SYSTEM)
  (CL:WHEN (CL:EQ SYSTEM NULL)
   (CL:SETQ SYSTEM *CURRENTSYSTEMDEFINITION*))
  (CL:IF (CL:NOT (CL:EQ SYSTEM NULL))
   (CL:RETURN-FROM SYSTEM-STARTUP-FILE-NAME "startup-system")
   (CL:RETURN-FROM SYSTEM-STARTUP-FILE-NAME STELLA::NULL-STRING)))

;;; (DEFUN (SYSTEM-STARTUP-FILE? BOOLEAN) ...)

(CL:DEFUN SYSTEM-STARTUP-FILE? (FILE)
  (CL:WHEN (CL:EQ FILE STELLA::NULL-STRING)
   (CL:SETQ FILE *CURRENTFILENAME*))
  (CL:RETURN-FROM SYSTEM-STARTUP-FILE?
   (CL:AND (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
    (STRING-EQL? (FILE-BASE-NAME FILE)
     (SYSTEM-STARTUP-FILE-NAME NULL)))))

;;; (DEFUN (SYSTEM-STARTED-UP? BOOLEAN) ...)

(CL:DEFUN SYSTEM-STARTED-UP? (SYSTEMNAME SYSTEMMODULENAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME SYSTEMMODULENAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SYSTEMMODULENAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ *FUNCTION-LOOKUP-TABLE* NULL)
   (CL:RETURN-FROM SYSTEM-STARTED-UP? CL:NIL))
  (CL:WHEN (STRING-EQUAL? SYSTEMNAME "STELLA")
   (CL:RETURN-FROM SYSTEM-STARTED-UP?
    (CL:NOT (CL:EQ *FUNCTION-LOOKUP-TABLE* NULL))))
  (CL:WHEN (CL:EQ (GET-STELLA-MODULE SYSTEMMODULENAME CL:NIL) NULL)
   (CL:RETURN-FROM SYSTEM-STARTED-UP? CL:NIL))
  (CL:LET*
   ((STARTUPFUNCTIONSYMBOL
     (LOOKUP-SYMBOL-IN-MODULE (SYSTEM-STARTUP-FUNCTION-NAME SYSTEMNAME)
      (GET-STELLA-MODULE SYSTEMMODULENAME CL:NIL) CL:T))
    (STARTUPFUNCTION
     (CL:IF (CL:NOT (CL:EQ STARTUPFUNCTIONSYMBOL NULL))
      (LOOKUP-FUNCTION STARTUPFUNCTIONSYMBOL) NULL)))
   (CL:RETURN-FROM SYSTEM-STARTED-UP?
    (CL:AND (CL:NOT (CL:EQ STARTUPFUNCTION NULL))
     (CL:NOT
      (CL:EQ (%METHOD-SLOT.FUNCTION-CODE STARTUPFUNCTION) NULL))))))

;;; (DEFUN (YIELD-STARTUP-REQUIRED-SYSTEMS CONS) ...)

(CL:DEFUN YIELD-STARTUP-REQUIRED-SYSTEMS (SYSTEM)
  (CL:LET* ((STARTUPFORMS NIL))
   (CL:LET*
    ((SYSTEMNAME NULL)
     (ITER-000 (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYSTEMNAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-UNLESS
          (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? SYSTEMNAME
           (CONS
            (WRAP-STRING
             (%MODULE.MODULE-FULL-NAME
              (GET-CARDINAL-MODULE
               (GET-SYSTEM-DEFINITION
                (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME) CL:T))))
            NIL))
          (CONS
           (SYSTEM-STARTUP-FUNCTION-SYMBOL
            (GET-SYSTEM-DEFINITION
             (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME) CL:T))
           NIL)
          NIL)
         NIL))
       (CL:IF (CL:EQ STARTUPFORMS NIL)
        (CL:SETQ STARTUPFORMS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFORMS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-UNLESS
          (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? SYSTEMNAME
           (CONS
            (WRAP-STRING
             (%MODULE.MODULE-FULL-NAME
              (GET-CARDINAL-MODULE
               (GET-SYSTEM-DEFINITION
                (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME) CL:T))))
            NIL))
          (CONS
           (SYSTEM-STARTUP-FUNCTION-SYMBOL
            (GET-SYSTEM-DEFINITION
             (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME) CL:T))
           NIL)
          NIL)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-STARTUP-REQUIRED-SYSTEMS
    (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
     KWD-SYSTEMS-EARLY-INITS (CONCATENATE STARTUPFORMS NIL)))))

;;; (DEFUN (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (CONS OF CONS)) ...)

(CL:DEFUN COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (SYSTEM)
  (CL:LET*
   ((SYSTEMFILENAME (%SYSTEM-DEFINITION.DEFINITION-FILE SYSTEM))
    (MODULE NULL) (STARTUPFORM NULL) (STARTUPFORMS NIL))
   (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((INPUTSTREAM NULL))
     (CL:UNWIND-PROTECT
      (CL:PROGN (CL:SETQ INPUTSTREAM (OPEN-INPUT-FILE SYSTEMFILENAME))
       (CL:LET*
        ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
         (CL:TAGBODY (CL:SETQ STARTUPFORM NULL)
          (CL:COND
           ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
            (CL:PROGN
             (CL:WHEN
              (CL:EQ (%%VALUE TREE) SYM-SYSTEMS-STELLA-DEFMODULE)
              (%EVALUATE TREE)
              (CL:SETQ MODULE
               (GET-STELLA-MODULE
                (COERCE-TO-MODULE-NAME (%%VALUE (%%REST TREE)) CL:T)
                CL:T))
              (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
               (CL:SETQ STARTUPFORM
                (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
                 KWD-SYSTEMS-MODULES (YIELD-DEFINE-MODULE MODULE)
                 NIL))))
             (CL:WHEN
              (CL:EQ (%%VALUE TREE) SYM-SYSTEMS-STELLA-IN-MODULE)
              (%EVALUATE TREE))))
           (CL:T))
          (CL:WHEN (CL:EQ STARTUPFORM NULL) (CL:GO :CONTINUE))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS STARTUPFORM NIL))
            (CL:IF (CL:EQ STARTUPFORMS NIL)
             (CL:SETQ STARTUPFORMS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFORMS COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000) (CONS STARTUPFORM NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          :CONTINUE))))
      (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
    (CL:RETURN-FROM COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE
     STARTUPFORMS))))

;;; (DEFUN (COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE (CONS OF MODULE)) ...)

(CL:DEFUN COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE (SYSTEM)
  (CL:LET*
   ((STARTUPFORMS (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE SYSTEM))
    (MODULE NULL) (MODULES NIL))
   (CL:LET* ((FORM NULL) (ITER-000 STARTUPFORMS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FORM (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%%VALUE (%%REST FORM)) KWD-SYSTEMS-MODULES)
      (CL:LET* ((DEF NULL) (ITER-001 (%%REST (%%REST FORM))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ DEF (%%VALUE ITER-001))
        (CL:WHEN
         (CL:AND (CONS? DEF)
          (CL:EQ (%%VALUE DEF)
           SYM-SYSTEMS-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE))
         (CL:SETQ MODULE
          (GET-STELLA-MODULE
           (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST DEF)))
           CL:NIL))
         (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
          (CL:SETQ MODULES (CONS MODULE MODULES))))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE
    (REVERSE MODULES))))

;;; (DEFUN CREATE-SYSTEM-STARTUP-FILE ...)

(CL:DEFUN CREATE-SYSTEM-STARTUP-FILE (SYSTEM)
  (CL:WHEN (CL:EQ *CURRENTSYSTEMDEFINITION* NULL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Must be within a system environment to create startup file " EOL
    "   for system `" (%SYSTEM-DEFINITION.NAME SYSTEM) "'." EOL EOL)
   (CL:RETURN-FROM CREATE-SYSTEM-STARTUP-FILE))
  (CL:LET*
   ((*MODULE* (GET-CARDINAL-MODULE SYSTEM)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((FILE
      (MAKE-FILE-NAME (SYSTEM-STARTUP-FILE-NAME SYSTEM)
       KWD-SYSTEMS-STELLA CL:T))
     (STARTUPFNNAMES NIL) (STARTUPFORMS NIL))
    (CL:LET* ((OUTPUTSTREAM NULL))
     (CL:UNWIND-PROTECT
      (CL:PROGN (CL:SETQ OUTPUTSTREAM (OPEN-OUTPUT-FILE FILE))
       (CL:LET*
        ((F NULL) (ITER-000 (SYSTEM-DEFINITION-SOURCE-FILES SYSTEM))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ F (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS
             (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
             NIL))
           (CL:IF (CL:EQ STARTUPFNNAMES NIL)
            (CL:SETQ STARTUPFNNAMES COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFNNAMES COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS
             (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL-OUTPUT-FILE-HEADER OUTPUTSTREAM FILE CL:NIL)
       (CL:SETQ STARTUPFORMS
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-IN-MODULE
          (WRAP-STRING
           (%MODULE.MODULE-FULL-NAME (GET-CARDINAL-MODULE SYSTEM)))
          NIL)
         STARTUPFORMS))
       (CL:SETQ STARTUPFORMS
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-DEFUN
          (SYSTEM-STARTUP-FUNCTION-SYMBOL SYSTEM)
          (LIST* NIL KWD-SYSTEMS-PUBLIC? SYM-SYSTEMS-STELLA-TRUE NIL))
         STARTUPFORMS))
       (CL:COND
        ((STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYSTEM) "STELLA")
         (CL:SETQ STARTUPFORMS
          (CONS
           (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
            KWD-SYSTEMS-EARLY-INITS
            (LIST* SYM-SYSTEMS-STELLA-UNLESS
             (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP?
              (WRAP-STRING "stella") (WRAP-STRING "/STELLA") NIL)
             (LIST* SYM-SYSTEMS-STELLA-STARTUP SYM-SYSTEMS-STELLA-FALSE
              NIL)
             NIL)
            NIL)
           STARTUPFORMS)))
        (CL:T
         (CL:WHEN
          (CL:NOT
           (CL:EQ (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM) NULL))
          (CL:SETQ STARTUPFORMS
           (CONS (YIELD-STARTUP-REQUIRED-SYSTEMS SYSTEM)
            STARTUPFORMS)))
         (CL:LET*
          ((FORM NULL)
           (ITER-001 (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE SYSTEM)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ FORM (%%VALUE ITER-001))
           (CL:SETQ STARTUPFORMS (CONS FORM STARTUPFORMS))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:LET* ((STARTUPFN NULL) (ITER-002 STARTUPFNNAMES))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:SETQ STARTUPFN (%%VALUE ITER-002))
           (CL:WHEN (CL:EQ (LOOKUP-FUNCTION STARTUPFN) NULL)
            (CL:LET*
             ((*MODULE* (HOME-MODULE STARTUPFN)) (*CONTEXT* *MODULE*))
             (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
             (DEFINE-METHOD-FROM-PARSE-TREE
              (LIST* SYM-SYSTEMS-STELLA-DEFUN STARTUPFN
               (LIST* NIL KWD-SYSTEMS-PUBLIC? SYM-SYSTEMS-STELLA-TRUE
                NIL)))))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:LET* ((STARTUPFNCALLS NIL))
          (CL:LET*
           ((STARTUPFN NULL) (ITER-003 STARTUPFNNAMES)
            (COLLECT-001 NULL))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:SETQ STARTUPFN (%%VALUE ITER-003))
            (CL:IF (CL:EQ COLLECT-001 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-001 (CONS (CONS STARTUPFN NIL) NIL))
              (CL:IF (CL:EQ STARTUPFNCALLS NIL)
               (CL:SETQ STARTUPFNCALLS COLLECT-001)
               (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFNCALLS
                COLLECT-001)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-001)
               (CONS (CONS STARTUPFN NIL) NIL))
              (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
            (CL:SETQ ITER-003 (%%REST ITER-003))))
          (CL:SETQ STARTUPFORMS
           (CONS
            (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
             (LIST* SYM-SYSTEMS-STELLA-FOREACH SYM-SYSTEMS-STELLA-PHASE
              SYM-SYSTEMS-STELLA-IN
              (LIST* SYM-SYSTEMS-STELLA-INTERVAL
               (LIST* SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
                KWD-SYSTEMS-EARLY-INITS NIL)
               (LIST* SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
                KWD-SYSTEMS-FINAL NIL)
               NIL)
              SYM-SYSTEMS-STELLA-DO
              (LIST* SYM-SYSTEMS-STELLA-SETQ
               SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
               SYM-SYSTEMS-STELLA-PHASE NIL)
              (CONCATENATE STARTUPFNCALLS NIL))
             (LIST* SYM-SYSTEMS-STELLA-SETQ
              SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
              (WRAP-INTEGER 999) NIL)
             NIL)
            STARTUPFORMS)))))
       (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
        (CL:LET* ((FORM NULL) (ITER-004 (REVERSE STARTUPFORMS)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:SETQ FORM (%%VALUE ITER-004))
          (%%PRINT-STREAM
           (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUTPUTSTREAM) FORM EOL
           EOL)
          (CL:SETQ ITER-004 (%%REST ITER-004))))))
      (CL:WHEN (CL:NOT (CL:EQ OUTPUTSTREAM NULL))
       (FREE OUTPUTSTREAM))))))
  :VOID)

;;; (DEFUN (HELP-ALL-REQUIRED-SYSTEMS (LIST OF STRING-WRAPPER)) ...)

(CL:DEFUN HELP-ALL-REQUIRED-SYSTEMS (SYSTEM-NAME FOUND)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEM-NAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEM-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SYSTEM (GET-SYSTEM-DEFINITION SYSTEM-NAME CL:T)))
   (CL:LET*
    ((REQUIRED-SYSTEM-NAMES
      (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM)))
    (CL:WHEN (CL:NOT (CL:EQ REQUIRED-SYSTEM-NAMES NULL))
     (CL:LET* ((SYS NULL) (ITER-000 REQUIRED-SYSTEM-NAMES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN (CL:NOT (MEMBER? FOUND SYS))
        (HELP-ALL-REQUIRED-SYSTEMS (%STRING-WRAPPER.WRAPPER-VALUE SYS)
         FOUND)
        (PUSH FOUND SYS))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:RETURN-FROM HELP-ALL-REQUIRED-SYSTEMS FOUND))))

;;; (DEFUN (ALL-REQUIRED-SYSTEMS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN ALL-REQUIRED-SYSTEMS (SYSTEM-NAME)
  "Returns a CONS of all of the systems required by `system-name'"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEM-NAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEM-NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM ALL-REQUIRED-SYSTEMS
   (%LIST.THE-CONS-LIST
    (HELP-ALL-REQUIRED-SYSTEMS SYSTEM-NAME (NEW-LIST)))))

;;; (DEFUN (DATE-TO-VERSION-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  DATE-TO-VERSION-STRING))
(CL:DEFUN DATE-TO-VERSION-STRING (DATE GRANULARITY)
  "Transform `date' into a version string according to `granularity'
which is at least :days and defaults to :seconds."
  (CL:LET* ((FORMATSTRING "%Y.%m.%d.%H%M%S"))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FORMATSTRING))
   (CL:COND
    ((CL:EQ GRANULARITY KWD-SYSTEMS-DAYS)
     (CL:SETQ FORMATSTRING "%Y.%m.%d"))
    ((CL:EQ GRANULARITY KWD-SYSTEMS-HOURS)
     (CL:SETQ FORMATSTRING "%Y.%m.%d.%H"))
    ((CL:EQ GRANULARITY KWD-SYSTEMS-MINUTES)
     (CL:SETQ FORMATSTRING "%Y.%m.%d.%H%M"))
    ((CL:EQ GRANULARITY KWD-SYSTEMS-SECONDS)
     (CL:SETQ FORMATSTRING "%Y.%m.%d.%H%M%S"))
    (CL:T))
   (CL:RETURN-FROM DATE-TO-VERSION-STRING
    (FORMAT-DATE DATE NULL FORMATSTRING))))

;;; (DEFUN (GET-SYSTEM-LAST-MODIFIED-DATE CALENDAR-DATE) ...)

(CL:DEFUN GET-SYSTEM-LAST-MODIFIED-DATE (SYSTEM)
  "Compute a last-modified date for `system' based on its most recently modified source file."
  (CL:LET* ((DATE NULL))
   (CL:LET*
    ((*CURRENTSYSTEMDEFINITION*
      (GET-SYSTEM-DEFINITION (%SYSTEM-DEFINITION.NAME SYSTEM) CL:T))
     (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
    (CL:DECLARE
     (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
      *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:PROGN
     (CL:LET*
      ((FILE NULL) (ITER-000 (SYSTEM-DEFINITION-SOURCE-FILES SYSTEM)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FILE (%%VALUE ITER-000))
       (CL:SETQ FILE
        (WRAP-STRING
         (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
          KWD-SYSTEMS-STELLA CL:T)))
       (CL:WHEN (PROBE-FILE? (%STRING-WRAPPER.WRAPPER-VALUE FILE))
        (CL:WHEN
         (CL:OR (CL:EQ DATE NULL)
          (GREATER?
           (FILE-WRITE-DATE (%STRING-WRAPPER.WRAPPER-VALUE FILE))
           DATE))
         (CL:SETQ DATE
          (FILE-WRITE-DATE (%STRING-WRAPPER.WRAPPER-VALUE FILE)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:RETURN-FROM GET-SYSTEM-LAST-MODIFIED-DATE DATE)))))

;;; (DEFUN (GET-SYSTEM-VERSION-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-SYSTEM-VERSION-STRING))
(CL:DEFUN GET-SYSTEM-VERSION-STRING (SYSTEM)
  "Compute a version string for `system' which is either based on an explicit :version
annotation on `system's definition, the readable value of an existing `*<system>-version[-string]*',
variable or on its most recent modification date of any of its source files."
  (CL:LET*
   ((NAME (%SYSTEM-DEFINITION.NAME SYSTEM))
    (MODULE
     (GET-STELLA-MODULE (%SYSTEM-DEFINITION.CARDINAL-MODULE SYSTEM)
      CL:NIL))
    (VERSIONSYMBOLNAME STELLA::NULL-STRING) (VERSIONSYMBOL NULL)
    (VERSIONVARIABLE NULL)
    (VERSIONSTRING
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%SYSTEM-DEFINITION.DYNAMIC-SLOTS SYSTEM)
       SYM-SYSTEMS-STELLA-SYSTEM-VERSION NULL-STRING-WRAPPER))))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING NAME VERSIONSYMBOLNAME VERSIONSTRING))
   (CL:WHEN
    (CL:AND (CL:EQ VERSIONSTRING STELLA::NULL-STRING)
     (CL:NOT (CL:EQ MODULE NULL)))
    (CL:LET*
     ((PATTERN NULL)
      (ITER-000
       (CONS-LIST (WRAP-STRING "*<name>-version*")
        (WRAP-STRING "*<name>-version-string*"))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PATTERN (%%VALUE ITER-000))
      (CL:SETQ VERSIONSYMBOLNAME
       (REPLACE-SUBSTRINGS (%STRING-WRAPPER.WRAPPER-VALUE PATTERN) NAME
        "<name>"))
      (CL:WHEN (CL:NOT (%MODULE.CASE-SENSITIVE? MODULE))
       (CL:SETQ VERSIONSYMBOLNAME (STRING-UPCASE VERSIONSYMBOLNAME)))
      (CL:SETQ VERSIONSYMBOL
       (LOOKUP-SYMBOL-IN-MODULE VERSIONSYMBOLNAME MODULE CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ VERSIONSYMBOL NULL))
       (CL:SETQ VERSIONVARIABLE (LOOKUP-GLOBAL-VARIABLE VERSIONSYMBOL))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ VERSIONVARIABLE NULL))
         (CL:EQ (TYPE VERSIONVARIABLE) SGT-SYSTEMS-STELLA-STRING)
         (CL:NOT
          (CL:EQ (READ-GLOBAL-VARIABLE-VALUE VERSIONVARIABLE) NULL)))
        (CL:SETQ VERSIONSTRING
         (%STRING-WRAPPER.WRAPPER-VALUE
          (READ-GLOBAL-VARIABLE-VALUE VERSIONVARIABLE)))
        (CL:WHEN (CL:NOT (CL:EQ VERSIONSTRING STELLA::NULL-STRING))
         (CL:RETURN))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:WHEN (CL:EQ VERSIONSTRING STELLA::NULL-STRING)
    (CL:SETQ VERSIONSTRING
     (DATE-TO-VERSION-STRING (GET-SYSTEM-LAST-MODIFIED-DATE SYSTEM)
      KWD-SYSTEMS-SECONDS)))
   (CL:RETURN-FROM GET-SYSTEM-VERSION-STRING
    (%STRING-WRAPPER.WRAPPER-VALUE
     (LAST (SPLIT-STRING VERSIONSTRING #\ ))))))

;;; (DEFUN (AUTOLOAD FUNCTION-CODE) ...)

(CL:DEFUN AUTOLOAD (QUALIFIEDNAME SYSTEMNAME CACHE ERROR?)
  "Autoload function `qualifiedName' from system `systemName'.
If it is already present in the system, simply return its code.  If `cache'
is defined, return its value if defined, otherwise, set its value to the
function found.  If the function failed to be defined by loading `systemName'
and `error?' is true, raise an error.  Otherwise, simply return NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((FUNCTION NULL))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:LET* ((FUNCTIONWRAPPER (%SURROGATE.SURROGATE-VALUE CACHE)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONWRAPPER NULL))
      (CL:RETURN-FROM AUTOLOAD
       (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FUNCTIONWRAPPER)))))
   (CL:HANDLER-CASE
    (CL:LET*
     ((FUNCTIONNAME STELLA::NULL-STRING)
      (FUNCTIONMODULENAME STELLA::NULL-STRING) (TYPE NULL))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-STRING FUNCTIONNAME FUNCTIONMODULENAME))
     (CL:MULTIPLE-VALUE-SETQ (FUNCTIONNAME FUNCTIONMODULENAME TYPE)
      (PARSE-STELLA-NAME QUALIFIEDNAME CL:NIL))
     (CL:SETQ TYPE TYPE)
     (CL:LET*
      ((FUNCTIONMODULE NULL) (FUNCTIONNAMESYMBOL NULL)
       (FUNCTIONOBJECT NULL))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONMODULENAME STELLA::NULL-STRING))
       (CL:SETQ FUNCTIONMODULE
        (GET-STELLA-MODULE FUNCTIONMODULENAME
         (CL:AND ERROR? (CL:EQ SYSTEMNAME STELLA::NULL-STRING)))))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONMODULE NULL))
       (CL:SETQ FUNCTIONNAMESYMBOL
        (LOOKUP-SYMBOL-IN-MODULE FUNCTIONNAME FUNCTIONMODULE CL:NIL)))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONNAMESYMBOL NULL))
       (CL:SETQ FUNCTIONOBJECT (LOOKUP-FUNCTION FUNCTIONNAMESYMBOL)))
      (CL:COND
       ((CL:NOT (CL:EQ FUNCTIONOBJECT NULL))
        (CL:SETQ FUNCTION (%METHOD-SLOT.FUNCTION-CODE FUNCTIONOBJECT)))
       ((CL:AND (CL:NOT (CL:EQ SYSTEMNAME STELLA::NULL-STRING))
         (CL:NOT (SYSTEM-LOADED? SYSTEMNAME)))
        (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
         (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
         (%MAKE-SYSTEM SYSTEMNAME NIL))
        (CL:RETURN-FROM AUTOLOAD
         (AUTOLOAD QUALIFIEDNAME STELLA::NULL-STRING CACHE ERROR?))))))
    (STELLA-EXCEPTION (E)
     (CL:WHEN ERROR?
      (CL:IF (CL:NOT (CL:EQ SYSTEMNAME STELLA::NULL-STRING))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "autoload: failed to define `" QUALIFIEDNAME "': `"
         (EXCEPTION-MESSAGE E) "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
       (CL:ERROR E)))))
   (CL:WHEN (CL:EQ FUNCTION NULL)
    (CL:IF ERROR?
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "autoload: failed to define `" QUALIFIEDNAME "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))
     (CL:RETURN-FROM AUTOLOAD NULL)))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE CACHE)
     (WRAP-FUNCTION-CODE FUNCTION)))
   (CL:RETURN-FROM AUTOLOAD FUNCTION)))

;;; (DEFUN MAKE-STELLA ...)

(CL:DEFUN MAKE-STELLA (FORCERECOMPILATION?)
  (%MAKE-SYSTEM "STELLA"
   (CONS-LIST KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FORCE-TRANSLATION?
    (CL:IF FORCERECOMPILATION? TRUE-WRAPPER FALSE-WRAPPER)
    KWD-SYSTEMS-DEVELOPMENT-SETTINGS? FALSE-WRAPPER))
  :VOID)

;;; (DEFUN (PARSE-CONFIGURATION-FILE-LINE STRING-WRAPPER WRAPPER KEYWORD) ...)

(CL:DEFUN PARSE-CONFIGURATION-FILE-LINE (LINE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
  #+MCL
  (CL:CHECK-TYPE LINE CL:SIMPLE-STRING)
  (CL:LET*
   ((START 0) (HASHPOS (POSITION LINE #\# 0))
    (EQUALPOS (POSITION LINE #\= 0)) (END EQUALPOS)
    (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH LINE)))
    (PROPERTY STELLA::NULL-STRING) (VALUESTRING STELLA::NULL-STRING)
    (VALUE NULL) (OPERATOR KWD-SYSTEMS-SET))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START HASHPOS EQUALPOS END LENGTH)
    (CL:TYPE CL:SIMPLE-STRING PROPERTY VALUESTRING))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 0)
      (UPPER-BOUND-000
       (CL:1-
        (CL:IF (CL:NOT (CL:= HASHPOS NULL-INTEGER)) HASHPOS LENGTH))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
      (CL:SETQ I ITER-000)
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (CL:AREF *CHARACTER-TYPE-TABLE*
          (CL:THE CL:FIXNUM
           (CL:CHAR-CODE
            (CL:LET ((SELF LINE) (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION))))))
         KWD-SYSTEMS-WHITE-SPACE))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:WHEN ALWAYS?-000
     (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
      (CL:VALUES NULL NULL NULL))))
   (CL:WHEN (CL:OR (CL:= EQUALPOS NULL-INTEGER) (CL:= EQUALPOS 0))
    (CL:WARN "Illegal line in configuration file: `~A'" LINE)
    (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
     (CL:VALUES NULL NULL NULL)))
   (CL:LOOP WHILE
    (CL:EQ
     (CL:AREF *CHARACTER-TYPE-TABLE*
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET ((SELF LINE) (POSITION START))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     KWD-SYSTEMS-WHITE-SPACE)
    DO (CL:SETQ START (CL:1+ START)))
   (CL:WHEN
    (CL:EQL
     (CL:LET ((SELF LINE) (POSITION (CL:1- END)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\+)
    (CL:SETQ OPERATOR KWD-SYSTEMS-ADD) (CL:SETQ END (CL:1- END)))
   (CL:LOOP WHILE
    (CL:EQ
     (CL:AREF *CHARACTER-TYPE-TABLE*
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET ((SELF LINE) (POSITION (CL:1- END)))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     KWD-SYSTEMS-WHITE-SPACE)
    DO (CL:SETQ END (CL:1- END)))
   (CL:WHEN (CL:<= END START)
    (CL:WARN "Illegal property in configuration file: `~A'" LINE)
    (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
     (CL:VALUES NULL NULL NULL)))
   (CL:SETQ PROPERTY (SUBSEQUENCE LINE START END))
   (CL:SETQ VALUESTRING (SUBSEQUENCE LINE (CL:1+ EQUALPOS) LENGTH))
   (CL:COND
    ((STRING-EQUAL? VALUESTRING "TRUE") (CL:SETQ VALUE TRUE-WRAPPER))
    ((STRING-EQUAL? VALUESTRING "FALSE") (CL:SETQ VALUE FALSE-WRAPPER))
    (CL:T
     (CL:HANDLER-CASE
      (CL:LET*
       ((TEST-VALUE-000
         (SAFE-PRIMARY-TYPE
          (CL:SETQ VALUE
           (READ-S-EXPRESSION-FROM-STRING VALUESTRING)))))
       (CL:COND
        ((CL:OR (SUBTYPE-OF-INTEGER? TEST-VALUE-000)
          (SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
          (SUBTYPE-OF-FLOAT? TEST-VALUE-000)))
        (CL:T (CL:SETQ VALUE (WRAP-STRING VALUESTRING)))))
      (READ-EXCEPTION () (CL:SETQ VALUE (WRAP-STRING VALUESTRING))))))
   (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
    (CL:VALUES (WRAP-STRING PROPERTY) VALUE OPERATOR))))

;;; (DEFGLOBAL *SYSTEM-CONFIGURATION-TABLE* ...)

(CL:DEFVAR *SYSTEM-CONFIGURATION-TABLE* NULL)

;;; (DEFUN (LOAD-CONFIGURATION-FILE CONFIGURATION-TABLE) ...)

(CL:DEFUN %LOAD-CONFIGURATION-FILE (FILE)
  "Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean."
  (CL:LET* ((TEMP-000 (%FIND-FILE-IN-LOAD-PATH FILE NULL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
   (CL:SETQ FILE
    (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING)) TEMP-000
     FILE)))
  (ENSURE-FILE-EXISTS FILE "load-configuration-file")
  (CL:LET* ((CONFIGURATION (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((IN NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ IN (OPEN-INPUT-FILE FILE))
      (CL:LET* ((LINE STELLA::NULL-STRING) (ITER-000 (LINES IN)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ LINE (%LINE-ITERATOR.VALUE ITER-000))
        (CL:LET* ((KEY NULL) (VALUE NULL) (OPERATOR NULL))
         (CL:MULTIPLE-VALUE-SETQ (KEY VALUE OPERATOR)
          (PARSE-CONFIGURATION-FILE-LINE LINE))
         (CL:WHEN (CL:NOT (CL:EQ KEY NULL))
          (CL:COND
           ((CL:EQ OPERATOR KWD-SYSTEMS-SET)
            (SET-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE CONFIGURATION)
            (SET-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE NULL))
           ((CL:EQ OPERATOR KWD-SYSTEMS-ADD)
            (ADD-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE CONFIGURATION)
            (ADD-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE NULL))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              OPERATOR "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-000)))))))))))
     (CL:WHEN (CL:NOT (CL:EQ IN NULL)) (FREE IN))))
   (CL:RETURN-FROM %LOAD-CONFIGURATION-FILE CONFIGURATION)))

(CL:DEFUN LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER
   (%LOAD-CONFIGURATION-FILE
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO LOAD-CONFIGURATION-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-CONFIGURATION-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-CONFIGURATION-FILE)))

;;; (DEFUN SAVE-CONFIGURATION-VALUE ...)

(CL:DEFUN SAVE-CONFIGURATION-VALUE (STREAM VALUE)
  "Save `value' to `stream' as a properly formatted configuration
value."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
    ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:EQ VALUE TRUE-WRAPPER)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "true")
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        "false"))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (INTEGER-TO-STRING
        (CL:TRUNCATE (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (INTEGER-TO-STRING
        (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (FLOAT-TO-STRING (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) VALUE)))))
  :VOID)

;;; (DEFUN SAVE-CONFIGURATION-FILE ...)

(CL:DEFUN SAVE-CONFIGURATION-FILE (TABLE FILE TITLE)
  "Save `table' as a configuration file.  Uses a Java-style property file syntax."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TITLE))
  #+MCL
  (CL:CHECK-TYPE TITLE CL:SIMPLE-STRING)
  (CL:LET* ((*PRINTREADABLY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((OUT NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ OUT (OPEN-OUTPUT-FILE FILE))
      (CL:WHEN (CL:NOT (CL:EQ TITLE STELLA::NULL-STRING))
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT) "# "
        TITLE EOL))
      (CL:LET*
       ((KEY NULL) (VALUE NULL)
        (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST TABLE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
        (CL:SETQ KEY (%KV-CONS.KEY ITER-000))
        (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
          (CL:PROGN
           (CL:LET* ((V NULL) (ITER-001 VALUE))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:SETQ V (%%VALUE ITER-001))
             (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
              (UNWRAP-STRING KEY) " +=")
             (SAVE-CONFIGURATION-VALUE OUT V)
             (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
              EOL)
             (CL:SETQ ITER-001 (%%REST ITER-001))))))
         (CL:T
          (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
           (UNWRAP-STRING KEY) " =")
          (SAVE-CONFIGURATION-VALUE OUT VALUE)
          (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
           EOL)))
        (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))))
     (CL:WHEN (CL:NOT (CL:EQ OUT NULL)) (FREE OUT)))))
  :VOID)

;;; (DEFUN (LOOKUP-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN LOOKUP-CONFIGURATION-PROPERTY (PROPERTY DEFAULTVALUE CONFIGURATION)
  "Lookup `property' in `configuration' and return its value.
Use the global system configuration table if `configuration' is NULL.  Return
`defaultValue' if `property' is not defined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL))
    (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY VALUE)
    (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY DEFAULTVALUE))))

;;; (DEFUN (LOOKUP-CONFIGURATION-PROPERTY-VALUES CONS) ...)

(CL:DEFUN LOOKUP-CONFIGURATION-PROPERTY-VALUES (PROPERTY DEFAULTVALUE CONFIGURATION)
  "Lookup `property' in `configuration', assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if `configuration' is NULL.  Return `defaultValue' if `property' is not defined or
NIL is no default value is specified."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES
      (CONSIFY VALUE)))
    ((CL:NOT (CL:EQ DEFAULTVALUE NULL))
     (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES
      (CONSIFY DEFAULTVALUE)))
    (CL:T (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES NIL)))))

;;; (DEFUN (SET-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN SET-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Set `property' in `configuration' to `value' and return it.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY) VALUE)
  (RUN-CONFIGURATION-PROPERTY-DEMON KWD-SYSTEMS-SET PROPERTY VALUE
   CONFIGURATION)
  (CL:RETURN-FROM SET-CONFIGURATION-PROPERTY VALUE))

;;; (DEFUN (ADD-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN ADD-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Add `value' to `property' in `configuration' and return it.
If a previous value exists add `value' to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing `value'.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((TEMP-000 (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY)
    (CONCATENATE
     (CONSIFY (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 NIL))
     (CONS VALUE NIL))))
  (RUN-CONFIGURATION-PROPERTY-DEMON KWD-SYSTEMS-ADD PROPERTY VALUE
   CONFIGURATION)
  (CL:RETURN-FROM ADD-CONFIGURATION-PROPERTY VALUE))

;;; (DEFUN (CLEAR-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN CLEAR-CONFIGURATION-PROPERTY (PROPERTY CONFIGURATION)
  "Remove `property' in `configuration' and return the previous
value.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET*
   ((CURRENT-VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (REMOVE-AT CONFIGURATION (WRAP-STRING PROPERTY))
   (RUN-CONFIGURATION-PROPERTY-DEMON KWD-SYSTEMS-CLEAR PROPERTY
    CURRENT-VALUE CONFIGURATION)
   (CL:RETURN-FROM CLEAR-CONFIGURATION-PROPERTY CURRENT-VALUE)))

;;; (DEFUN (REMOVE-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN REMOVE-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Remove `value' from `property' in `configuration' and return it.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET*
   ((CURRENT-VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:WHEN (CL:NOT (CL:EQ CURRENT-VALUE NULL))
    (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY)
     (REMOVE CURRENT-VALUE VALUE)))
   (RUN-CONFIGURATION-PROPERTY-DEMON KWD-SYSTEMS-REMOVE PROPERTY VALUE
    CONFIGURATION)
   (CL:RETURN-FROM REMOVE-CONFIGURATION-PROPERTY VALUE)))

;;; (DEFUN PRINT-CONFIGURATION-PROPERTIES ...)

(CL:DEFUN PRINT-CONFIGURATION-PROPERTIES (CONFIGURATION STREAM)
  "Print all properties defined in `configuration' to `stream'."
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET*
    ((ENTRY NULL)
     (ITER-000 (SORT-TUPLES (CONSIFY CONFIGURATION) 0 NULL)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      (UNWRAP-STRING (%%VALUE ENTRY)) " = ")
     (CL:IF (STRING? (%%VALUE (%%REST ENTRY)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (UNWRAP-STRING (%%VALUE (%%REST ENTRY))) EOL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%%VALUE (%%REST ENTRY)) EOL))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFGLOBAL *PL-ROOT-DIRECTORY* ...)

(CL:DEFVAR *PL-ROOT-DIRECTORY* STELLA::NULL-STRING
  "The :root-directory portion of the PL logical host.  This variable
is primarily defined to allow us to dynamically change this via a configuration demon.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *PL-ROOT-DIRECTORY*))

;;; (DEFUN (*PL-ROOT-DIRECTORY*-SETTER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  *PL-ROOT-DIRECTORY*-SETTER))
(CL:DEFUN *PL-ROOT-DIRECTORY*-SETTER (VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:SETQ *PL-ROOT-DIRECTORY* VALUE)
  (%DEFINE-LOGICAL-HOST-PROPERTY "PL" KWD-SYSTEMS-ROOT-DIRECTORY
   (WRAP-STRING VALUE))
  (CL:RETURN-FROM *PL-ROOT-DIRECTORY*-SETTER VALUE))

;;; (DEFUN CONFIGURE-STELLA ...)

(CL:DEFUN %CONFIGURE-STELLA (FILE)
  "Perform STELLA run-time configuration.  If supplied, load the
configuration file `file' first which should be supplied with a physical pathname."
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
    (CL:NOT
     (CL:EQ (%FIND-FILE-IN-LOAD-PATH FILE NULL) STELLA::NULL-STRING)))
   (%LOAD-CONFIGURATION-FILE FILE))
  (%DEFINE-LOGICAL-HOST-PROPERTY "PL" KWD-SYSTEMS-ROOT-DIRECTORY
   (CL:IF (CL:NOT (CL:EQ *PL-ROOT-DIRECTORY* STELLA::NULL-STRING))
    (WRAP-STRING *PL-ROOT-DIRECTORY*)
    (LOOKUP-CONFIGURATION-PROPERTY "PowerLoomRootDirectory" NULL NULL)))
  :VOID)

(CL:DEFUN CONFIGURE-STELLA-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CONFIGURE-STELLA
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO CONFIGURE-STELLA (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Perform STELLA run-time configuration.  If supplied, load the
configuration file `file' first which should be supplied with a physical pathname."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/CONFIGURE-STELLA|)) (CL:MACRO-FUNCTION (CL:QUOTE CONFIGURE-STELLA)))

;;; (DEFUN (GET-PROPERTY OBJECT) ...)

(CL:DEFUN %GET-PROPERTY (PROPERTY DEFAULTVALUE)
  "Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module."
  (CL:LET*
   ((KEY (COERCE-TO-STRING PROPERTY)) (DEFAULT (%%VALUE DEFAULTVALUE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (CL:RETURN-FROM %GET-PROPERTY
    (LOOKUP-CONFIGURATION-PROPERTY KEY DEFAULT
     *SYSTEM-CONFIGURATION-TABLE*))))

(CL:DEFUN GET-PROPERTY-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM GET-PROPERTY-EVALUATOR-WRAPPER
   (%GET-PROPERTY (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))))

(CL:DEFMACRO GET-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/GET-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE GET-PROPERTY)))

;;; (DEFUN SET-PROPERTY ...)

(CL:DEFUN %SET-PROPERTY (PROPERTY VALUE)
  "Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module."
  (CL:LET* ((KEY (COERCE-TO-STRING PROPERTY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (SET-CONFIGURATION-PROPERTY KEY VALUE *SYSTEM-CONFIGURATION-TABLE*))
  :VOID)

(CL:DEFMACRO SET-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-PROPERTY)))

;;; (DEFUN ADD-PROPERTY-VALUE ...)

(CL:DEFUN %ADD-PROPERTY-VALUE (PROPERTY VALUE)
  "Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module."
  (CL:LET* ((KEY (COERCE-TO-STRING PROPERTY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (ADD-CONFIGURATION-PROPERTY KEY VALUE *SYSTEM-CONFIGURATION-TABLE*))
  :VOID)

(CL:DEFMACRO ADD-PROPERTY-VALUE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ADD-PROPERTY-VALUE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-PROPERTY-VALUE)))

;;; (DEFUN PRINT-PROPERTIES ...)

(CL:DEFUN PRINT-PROPERTIES ()
  "Print all current configuration property information to
standard output."
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "------------------------------------------------------------" EOL
   "# Loaded System Configuration" EOL)
  (PRINT-CONFIGURATION-PROPERTIES *SYSTEM-CONFIGURATION-TABLE*
   STANDARD-OUTPUT)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "------------------------------------------------------------" EOL)
  :VOID)

;;; (DEFGLOBAL *REGISTERED-PROPERTY-DEMONS* ...)

(CL:DEFVAR *REGISTERED-PROPERTY-DEMONS* NULL)

;;; (DEFUN REGISTER-PROPERTY-DEMON ...)

(CL:DEFUN REGISTER-PROPERTY-DEMON (PROPERTY DEMONNAME)
  "Register the function named `demonName' as the demon for `property'.
Demons will be run as after demons on every configuration table update.  Set the
property `stella.test.propertyDemon' to see a test demon in action."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:LET* ((DEMON (LOOKUP-FUNCTION DEMONNAME)))
   (CL:WHEN (CL:EQ DEMON NULL)
    (CL:SETQ DEMON (LOOKUP-GLOBAL-VARIABLE DEMONNAME)))
   (CL:IF (CL:NOT (CL:EQ DEMON NULL))
    (INSERT-AT *REGISTERED-PROPERTY-DEMONS* (WRAP-STRING PROPERTY)
     DEMON)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "register-property-demon: cannot find a function or variable with this name: `"
      DEMONNAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN UNREGISTER-PROPERTY-DEMON ...)

(CL:DEFUN UNREGISTER-PROPERTY-DEMON (PROPERTY)
  "Unregister any demon for `property'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (REMOVE-AT *REGISTERED-PROPERTY-DEMONS* (WRAP-STRING PROPERTY))
  :VOID)

;;; (DEFUN (LOOKUP-VARIABLE-DEMON-SETTER METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-VARIABLE-DEMON-SETTER (DEMON)
  (CL:LET*
   ((VARIABLENAME (%GLOBAL-VARIABLE.VARIABLE-NAME DEMON))
    (POSTFIX
     (CL:IF (%MODULE.CASE-SENSITIVE? (HOME-MODULE DEMON)) "-setter"
      "-SETTER"))
    (SETTERNAME
     (INTERN-DERIVED-SYMBOL VARIABLENAME
      (CONCATENATE (%SYMBOL.SYMBOL-NAME VARIABLENAME) POSTFIX))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING POSTFIX))
   (CL:RETURN-FROM LOOKUP-VARIABLE-DEMON-SETTER
    (LOOKUP-FUNCTION SETTERNAME))))

;;; (DEFUN RUN-CONFIGURATION-PROPERTY-DEMON ...)

(CL:DEFUN RUN-CONFIGURATION-PROPERTY-DEMON (ACTION PROPERTY VALUE TABLE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:LET*
   ((DEMON
     (LOOKUP *REGISTERED-PROPERTY-DEMONS* (WRAP-STRING PROPERTY))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DEMON)))
    (CL:COND
     ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
      (CL:PROGN
       (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE DEMON) ACTION PROPERTY
        VALUE TABLE)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-GLOBAL-VARIABLE)
      (CL:PROGN
       (CL:SETQ VALUE
        (LOOKUP-CONFIGURATION-PROPERTY PROPERTY NULL TABLE))
       (CL:LET*
        ((SETTER (LOOKUP-VARIABLE-DEMON-SETTER DEMON))
         (VARIABLETYPE
          (TYPE-SPEC-TO-BASE-TYPE (GLOBAL-VARIABLE-TYPE-SPEC DEMON)))
         (COERCEDVALUE
          (CL:IF (CL:NOT (CL:EQ VALUE NULL))
           (COERCE-VALUE-TO-TYPE VALUE VARIABLETYPE CL:NIL) NULL)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (CL:EQ COERCEDVALUE NULL))
         (CL:WARN
          "run-configuration-property-demon: cannot coerce `~A' to type `~A'"
          VALUE VARIABLETYPE)
         (CL:RETURN-FROM RUN-CONFIGURATION-PROPERTY-DEMON))
        (CL:COND
         ((CL:NOT (CL:EQ SETTER NULL))
          (CL:COND
           ((CL:EQ VARIABLETYPE SGT-SYSTEMS-STELLA-INTEGER)
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             (UNWRAP-INTEGER COERCEDVALUE)))
           ((CL:EQ VARIABLETYPE SGT-SYSTEMS-STELLA-LONG-INTEGER)
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             (UNWRAP-LONG-INTEGER COERCEDVALUE)))
           ((CL:EQ VARIABLETYPE SGT-SYSTEMS-STELLA-FLOAT)
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             (UNWRAP-FLOAT COERCEDVALUE)))
           ((CL:EQ VARIABLETYPE SGT-SYSTEMS-STELLA-STRING)
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             (UNWRAP-STRING COERCEDVALUE)))
           ((CL:EQ VARIABLETYPE SGT-SYSTEMS-STELLA-BOOLEAN)
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             (CL:EQ COERCEDVALUE TRUE-WRAPPER)))
           (CL:T
            (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE SETTER)
             COERCEDVALUE))))
         (CL:T (WRITE-GLOBAL-VARIABLE-VALUE DEMON COERCEDVALUE))))))
     (CL:T))))
  :VOID)

;;; (DEFUN DEMON-PROPERTY-HANDLER ...)

(CL:DEFUN DEMON-PROPERTY-HANDLER (DEMON SLOT PROPERTY)
  (DEFAULT-OPTION-HANDLER DEMON SLOT PROPERTY)
  (INSERT-AT *REGISTERED-PROPERTY-DEMONS*
   (WRAP-STRING (COERCE-TO-STRING PROPERTY)) DEMON)
  :VOID)

;;; (DEFUN TEST-PROPERTY-DEMON ...)

(CL:DEFUN TEST-PROPERTY-DEMON (ACTION PROPERTY VALUE TABLE)
  "A test demon for the property demon machinery which simply prints arguments."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:SETQ TABLE TABLE)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "test-property-demon: action=" ACTION ", property=" PROPERTY
   ", value-arg=" VALUE ", prop-value="
   (LOOKUP-CONFIGURATION-PROPERTY PROPERTY NULL TABLE) EOL)
  :VOID)

(CL:DEFUN NEW-CMD-LINE-OPTION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CMD-LINE-OPTION))
   (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION SELF) KWD-SYSTEMS-ERROR)
   (CL:SETF (%CMD-LINE-OPTION.HANDLER SELF)
    (CL:FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER))
   (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE SELF) NULL)
   (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS SELF) 0)
   (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? SELF) CL:NIL)
   (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE SELF)
    SGT-SYSTEMS-STELLA-STRING)
   (CL:SETF (%CMD-LINE-OPTION.KEYS SELF) NIL)
   (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION SELF) "Not documented.")
   (CL:RETURN-FROM NEW-CMD-LINE-OPTION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CMD-LINE-OPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-SYSTEMS-STELLA-CMD-LINE-OPTION))

(CL:DEFUN ACCESS-CMD-LINE-OPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%CMD-LINE-OPTION.DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-KEYS)
    (CL:IF SETVALUE? (CL:SETF (%CMD-LINE-OPTION.KEYS SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.KEYS SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-VALUE-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.VALUE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-MULTI-VALUED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CMD-LINE-OPTION.MULTI-VALUED? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-N-ARGUMENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CMD-LINE-OPTION.N-ARGUMENTS SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-DEFAULT-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.DEFAULT-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-HANDLER)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.HANDLER SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%CMD-LINE-OPTION.HANDLER SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-ERROR-ACTION)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.ERROR-ACTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CMD-LINE-OPTION-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *REGISTERED-COMMAND-LINE-OPTIONS* ...)

(CL:DEFVAR *REGISTERED-COMMAND-LINE-OPTIONS* NULL)

;;; (DEFUN REGISTER-CMD-LINE-OPTION ...)

(CL:DEFUN REGISTER-CMD-LINE-OPTION (CL:&REST OPTIONS)
  "Register a command line option.  :key identifies the name of the option which
will usually start with a dash such as `-e' or `--eval'.  :key2 and :key3 can be used to supply
additional options (e.g., long option formats).  To supply even more keys, a list can be supplied
with the :keys option.  If a :property is supplied, this option simply sets or adds to the values
of the specified system configuration property.  If a :handler name is specified, its function
will be used to interpret the values of the option.  :documentation can be used to supply a
documentation string which will be printed by the `help-option-handler' (usually bound to `-?').
:value-type describes what type an option value should be coerced to before assigning it to the
specified configuration :property.  :n-arguments describes how many arguments this option
takes.  This will be 0 for simple switches and can be 1 or greater than one for option handlers
that need one or more arguments.  :default-value defines the value to use for zero-argument
:property options.  If :multi-valued? is true, values of multiple occurrences of the option will be
added to the specified configuration :property.  :error-action can be one of :ignore, :warn or
:error to specify what to do in case an error is encountered during option processing."
  (CL:LET* ((ARGLIST-000 NIL))
   (CL:LET* ((ARG-000 NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
       (CL:IF (CL:EQ ARGLIST-000 NIL) (CL:SETQ ARGLIST-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET*
    ((THEOPTIONS
      (PARSE-OPTIONS ARGLIST-000
       (LIST* KWD-SYSTEMS-DOCUMENTATION SGT-SYSTEMS-STELLA-STRING
        KWD-SYSTEMS-KEY SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEY2
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEY3
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEYS
        SGT-SYSTEMS-STELLA-CONS KWD-SYSTEMS-VALUE-TYPE
        SGT-SYSTEMS-STELLA-TYPE KWD-SYSTEMS-MULTI-VALUED?
        SGT-SYSTEMS-STELLA-BOOLEAN KWD-SYSTEMS-N-ARGUMENTS
        SGT-SYSTEMS-STELLA-INTEGER KWD-SYSTEMS-DEFAULT-VALUE
        SGT-SYSTEMS-STELLA-OBJECT KWD-SYSTEMS-PROPERTY
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-HANDLER
        SGT-SYSTEMS-STELLA-SYMBOL KWD-SYSTEMS-ERROR-ACTION
        SGT-SYSTEMS-STELLA-KEYWORD NIL)
       CL:T CL:NIL))
     (CMDLINEOPTION (NEW-CMD-LINE-OPTION)) (VALUE NULL))
    (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION CMDLINEOPTION)
     (%STRING-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-DOCUMENTATION
       (WRAP-STRING "Not documented."))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY2))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY3))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:LET*
     ((VAL NULL)
      (ITER-001 (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-KEYS NIL)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ VAL (%%VALUE ITER-001))
      (CL:SETQ VALUE
       (COERCE-VALUE-TO-TYPE VAL SGT-SYSTEMS-STELLA-STRING CL:T))
      (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
       (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
     (REVERSE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
    (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE CMDLINEOPTION)
     (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-VALUE-TYPE
      SGT-SYSTEMS-STELLA-STRING))
    (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? CMDLINEOPTION)
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-MULTI-VALUED?
       FALSE-WRAPPER)))
    (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS CMDLINEOPTION)
     (%INTEGER-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-N-ARGUMENTS
       (WRAP-INTEGER 0))))
    (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE CMDLINEOPTION)
     (LOOKUP THEOPTIONS KWD-SYSTEMS-DEFAULT-VALUE))
    (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY CMDLINEOPTION)
     (%STRING-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-PROPERTY
       NULL-STRING-WRAPPER)))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-HANDLER))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETQ VALUE (LOOKUP-FUNCTION VALUE))
     (CL:WHEN (CL:EQ VALUE NULL)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "register-cmd-line-option: cannot find handler function: `"
        (LOOKUP THEOPTIONS KWD-SYSTEMS-HANDLER) "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
     (CL:SETF (%CMD-LINE-OPTION.HANDLER CMDLINEOPTION)
      (%METHOD-SLOT.FUNCTION-CODE VALUE)))
    (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION CMDLINEOPTION)
     (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-ERROR-ACTION
      KWD-SYSTEMS-ERROR))
    (CL:LET*
     ((KEY NULL) (ITER-002 (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-002))
      (INSERT-AT *REGISTERED-COMMAND-LINE-OPTIONS* KEY CMDLINEOPTION)
      (CL:SETQ ITER-002 (%%REST ITER-002))))))
  :VOID)

;;; (DEFUN UNREGISTER-CMD-LINE-OPTION ...)

(CL:DEFUN UNREGISTER-CMD-LINE-OPTION (KEY)
  "Unregister the command line option identified by `key' under all its keys."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  #+MCL
  (CL:CHECK-TYPE KEY CL:SIMPLE-STRING)
  (CL:LET*
   ((CMDLINEOPTION
     (LOOKUP *REGISTERED-COMMAND-LINE-OPTIONS* (WRAP-STRING KEY))))
   (CL:WHEN (CL:NOT (CL:EQ CMDLINEOPTION NULL))
    (CL:LET*
     ((REGISTEREDKEY NULL)
      (ITER-000 (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ REGISTEREDKEY (%%VALUE ITER-000))
      (REMOVE-AT *REGISTERED-COMMAND-LINE-OPTIONS* REGISTEREDKEY)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (REMOVE-AT *REGISTERED-COMMAND-LINE-OPTIONS* (WRAP-STRING KEY))))
  :VOID)

;;; (DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS ...)

(CL:DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS ()
  "Unregister all currently registered command line options."
  (CLEAR *REGISTERED-COMMAND-LINE-OPTIONS*)
  :VOID)

;;; (DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER ...)

(CL:DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER (OPTION VALUE)
  "Default handler that tries to set a system property based on `option' and `value'."
  (CL:LET*
   ((PROPERTY (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY OPTION))
    (DEFAULTVALUE (%CMD-LINE-OPTION.DEFAULT-VALUE OPTION)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
   (CL:WHEN (CL:EQ PROPERTY STELLA::NULL-STRING) (CL:SETQ PROPERTY "")
    (CL:LET* ((KEY NULL) (ITER-000 (%CMD-LINE-OPTION.KEYS OPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:WHEN
       (CL:>
        (CL:THE CL:FIXNUM
         (CL:LENGTH (CL:THE CL:SIMPLE-STRING (UNWRAP-STRING KEY))))
        (CL:THE CL:FIXNUM (CL:LENGTH PROPERTY)))
       (CL:SETQ PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE KEY)))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:WHEN
    (CL:AND (CL:EQ DEFAULTVALUE NULL)
     (CL:EQ (%CMD-LINE-OPTION.VALUE-TYPE OPTION)
      SGT-SYSTEMS-STELLA-BOOLEAN))
    (CL:SETQ DEFAULTVALUE TRUE-WRAPPER))
   (CL:WHEN (CL:EQ VALUE NULL) (CL:SETQ VALUE DEFAULTVALUE))
   (CL:IF (%CMD-LINE-OPTION.MULTI-VALUED? OPTION)
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((VAL NULL) (ITER-001 VALUE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ VAL (%%VALUE ITER-001))
         (ADD-CONFIGURATION-PROPERTY PROPERTY VAL NULL)
         (CL:SETQ ITER-001 (%%REST ITER-001))))))
     (CL:T (ADD-CONFIGURATION-PROPERTY PROPERTY VALUE NULL)))
    (SET-CONFIGURATION-PROPERTY PROPERTY VALUE NULL)))
  :VOID)

;;; (DEFGLOBAL *UNPROCESSED-COMMAND-LINE-ARGUMENTS* ...)

(CL:DEFVAR *UNPROCESSED-COMMAND-LINE-ARGUMENTS* NULL)

;;; (DEFUN PROCESS-COMMAND-LINE-ARGUMENTS ...)

(CL:DEFUN PROCESS-COMMAND-LINE-ARGUMENTS (COUNT ARGUMENTS UNHANDLEDOPTIONACTION)
  "Interpret any command line `arguments' for which handlers have been registered.
Leave any remaining unprocessed arguments in `*unprocessed-command-line-arguments*'.
If any unprocessed arguments use option syntax (that is they start with a `-'), proceed
according to `unhandledOptionAction' which can be one of :ignore, :warn or :error.
This ensures that at any point in the option processing, `*unprocessed-command-line-arguments*'
accurately reflects the arguments which have been either skipped or not handled yet."
  (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT)
   (CL:TYPE CL:SIMPLE-VECTOR ARGUMENTS))
  #+MCL
  (CL:CHECK-TYPE COUNT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE ARGUMENTS CL:SIMPLE-VECTOR)
  (CL:WHEN (CL:EQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS* NULL)
   (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
    (CONSIFY-COMMAND-LINE-ARGUMENTS COUNT ARGUMENTS)))
  (CL:LET*
   ((CMDLINEARGS (COPY-CONS-LIST *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (ARGUMENT STELLA::NULL-STRING) (NARGS (LENGTH CMDLINEARGS))
    (OPTION NULL) (VALUE NULL)
    (UNPROCESSEDARGS (CONS NULL *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (UNPROCESSEDTRAILER UNPROCESSEDARGS))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ARGUMENT)
    (CL:TYPE CL:FIXNUM NARGS))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CMDLINEARGS NIL)) DO
    (CL:TAGBODY
     (CL:LET* ((HEAD-000 (%%VALUE CMDLINEARGS)))
      (CL:SETQ CMDLINEARGS (%%REST CMDLINEARGS))
      (CL:SETQ ARGUMENT (%STRING-WRAPPER.WRAPPER-VALUE HEAD-000)))
     (CL:SETQ NARGS (CL:1- NARGS))
     (CL:SETQ OPTION
      (LOOKUP *REGISTERED-COMMAND-LINE-OPTIONS*
       (WRAP-STRING ARGUMENT)))
     (CL:SETQ VALUE NULL)
     (CL:COND
      ((CL:NOT (CL:EQ OPTION NULL))
       (CL:WHEN (CL:< NARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION))
        (CL:LET*
         ((TEST-VALUE-000 (%CMD-LINE-OPTION.ERROR-ACTION OPTION)))
         (CL:COND
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-ERROR)
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
             "process-command-line-arguments: missing value for option: `"
             ARGUMENT "'")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-WARN)
           (CL:WARN
            "process-command-line-arguments: missing value for option: `~A'"
            ARGUMENT))
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-IGNORE))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
             TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
        (CL:GO :CONTINUE))
       (CL:CASE (%CMD-LINE-OPTION.N-ARGUMENTS OPTION) (0)
        (1
         (CL:LET* ((HEAD-001 (%%VALUE CMDLINEARGS)))
          (CL:SETQ CMDLINEARGS (%%REST CMDLINEARGS))
          (CL:SETQ VALUE HEAD-001))
         (CL:SETQ NARGS (CL:1- NARGS)))
        (CL:OTHERWISE
         (CL:LET* ((VALUE-000 NIL))
          (CL:LET*
           ((ARG NULL) (ITER-000 CMDLINEARGS) (I NULL-INTEGER)
            (ITER-001 1)
            (UPPER-BOUND-000 (%CMD-LINE-OPTION.N-ARGUMENTS OPTION))
            (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
            (COLLECT-000 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
             (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
            DO (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
              (CL:IF (CL:EQ VALUE-000 NIL)
               (CL:SETQ VALUE-000 COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (%%REST ITER-000))
            (CL:SETQ ITER-001 (CL:1+ ITER-001))))
          (CL:SETQ VALUE VALUE-000))
         (CL:SETQ CMDLINEARGS
          (NTH-REST CMDLINEARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION)))
         (CL:SETQ NARGS
          (CL:- NARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION)))))
       (CL:SETF (%%REST UNPROCESSEDTRAILER)
        (NTH-REST UNPROCESSEDTRAILER
         (CL:+ (%CMD-LINE-OPTION.N-ARGUMENTS OPTION) 2)))
       (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
        (%%REST UNPROCESSEDARGS))
       (CL:HANDLER-CASE
        (CL:FUNCALL (%CMD-LINE-OPTION.HANDLER OPTION) OPTION VALUE)
        (CL:CONDITION (E)
         (CL:LET*
          ((TEST-VALUE-001 (%CMD-LINE-OPTION.ERROR-ACTION OPTION)))
          (CL:COND
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ERROR)
            (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
              "Error during processing of `" ARGUMENT "' option: `"
              (EXCEPTION-MESSAGE E) "'")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-WARN)
            (CL:WARN "Error during processing of `~A' option: `~A'"
             ARGUMENT (EXCEPTION-MESSAGE E)))
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-IGNORE))
           (CL:T
            (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003) "`"
              TEST-VALUE-001 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-003))))))))))
      (CL:T (CL:SETQ UNPROCESSEDTRAILER (%%REST UNPROCESSEDTRAILER))))
     :CONTINUE))
   (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
    (%%REST UNPROCESSEDARGS))
   (CL:LET*
    ((ARG NULL) (ITER-002 *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-002))
     (CL:WHEN (STARTS-WITH? (UNWRAP-STRING ARG) "-" 0)
      (CL:COND
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-WARN)
        (CL:WARN "Unhandled command line option: `~A'"
         (UNWRAP-STRING ARG)))
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-ERROR)
        (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
          "Unhandled command line option: `" (UNWRAP-STRING ARG) "'")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-004)))))
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-IGNORE) (CL:RETURN))
       (CL:T
        (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005) "`"
          UNHANDLEDOPTIONACTION "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-005)))))))
     (CL:SETQ ITER-002 (%%REST ITER-002)))))
  :VOID)

;;; (DEFUN (UNPROCESSED-COMMAND-LINE-ARGUMENTS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN UNPROCESSED-COMMAND-LINE-ARGUMENTS ()
  "Return all command line arguments which have not yet been processed
by (or been ignored by) `process-command-line-arguments'.  If arguments have not yet
been processed, this will return NULL."
  (CL:RETURN-FROM UNPROCESSED-COMMAND-LINE-ARGUMENTS
   *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))

;;; (DEFUN EVAL-OPTION-HANDLER ...)

(CL:DEFUN EVAL-OPTION-HANDLER (OPTION VALUE)
  "Interpret an --eval option by evaluating `value'."
  (CL:SETQ OPTION OPTION)
  (%EVALUATE
   (CL:IF (STRING? VALUE)
    (READ-S-EXPRESSION-FROM-STRING
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
    VALUE))
  :VOID)

;;; (DEFUN EVAL-IN-MODULE-OPTION-HANDLER ...)

(CL:DEFUN EVAL-IN-MODULE-OPTION-HANDLER (OPTION VALUE)
  "Interpret an --eval-in-module option.  `value' is expected
to be of the form `(<module-name> <s-expression>)'."
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((*MODULE* (COERCE-TO-MODULE (%%VALUE VALUE) CL:T))
       (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (EVAL-OPTION-HANDLER OPTION (%%VALUE (%%REST VALUE))))))
   (CL:T))
  :VOID)

;;; (DEFUN LOAD-PATH-OPTION-HANDLER ...)

(CL:DEFUN LOAD-PATH-OPTION-HANDLER (OPTION VALUE)
  "Modify the current file load path according to `option' and `value'."
  (CL:COND
   ((MEMBER? (%CMD-LINE-OPTION.KEYS OPTION) (WRAP-STRING "--path="))
    (%SET-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   ((MEMBER? (%CMD-LINE-OPTION.KEYS OPTION) (WRAP-STRING "--path=+"))
    (%ADD-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   (CL:T (%PUSH-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
  :VOID)

;;; (DEFUN CONFIG-FILE-OPTION-HANDLER ...)

(CL:DEFUN CONFIG-FILE-OPTION-HANDLER (OPTION VALUE)
  "Load the configuration file `value'.  This will
modify currently set system properties defined in `value' with new
values but leave all other currently set properties as they are."
  (CL:SETQ OPTION OPTION)
  (CL:LET* ((CURRENTCONFIG *SYSTEM-CONFIGURATION-TABLE*))
   (CL:HANDLER-CASE
    (CL:PROGN
     (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* (COPY CURRENTCONFIG))
     (%LOAD-CONFIGURATION-FILE (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
    (CL:CONDITION ()
     (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* CURRENTCONFIG))))
  :VOID)

;;; (DEFUN LOAD-FILE-OPTION-HANDLER ...)

(CL:DEFUN LOAD-FILE-OPTION-HANDLER (OPTION VALUE)
  "Load the file `value' using the STELLA `load-file' command."
  (CL:SETQ OPTION OPTION)
  (%LOAD-FILE (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
  :VOID)

;;; (DEFUN DEFINE-PROPERTY-OPTION-HANDLER ...)

(CL:DEFUN DEFINE-PROPERTY-OPTION-HANDLER (OPTION VALUE)
  (CL:SETQ OPTION OPTION)
  (CL:LET* ((PROP NULL) (VAL NULL) (OP NULL))
   (CL:MULTIPLE-VALUE-SETQ (PROP VAL OP)
    (PARSE-CONFIGURATION-FILE-LINE
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   (CL:IF (CL:EQ OP KWD-SYSTEMS-ADD)
    (ADD-CONFIGURATION-PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE PROP)
     VAL NULL)
    (SET-CONFIGURATION-PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE PROP)
     VAL NULL)))
  :VOID)

;;; (DEFGLOBAL *COMMAND-LINE-HELP-HEADER* ...)

(CL:DEFVAR *COMMAND-LINE-HELP-HEADER* ""
  "Documentation to be printed at the beginning of command line help.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *COMMAND-LINE-HELP-HEADER*))

;;; (DEFGLOBAL *COMMAND-LINE-HELP-TRAILER* ...)

(CL:DEFVAR *COMMAND-LINE-HELP-TRAILER* ""
  "Documentation to be printed at the end of command line help.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *COMMAND-LINE-HELP-TRAILER*))

;;; (DEFUN HELP-OPTION-HANDLER ...)

(CL:DEFUN HELP-OPTION-HANDLER (OPTION VALUE)
  "Print documentation about all currently registered option handlers."
  (CL:SETQ VALUE VALUE)
  (CL:LET* ((SORTEDOPTIONS NIL))
   (CL:LET*
    ((KEY NULL) (OPTION NULL)
     (ITER-000 (ALLOCATE-ITERATOR *REGISTERED-COMMAND-LINE-OPTIONS*))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
     (CL:SETQ OPTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:WHEN (EQL? KEY (%%VALUE (%CMD-LINE-OPTION.KEYS OPTION)))
      (CL:LOOP WHILE
       (STARTS-WITH? (%STRING-WRAPPER.WRAPPER-VALUE KEY) "-" 0) DO
       (CL:SETQ KEY
        (WRAP-STRING
         (SUBSEQUENCE (UNWRAP-STRING KEY) 1 NULL-INTEGER))))
      (CL:SETQ KEY
       (WRAP-STRING
        (STRING-DOWNCASE (%STRING-WRAPPER.WRAPPER-VALUE KEY))))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000 (CONS (CONS-LIST KEY OPTION) NIL))
        (CL:IF (CL:EQ SORTEDOPTIONS NIL)
         (CL:SETQ SORTEDOPTIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SORTEDOPTIONS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CONS-LIST KEY OPTION) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:SETQ SORTEDOPTIONS
    (SORT-TUPLES (REMOVE-DUPLICATES SORTEDOPTIONS) 0 NULL))
   (CL:WHEN (CL:NOT (BLANK-STRING? *COMMAND-LINE-HELP-HEADER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     *COMMAND-LINE-HELP-HEADER* EOL))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "The following command line options are supported:" EOL)
   (CL:LET* ((TUPLE NULL) (ITER-001 SORTEDOPTIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-001))
     (CL:SETQ OPTION (%%VALUE (%%REST TUPLE)))
     (CL:LET*
      ((KEY NULL) (ITER-002 (%CMD-LINE-OPTION.KEYS OPTION))
       (I NULL-INTEGER) (ITER-003 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
       (CL:WHEN (CL:> I 1)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         ", "))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        (UNWRAP-STRING KEY))
       (CL:SETQ ITER-002 (%%REST ITER-002))
       (CL:SETQ ITER-003 (CL:1+ ITER-003))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      " ")
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%CMD-LINE-OPTION.DOCUMENTATION OPTION) EOL)
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:WHEN (CL:NOT (BLANK-STRING? *COMMAND-LINE-HELP-TRAILER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     *COMMAND-LINE-HELP-TRAILER* EOL))
   (SET-CONFIGURATION-PROPERTY "stella.showInfoOnly" TRUE-WRAPPER NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS1 ()
  (CL:PROGN
   (CL:SETQ SYM-SYSTEMS-STELLA-SET-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-LOAD-PATH" NULL 0))
   (CL:SETQ KWD-SYSTEMS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSH-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ADD-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DROP-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DROP-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-FIND-FILE-IN-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIND-FILE-IN-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-PROPERTY-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ KWD-SYSTEMS-OPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIONS" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-IDENTITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDENTITY" NULL 1))
   (CL:SETQ KWD-SYSTEMS-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-MODULE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFSYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSYSTEM" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFCLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCLASS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFSLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-FILE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-REQUIRED-SYSTEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED-SYSTEMS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LOAD-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LANGUAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LANGUAGE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-MAKE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE-SYSTEM" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LISP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CPP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-JAVA-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DATA-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATA-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PREPROCESSED-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREPROCESSED-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CARDINAL-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINAL-MODULE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-SOURCE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-NATIVE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-BINARY-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-BINARY-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-BANNER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BANNER" NULL 2))
   (CL:SETQ KWD-SYSTEMS-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPYRIGHT-HEADER" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PRODUCTION-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEVELOPMENT-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FINALIZATION-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZATION-FUNCTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS2 ()
  (CL:PROGN
   (CL:SETQ KWD-SYSTEMS-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LISP-BINARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-BINARY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-TWO-PASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TWO-PASS?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEVELOPMENT-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PRODUCTION-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FORCE-TRANSLATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-TRANSLATION?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FORCE-RECOMPILATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-RECOMPILATION?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LOAD-SYSTEM?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-STARTUP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-RECURSIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECURSIVE?" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-FILE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-NAME" NULL 1))
   (CL:SETQ KWD-SYSTEMS-PROCESSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCESSED" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-MAKE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE-SYSTEM" NULL 0))
   (CL:SETQ KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL
     2))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-STARTED-UP?" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
   (CL:SETQ KWD-SYSTEMS-EARLY-INITS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EARLY-INITS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULES" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFINE-MODULE-FROM-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DEFINE-MODULE-FROM-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-PHASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE-TO-INTEGER" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FINAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STARTUP-TIME-PHASE*" NULL 0))
   (CL:SETQ KWD-SYSTEMS-DAYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DAYS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-HOURS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOURS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-MINUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MINUTES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-SECONDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SECONDS" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-SYSTEM-VERSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-VERSION" NULL 0))
   (CL:SETQ KWD-SYSTEMS-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ADD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIGURATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIGURATION-TABLE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-CONFIGURATION-FILE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-CLEAR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR" NULL 2))
   (CL:SETQ KWD-SYSTEMS-REMOVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REMOVE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-DIRECTORY" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIGURE-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIGURE-STELLA" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-GET-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SET-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-PROPERTY-VALUE" NULL 0))
   (CL:SETQ SGT-SYSTEMS-STELLA-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-GLOBAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 1))
   (CL:SETQ SYM-SYSTEMS-STELLA-TEST-PROPERTY-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-PROPERTY-DEMON" NULL 0))
   (CL:SETQ KWD-SYSTEMS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-CMD-LINE-OPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CMD-LINE-OPTION" NULL 1))
   (CL:SETQ SYM-SYSTEMS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-KEYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-VALUE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-TYPE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-MULTI-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTI-VALUED?" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS3 ()
  (CL:PROGN
   (CL:SETQ SYM-SYSTEMS-STELLA-N-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "N-ARGUMENTS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFAULT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-VALUE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIGURATION-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ERROR-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR-ACTION" NULL 0))
   (CL:SETQ KWD-SYSTEMS-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEY2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY2" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEY3
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY3" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-VALUE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-TYPE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 1))
   (CL:SETQ KWD-SYSTEMS-MULTI-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTI-VALUED?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-N-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "N-ARGUMENTS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEFAULT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-VALUE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ KWD-SYSTEMS-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLER" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ERROR-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR-ACTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
   (CL:SETQ KWD-SYSTEMS-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-IN-MODULE-OPTION-HANDLER"
     NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-PATH-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIG-FILE-OPTION-HANDLER" NULL
     0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-FILE-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-PROPERTY-OPTION-HANDLER"
     NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HELP-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SYSTEMS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS4 ()
  (CL:PROGN (CL:SETQ *FILE-LOAD-PATH* NIL)
   (CL:SETQ *STELLA-FILE-EXTENSIONS* (CONS-LIST (WRAP-STRING ".ste")))
   (CL:SETQ *CURRENTLOADFILE* STELLA::NULL-STRING)
   (CL:SETQ *SYSTEMDEFINITIONS* (NEW-LIST))
   (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *PL-ROOT-DIRECTORY* STELLA::NULL-STRING)
   (CL:SETQ *REGISTERED-PROPERTY-DEMONS* (NEW-KEY-VALUE-MAP))
   (CL:SETQ *REGISTERED-COMMAND-LINE-OPTIONS* (NEW-KEY-VALUE-MAP)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PARSE-DIRECTORY-PATH"
    "(DEFUN (PARSE-DIRECTORY-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)))"
    (CL:FUNCTION PARSE-DIRECTORY-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-LOAD-PATH"
    "(DEFUN (SET-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %SET-LOAD-PATH)
    (CL:FUNCTION SET-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-LOAD-PATH"
    "(DEFUN (GET-LOAD-PATH (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return the current STELLA load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION GET-LOAD-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-LOAD-PATH"
    "(DEFUN (PUSH-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %PUSH-LOAD-PATH)
    (CL:FUNCTION PUSH-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "POP-LOAD-PATH"
    "(DEFUN (POP-LOAD-PATH STRING) () :DOCUMENTATION \"Remove the first element from the STELLA load path
and return the removed element.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION POP-LOAD-PATH)
    (CL:FUNCTION POP-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ADD-LOAD-PATH"
    "(DEFUN (ADD-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %ADD-LOAD-PATH)
    (CL:FUNCTION ADD-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DROP-LOAD-PATH"
    "(DEFUN (DROP-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Remove the directories listed in the |-separated
`path' from the PowerLoom load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %DROP-LOAD-PATH)
    (CL:FUNCTION DROP-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "FIND-FILE-IN-LOAD-PATH"
    "(DEFUN (FIND-FILE-IN-LOAD-PATH STRING) ((FILE STRING) (EXTENSIONS (CONS OF STRING-WRAPPER))) :DOCUMENTATION \"Try to find `file' in the current load path and, if found,
return its full name.  If `file' can't be found literally, try to find it
with any of the listed `extensions' added.  If `extensions' is NULL it defaults
to `*stella-file-extensions*', therefore, to not default to any extensions
the value has to be supplied as NIL.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %FIND-FILE-IN-LOAD-PATH)
    (CL:FUNCTION FIND-FILE-IN-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-BOOLEAN"
    "(DEFUN (COERCE-VALUE-TO-BOOLEAN BOOLEAN-WRAPPER) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the boolean object represented by `value'.  Return NULL
if coercion is not possible or raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-BOOLEAN"
    "(DEFUN (COERCE-TO-BOOLEAN BOOLEAN-WRAPPER) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the boolean object represented by `object'.
Return NULL if coercion is not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-STRING"
    "(DEFUN (COERCE-VALUE-TO-STRING STRING) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' into a string if possible, return NULL
otherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-STRING"
    "(DEFUN (COERCE-TO-STRING STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `object' into a string.  If no standard coercion
is possible, simply stringify `object'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-FLOAT"
    "(DEFUN (COERCE-VALUE-TO-FLOAT FLOAT) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to a float value if possible, return
NULL otherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-FLOAT"
    "(DEFUN (COERCE-TO-FLOAT FLOAT) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `number' to a float value or NULL if not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-TYPE"
    "(DEFUN (COERCE-VALUE-TO-TYPE OBJECT) ((VALUE OBJECT) (TYPE TYPE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible
or raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-OPTION-VALUE"
    "(DEFUN (COERCE-OPTION-VALUE OBJECT) ((VALUE OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-OPTION-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "VET-OPTIONS"
    "(DEFUN (VET-OPTIONS PROPERTY-LIST) ((PLIST OBJECT) (LEGALOPTIONS (CONS OF KEYWORD))))"
    (CL:FUNCTION VET-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-OPTIONS"
    "(DEFUN (PARSE-OPTIONS PROPERTY-LIST) ((OPTIONS OBJECT) (|LEGALOPTIONS&TYPES| CONS) (COERCIONERROR? BOOLEAN) (ALLOWOTHERKEYS? BOOLEAN)) :DOCUMENTATION \"Parse `options', check their validity according to
`legalOptions&Types' and return the result as a PROPERTY-LIST.
`legalOptions&Types' has to either be NULL or a flat list of legal
<keyword> <coercionType> pairs.  A type specifcation of @IDENTITY
means don't perform any coercion.
If `coercionError?' is TRUE, raise an error if a coercion failed.
If `allowOtherKeys?' is TRUE options other than those specified in
`legalOptions&Types' are allowed but won't be coerced since we don't
know their type.  A special implicit :options keyword that does not
need to be declared can be used to pass in an already parsed options
list from a caller, which will then be analyzed and used instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PARSE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-COMMAND"
    "(DEFUN (EVALUATE-COMMAND OBJECT) ((COMMAND OBJECT) (FINALIZE? BOOLEAN)))"
    (CL:FUNCTION EVALUATE-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-FILE"
    "(DEFUN LOAD-FILE ((FILE STRING)) :DOCUMENTATION \"Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %LOAD-FILE) (CL:FUNCTION LOAD-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "MAKE-SYSTEM-DEFINITION-FILE-NAME"
    "(DEFUN (MAKE-SYSTEM-DEFINITION-FILE-NAME FILE-NAME) ((NAME STRING)) :DOCUMENTATION \"Make a canonical system definition file name for a system named `name'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MAKE-SYSTEM-DEFINITION-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-STELLA-SYSTEMS-PATH"
    "(DEFUN (BUILD-STELLA-SYSTEMS-PATH (CONS OF STRING-WRAPPER)) ())"
    (CL:FUNCTION BUILD-STELLA-SYSTEMS-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-SYSTEM-DEFINITION-FILE"
    "(DEFUN (FIND-SYSTEM-DEFINITION-FILE FILE-NAME) ((NAME STRING)) :DOCUMENTATION \"Try to find an existing system definition file for a system named `name'
in the current STELLA_SYSTEMS_PATH or built-in implicit systems path.  Return NULL if no
such definition file can be found.  See `build-stella-systems-path' on where it looks.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-SYSTEM-DEFINITION-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE"
    "(DEFUN (FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE FILE-NAME) ((SYSDEFFILE FILE-NAME)) :DOCUMENTATION \"Given a system definition file `sysDefFile' try to determine the root directory
of the STELLA installation containing this system by looking for top-level native directories.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-SYSTEM-ROOT-DIRECTORY-FROM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-SYSTEM-ROOT-DIRECTORY"
    "(DEFUN (FIND-SYSTEM-ROOT-DIRECTORY FILE-NAME) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Given a system definition `system' try to determine the root directory
of the STELLA installation containing this system based on its definition file.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-SYSTEM-ROOT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SYSTEM-ROOT-DIRECTORIES"
    "(DEFUN COMPUTE-SYSTEM-ROOT-DIRECTORIES ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute any root directories for sources, native and Lisp binary directories
in case they were not explicitly specified in `system's definition.  Raises an error in case
any of those root directories is missing and can't be computed.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COMPUTE-SYSTEM-ROOT-DIRECTORIES) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-LIST-OF-FILE-PATHS"
    "(DEFUN (PARSE-LIST-OF-FILE-PATHS (CONS OF STRING-WRAPPER)) ((FILES CONS)))"
    (CL:FUNCTION PARSE-LIST-OF-FILE-PATHS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-SYSTEM"
    "(DEFUN (DEFINE-SYSTEM SYSTEM-DEFINITION) ((NAME OBJECT) (OPTIONS CONS)))"
    (CL:FUNCTION DEFINE-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFSYSTEM"
    "(DEFUN (DEFSYSTEM SYSTEM-DEFINITION) ((NAME SYMBOL) |&REST| (OPTIONS OBJECT)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE :DOCUMENTATION \"Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java\")"
    (CL:FUNCTION %DEFSYSTEM) (CL:FUNCTION DEFSYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-DEFINITION"
    "(DEFUN (GET-SYSTEM-DEFINITION SYSTEM-DEFINITION) ((NAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a system named 'name'.  If no such system is currently defined,
look for a system definition file for `name' in standard locations and try to load it.
If no matching system could be found or loaded and `error?' is true, raise an error,
otherwise, simply return NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SYSTEM-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CARDINAL-MODULE"
    "(DEFUN (GET-CARDINAL-MODULE MODULE) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION GET-CARDINAL-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-SYSTEM-FILES"
    "(DEFUN HELP-GET-SYSTEM-FILES ((FILENAME FILE-NAME) (COLLECTION LIST) (PROBEFILE? BOOLEAN)))"
    (CL:FUNCTION HELP-GET-SYSTEM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-FILES"
    "(DEFUN (GET-SYSTEM-FILES (LIST OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION) (TYPE KEYWORD) (PROBEFILES? BOOLEAN)))"
    (CL:FUNCTION GET-SYSTEM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAN-SYSTEM"
    "(DEFUN CLEAN-SYSTEM ((SYSTEMNAME STRING)))"
    (CL:FUNCTION CLEAN-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-OPTIMIZATION-LEVELS"
    "(DEFUN COMPUTE-OPTIMIZATION-LEVELS ((SYSTEM SYSTEM-DEFINITION) (PRODUCTIONMODE? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-OPTIMIZATION-LEVELS) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-SYSTEM"
    "(DEFUN (MAKE-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `make-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %MAKE-SYSTEM)
    (CL:FUNCTION MAKE-SYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RUN-SYSTEM-FINALIZATION"
    "(DEFUN RUN-SYSTEM-FINALIZATION ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION RUN-SYSTEM-FINALIZATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITION-SOURCE-FILES"
    "(DEFUN (SYSTEM-DEFINITION-SOURCE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-DEFINITION-SOURCE-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "FILES-PLUS-SYSTEM-STARTUP"
    "(DEFUN (FILES-PLUS-SYSTEM-STARTUP (CONS OF STRING-WRAPPER)) ((FILES (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION FILES-PLUS-SYSTEM-STARTUP) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITION-NATIVE-FILES"
    "(DEFUN (SYSTEM-DEFINITION-NATIVE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-DEFINITION-NATIVE-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-LOADED?"
    "(DEFUN (SYSTEM-LOADED? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has been loaded.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SYSTEM-LOADED?) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-LOADED-OR-STARTED-UP?"
    "(DEFUN (SYSTEM-LOADED-OR-STARTED-UP? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has either been loaded
or initialized with its startup function.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SYSTEM-LOADED-OR-STARTED-UP?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SYSTEM"
    "(DEFUN CLEAR-SYSTEM ((NAME STRING)) :DOCUMENTATION \"Clears out the system definition named `name'.  If
`name' is `null', then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-PREPROCESSED-FILES"
    "(DEFUN LOAD-PREPROCESSED-FILES ((SYSTEMNAME STRING)))"
    (CL:FUNCTION LOAD-PREPROCESSED-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-SYSTEM"
    "(DEFUN (LOAD-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.

`:recursive?' (default false): if true, perform `load-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %LOAD-SYSTEM)
    (CL:FUNCTION LOAD-SYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COMPILE-AND-LOAD-FILES"
    "(DEFUN (COMPILE-AND-LOAD-FILES BOOLEAN) ((FILES (CONS OF STRING-WRAPPER)) (LANGUAGE KEYWORD) (FORCERECOMPILATION? BOOLEAN)))"
    (CL:FUNCTION COMPILE-AND-LOAD-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-SYSTEM-STARTUP-FUNCTION"
    "(DEFUN RUN-SYSTEM-STARTUP-FUNCTION ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION RUN-SYSTEM-STARTUP-FUNCTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))"
    (WRAP-METHOD-CODE (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-NAME)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEMNAME STRING)))"
    (WRAP-METHOD-CODE (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-NAME)) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FUNCTION-SYMBOL"
    "(DEFUN (SYSTEM-STARTUP-FUNCTION-SYMBOL SYMBOL) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-NAME-FROM-FILE"
    "(DEFUN (STARTUP-NAME-FROM-FILE SYMBOL) ((FILE FILE-NAME)))"
    (CL:FUNCTION STARTUP-NAME-FROM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-NAMES-FROM-FILES"
    "(DEFUN (STARTUP-NAMES-FROM-FILES (CONS OF SYMBOL)) ((FILES (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION STARTUP-NAMES-FROM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FILE-NAME"
    "(DEFUN (SYSTEM-STARTUP-FILE-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-STARTUP-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FILE?"
    "(DEFUN (SYSTEM-STARTUP-FILE? BOOLEAN) ((FILE FILE-NAME)))"
    (CL:FUNCTION SYSTEM-STARTUP-FILE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTED-UP?"
    "(DEFUN (SYSTEM-STARTED-UP? BOOLEAN) ((SYSTEMNAME STRING) (SYSTEMMODULENAME STRING)))"
    (CL:FUNCTION SYSTEM-STARTED-UP?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STARTUP-REQUIRED-SYSTEMS"
    "(DEFUN (YIELD-STARTUP-REQUIRED-SYSTEMS CONS) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION YIELD-STARTUP-REQUIRED-SYSTEMS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE"
    "(DEFUN (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (CONS OF CONS)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE"
    "(DEFUN (COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE (CONS OF MODULE)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION COLLECT-DEFINED-MODULES-FROM-SYSTEM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SYSTEM-STARTUP-FILE"
    "(DEFUN CREATE-SYSTEM-STARTUP-FILE ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION CREATE-SYSTEM-STARTUP-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ALL-REQUIRED-SYSTEMS"
    "(DEFUN (HELP-ALL-REQUIRED-SYSTEMS (LIST OF STRING-WRAPPER)) ((SYSTEM-NAME STRING) (FOUND (LIST OF STRING-WRAPPER))))"
    (CL:FUNCTION HELP-ALL-REQUIRED-SYSTEMS) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS6 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "ALL-REQUIRED-SYSTEMS"
    "(DEFUN (ALL-REQUIRED-SYSTEMS (CONS OF STRING-WRAPPER)) ((SYSTEM-NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns a CONS of all of the systems required by `system-name'\")"
    (CL:FUNCTION ALL-REQUIRED-SYSTEMS) NULL)
   (DEFINE-FUNCTION-OBJECT "DATE-TO-VERSION-STRING"
    "(DEFUN (DATE-TO-VERSION-STRING STRING) ((DATE CALENDAR-DATE) (GRANULARITY KEYWORD)) :DOCUMENTATION \"Transform `date' into a version string according to `granularity'
which is at least :days and defaults to :seconds.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DATE-TO-VERSION-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-LAST-MODIFIED-DATE"
    "(DEFUN (GET-SYSTEM-LAST-MODIFIED-DATE CALENDAR-DATE) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute a last-modified date for `system' based on its most recently modified source file.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SYSTEM-LAST-MODIFIED-DATE) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT SYSTEM-DEFINITION SYSTEM-VERSION :TYPE STRING :OPTION-KEYWORD :VERSION :DOCUMENTATION \"Explicitly define a version number for this system.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-VERSION-STRING"
    "(DEFUN (GET-SYSTEM-VERSION-STRING STRING) ((SYSTEM SYSTEM-DEFINITION)) :DOCUMENTATION \"Compute a version string for `system' which is either based on an explicit :version
annotation on `system's definition, the readable value of an existing `*<system>-version[-string]*',
variable or on its most recent modification date of any of its source files.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SYSTEM-VERSION-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "AUTOLOAD"
    "(DEFUN (AUTOLOAD FUNCTION-CODE) ((QUALIFIEDNAME STRING) (SYSTEMNAME STRING) (CACHE SURROGATE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Autoload function `qualifiedName' from system `systemName'.
If it is already present in the system, simply return its code.  If `cache'
is defined, return its value if defined, otherwise, set its value to the
function found.  If the function failed to be defined by loading `systemName'
and `error?' is true, raise an error.  Otherwise, simply return NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION AUTOLOAD) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-STELLA"
    "(DEFUN MAKE-STELLA ((FORCERECOMPILATION? BOOLEAN)))"
    (CL:FUNCTION MAKE-STELLA) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-CONFIGURATION-FILE-LINE"
    "(DEFUN (PARSE-CONFIGURATION-FILE-LINE STRING-WRAPPER WRAPPER KEYWORD) ((LINE STRING)))"
    (CL:FUNCTION PARSE-CONFIGURATION-FILE-LINE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-CONFIGURATION-FILE"
    "(DEFUN (LOAD-CONFIGURATION-FILE CONFIGURATION-TABLE) ((FILE FILE-NAME)) :DOCUMENTATION \"Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %LOAD-CONFIGURATION-FILE)
    (CL:FUNCTION LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SAVE-CONFIGURATION-VALUE"
    "(DEFUN SAVE-CONFIGURATION-VALUE ((STREAM OUTPUT-STREAM) (VALUE OBJECT)) :DOCUMENTATION \"Save `value' to `stream' as a properly formatted configuration
value.\")" (CL:FUNCTION SAVE-CONFIGURATION-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-CONFIGURATION-FILE"
    "(DEFUN SAVE-CONFIGURATION-FILE ((TABLE CONFIGURATION-TABLE) (FILE FILE-NAME) (TITLE STRING)) :DOCUMENTATION \"Save `table' as a configuration file.  Uses a Java-style property file syntax.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SAVE-CONFIGURATION-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONFIGURATION-PROPERTY"
    "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (DEFAULTVALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration' and return its value.
Use the global system configuration table if `configuration' is NULL.  Return
`defaultValue' if `property' is not defined.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONFIGURATION-PROPERTY-VALUES"
    "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY-VALUES CONS) ((PROPERTY STRING) (DEFAULTVALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration', assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if `configuration' is NULL.  Return `defaultValue' if `property' is not defined or
NIL is no default value is specified.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CONFIGURATION-PROPERTY-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-CONFIGURATION-PROPERTY"
    "(DEFUN (SET-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Set `property' in `configuration' to `value' and return it.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SET-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-CONFIGURATION-PROPERTY"
    "(DEFUN (ADD-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Add `value' to `property' in `configuration' and return it.
If a previous value exists add `value' to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing `value'.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ADD-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-CONFIGURATION-PROPERTY"
    "(DEFUN (CLEAR-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `property' in `configuration' and return the previous
value.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-CONFIGURATION-PROPERTY"
    "(DEFUN (REMOVE-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `value' from `property' in `configuration' and return it.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONFIGURATION-PROPERTIES"
    "(DEFUN PRINT-CONFIGURATION-PROPERTIES ((CONFIGURATION CONFIGURATION-TABLE) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Print all properties defined in `configuration' to `stream'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-CONFIGURATION-PROPERTIES) NULL)
   (DEFINE-FUNCTION-OBJECT "*PL-ROOT-DIRECTORY*-SETTER"
    "(DEFUN (*PL-ROOT-DIRECTORY*-SETTER STRING) ((VALUE STRING)))"
    (CL:FUNCTION *PL-ROOT-DIRECTORY*-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CONFIGURE-STELLA"
    "(DEFUN CONFIGURE-STELLA ((FILE FILE-NAME)) :DOCUMENTATION \"Perform STELLA run-time configuration.  If supplied, load the
configuration file `file' first which should be supplied with a physical pathname.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %CONFIGURE-STELLA)
    (CL:FUNCTION CONFIGURE-STELLA-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-PROPERTY"
    "(DEFUN (GET-PROPERTY OBJECT) ((PROPERTY NAME) |&REST| (DEFAULTVALUE OBJECT)) :DOCUMENTATION \"Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %GET-PROPERTY)
    (CL:FUNCTION GET-PROPERTY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-PROPERTY"
    "(DEFUN SET-PROPERTY ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %SET-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-PROPERTY-VALUE"
    "(DEFUN ADD-PROPERTY-VALUE ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %ADD-PROPERTY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-PROPERTIES"
    "(DEFUN PRINT-PROPERTIES () :DOCUMENTATION \"Print all current configuration property information to
standard output.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION PRINT-PROPERTIES) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-PROPERTY-DEMON"
    "(DEFUN REGISTER-PROPERTY-DEMON ((PROPERTY STRING) (DEMONNAME SYMBOL)) :DOCUMENTATION \"Register the function named `demonName' as the demon for `property'.
Demons will be run as after demons on every configuration table update.  Set the
property `stella.test.propertyDemon' to see a test demon in action.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-PROPERTY-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-PROPERTY-DEMON"
    "(DEFUN UNREGISTER-PROPERTY-DEMON ((PROPERTY STRING)) :DOCUMENTATION \"Unregister any demon for `property'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNREGISTER-PROPERTY-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VARIABLE-DEMON-SETTER"
    "(DEFUN (LOOKUP-VARIABLE-DEMON-SETTER METHOD-SLOT) ((DEMON GLOBAL-VARIABLE)))"
    (CL:FUNCTION LOOKUP-VARIABLE-DEMON-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-CONFIGURATION-PROPERTY-DEMON"
    "(DEFUN RUN-CONFIGURATION-PROPERTY-DEMON ((ACTION KEYWORD) (PROPERTY STRING) (VALUE OBJECT) (TABLE CONFIGURATION-TABLE)))"
    (CL:FUNCTION RUN-CONFIGURATION-PROPERTY-DEMON) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT DEMON-PROPERTY :TYPE STRING :OPTION-KEYWORD :DEMON-PROPERTY :OPTION-HANDLER DEMON-PROPERTY-HANDLER :DOCUMENTATION \"Holds the property monitored by a demon function.  This slot is primarily used
to allow us the use of the :demon-property option handler for demon registration.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT GLOBAL-VARIABLE DEMON-PROPERTY :TYPE STRING :OPTION-KEYWORD :DEMON-PROPERTY :OPTION-HANDLER DEMON-PROPERTY-HANDLER :DOCUMENTATION \"Holds the property monitored by a demon for this variable.  This slot is
primarily used to allow us the use of the :demon-property option handler for demon registration.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "DEMON-PROPERTY-HANDLER"
    "(DEFUN DEMON-PROPERTY-HANDLER ((DEMON MAPPABLE-OBJECT) (SLOT STORAGE-SLOT) (PROPERTY OBJECT)))"
    (CL:FUNCTION DEMON-PROPERTY-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-PROPERTY-DEMON"
    "(DEFUN TEST-PROPERTY-DEMON ((ACTION KEYWORD) (PROPERTY STRING) (VALUE OBJECT) (TABLE CONFIGURATION-TABLE)) :DOCUMENTATION \"A test demon for the property demon machinery which simply prints arguments.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-PROPERTY-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-CMD-LINE-OPTION"
    "(DEFUN REGISTER-CMD-LINE-OPTION (|&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Register a command line option.  :key identifies the name of the option which
will usually start with a dash such as `-e' or `--eval'.  :key2 and :key3 can be used to supply
additional options (e.g., long option formats).  To supply even more keys, a list can be supplied
with the :keys option.  If a :property is supplied, this option simply sets or adds to the values
of the specified system configuration property.  If a :handler name is specified, its function
will be used to interpret the values of the option.  :documentation can be used to supply a
documentation string which will be printed by the `help-option-handler' (usually bound to `-?').
:value-type describes what type an option value should be coerced to before assigning it to the
specified configuration :property.  :n-arguments describes how many arguments this option
takes.  This will be 0 for simple switches and can be 1 or greater than one for option handlers
that need one or more arguments.  :default-value defines the value to use for zero-argument
:property options.  If :multi-valued? is true, values of multiple occurrences of the option will be
added to the specified configuration :property.  :error-action can be one of :ignore, :warn or
:error to specify what to do in case an error is encountered during option processing.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-CMD-LINE-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-CMD-LINE-OPTION"
    "(DEFUN UNREGISTER-CMD-LINE-OPTION ((KEY STRING)) :DOCUMENTATION \"Unregister the command line option identified by `key' under all its keys.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNREGISTER-CMD-LINE-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-ALL-CMD-LINE-OPTIONS"
    "(DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS () :DOCUMENTATION \"Unregister all currently registered command line options.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNREGISTER-ALL-CMD-LINE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-CMD-LINE-OPTION-HANDLER"
    "(DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Default handler that tries to set a system property based on `option' and `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-COMMAND-LINE-ARGUMENTS"
    "(DEFUN PROCESS-COMMAND-LINE-ARGUMENTS ((COUNT INTEGER) (ARGUMENTS (ARRAY () OF STRING)) (UNHANDLEDOPTIONACTION KEYWORD)) :DOCUMENTATION \"Interpret any command line `arguments' for which handlers have been registered.
Leave any remaining unprocessed arguments in `*unprocessed-command-line-arguments*'.
If any unprocessed arguments use option syntax (that is they start with a `-'), proceed
according to `unhandledOptionAction' which can be one of :ignore, :warn or :error.
This ensures that at any point in the option processing, `*unprocessed-command-line-arguments*'
accurately reflects the arguments which have been either skipped or not handled yet.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PROCESS-COMMAND-LINE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNPROCESSED-COMMAND-LINE-ARGUMENTS"
    "(DEFUN (UNPROCESSED-COMMAND-LINE-ARGUMENTS (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return all command line arguments which have not yet been processed
by (or been ignored by) `process-command-line-arguments'.  If arguments have not yet
been processed, this will return NULL.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION UNPROCESSED-COMMAND-LINE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVAL-OPTION-HANDLER"
    "(DEFUN EVAL-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval option by evaluating `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVAL-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "EVAL-IN-MODULE-OPTION-HANDLER"
    "(DEFUN EVAL-IN-MODULE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval-in-module option.  `value' is expected
to be of the form `(<module-name> <s-expression>)'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVAL-IN-MODULE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-PATH-OPTION-HANDLER"
    "(DEFUN LOAD-PATH-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Modify the current file load path according to `option' and `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOAD-PATH-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "CONFIG-FILE-OPTION-HANDLER"
    "(DEFUN CONFIG-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the configuration file `value'.  This will
modify currently set system properties defined in `value' with new
values but leave all other currently set properties as they are.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONFIG-FILE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-FILE-OPTION-HANDLER"
    "(DEFUN LOAD-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the file `value' using the STELLA `load-file' command.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOAD-FILE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-PROPERTY-OPTION-HANDLER"
    "(DEFUN DEFINE-PROPERTY-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)))"
    (CL:FUNCTION DEFINE-PROPERTY-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-OPTION-HANDLER"
    "(DEFUN HELP-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Print documentation about all currently registered option handlers.\" :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-SYSTEMS"
    "(DEFUN STARTUP-SYSTEMS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SYSTEMS) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSystems") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-SYSTEMS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SYSTEMS1)
    (HELP-STARTUP-SYSTEMS2) (HELP-STARTUP-SYSTEMS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-SYSTEMS4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE CONFIGURATION-TABLE (KEY-VALUE-LIST OF STRING-WRAPPER OBJECT))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CMD-LINE-OPTION"
        "(DEFCLASS CMD-LINE-OPTION (STANDARD-OBJECT) :SLOTS ((DOCUMENTATION :TYPE STRING :INITIALLY \"Not documented.\") (KEYS :TYPE (CONS OF STRING-WRAPPER) :INITIALLY NIL) (VALUE-TYPE :TYPE TYPE :INITIALLY @STRING) (MULTI-VALUED? :TYPE BOOLEAN :INITIALLY FALSE) (N-ARGUMENTS :TYPE INTEGER :INITIALLY 0 :DOCUMENTATION \"The number of args expected by this option.
Common values are 0 or 1, but certain options might take more than one argument.\") (DEFAULT-VALUE :TYPE OBJECT :DOCUMENTATION \"The value to use for 0-arg options.
Defaults to TRUE for 0-arg options with boolean value type.\") (CONFIGURATION-PROPERTY :TYPE STRING) (HANDLER :TYPE FUNCTION-CODE :INITIALLY (THE-CODE :FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER)) (ERROR-ACTION :TYPE KEYWORD :INITIALLY :ERROR :DOCUMENTATION \"One of :ignore, :warn, :error.\")))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CMD-LINE-OPTION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CMD-LINE-OPTION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SYSTEMS5)
    (HELP-STARTUP-SYSTEMS6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *FILE-LOAD-PATH* (CONS OF STRING-WRAPPER) NIL)" NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-SET-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-ADD-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-DROP-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *STELLA-FILE-EXTENSIONS* CONS (CONS-LIST \".ste\") :DOCUMENTATION \"File extensions to append by default when a
file is looked up by `find-file-in-load-path'.\" :PUBLIC? TRUE)" NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-FIND-FILE-IN-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENTLOADFILE* STRING NULL :DOCUMENTATION \"Full pathname of file that is currently being loaded (or similar).\" :PUBLIC? TRUE)"
     NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-FILE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *SYSTEMDEFINITIONS* (LIST OF SYSTEM-DEFINITION) (NEW LIST) :DOCUMENTATION \"A list of all defined systems.\")"
     NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-DEFSYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENT-SYSTEM-ACTION* PROPERTY-LIST NULL :DOCUMENTATION \"Holds the action and options of the current system action
such as :make-system, :load-system or :translate-system.  This is used to
perform the appropriate actions on required systems in `define-system'.\")"
     NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-MAKE-SYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-SYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *SYSTEM-CONFIGURATION-TABLE* CONFIGURATION-TABLE (NEW CONFIGURATION-TABLE))"
     NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *PL-ROOT-DIRECTORY* STRING NULL :DOCUMENTATION \"The :root-directory portion of the PL logical host.  This variable
is primarily defined to allow us to dynamically change this via a configuration demon.\" :DEMON-PROPERTY \"stella.plRootDirectory\" :PUBLIC? TRUE)"
     NULL)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-CONFIGURE-STELLA
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-GET-PROPERTY
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-SET-PROPERTY
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *REGISTERED-PROPERTY-DEMONS* (KEY-VALUE-MAP OF STRING-WRAPPER MAPPABLE-OBJECT) (NEW KEY-VALUE-MAP))"
     NULL)
    (REGISTER-PROPERTY-DEMON "stella.test.propertyDemon"
     SYM-SYSTEMS-STELLA-TEST-PROPERTY-DEMON)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *REGISTERED-COMMAND-LINE-OPTIONS* (KEY-VALUE-MAP OF STRING-WRAPPER CMD-LINE-OPTION) (NEW KEY-VALUE-MAP))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *UNPROCESSED-COMMAND-LINE-ARGUMENTS* (CONS OF STRING-WRAPPER) NULL)"
     NULL)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-e")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--eval") KWD-SYSTEMS-KEY3
     (WRAP-STRING "-eval") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<s-expression>
  Evaluate the STELLA <s-expression> in the current module.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER KWD-SYSTEMS-ERROR-ACTION
     KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY
     (WRAP-STRING "--eval-in-module") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<module-name> <s-expression>
  Evaluate the STELLA <s-expression> in module <module-name>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 2) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--path+=")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Add <path> to the front of the current file load path.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path=")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Set the current file load path to <path>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path=+")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Add <path> at the end of the current file load path.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-c")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--configuration-file")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<file>
  Load the STELLA configuration file <file>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-l")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--load") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<file>
  Load the STELLA file <file>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-D")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--define")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<property>{=|+=|-=}<value>}
  Set the STELLA configuration <property> to <value>.  Multi-valued properties can be
  added to via the `+=' and removed from via the `-=' assignment operator.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *COMMAND-LINE-HELP-HEADER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the beginning of command line help.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *COMMAND-LINE-HELP-TRAILER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the end of command line help.\" :PUBLIC? TRUE)"
     NULL)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-?")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--help") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "
  Print this command line help message.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 0) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER)))
  :VOID)
