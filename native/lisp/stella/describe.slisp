;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; describe.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-DESCRIBE-STELLA-GET NULL)
(CL:DEFVAR KWD-DESCRIBE-COMMON-LISP NULL)
(CL:DEFVAR KWD-DESCRIBE-FUNCTION NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-CLASS NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-OBJECT NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-CONTEXT NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-SLOT NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-DEMON NULL)
(CL:DEFVAR KWD-DESCRIBE-VERBOSE NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-DESCRIBE NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-CONS NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-LIST NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-ITERATOR NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-RELATION NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-TRUE NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-FALSE NULL)
(CL:DEFVAR SGT-DESCRIBE-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR KWD-DESCRIBE-SOURCE NULL)
(CL:DEFVAR KWD-DESCRIBE-TERSE NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-SLOT NULL)
(CL:DEFVAR KWD-DESCRIBE-OWNER NULL)
(CL:DEFVAR KWD-DESCRIBE-TYPE NULL)
(CL:DEFVAR KWD-DESCRIBE-INITIALLY NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-DEFMODULE NULL)
(CL:DEFVAR KWD-DESCRIBE-INCLUDES NULL)
(CL:DEFVAR KWD-DESCRIBE-USES NULL)
(CL:DEFVAR KWD-DESCRIBE-SHADOWS NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA->>_INFERRED_SLOTS NULL)
(CL:DEFVAR KWD-DESCRIBE-CHILDREN NULL)
(CL:DEFVAR KWD-DESCRIBE-USED-BY NULL)
(CL:DEFVAR KWD-DESCRIBE-CARDINAL-MODULE NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-STARTUP-DESCRIBE NULL)
(CL:DEFVAR SYM-DESCRIBE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-STRING-WRAPPER FALSE-WRAPPER
  TRUE-WRAPPER ELLIPSIS NULL-INTEGER STANDARD-OUTPUT EOL NIL))

;;; (DEFUN (GET OBJECT) ...)

(CL:DEFUN %GET (NAME TYPE)
  (CL:LET* ((TYPESPEC TYPE))
   (CL:RETURN-FROM %GET (SEARCH-FOR-OBJECT NAME (%%VALUE TYPESPEC)))))

(CL:DEFUN GET-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM GET-EVALUATOR-WRAPPER
   (%GET (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))))

(CL:DEFMACRO GET (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/GET|)) (CL:MACRO-FUNCTION (CL:QUOTE GET)))

;;; (DEFMETHOD (GET-OBJECT OBJECT) ...)

(%%DEFCONSMETHOD GET-OBJECT ((SELF OBJECT) TYPE)
  (CL:RETURN-FROM GET-OBJECT (SEARCH-FOR-OBJECT SELF TYPE)))

;;; (DEFMETHOD (GET-OBJECT OBJECT) ...)

(CL:DEFMETHOD GET-OBJECT ((SELF CL:STRING) TYPE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET*
   ((WRAPPEDSTRING (WRAP-STRING SELF))
    (OBJECT (SEARCH-FOR-OBJECT WRAPPEDSTRING TYPE)))
   (FREE WRAPPEDSTRING) (CL:RETURN-FROM GET-OBJECT OBJECT)))

;;; (DEFMETHOD (GET-OBJECT OBJECT) ...)

(%%DEFINTEGERMETHOD GET-OBJECT ((SELF CL:FIXNUM) TYPE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:FIXNUM)
  (CL:LET*
   ((WRAPPEDINTEGER (WRAP-INTEGER SELF))
    (OBJECT (SEARCH-FOR-OBJECT WRAPPEDINTEGER TYPE)))
   (FREE WRAPPEDINTEGER) (CL:RETURN-FROM GET-OBJECT OBJECT)))

;;; (DEFGLOBAL *STRING-TO-OBJECT-FUNCTIONS* ...)

(CL:DEFVAR *STRING-TO-OBJECT-FUNCTIONS* NULL
  "Table of functions (keyed by type of object returned) that can
be called to search for an object identified by a string.")

;;; (DEFGLOBAL *INTEGER-TO-OBJECT-FUNCTIONS* ...)

(CL:DEFVAR *INTEGER-TO-OBJECT-FUNCTIONS* NULL
  "List of functions that can be called to search for
an object identified by an integer.")

;;; (DEFUN (STRING-SEARCH-FOR-OBJECT OBJECT) ...)

(CL:DEFUN STRING-SEARCH-FOR-OBJECT (STRING CLASSTYPE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET* ((OBJECT NULL))
   (CL:LET*
    ((TYPE NULL) (FN NULL)
     (ITER-000
      (%KEY-VALUE-LIST.THE-KV-LIST *STRING-TO-OBJECT-FUNCTIONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ TYPE (%KV-CONS.KEY ITER-000))
     (CL:SETQ FN (%KV-CONS.VALUE ITER-000))
     (CL:WHEN
      (CL:OR (CL:EQ CLASSTYPE NULL) (SUBTYPE-OF? TYPE CLASSTYPE))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FN)
         SGT-DESCRIBE-STELLA-FUNCTION-CODE-WRAPPER)
        (CL:PROGN
         (CL:SETQ OBJECT
          (CL:FUNCALL (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FN)
           STRING))))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          (SAFE-PRIMARY-TYPE FN) "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
      (CL:WHEN (CL:NOT (CL:EQ OBJECT NULL))
       (CL:RETURN-FROM STRING-SEARCH-FOR-OBJECT OBJECT)))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
   (CL:RETURN-FROM STRING-SEARCH-FOR-OBJECT NULL)))

;;; (DEFUN (SEARCH-FOR-OBJECT OBJECT) ...)

(CL:DEFUN SEARCH-FOR-OBJECT (SELF TYPEREF)
  "If `self' is a string or a symbol, search for an object named
`self' of type `type'.  Otherwise, if `self' is an object, return it."
  (CL:LET* ((CLASSTYPE NULL))
   (CL:WHEN (CL:NOT (CL:EQ TYPEREF NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TYPEREF)))
     (CL:COND
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ CLASSTYPE
         (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL.SYMBOL-NAME TYPEREF)
          (%SYMBOL.HOME-CONTEXT TYPEREF) CL:NIL))))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ CLASSTYPE TYPEREF)))
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ CLASSTYPE
         (LOOKUP-SURROGATE (%STRING-WRAPPER.WRAPPER-VALUE TYPEREF)))))
      ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ CLASSTYPE (%CLASS.CLASS-TYPE TYPEREF))))
      (CL:T
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Invalid type reference: `" TYPEREF "'" EOL))))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ CLASSTYPE NULL))
      (CL:OR (CL:EQ (%SURROGATE.SURROGATE-VALUE CLASSTYPE) NULL)
       (CL:NOT
        (ISA? (%SURROGATE.SURROGATE-VALUE CLASSTYPE)
         SGT-DESCRIBE-STELLA-CLASS))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "No class exists with name: `" (%SURROGATE.SYMBOL-NAME CLASSTYPE)
      "'" EOL)
     (CL:SETQ CLASSTYPE NULL)))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-001)
      (CL:PROGN
       (CL:LET*
        ((STRING (%STRING-WRAPPER.WRAPPER-VALUE SELF))
         (OBJECT (STRING-SEARCH-FOR-OBJECT STRING CLASSTYPE))
         (MODULE NULL))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
        (CL:WHEN
         (CL:AND (CL:EQ OBJECT NULL) (QUALIFIED-STELLA-NAME? STRING))
         (CL:MULTIPLE-VALUE-SETQ (MODULE STRING)
          (COMPUTE-MODULE-AND-BARE-NAME STRING))
         (CL:SETQ OBJECT (STRING-SEARCH-FOR-OBJECT STRING CLASSTYPE)))
        (CL:WHEN (CL:EQ OBJECT NULL)
         (CL:SETQ STRING (STRING-UPCASE STRING))
         (CL:SETQ OBJECT (STRING-SEARCH-FOR-OBJECT STRING CLASSTYPE)))
        (CL:RETURN-FROM SEARCH-FOR-OBJECT OBJECT))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
      (CL:PROGN
       (CL:RETURN-FROM SEARCH-FOR-OBJECT
        (SEARCH-FOR-OBJECT (WRAP-STRING (%SYMBOL.SYMBOL-NAME SELF))
         CLASSTYPE))))
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
      (CL:PROGN
       (CL:LET*
        ((INTEGER (%INTEGER-WRAPPER.WRAPPER-VALUE SELF)) (OBJECT NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INTEGER))
        (CL:LET*
         ((FN NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST *INTEGER-TO-OBJECT-FUNCTIONS*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ FN (%%VALUE ITER-000))
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FN)
             SGT-DESCRIBE-STELLA-FUNCTION-CODE-WRAPPER)
            (CL:PROGN
             (CL:SETQ OBJECT
              (CL:FUNCALL (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FN)
               INTEGER))))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              (SAFE-PRIMARY-TYPE FN) "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
          (CL:WHEN (CL:NOT (CL:EQ OBJECT NULL))
           (CL:RETURN-FROM SEARCH-FOR-OBJECT OBJECT))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:RETURN-FROM SEARCH-FOR-OBJECT NULL))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-DESCRIBE-STELLA-OBJECT)
      (CL:PROGN (CL:RETURN-FROM SEARCH-FOR-OBJECT SELF)))
     (CL:T (CL:RETURN-FROM SEARCH-FOR-OBJECT NULL))))))

;;; (DEFUN (FILTER-STRING-TO-CLASS? BOOLEAN) ...)

(CL:DEFUN FILTER-STRING-TO-CLASS? (SELF ITERATOR)
  (CL:IF (CL:= (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR) 1)
   (CL:RETURN-FROM FILTER-STRING-TO-CLASS?
    (STRING-EQL? (CLASS-NAME SELF)
     (%STRING-WRAPPER.WRAPPER-VALUE
      (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR))))
   (CL:RETURN-FROM FILTER-STRING-TO-CLASS?
    (CL:NOT
     (CL:=
      (STRING-SEARCH (CLASS-NAME SELF)
       (%STRING-WRAPPER.WRAPPER-VALUE
        (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR))
       0)
      NULL-INTEGER)))))

;;; (DEFUN (STRING-TO-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN STRING-TO-CLASSES (STRING EXACT?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-CLASSES NULL CL:NIL))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-STRING-TO-CLASS?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR)
    (WRAP-STRING STRING))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR)
    (CL:IF EXACT? 1 0))
   (CL:RETURN-FROM STRING-TO-CLASSES ITERATOR)))

;;; (DEFUN (STRING-TO-CLASS OBJECT) ...)

(CL:DEFUN STRING-TO-CLASS (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM STRING-TO-CLASS (GET-STELLA-CLASS STRING CL:NIL)))

;;; (DEFUN (STRING-TO-CONTEXT OBJECT) ...)

(CL:DEFUN STRING-TO-CONTEXT (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:HANDLER-CASE
   (CL:RETURN-FROM STRING-TO-CONTEXT
    (GET-STELLA-CONTEXT-SLOWLY STRING))
   (NO-SUCH-CONTEXT-EXCEPTION ()
    (CL:RETURN-FROM STRING-TO-CONTEXT NULL))))

;;; (DEFUN (STRING-TO-FUNCTION OBJECT) ...)

(CL:DEFUN STRING-TO-FUNCTION (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM STRING-TO-FUNCTION (LOOKUP-FUNCTION-BY-NAME STRING)))

;;; (DEFUN (DOTTED-STRING? BOOLEAN) ...)

(CL:DEFUN DOTTED-STRING? (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM DOTTED-STRING?
   (CL:NOT (CL:= (POSITION STRING #\. 0) NULL-INTEGER))))

;;; (DEFUN (YIELD-EXPLODED-METHOD-NAME STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING)
   (CL:VALUES CL:SIMPLE-STRING CL:SIMPLE-STRING))
  YIELD-EXPLODED-METHOD-NAME))
(CL:DEFUN YIELD-EXPLODED-METHOD-NAME (DOTTEDSTRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOTTEDSTRING))
  #+MCL
  (CL:CHECK-TYPE DOTTEDSTRING CL:SIMPLE-STRING)
  (CL:LET*
   ((DOTPOSITION (POSITION DOTTEDSTRING #\. 0))
    (FIRSTSTRING STELLA::NULL-STRING)
    (SECONDSTRING STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:FIXNUM DOTPOSITION)
    (CL:TYPE CL:SIMPLE-STRING FIRSTSTRING SECONDSTRING))
   (CL:WHEN (CL:NOT (CL:= DOTPOSITION NULL-INTEGER))
    (CL:SETQ FIRSTSTRING (SUBSEQUENCE DOTTEDSTRING 0 DOTPOSITION))
    (CL:SETQ SECONDSTRING
     (SUBSEQUENCE DOTTEDSTRING (CL:1+ DOTPOSITION) NULL-INTEGER)))
   (CL:RETURN-FROM YIELD-EXPLODED-METHOD-NAME
    (CL:VALUES FIRSTSTRING SECONDSTRING))))

;;; (DEFUN (STRING-TO-SLOT OBJECT) ...)

(CL:DEFUN STRING-TO-SLOT (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:IF (DOTTED-STRING? STRING)
   (CL:LET*
    ((CLASSSTRING STELLA::NULL-STRING)
     (SLOTSTRING STELLA::NULL-STRING))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASSSTRING SLOTSTRING))
    (CL:MULTIPLE-VALUE-SETQ (CLASSSTRING SLOTSTRING)
     (YIELD-EXPLODED-METHOD-NAME STRING))
    (CL:LET*
     ((CLASS (GET-STELLA-CLASS CLASSSTRING CL:NIL)) (SLOTNAME NULL))
     (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
      (CL:SETQ SLOTNAME (LOOKUP-SYMBOL SLOTSTRING))
      (CL:WHEN (CL:NOT (CL:EQ SLOTNAME NULL))
       (CL:RETURN-FROM STRING-TO-SLOT (LOOKUP-SLOT CLASS SLOTNAME))))))
   (CL:LET* ((SYMBOL (LOOKUP-SYMBOL STRING)))
    (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
     (CL:RETURN-FROM STRING-TO-SLOT (LOOKUP-FUNCTION SYMBOL)))))
  (CL:RETURN-FROM STRING-TO-SLOT NULL))

;;; (DEFUN (STRING-TO-SURROGATE-VALUE OBJECT) ...)

(CL:DEFUN STRING-TO-SURROGATE-VALUE (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET* ((SGT NULL) (ITER-000 (ALL-SURROGATES NULL CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SGT (%ITERATOR.VALUE ITER-000))
    (CL:WHEN (STRING-EQL? (%SURROGATE.SYMBOL-NAME SGT) STRING)
     (CL:RETURN-FROM STRING-TO-SURROGATE-VALUE
      (%SURROGATE.SURROGATE-VALUE SGT)))))
  (CL:RETURN-FROM STRING-TO-SURROGATE-VALUE NULL))

;;; (DEFUN (STRING-TO-DEMON OBJECT) ...)

(CL:DEFUN STRING-TO-DEMON (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM STRING-TO-DEMON (LOOKUP-DEMON STRING)))

;;; (DEFUN (INTEGER-TO-CONTEXT OBJECT) ...)

(CL:DEFUN INTEGER-TO-CONTEXT (INTEGER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INTEGER))
  #+MCL
  (CL:CHECK-TYPE INTEGER CL:FIXNUM)
  (CL:RETURN-FROM INTEGER-TO-CONTEXT
   (GET-STELLA-CONTEXT-SLOWLY INTEGER)))

;;; (DEFGLOBAL *DEFAULT-DESCRIBE-MODE* ...)

(CL:DEFVAR *DEFAULT-DESCRIBE-MODE* NULL
  "Specifies the print mode for `describe' when no second
argument is given.")

;;; (DEFUN DESCRIBE ...)

(CL:DEFUN %DESCRIBE (NAME MODE)
  "Print a description of an object in :verbose, :terse,
or :source modes."
  (CL:LET*
   ((OBJECT (CL:IF (CL:EQ NAME NULL) NULL (GET-OBJECT NAME NULL)))
    (MODESPEC (%%VALUE MODE)) (VALIDMODE NULL))
   (CL:WHEN (CL:EQ MODESPEC NULL)
    (CL:SETQ MODESPEC *DEFAULT-DESCRIBE-MODE*))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE MODESPEC)
      SGT-DESCRIBE-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN
      (CL:LET*
       ((TEST-VALUE-000 (%GENERALIZED-SYMBOL.SYMBOL-NAME MODESPEC)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
       (CL:COND
        ((CL:OR (STRING-EQL? TEST-VALUE-000 "VERBOSE")
          (STRING-EQL? TEST-VALUE-000 "TERSE")
          (STRING-EQL? TEST-VALUE-000 "SOURCE"))
         (CL:SETQ VALIDMODE
          (INTERN-KEYWORD (%GENERALIZED-SYMBOL.SYMBOL-NAME MODESPEC))))
        (CL:T)))))
    (CL:T))
   (CL:WHEN (CL:EQ VALIDMODE NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Valid modes (the second argument to 'describe') are " EOL
     "   :VERBOSE, :TERSE, and :SOURCE" EOL)
    (CL:SETQ VALIDMODE *DEFAULT-DESCRIBE-MODE*))
   (CL:IF (CL:EQ OBJECT NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "NULL")
    (DESCRIBE-OBJECT OBJECT STANDARD-OUTPUT VALIDMODE)))
  :VOID)

(CL:DEFUN DESCRIBE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DESCRIBE (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))
  :VOID)

(CL:DEFMACRO DESCRIBE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print a description of an object in :verbose, :terse,
or :source modes."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DESCRIBE|)) (CL:MACRO-FUNCTION (CL:QUOTE DESCRIBE)))

;;; (DEFUN DESCRIBE-TERSELY ...)

(CL:DEFUN DESCRIBE-TERSELY (SELF STREAM)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) SELF)
  :VOID)

;;; (DEFUN PRETTY-PRINT-STELLA-TREE ...)

(CL:DEFUN PRETTY-PRINT-STELLA-TREE (TREE STREAM)
  (CL:SETQ TREE (CONSIFY-LISTS-AND-ITERATORS TREE))
  (CL:LET* ((*PRINTPRETTYCODE?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTPRETTYCODE?*))
   (PRINT-STELLA-CODE TREE (%OUTPUT-STREAM.NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFUN PRETTY-PRINT-DEFINITION-TREE ...)

(CL:DEFUN PRETTY-PRINT-DEFINITION-TREE (TREE STREAM)
  (CL:SETQ TREE (CONSIFY-LISTS-AND-ITERATORS TREE))
  (CL:LET* ((*PRINTPRETTYCODE?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTPRETTYCODE?*))
   (PRINT-STELLA-DEFINITION TREE (%OUTPUT-STREAM.NATIVE-STREAM STREAM)))
  :VOID)

;;; (DEFGLOBAL *PRETTY-PRINT-LIST-CUTOFF* ...)

(CL:DEFVAR *PRETTY-PRINT-LIST-CUTOFF* 5
  "Lists longer than the cutoff are truncated during
pretty printing.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *PRETTY-PRINT-LIST-CUTOFF*))

;;; (DEFUN (CONSIFY-LISTS-AND-ITERATORS OBJECT) ...)

(CL:DEFUN CONSIFY-LISTS-AND-ITERATORS (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM CONSIFY-LISTS-AND-ITERATORS TREE))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-DESCRIBE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((CONS (ALLOCATE-ITERATOR TREE)))
       (CL:LOOP WHILE (NEXT? CONS) DO
        (VALUE-SETTER CONS
         (CONSIFY-LISTS-AND-ITERATORS (%CONS-ITERATOR.VALUE CONS)))))
      (CL:RETURN-FROM CONSIFY-LISTS-AND-ITERATORS TREE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIBE-STELLA-LIST)
     (CL:PROGN
      (CL:LET* ((CONSLIST NIL))
       (CL:LET*
        ((ITEM NULL) (ITER-000 (%LIST.THE-CONS-LIST TREE))
         (I NULL-INTEGER) (ITER-001 0)
         (UPPER-BOUND-000 *PRETTY-PRINT-LIST-CUTOFF*)
         (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
         (COLLECT-000 NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
         DO (CL:SETQ ITEM (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS
             (CL:IF (CL:= I *PRETTY-PRINT-LIST-CUTOFF*) ELLIPSIS ITEM)
             NIL))
           (CL:IF (CL:EQ CONSLIST NIL) (CL:SETQ CONSLIST COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST CONSLIST COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS
             (CL:IF (CL:= I *PRETTY-PRINT-LIST-CUTOFF*) ELLIPSIS ITEM)
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))
         (CL:SETQ ITER-001 (CL:1+ ITER-001))))
       (CL:RETURN-FROM CONSIFY-LISTS-AND-ITERATORS CONSLIST))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIBE-STELLA-ITERATOR)
     (CL:PROGN
      (CL:LET* ((CONSLIST NIL))
       (CL:LET*
        ((ITEM NULL) (ITER-002 TREE) (I NULL-INTEGER) (ITER-003 0)
         (UPPER-BOUND-001 *PRETTY-PRINT-LIST-CUTOFF*)
         (UNBOUNDED?-001 (CL:= UPPER-BOUND-001 NULL-INTEGER))
         (COLLECT-001 NULL))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-001))
        (CL:LOOP WHILE
         (CL:AND (NEXT? ITER-002)
          (CL:OR UNBOUNDED?-001 (CL:<= ITER-003 UPPER-BOUND-001)))
         DO (CL:SETQ ITEM (%ITERATOR.VALUE ITER-002))
         (CL:SETQ I ITER-003)
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-001
            (CONS
             (CL:IF (CL:= I *PRETTY-PRINT-LIST-CUTOFF*) ELLIPSIS ITEM)
             NIL))
           (CL:IF (CL:EQ CONSLIST NIL) (CL:SETQ CONSLIST COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST CONSLIST COLLECT-001)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-001)
            (CONS
             (CL:IF (CL:= I *PRETTY-PRINT-LIST-CUTOFF*) ELLIPSIS ITEM)
             NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
         (CL:SETQ ITER-003 (CL:1+ ITER-003))))
       (CL:RETURN-FROM CONSIFY-LISTS-AND-ITERATORS CONSLIST))))
    (CL:T (CL:RETURN-FROM CONSIFY-LISTS-AND-ITERATORS TREE)))))

;;; (DEFMETHOD PRINT-DEFINITION ...)

(CL:DEFMETHOD PRINT-DEFINITION ((SELF MODULE) STREAM)
  (CL:LET*
   ((OPTIONS
     (READ-S-EXPRESSION-FROM-STRING
      (%MODULE.STRINGIFIED-OPTIONS SELF))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "(DEFMODULE \"" (%MODULE.MODULE-FULL-NAME SELF) "\"")
    (CL:LOOP WHILE (CL:NOT (CL:EQ OPTIONS NIL)) DO
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "  "
      (%%VALUE OPTIONS) " " (%%VALUE (%%REST OPTIONS)))
     (CL:SETQ OPTIONS (NTH-REST OPTIONS 2)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL)))
  :VOID)

;;; (DEFUN PRINT-CLASS-LIST ...)

(CL:DEFUN PRINT-CLASS-LIST (SELF STREAM)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
  (CL:WHEN (NEXT? SELF)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
    (%SURROGATE.SYMBOL-NAME
     (%CLASS.CLASS-TYPE (%ITERATOR.VALUE SELF)))))
  (CL:LOOP WHILE (NEXT? SELF) DO
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "
    (%SURROGATE.SYMBOL-NAME
     (%CLASS.CLASS-TYPE (%ITERATOR.VALUE SELF)))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
  :VOID)

;;; (DEFMETHOD PRETTY-PRINT-OBJECT ...)

(CL:DEFMETHOD PRETTY-PRINT-OBJECT ((SELF SLOT) STREAM)
  (CL:SETQ STREAM STREAM)
  :VOID)

;;; (DEFSPECIAL *SLOTOPTIONSLOTS* ...)

(CL:DEFVAR *SLOTOPTIONSLOTS* NULL
  "List of slots containing storage-slot options")

;;; (DEFSPECIAL *CLASSOPTIONSLOTS* ...)

(CL:DEFVAR *CLASSOPTIONSLOTS* NULL
  "List of slots containing class options")

;;; (DEFSPECIAL *CLASSUNSTRINGIFIEDOPTIONS* ...)

(CL:DEFVAR *CLASSUNSTRINGIFIEDOPTIONS* NULL
  "Plist of unstringifed class options")

;;; (DEFUN (GET-CLASS-OPTIONS (CONS OF STORAGE-SLOT)) ...)

(CL:DEFUN GET-CLASS-OPTIONS ()
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((SLOT NULL)
     (ITER-000
      (PRIVATE-CLASS-STORAGE-SLOTS
       (%SURROGATE.SURROGATE-VALUE SGT-DESCRIBE-STELLA-CLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((SLOT NULL)
     (ITER-001
      (PUBLIC-CLASS-STORAGE-SLOTS
       (%SURROGATE.SURROGATE-VALUE SGT-DESCRIBE-STELLA-CLASS)))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-001))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOT NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOT NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
   (CL:LET*
    ((SLOT NULL)
     (ITER-002
      (PRIVATE-CLASS-STORAGE-SLOTS
       (%SURROGATE.SURROGATE-VALUE SGT-DESCRIBE-STELLA-RELATION)))
     (COLLECT-002 NULL))
    (CL:LOOP WHILE (NEXT? ITER-002) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-002))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-002 NULL)
       (CL:PROGN (CL:SETQ COLLECT-002 (CONS SLOT NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-002)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-002)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-002) (CONS SLOT NIL))
        (CL:SETQ COLLECT-002 (%%REST COLLECT-002)))))))
   (CL:LET*
    ((SLOT NULL)
     (ITER-003
      (PUBLIC-CLASS-STORAGE-SLOTS
       (%SURROGATE.SURROGATE-VALUE SGT-DESCRIBE-STELLA-RELATION)))
     (COLLECT-003 NULL))
    (CL:LOOP WHILE (NEXT? ITER-003) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-003))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-003 NULL)
       (CL:PROGN (CL:SETQ COLLECT-003 (CONS SLOT NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-003)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-003)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-003) (CONS SLOT NIL))
        (CL:SETQ COLLECT-003 (%%REST COLLECT-003)))))))
   (CL:RETURN-FROM GET-CLASS-OPTIONS RESULT)))

;;; (DEFUN (GET-UNSTRINGIFIED-CLASS-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN GET-UNSTRINGIFIED-CLASS-OPTIONS (CLASS)
  (CL:LET* ((THEOPTIONS (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST THEOPTIONS)
    (%%REST
     (%%REST
      (%%REST
       (READ-S-EXPRESSION-FROM-STRING
        (%CLASS.CLASS-STRINGIFIED-SOURCE CLASS))))))
   (CL:RETURN-FROM GET-UNSTRINGIFIED-CLASS-OPTIONS THEOPTIONS)))

;;; (DEFUN (GET-SLOT-OPTIONS (CONS OF STORAGE-SLOT)) ...)

(CL:DEFUN GET-SLOT-OPTIONS ()
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((SLOT NULL)
     (ITER-000
      (PRIVATE-CLASS-STORAGE-SLOTS
       (%SURROGATE.SURROGATE-VALUE SGT-DESCRIBE-STELLA-STORAGE-SLOT)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
        (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:RETURN-FROM GET-SLOT-OPTIONS RESULT)))

;;; (DEFUN PRETTY-PRINT-LITERAL ...)

(CL:DEFUN PRETTY-PRINT-LITERAL (LITERAL STREAM)
  (CL:COND
   ((SUBTYPE-OF-BOOLEAN? (SAFE-PRIMARY-TYPE LITERAL))
    (CL:PROGN
     (CL:IF (CL:EQ LITERAL TRUE-WRAPPER)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "TRUE")
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "FALSE"))))
   (CL:T
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) LITERAL))))
  :VOID)

;;; (DEFUN (LITERAL-EQL? BOOLEAN) ...)

(CL:DEFUN LITERAL-EQL? (X Y)
  (CL:WHEN
   (CL:OR
    (CL:AND (CL:NOT (CL:EQ X NULL))
     (ISA? X SGT-DESCRIBE-STELLA-BOOLEAN-WRAPPER))
    (CL:AND (CL:NOT (CL:EQ Y NULL))
     (ISA? Y SGT-DESCRIBE-STELLA-BOOLEAN-WRAPPER)))
   (CL:RETURN-FROM LITERAL-EQL?
    (CL:OR
     (CL:AND (CL:EQ X NULL)
      (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN Y)))
     (CL:AND (CL:EQ Y NULL)
      (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN X)))
     (EQL? X Y))))
  (CL:RETURN-FROM LITERAL-EQL? (EQL? X Y)))

;;; (DEFUN (CONVERT-TO-LITERAL OBJECT) ...)

(CL:DEFUN CONVERT-TO-LITERAL (OBJECT)
  (CL:WHEN (CL:EQ OBJECT NULL)
   (CL:RETURN-FROM CONVERT-TO-LITERAL OBJECT))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJECT)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIBE-STELLA-LITERAL-WRAPPER)
     (CL:PROGN (CL:RETURN-FROM CONVERT-TO-LITERAL OBJECT)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:EQ OBJECT SYM-DESCRIBE-STELLA-TRUE)
       (CL:RETURN-FROM CONVERT-TO-LITERAL TRUE-WRAPPER))
      (CL:WHEN (CL:EQ OBJECT SYM-DESCRIBE-STELLA-FALSE)
       (CL:RETURN-FROM CONVERT-TO-LITERAL FALSE-WRAPPER))
      (CL:RETURN-FROM CONVERT-TO-LITERAL OBJECT)))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM CONVERT-TO-LITERAL OBJECT)))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM CONVERT-TO-LITERAL OBJECT)))
    (CL:T
     (CL:WARN
      "`convert-to-literal': Can't handle non-boolean literals")
     (CL:RETURN-FROM CONVERT-TO-LITERAL NULL)))))

;;; (DEFUN PRETTY-PRINT-CLASS-OPTIONS ...)

(CL:DEFUN PRETTY-PRINT-CLASS-OPTIONS (CLASS STREAM)
  (CL:LET* ((OPTIONVALUE NULL))
   (CL:LET* ((OPTIONSLOT NULL) (ITER-000 *CLASSOPTIONSLOTS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ OPTIONSLOT (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:SETQ OPTIONVALUE (READ-SLOT-VALUE CLASS OPTIONSLOT))
      (CL:WHEN (CL:EQ OPTIONVALUE NULL) (CL:GO :CONTINUE))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPTIONVALUE)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-DESCRIBE-STELLA-LITERAL-WRAPPER)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL))
              OPTIONVALUE)
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL (DEFAULT-FORM OPTIONSLOT))
              OPTIONVALUE)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
            "  :"
            (STRING-DOWNCASE
             (%KEYWORD.SYMBOL-NAME
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
            " ")
           (PRETTY-PRINT-LITERAL OPTIONVALUE STREAM))))
        ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL))
              OPTIONVALUE)
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL (DEFAULT-FORM OPTIONSLOT))
              OPTIONVALUE)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
            "  :"
            (STRING-DOWNCASE
             (%KEYWORD.SYMBOL-NAME
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
            " ")
           (PRETTY-PRINT-LITERAL OPTIONVALUE STREAM))))
        ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL))
              OPTIONVALUE)
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL (DEFAULT-FORM OPTIONSLOT))
              OPTIONVALUE)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
            "  :"
            (STRING-DOWNCASE
             (%KEYWORD.SYMBOL-NAME
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
            " ")
           (PRETTY-PRINT-LITERAL OPTIONVALUE STREAM))))
        ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL))
              OPTIONVALUE)
             (LITERAL-EQL?
              (CONVERT-TO-LITERAL (DEFAULT-FORM OPTIONSLOT))
              OPTIONVALUE)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
            "  :"
            (STRING-DOWNCASE
             (%KEYWORD.SYMBOL-NAME
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
            " ")
           (PRETTY-PRINT-LITERAL OPTIONVALUE STREAM))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-DESCRIBE-STELLA-LIST)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR (EMPTY? OPTIONVALUE)
             (CL:EQ
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL)
              OPTIONVALUE)
             (CL:EQ (DEFAULT-FORM OPTIONSLOT) OPTIONVALUE)))
           (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
             "  :"
             (STRING-DOWNCASE
              (%KEYWORD.SYMBOL-NAME
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
             " ")
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
             (LOOKUP *CLASSUNSTRINGIFIEDOPTIONS*
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))))))
        ((CL:EQ TEST-VALUE-000 SGT-DESCRIBE-STELLA-CONS)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:OR (CL:EQ OPTIONVALUE NIL)
             (CL:EQ
              (DYNAMIC-SLOT-VALUE
               (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
               SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL)
              OPTIONVALUE)
             (CL:EQ (DEFAULT-FORM OPTIONSLOT) OPTIONVALUE)))
           (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL
             "  :"
             (STRING-DOWNCASE
              (%KEYWORD.SYMBOL-NAME
               (DYNAMIC-SLOT-VALUE
                (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
                SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
             " ")
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
             OPTIONVALUE)))))
        (CL:T)))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN PRETTY-PRINT-SLOT-OPTIONS ...)

(CL:DEFUN PRETTY-PRINT-SLOT-OPTIONS (SLOT STREAM)
  (CL:LET* ((SLOTVALUE NULL))
   (CL:LET* ((OPTIONSLOT NULL) (ITER-000 *SLOTOPTIONSLOTS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ OPTIONSLOT (%%VALUE ITER-000))
     (CL:TAGBODY (CL:SETQ SLOTVALUE (READ-SLOT-VALUE SLOT OPTIONSLOT))
      (CL:WHEN (CL:EQ SLOTVALUE NULL) (CL:GO :CONTINUE))
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SLOTVALUE)
         SGT-DESCRIBE-STELLA-LITERAL-WRAPPER)
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (LITERAL-EQL?
            (DYNAMIC-SLOT-VALUE
             (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
             SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL)
            SLOTVALUE))
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " :"
           (STRING-DOWNCASE
            (%KEYWORD.SYMBOL-NAME
             (DYNAMIC-SLOT-VALUE
              (%STORAGE-SLOT.DYNAMIC-SLOTS OPTIONSLOT)
              SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD NULL)))
           " ")
          (PRETTY-PRINT-LITERAL SLOTVALUE STREAM))))
       (CL:T))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFMETHOD PRETTY-PRINT-OBJECT ...)

(CL:DEFMETHOD PRETTY-PRINT-OBJECT ((SELF STORAGE-SLOT) STREAM)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
   (STRING-DOWNCASE
    (%SYMBOL.SYMBOL-NAME (%STORAGE-SLOT.SLOT-NAME SELF)))
   " :type ")
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER NULL)
      NULL))
    (STRINGIFY
     (YIELD-TYPE-SPEC-TREE
      (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER NULL)))
    (STRINGIFY
     (YIELD-TYPE-SPEC-TREE (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)))))
  (PRETTY-PRINT-SLOT-OPTIONS SELF STREAM)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
  :VOID)

;;; (DEFUN PRETTY-PRINT-METHOD-PARAMETERS ...)

(CL:DEFUN PRETTY-PRINT-METHOD-PARAMETERS (STREAM METHOD)
  (CL:LET*
   ((LASTARGINDEX
     (CL:IF
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-DESCRIBE-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
      (LENGTH (METHOD-PARAMETER-NAMES METHOD)) -1)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTARGINDEX))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(")
    (CL:LET*
     ((PARAMETER NULL)
      (ITER-000 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
      (TSPEC NULL)
      (ITER-001
       (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
      (I NULL-INTEGER) (ITER-002 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
       (CL:NOT (CL:EQ ITER-001 NIL)))
      DO (CL:SETQ PARAMETER (%%VALUE ITER-000))
      (CL:SETQ TSPEC (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
      (CL:WHEN (CL:> I 1)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))
      (CL:WHEN (CL:= I LASTARGINDEX)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "&rest ")
       (CL:SETQ TSPEC (VARIABLE-ARGUMENTS-TYPE METHOD)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
       (STRING-DOWNCASE (%SYMBOL.SYMBOL-NAME PARAMETER)) " "
       (YIELD-TYPE-SPEC-TREE TSPEC) ")")
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (CL:1+ ITER-002))))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")))
  :VOID)

;;; (DEFMETHOD PRETTY-PRINT-OBJECT ...)

(CL:DEFMETHOD PRETTY-PRINT-OBJECT ((SELF METHOD-SLOT) STREAM)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "("
   (STRING-DOWNCASE
    (%SYMBOL.SYMBOL-NAME (%METHOD-SLOT.SLOT-NAME SELF)))
   " ")
  (PRETTY-PRINT-METHOD-PARAMETERS STREAM SELF)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " :type ")
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER NULL)
      NULL))
    (STRINGIFY
     (YIELD-TYPE-SPEC-TREE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER NULL)))
    (STRINGIFY
     (YIELD-TYPE-SPEC-TREE (%METHOD-SLOT.SLOT-BASE-TYPE SELF)))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
  :VOID)

;;; (DEFUN PRETTY-PRINT-SLOT-BLOCK ...)

(CL:DEFUN PRETTY-PRINT-SLOT-BLOCK (STREAM ITERATOR SLOTGROUP)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SLOTGROUP))
  #+MCL
  (CL:CHECK-TYPE SLOTGROUP CL:SIMPLE-STRING)
  (CL:IF (NEXT? ITERATOR)
   (CL:LET* ((SLOT (%ITERATOR.VALUE ITERATOR)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "  "
     SLOTGROUP EOL "  (")
    (PRETTY-PRINT-OBJECT SLOT STREAM))
   (CL:RETURN-FROM PRETTY-PRINT-SLOT-BLOCK))
  (CL:LET* ((SLOT NULL) (ITER-000 ITERATOR))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL "   ")
    (PRETTY-PRINT-OBJECT SLOT STREAM)))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")")
  :VOID)

;;; (DEFUN PRETTY-PRINT-SLOTS ...)

(CL:DEFUN PRETTY-PRINT-SLOTS (SELF STREAM)
  (PRETTY-PRINT-SLOT-BLOCK STREAM (PUBLIC-CLASS-STORAGE-SLOTS SELF)
   ":public-slots")
  (PRETTY-PRINT-SLOT-BLOCK STREAM (PRIVATE-CLASS-STORAGE-SLOTS SELF)
   ":slots")
  (PRETTY-PRINT-SLOT-BLOCK STREAM (PUBLIC-CLASS-METHODS SELF)
   ":public-methods")
  (PRETTY-PRINT-SLOT-BLOCK STREAM (PRIVATE-CLASS-METHODS SELF)
   ":methods")
  :VOID)

;;; (DEFMETHOD PRETTY-PRINT-OBJECT ...)

(CL:DEFMETHOD PRETTY-PRINT-OBJECT ((SELF CLASS) STREAM)
  (CL:LET*
   ((*SLOTOPTIONSLOTS* (GET-SLOT-OPTIONS))
    (*CLASSOPTIONSLOTS* (GET-CLASS-OPTIONS))
    (*CLASSUNSTRINGIFIEDOPTIONS*
     (GET-UNSTRINGIFIED-CLASS-OPTIONS SELF)))
   (CL:DECLARE
    (CL:SPECIAL *SLOTOPTIONSLOTS* *CLASSOPTIONSLOTS*
     *CLASSUNSTRINGIFIEDOPTIONS*))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "(defclass "
    (%SURROGATE.SYMBOL-NAME (%CLASS.CLASS-TYPE SELF)) " ")
   (PRINT-CLASS-LIST
    (NEW-TYPES-TO-CLASSES-ITERATOR
     (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS SELF)))
    STREAM)
   (PRETTY-PRINT-CLASS-OPTIONS SELF STREAM)
   (PRETTY-PRINT-SLOTS SELF STREAM)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ")" EOL)
   (CL:WHEN (NEXT? (CLASS-TABLES SELF NIL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)
    (CL:LET* ((TABLE NULL) (ITER-000 (CLASS-TABLES SELF NIL)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ TABLE (%ITERATOR.VALUE ITER-000))
      (PRETTY-PRINT-OBJECT TABLE STREAM)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL)))
  :VOID)

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(%%DEFCONSMETHOD DESCRIBE-OBJECT ((SELF OBJECT) STREAM MODE)
  "Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  The :terse mode is often equivalent
to the standard print function."
  (CL:SETQ MODE MODE)
  (DESCRIBE-TERSELY SELF STREAM)
  :VOID)

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(CL:DEFMETHOD DESCRIBE-OBJECT ((SELF CLASS) STREAM MODE)
  (CL:COND
   ((CL:EQ MODE KWD-DESCRIBE-SOURCE)
    (PRETTY-PRINT-DEFINITION-TREE
     (READ-S-EXPRESSION-FROM-STRING
      (%CLASS.CLASS-STRINGIFIED-SOURCE SELF))
     STREAM))
   ((CL:EQ MODE KWD-DESCRIBE-TERSE) (DESCRIBE-TERSELY SELF STREAM))
   ((CL:EQ MODE KWD-DESCRIBE-VERBOSE)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "SOURCE mode:" EOL)
    (DESCRIBE-OBJECT SELF STREAM KWD-DESCRIBE-SOURCE))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" MODE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(CL:DEFMETHOD DESCRIBE-OBJECT ((SELF STORAGE-SLOT) STREAM MODE)
  (CL:COND
   ((CL:EQ MODE KWD-DESCRIBE-SOURCE)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "TERSE mode:"
     EOL)
    (DESCRIBE-OBJECT SELF STREAM KWD-DESCRIBE-TERSE))
   ((CL:EQ MODE KWD-DESCRIBE-TERSE) (DESCRIBE-TERSELY SELF STREAM))
   ((CL:EQ MODE KWD-DESCRIBE-VERBOSE)
    (PRETTY-PRINT-DEFINITION-TREE
     (LIST* SYM-DESCRIBE-STELLA-SLOT (%STORAGE-SLOT.SLOT-NAME SELF)
      (LIST* KWD-DESCRIBE-OWNER
       (WRAP-STRING
        (%SURROGATE.SYMBOL-NAME (%STORAGE-SLOT.SLOT-OWNER SELF)))
       (LIST* KWD-DESCRIBE-TYPE (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
        (LIST* KWD-DESCRIBE-INITIALLY
         (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
          SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE NULL)
         NIL))))
     STREAM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" MODE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFMETHOD DESCRIBE-OBJECT ...)

(CL:DEFMETHOD DESCRIBE-OBJECT ((SELF MODULE) STREAM MODE)
  (CL:COND
   ((CL:EQ MODE KWD-DESCRIBE-SOURCE)
    (PRETTY-PRINT-STELLA-TREE
     (READ-S-EXPRESSION-FROM-STRING (XMODULE-STRINGIFIED-SOURCE SELF))
     STREAM))
   ((CL:EQ MODE KWD-DESCRIBE-TERSE) (DESCRIBE-TERSELY SELF STREAM))
   ((CL:EQ MODE KWD-DESCRIBE-VERBOSE)
    (PRETTY-PRINT-DEFINITION-TREE
     (LIST* SYM-DESCRIBE-STELLA-DEFMODULE
      (WRAP-STRING (%MODULE.MODULE-NAME SELF))
      (LIST* KWD-DESCRIBE-INCLUDES (%MODULE.PARENT-MODULES SELF)
       (LIST* KWD-DESCRIBE-USES (%MODULE.USES SELF)
        (LIST* KWD-DESCRIBE-SHADOWS (SHADOWED-SURROGATES SELF)
         (LIST* SYM-DESCRIBE-STELLA->>_INFERRED_SLOTS
          KWD-DESCRIBE-CHILDREN (%MODULE.CHILD-CONTEXTS SELF)
          (LIST* KWD-DESCRIBE-USED-BY (%MODULE.USED-BY SELF)
           (LIST* KWD-DESCRIBE-CARDINAL-MODULE
            (%MODULE.CARDINAL-MODULE SELF) NIL)))))))
     STREAM))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" MODE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN (XMODULE-STRINGIFIED-SOURCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  XMODULE-STRINGIFIED-SOURCE))
(CL:DEFUN XMODULE-STRINGIFIED-SOURCE (SELF)
  (CL:RETURN-FROM XMODULE-STRINGIFIED-SOURCE
   (CONCATENATE "(defmodule "
    (CONCATENATE (%MODULE.MODULE-NAME SELF)
     (CONCATENATE " "
      (CONCATENATE (%MODULE.STRINGIFIED-OPTIONS SELF) ")"))))))

;;; (DEFUN (SHORT-DOCUMENTATION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  SHORT-DOCUMENTATION))
(CL:DEFUN SHORT-DOCUMENTATION (DOCUMENTATION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
  #+MCL
  (CL:CHECK-TYPE DOCUMENTATION CL:SIMPLE-STRING)
  (CL:LET* ((LINEEND NULL-INTEGER) (SENTENCEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LINEEND SENTENCEEND))
   (CL:WHEN (CL:EQ DOCUMENTATION STELLA::NULL-STRING)
    (CL:SETQ DOCUMENTATION "Not documented."))
   (CL:SETQ LINEEND (POSITION DOCUMENTATION #\Return 0))
   (CL:WHEN (CL:= LINEEND NULL-INTEGER)
    (CL:SETQ LINEEND (POSITION DOCUMENTATION #\Linefeed 0)))
   (CL:WHEN (CL:= LINEEND NULL-INTEGER)
    (CL:RETURN-FROM SHORT-DOCUMENTATION DOCUMENTATION))
   (CL:WHEN
    (MEMBER? ".!"
     (CL:LET ((SELF DOCUMENTATION) (POSITION (CL:1- LINEEND)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))))
    (CL:RETURN-FROM SHORT-DOCUMENTATION
     (SUBSEQUENCE DOCUMENTATION 0 LINEEND)))
   (CL:SETQ SENTENCEEND (POSITION DOCUMENTATION #\. 0))
   (CL:IF
    (CL:AND (CL:NOT (CL:= SENTENCEEND NULL-INTEGER))
     (CL:<= SENTENCEEND 155))
    (CL:RETURN-FROM SHORT-DOCUMENTATION
     (SUBSEQUENCE DOCUMENTATION 0 (CL:1+ SENTENCEEND)))
    (CL:RETURN-FROM SHORT-DOCUMENTATION
     (SUBSEQUENCE DOCUMENTATION 0 LINEEND)))))

;;; (DEFUN PRINT-DOCUMENTATION-STRING ...)

(CL:DEFUN PRINT-DOCUMENTATION-STRING (STRING INDENT STREAM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)
   (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:WHEN (CL:= INDENT NULL-INTEGER) (CL:SETQ INDENT 0))
  (CL:LET*
   ((LINE STELLA::NULL-STRING)
    (ITER-000 (LINES (MAKE-TOKENIZER-STRING-STREAM STRING))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ LINE (%LINE-ITERATOR.VALUE ITER-000))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 INDENT)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-001) (CL:SETQ I I)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) LINE EOL)))
  :VOID)

;;; (DEFMETHOD PRINT-DOCUMENTATION ...)

(CL:DEFMETHOD PRINT-DOCUMENTATION ((SELF METHOD-SLOT) STREAM SHORT?)
  (CL:WHEN (CL:EQ STREAM NULL) (CL:SETQ STREAM STANDARD-OUTPUT))
  (CL:LET*
   ((DOCUMENTATION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
       SYM-DESCRIBE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
    (%METHOD-SLOT.SLOT-NAME SELF))
   (CL:WHEN (CL:NOT SHORT?)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
    (PRETTY-PRINT-METHOD-PARAMETERS STREAM SELF))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ":" EOL)
   (PRINT-DOCUMENTATION-STRING
    (CL:IF SHORT? (SHORT-DOCUMENTATION DOCUMENTATION) DOCUMENTATION) 2
    STREAM))
  :VOID)

(CL:DEFUN HELP-STARTUP-DESCRIBE1 ()
  (CL:PROGN
   (CL:SETQ SYM-DESCRIBE-STELLA-GET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET" NULL 0))
   (CL:SETQ KWD-DESCRIBE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-DESCRIBE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-DESCRIBE-STELLA-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON" NULL 1))
   (CL:SETQ KWD-DESCRIBE-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBOSE" NULL 2))
   (CL:SETQ SGT-DESCRIBE-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SYM-DESCRIBE-STELLA-DESCRIBE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIBE" NULL 0))
   (CL:SETQ SGT-DESCRIBE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR" NULL 1))
   (CL:SETQ SYM-DESCRIBE-STELLA-SLOT-OPTION-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-KEYWORD" NULL 0))
   (CL:SETQ SGT-DESCRIBE-STELLA-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 1))
   (CL:SETQ SGT-DESCRIBE-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
   (CL:SETQ SYM-DESCRIBE-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-DESCRIBE-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SGT-DESCRIBE-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER" NULL 1))
   (CL:SETQ SYM-DESCRIBE-STELLA-SLOT-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-INITIAL-VALUE" NULL 0))
   (CL:SETQ SYM-DESCRIBE-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-DESCRIBE-STELLA-METHOD-VARIABLE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL
     0))
   (CL:SETQ KWD-DESCRIBE-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOURCE" NULL 2))
   (CL:SETQ KWD-DESCRIBE-TERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERSE" NULL 2))
   (CL:SETQ SYM-DESCRIBE-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 0))
   (CL:SETQ KWD-DESCRIBE-OWNER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OWNER" NULL 2))
   (CL:SETQ KWD-DESCRIBE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-DESCRIBE-INITIALLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALLY" NULL 2))
   (CL:SETQ SYM-DESCRIBE-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
   (CL:SETQ KWD-DESCRIBE-INCLUDES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDES" NULL 2))
   (CL:SETQ KWD-DESCRIBE-USES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USES" NULL 2))
   (CL:SETQ KWD-DESCRIBE-SHADOWS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOWS" NULL 2))
   (CL:SETQ SYM-DESCRIBE-STELLA->>_INFERRED_SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">>_INFERRED_SLOTS" NULL 0))
   (CL:SETQ KWD-DESCRIBE-CHILDREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 2))
   (CL:SETQ KWD-DESCRIBE-USED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USED-BY" NULL 2))
   (CL:SETQ KWD-DESCRIBE-CARDINAL-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINAL-MODULE" NULL 2))
   (CL:SETQ SYM-DESCRIBE-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-DESCRIBE-STELLA-STARTUP-DESCRIBE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-DESCRIBE" NULL 0))
   (CL:SETQ SYM-DESCRIBE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-DESCRIBE2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "GET"
    "(DEFUN (GET OBJECT) ((NAME NAME) |&REST| (TYPE NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %GET) (CL:FUNCTION GET-EVALUATOR-WRAPPER))
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-OBJECT OBJECT) ((SELF OBJECT) (TYPE OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION GET-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-OBJECT OBJECT) ((SELF STRING) (TYPE OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION GET-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-OBJECT OBJECT) ((SELF INTEGER) (TYPE OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION GET-OBJECT)) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-SEARCH-FOR-OBJECT"
    "(DEFUN (STRING-SEARCH-FOR-OBJECT OBJECT) ((STRING STRING) (CLASSTYPE TYPE)))"
    (CL:FUNCTION STRING-SEARCH-FOR-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "SEARCH-FOR-OBJECT"
    "(DEFUN (SEARCH-FOR-OBJECT OBJECT) ((SELF OBJECT) (TYPEREF OBJECT)) :DOCUMENTATION \"If `self' is a string or a symbol, search for an object named
`self' of type `type'.  Otherwise, if `self' is an object, return it.\")"
    (CL:FUNCTION SEARCH-FOR-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-STRING-TO-CLASS?"
    "(DEFUN (FILTER-STRING-TO-CLASS? BOOLEAN) ((SELF CLASS) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-STRING-TO-CLASS?) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-CLASSES"
    "(DEFUN (STRING-TO-CLASSES (ITERATOR OF CLASS)) ((STRING STRING) (EXACT? BOOLEAN)))"
    (CL:FUNCTION STRING-TO-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-CLASS"
    "(DEFUN (STRING-TO-CLASS OBJECT) ((STRING STRING)))"
    (CL:FUNCTION STRING-TO-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-CONTEXT"
    "(DEFUN (STRING-TO-CONTEXT OBJECT) ((STRING STRING)))"
    (CL:FUNCTION STRING-TO-CONTEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-FUNCTION"
    "(DEFUN (STRING-TO-FUNCTION OBJECT) ((STRING STRING)))"
    (CL:FUNCTION STRING-TO-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "DOTTED-STRING?"
    "(DEFUN (DOTTED-STRING? BOOLEAN) ((STRING STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION DOTTED-STRING?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-EXPLODED-METHOD-NAME"
    "(DEFUN (YIELD-EXPLODED-METHOD-NAME STRING STRING) ((DOTTEDSTRING STRING)))"
    (CL:FUNCTION YIELD-EXPLODED-METHOD-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-SLOT"
    "(DEFUN (STRING-TO-SLOT OBJECT) ((STRING STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION STRING-TO-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-SURROGATE-VALUE"
    "(DEFUN (STRING-TO-SURROGATE-VALUE OBJECT) ((STRING STRING)))"
    (CL:FUNCTION STRING-TO-SURROGATE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-DEMON"
    "(DEFUN (STRING-TO-DEMON OBJECT) ((STRING STRING)))"
    (CL:FUNCTION STRING-TO-DEMON) NULL)
   (DEFINE-FUNCTION-OBJECT "INTEGER-TO-CONTEXT"
    "(DEFUN (INTEGER-TO-CONTEXT OBJECT) ((INTEGER INTEGER)))"
    (CL:FUNCTION INTEGER-TO-CONTEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "DESCRIBE"
    "(DEFUN DESCRIBE ((NAME OBJECT) |&REST| (MODE OBJECT)) :DOCUMENTATION \"Print a description of an object in :verbose, :terse,
or :source modes.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %DESCRIBE) (CL:FUNCTION DESCRIBE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DESCRIBE-TERSELY"
    "(DEFUN DESCRIBE-TERSELY ((SELF OBJECT) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION DESCRIBE-TERSELY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-STELLA-TREE"
    "(DEFUN PRETTY-PRINT-STELLA-TREE ((TREE CONS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-STELLA-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-DEFINITION-TREE"
    "(DEFUN PRETTY-PRINT-DEFINITION-TREE ((TREE CONS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSIFY-LISTS-AND-ITERATORS"
    "(DEFUN (CONSIFY-LISTS-AND-ITERATORS OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CONSIFY-LISTS-AND-ITERATORS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-DEFINITION ((SELF MODULE) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION PRINT-DEFINITION)) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CLASS-LIST"
    "(DEFUN PRINT-CLASS-LIST ((SELF (ITERATOR OF CLASS)) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-CLASS-LIST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRETTY-PRINT-OBJECT ((SELF SLOT) (STREAM OUTPUT-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PRETTY-PRINT-OBJECT)) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASS-OPTIONS"
    "(DEFUN (GET-CLASS-OPTIONS (CONS OF STORAGE-SLOT)) ())"
    (CL:FUNCTION GET-CLASS-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-UNSTRINGIFIED-CLASS-OPTIONS"
    "(DEFUN (GET-UNSTRINGIFIED-CLASS-OPTIONS PROPERTY-LIST) ((CLASS CLASS)))"
    (CL:FUNCTION GET-UNSTRINGIFIED-CLASS-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT-OPTIONS"
    "(DEFUN (GET-SLOT-OPTIONS (CONS OF STORAGE-SLOT)) ())"
    (CL:FUNCTION GET-SLOT-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-LITERAL"
    "(DEFUN PRETTY-PRINT-LITERAL ((LITERAL OBJECT) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-LITERAL) NULL)
   (DEFINE-FUNCTION-OBJECT "LITERAL-EQL?"
    "(DEFUN (LITERAL-EQL? BOOLEAN) ((X OBJECT) (Y OBJECT)))"
    (CL:FUNCTION LITERAL-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONVERT-TO-LITERAL"
    "(DEFUN (CONVERT-TO-LITERAL OBJECT) ((OBJECT OBJECT)))"
    (CL:FUNCTION CONVERT-TO-LITERAL) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-CLASS-OPTIONS"
    "(DEFUN PRETTY-PRINT-CLASS-OPTIONS ((CLASS CLASS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-CLASS-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-SLOT-OPTIONS"
    "(DEFUN PRETTY-PRINT-SLOT-OPTIONS ((SLOT STORAGE-SLOT) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-SLOT-OPTIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRETTY-PRINT-OBJECT ((SELF STORAGE-SLOT) (STREAM OUTPUT-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PRETTY-PRINT-OBJECT)) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-METHOD-PARAMETERS"
    "(DEFUN PRETTY-PRINT-METHOD-PARAMETERS ((STREAM OUTPUT-STREAM) (METHOD METHOD-SLOT)))"
    (CL:FUNCTION PRETTY-PRINT-METHOD-PARAMETERS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRETTY-PRINT-OBJECT ((SELF METHOD-SLOT) (STREAM OUTPUT-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PRETTY-PRINT-OBJECT)) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-SLOT-BLOCK"
    "(DEFUN PRETTY-PRINT-SLOT-BLOCK ((STREAM OUTPUT-STREAM) (ITERATOR (ITERATOR OF SLOT)) (SLOTGROUP STRING)))"
    (CL:FUNCTION PRETTY-PRINT-SLOT-BLOCK) NULL)
   (DEFINE-FUNCTION-OBJECT "PRETTY-PRINT-SLOTS"
    "(DEFUN PRETTY-PRINT-SLOTS ((SELF CLASS) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRETTY-PRINT-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRETTY-PRINT-OBJECT ((SELF CLASS) (STREAM OUTPUT-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PRETTY-PRINT-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF OBJECT) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :PUBLIC? TRUE :DOCUMENTATION \"Prints a description of 'self' to stream 'stream'.  'mode'
can be :terse, :verbose, or :source.  The :terse mode is often equivalent
to the standard print function.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION DESCRIBE-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF CLASS) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESCRIBE-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF STORAGE-SLOT) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESCRIBE-OBJECT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESCRIBE-OBJECT ((SELF MODULE) (STREAM OUTPUT-STREAM) (MODE KEYWORD)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DESCRIBE-OBJECT)) NULL)
   (DEFINE-FUNCTION-OBJECT "XMODULE-STRINGIFIED-SOURCE"
    "(DEFUN (XMODULE-STRINGIFIED-SOURCE STRING) ((SELF MODULE)))"
    (CL:FUNCTION XMODULE-STRINGIFIED-SOURCE) NULL)
   (DEFINE-FUNCTION-OBJECT "SHORT-DOCUMENTATION"
    "(DEFUN (SHORT-DOCUMENTATION STRING) ((DOCUMENTATION STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION SHORT-DOCUMENTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-DOCUMENTATION-STRING"
    "(DEFUN PRINT-DOCUMENTATION-STRING ((STRING STRING) (INDENT INTEGER) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-DOCUMENTATION-STRING) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-DOCUMENTATION ((SELF METHOD-SLOT) (STREAM OUTPUT-STREAM) (SHORT? BOOLEAN)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION PRINT-DOCUMENTATION)) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-DESCRIBE"
    "(DEFUN STARTUP-DESCRIBE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-DESCRIBE) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-DESCRIBE-STELLA-STARTUP-DESCRIBE)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-DESCRIBE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupDescribe") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-DESCRIBE ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-DESCRIBE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *STRING-TO-OBJECT-FUNCTIONS* (NEW-KEY-VALUE-LIST))
    (CL:SETQ *INTEGER-TO-OBJECT-FUNCTIONS* (LIST))
    (CL:SETQ *DEFAULT-DESCRIBE-MODE* KWD-DESCRIBE-VERBOSE))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-DESCRIBE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (REGISTER-NATIVE-NAME SYM-DESCRIBE-STELLA-GET
     KWD-DESCRIBE-COMMON-LISP KWD-DESCRIBE-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *STRING-TO-OBJECT-FUNCTIONS* (KEY-VALUE-LIST OF TYPE CODE-WRAPPER) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"Table of functions (keyed by type of object returned) that can
be called to search for an object identified by a string.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *INTEGER-TO-OBJECT-FUNCTIONS* (LIST OF CODE-WRAPPER) (LIST) :DOCUMENTATION \"List of functions that can be called to search for
an object identified by an integer.\")" NULL)
    (CLEAR *STRING-TO-OBJECT-FUNCTIONS*)
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS* SGT-DESCRIBE-STELLA-CLASS
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-CLASS)))
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS* SGT-DESCRIBE-STELLA-CONTEXT
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-CONTEXT)))
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS*
     SGT-DESCRIBE-STELLA-METHOD-SLOT
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-FUNCTION)))
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS* SGT-DESCRIBE-STELLA-SLOT
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-SLOT)))
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS* SGT-DESCRIBE-STELLA-OBJECT
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-SURROGATE-VALUE)))
    (INSERT-AT *STRING-TO-OBJECT-FUNCTIONS* SGT-DESCRIBE-STELLA-DEMON
     (WRAP-FUNCTION-CODE (CL:FUNCTION STRING-TO-DEMON)))
    (INSERT *INTEGER-TO-OBJECT-FUNCTIONS*
     (WRAP-FUNCTION-CODE (CL:FUNCTION INTEGER-TO-CONTEXT)))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DEFAULT-DESCRIBE-MODE* KEYWORD :VERBOSE :PUBLIC? TRUE :DOCUMENTATION \"Specifies the print mode for `describe' when no second
argument is given.\")" NULL)
    (REGISTER-NATIVE-NAME SYM-DESCRIBE-STELLA-DESCRIBE
     KWD-DESCRIBE-COMMON-LISP KWD-DESCRIBE-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *PRETTY-PRINT-LIST-CUTOFF* INTEGER 5 :PUBLIC? TRUE :DOCUMENTATION \"Lists longer than the cutoff are truncated during
pretty printing.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *SLOTOPTIONSLOTS* (CONS OF STORAGE-SLOT) NULL :DOCUMENTATION \"List of slots containing storage-slot options\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CLASSOPTIONSLOTS* (CONS OF STORAGE-SLOT) NULL :DOCUMENTATION \"List of slots containing class options\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CLASSUNSTRINGIFIEDOPTIONS* PROPERTY-LIST NULL :DOCUMENTATION \"Plist of unstringifed class options\")"
     NULL)))
  :VOID)
