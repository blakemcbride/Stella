;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; walk.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR KWD-WALK-WARN-ABOUT-MISSING-METHODS NULL)
(CL:DEFVAR KWD-WALK-SUPPRESS-WARNINGS NULL)
(CL:DEFVAR KWD-WALK-USE-HARDCODED-SYMBOLS NULL)
(CL:DEFVAR KWD-WALK-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-WALK-USE-COMMON-LISP-CONSES NULL)
(CL:DEFVAR KWD-WALK-USE-CPP-GARBAGE-COLLECTOR NULL)
(CL:DEFVAR KWD-WALK-MINIMIZE-JAVA-PREFIXES NULL)
(CL:DEFVAR KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER NULL)
(CL:DEFVAR KWD-WALK-SUPPORT-UNEXEC NULL)
(CL:DEFVAR KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-SET-STELLA-FEATURE NULL)
(CL:DEFVAR KWD-WALK-COMMON-LISP NULL)
(CL:DEFVAR KWD-WALK-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-UNSET-STELLA-FEATURE NULL)
(CL:DEFVAR SYM-WALK-STELLA-MEMB? NULL)
(CL:DEFVAR SYM-WALK-STELLA-*TRACED-KEYWORDS* NULL)
(CL:DEFVAR SGT-WALK-STELLA-VOID NULL)
(CL:DEFVAR SYM-WALK-STELLA-OR NULL)
(CL:DEFVAR SGT-WALK-STELLA-CONS NULL)
(CL:DEFVAR SYM-WALK-STELLA-WHEN NULL)
(CL:DEFVAR SYM-WALK-STELLA-AND NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT NULL)
(CL:DEFVAR SYM-WALK-STELLA-EOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-FLUSH-OUTPUT NULL)
(CL:DEFVAR SYM-WALK-STELLA-STANDARD-OUTPUT NULL)
(CL:DEFVAR SYM-WALK-STELLA-ADD-TRACE NULL)
(CL:DEFVAR SYM-WALK-STELLA-DROP-TRACE NULL)
(CL:DEFVAR KWD-WALK-JAVA NULL)
(CL:DEFVAR SGT-WALK-STELLA-F-GET-QUOTED-TREE-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-WALK-STELLA-TRANSLATION-UNIT NULL)
(CL:DEFVAR SYM-WALK-STELLA-HOME-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-TU-HOME-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-THE-OBJECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-CATEGORY NULL)
(CL:DEFVAR SYM-WALK-STELLA-ANNOTATION NULL)
(CL:DEFVAR SYM-WALK-STELLA-AUXILIARY? NULL)
(CL:DEFVAR SYM-WALK-STELLA-CODE-REGISTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-TRANSLATION NULL)
(CL:DEFVAR SYM-WALK-STELLA-REFERENCED-GLOBALS NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-GLOBAL-VARIABLE NULL)
(CL:DEFVAR KWD-WALK-CPP NULL)
(CL:DEFVAR KWD-WALK-CPP-STANDALONE NULL)
(CL:DEFVAR KWD-WALK-IDL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SET-TRANSLATOR-OUTPUT-LANGUAGE NULL)
(CL:DEFVAR SYM-WALK-STELLA-PROGN NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFCLASS NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFSLOT NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFMETHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFOPERATOR NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFGLOBAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFSPECIAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFCONSTANT NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFTYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFMODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFMACRO NULL)
(CL:DEFVAR SYM-WALK-STELLA-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR SYM-WALK-STELLA-VERBATIM NULL)
(CL:DEFVAR SYM-WALK-STELLA-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-TYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-SLOT NULL)
(CL:DEFVAR KWD-WALK-JAVA-STANDALONE NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-CONSTRUCTOR? NULL)
(CL:DEFVAR KWD-WALK-DEFINE NULL)
(CL:DEFVAR KWD-WALK-FINALIZE NULL)
(CL:DEFVAR KWD-WALK-WALK NULL)
(CL:DEFVAR KWD-WALK-TRANSLATE NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-MACRO? NULL)
(CL:DEFVAR SGT-WALK-STELLA-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SGT-WALK-STELLA-TYPE-SPEC NULL)
(CL:DEFVAR SGT-WALK-STELLA-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR SYM-WALK-STELLA-LOG-FUNCTION-CALL NULL)
(CL:DEFVAR SYM-WALK-STELLA-START-FUNCTION-CALL-LOGGING NULL)
(CL:DEFVAR SYM-WALK-STELLA-STOP-FUNCTION-CALL-LOGGING NULL)
(CL:DEFVAR SYM-WALK-STELLA-SET-CALL-LOG-BREAK-POINT NULL)
(CL:DEFVAR SYM-WALK-STELLA-BREAK-PROGRAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-TERMINATE-PROGRAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-PO NULL)
(CL:DEFVAR SYM-WALK-STELLA-NULL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQ? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-< NULL)
(CL:DEFVAR SYM-WALK-STELLA-<= NULL)
(CL:DEFVAR SYM-WALK-STELLA-> NULL)
(CL:DEFVAR SYM-WALK-STELLA->= NULL)
(CL:DEFVAR SYM-WALK-STELLA-CAST NULL)
(CL:DEFVAR SGT-WALK-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-WALK-STELLA-LISP-CODE NULL)
(CL:DEFVAR SGT-WALK-STELLA-OUTPUT-STREAM NULL)
(CL:DEFVAR SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-INLINE NULL)
(CL:DEFVAR SGT-WALK-STELLA-UNINITIALIZED NULL)
(CL:DEFVAR KWD-WALK-SECOND-CLASS NULL)
(CL:DEFVAR SGT-WALK-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-WALK-STELLA-NULL NULL)
(CL:DEFVAR KWD-WALK-TYPE NULL)
(CL:DEFVAR KWD-WALK-ALIAS NULL)
(CL:DEFVAR SYM-WALK-STELLA-ERROR NULL)
(CL:DEFVAR SYM-WALK-STELLA-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR NULL)
(CL:DEFVAR SYM-WALK-STELLA-BAD-SYS NULL)
(CL:DEFVAR SGT-WALK-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-INTEGER NULL)
(CL:DEFVAR SGT-WALK-STELLA-LONG-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-LONG-INTEGER NULL)
(CL:DEFVAR SGT-WALK-STELLA-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-WALK-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-WALK-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-STRING NULL)
(CL:DEFVAR SGT-WALK-STELLA-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-WALK-STELLA-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-CHARACTER NULL)
(CL:DEFVAR SGT-WALK-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-WALK-STELLA-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-FUNCTION-CODE NULL)
(CL:DEFVAR SGT-WALK-STELLA-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-WALK-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SGT-WALK-STELLA-OBJECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-INLINE-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-STELLA-WRAP-LITERAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTEGER-TO-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTEGER-TO-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-STELLA-MUTABLE-STRING-TO-STRING NULL)
(CL:DEFVAR SYM-WALK-STELLA-STRING-TO-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-WALK-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTERN-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-CHARACTER-TO-STRING NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYMBOL-NAME NULL)
(CL:DEFVAR SYM-WALK-STELLA-INLINE-UNWRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-STELLA-WRAPPER-VALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-NUMBER-WRAPPER-TO-FLOAT NULL)
(CL:DEFVAR SGT-WALK-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-WALK-STELLA-CLASS NULL)
(CL:DEFVAR SYM-WALK-STELLA-SURROGATE-VALUE NULL)
(CL:DEFVAR SGT-WALK-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SGT-WALK-STELLA-NATIVE-INPUT-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-NATIVE-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-<X> NULL)
(CL:DEFVAR SGT-WALK-STELLA-SINGLE-FLOAT NULL)
(CL:DEFVAR SYM-WALK-STELLA-IDENTITY NULL)
(CL:DEFVAR SGT-WALK-STELLA-DOUBLE-FLOAT NULL)
(CL:DEFVAR SGT-WALK-STELLA-SHORT-INTEGER NULL)
(CL:DEFVAR SGT-WALK-STELLA-UNSIGNED-SHORT-INTEGER NULL)
(CL:DEFVAR SGT-WALK-STELLA-UNSIGNED-LONG-INTEGER NULL)
(CL:DEFVAR SYM-WALK-STELLA-VRLET NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-TYPED-SYS NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-INLINE-CALL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SAFE-CAST NULL)
(CL:DEFVAR SGT-WALK-STELLA-NON-OBJECT NULL)
(CL:DEFVAR SGT-WALK-STELLA-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-STELLA-LET NULL)
(CL:DEFVAR SYM-WALK-STELLA-X NULL)
(CL:DEFVAR SGT-WALK-STELLA-LITERAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-VOID-SYS NULL)
(CL:DEFVAR SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-FOREACH NULL)
(CL:DEFVAR SYM-WALK-STELLA-SETQ NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-SET-DEFAULT NULL)
(CL:DEFVAR SYM-WALK-STELLA-SETF NULL)
(CL:DEFVAR SYM-WALK-STELLA-SLOT-VALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-AREF NULL)
(CL:DEFVAR SYM-WALK-STELLA-AREF-SETTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-WITH-PROCESS-LOCK NULL)
(CL:DEFVAR SYM-WALK-STELLA-LOOP NULL)
(CL:DEFVAR SYM-WALK-STELLA-VALUES NULL)
(CL:DEFVAR SYM-WALK-STELLA-SPECIAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-SPECIAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-RETURN NULL)
(CL:DEFVAR SYM-WALK-STELLA-MV-SETQ NULL)
(CL:DEFVAR SYM-WALK-STELLA-MV-BIND NULL)
(CL:DEFVAR SYM-WALK-STELLA-BREAK NULL)
(CL:DEFVAR SYM-WALK-STELLA-CONTINUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-WHILE NULL)
(CL:DEFVAR SYM-WALK-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-WALK-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-FORALL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SOME NULL)
(CL:DEFVAR SYM-WALK-STELLA-SETOF NULL)
(CL:DEFVAR SYM-WALK-STELLA-SET-OF NULL)
(CL:DEFVAR SYM-WALK-STELLA-SELECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-IF NULL)
(CL:DEFVAR SYM-WALK-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-WALK-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-WALK-STELLA-NOT NULL)
(CL:DEFVAR SYM-WALK-STELLA-COND NULL)
(CL:DEFVAR SYM-WALK-STELLA-CASE NULL)
(CL:DEFVAR SYM-WALK-STELLA-TYPECASE NULL)
(CL:DEFVAR SYM-WALK-STELLA-= NULL)
(CL:DEFVAR SYM-WALK-STELLA-+ NULL)
(CL:DEFVAR SYM-WALK-STELLA-- NULL)
(CL:DEFVAR SYM-WALK-STELLA-* NULL)
(CL:DEFVAR |SYM-WALK-STELLA-/| NULL)
(CL:DEFVAR SYM-WALK-STELLA-QUOTE NULL)
(CL:DEFVAR SYM-WALK-STELLA-BQUOTE NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT-NATIVE-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-NEW NULL)
(CL:DEFVAR SYM-WALK-STELLA-ALLOCATE NULL)
(CL:DEFVAR SYM-WALK-STELLA-LOCAL-NEW NULL)
(CL:DEFVAR SYM-WALK-STELLA-MAKE NULL)
(CL:DEFVAR SYM-WALK-STELLA-FUNCALL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-METHOD-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-THE-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-CALL-SUPER-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-SIGNAL-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-EXCEPTION-CASE NULL)
(CL:DEFVAR SYM-WALK-STELLA-UNWIND-PROTECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-UNWIND-PROTECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-SLOT-VALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-SUPER-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-CALL-METHOD-SETTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-NEW NULL)
(CL:DEFVAR KWD-WALK-PUBLIC? NULL)
(CL:DEFVAR SYM-WALK-STELLA-TRUE NULL)
(CL:DEFVAR KWD-WALK-SYMBOLS NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTERN-RIGID-SYMBOL-WRT-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-GET-STELLA-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTERN-SYMBOL-AT NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTERN-SURROGATE-AT NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTERN-KEYWORD-AT NULL)
(CL:DEFVAR SYM-WALK-STELLA-FALSE NULL)
(CL:DEFVAR KWD-WALK-INLINE-ARGUMENT NULL)
(CL:DEFVAR SGT-WALK-STELLA-KEYWORD NULL)
(CL:DEFVAR KWD-WALK-PLACE-WHERE-VRLET-WAS NULL)
(CL:DEFVAR KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS NULL)
(CL:DEFVAR KWD-WALK-DYNAMIC NULL)
(CL:DEFVAR SYM-WALK-STELLA-IT NULL)
(CL:DEFVAR SYM-WALK-STELLA-ON NULL)
(CL:DEFVAR SYM-WALK-STELLA-DYNAMIC-SLOTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-WHERE NULL)
(CL:DEFVAR SYM-WALK-STELLA-KEY NULL)
(CL:DEFVAR SYM-WALK-STELLA-DO NULL)
(CL:DEFVAR SYM-WALK-STELLA-WRAPPEDVALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-VALUE NULL)
(CL:DEFVAR KWD-WALK-BIT NULL)
(CL:DEFVAR SYM-WALK-STELLA-DYNAMICSLOTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-NEWVALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-FOUNDMATCHINGENTRY? NULL)
(CL:DEFVAR SYM-WALK-STELLA-THE-KV-LIST NULL)
(CL:DEFVAR SYM-WALK-STELLA-KV-CONS NULL)
(CL:DEFVAR SYM-WALK-STELLA-OLDVALUE NULL)
(CL:DEFVAR KWD-WALK-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR KWD-WALK-DONT-INHERIT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-ACCESS-IN-CONTEXT NULL)
(CL:DEFVAR SYM-WALK-STELLA-HOME-CONTEXT NULL)
(CL:DEFVAR KWD-WALK-COPY-TO-CHILDREN? NULL)
(CL:DEFVAR SYM-WALK-STELLA-UPDATE-IN-CONTEXT NULL)
(CL:DEFVAR SYM-WALK-STELLA-CS-VALUE? NULL)
(CL:DEFVAR SGT-WALK-STELLA-ARRAY NULL)
(CL:DEFVAR SYM-WALK-STELLA-ANY-VALUE NULL)
(CL:DEFVAR SYM-WALK-STELLA-VARIABLE-DECLARATION NULL)
(CL:DEFVAR SYM-WALK-STELLA-ILLEGAL-VARIABLE NULL)
(CL:DEFVAR KWD-WALK-UNBIND-WITH-DESTRUCTORS NULL)
(CL:DEFVAR KWD-WALK-UNWIND-PROTECT NULL)
(CL:DEFVAR SGT-WALK-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-WALK-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYMBOL-ID NULL)
(CL:DEFVAR SYM-WALK-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-BOOLEAN? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-BOOLEAN? NULL)
(CL:DEFVAR SYM-WALK-STELLA-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-LONG-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-LONG-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-FLOAT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-FLOAT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-STRING? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-STRING? NULL)
(CL:DEFVAR SYM-WALK-STELLA-CHARACTER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-CHARACTER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-WRAPPER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-WRAPPER? NULL)
(CL:DEFVAR SGT-WALK-STELLA-VERBATIM-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-WALK-STELLA-VERBATIM-STRING? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-VERBATIM-STRING? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SURROGATE? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-SURROGATE? NULL)
(CL:DEFVAR SGT-WALK-STELLA-TYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-TYPE? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-TYPE? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYMBOL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-SYMBOL? NULL)
(CL:DEFVAR SGT-WALK-STELLA-TRANSIENT-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-TRANSIENT-SYMBOL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-TRANSIENT-SYMBOL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-KEYWORD? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-KEYWORD? NULL)
(CL:DEFVAR SYM-WALK-STELLA-CONS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-CONS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-STELLA-CLASS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-CLASS? NULL)
(CL:DEFVAR SGT-WALK-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-WALK-STELLA-STORAGE-SLOT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-STORAGE-SLOT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-SLOT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-METHOD-SLOT? NULL)
(CL:DEFVAR SGT-WALK-STELLA-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-STELLA-ANCHORED-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SGT-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-ISA? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SUBTYPE-OF? NULL)
(CL:DEFVAR SGT-WALK-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-WALK-STELLA-STRING-EQL? NULL)
(CL:DEFVAR SYM-WALK-STELLA-SAFE-PRIMARY-TYPE NULL)
(CL:DEFVAR SGT-WALK-STELLA-PROCESS-LOCK-OBJECT NULL)
(CL:DEFVAR SGT-WALK-STELLA-STANDARD-OBJECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL-TO-BOOLEAN? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL-TO-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL-TO-LONG-INTEGER? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL-TO-FLOAT? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EQL-TO-STRING? NULL)
(CL:DEFVAR SYM-WALK-STELLA-GET-QUOTED-TREE NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-BODY-ARGUMENT? NULL)
(CL:DEFVAR KWD-WALK-WARN NULL)
(CL:DEFVAR KWD-WALK-ERROR NULL)
(CL:DEFVAR KWD-WALK-CONTINUABLE-ERROR NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-WALK-STELLA-CONCATENATE NULL)
(CL:DEFVAR SYM-WALK-STELLA-NIL NULL)
(CL:DEFVAR SYM-WALK-STELLA-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-WALK-STELLA-CONS NULL)
(CL:DEFVAR SYM-WALK-STELLA-CONS-LIST NULL)
(CL:DEFVAR SYM-WALK-STELLA-ALLOCATE-ITERATOR NULL)
(CL:DEFVAR SGT-WALK-STELLA-ARGUMENT-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-WALK-STELLA-LENGTH NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-COPY-CONS-TREE NULL)
(CL:DEFVAR SYM-WALK-STELLA-GET-SYM NULL)
(CL:DEFVAR SYM-WALK-STELLA-GET-SGT NULL)
(CL:DEFVAR SYM-WALK-STELLA-GET-KWD NULL)
(CL:DEFVAR SGT-WALK-STELLA-ARGUMENT-LIST NULL)
(CL:DEFVAR SYM-WALK-STELLA-CACHED-INLINABLE-METHOD-BODY NULL)
(CL:DEFVAR KWD-WALK-INLINE-REFERENCES NULL)
(CL:DEFVAR SYM-WALK-STELLA-INLINE-CALL NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-INHERITS-THROUGH NULL)
(CL:DEFVAR SYM-WALK-STELLA-MAIN NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-NATIVE? NULL)
(CL:DEFVAR KWD-WALK-METHODS NULL)
(CL:DEFVAR SYM-WALK-STELLA-FORWARD-DECLARATION? NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-COMMAND? NULL)
(CL:DEFVAR SYM-WALK-STELLA-C-CALLABLE-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-LOOKUP-FUNCTION-BY-NAME NULL)
(CL:DEFVAR KWD-WALK-CLASS NULL)
(CL:DEFVAR KWD-WALK-EMBEDDED NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS-CONSTRUCTOR-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLASS-AUXILIARY-METHODS NULL)
(CL:DEFVAR SYM-WALK-STELLA-AUXILIARY-METHOD-REASON NULL)
(CL:DEFVAR KWD-WALK-FIRST-CLASS-WITH-TYPECASE NULL)
(CL:DEFVAR KWD-WALK-AUXILIARY? NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT-FORM NULL)
(CL:DEFVAR SYM-WALK-STELLA-PRINT-OBJECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-SELF NULL)
(CL:DEFVAR SYM-WALK-STELLA-STREAM NULL)
(CL:DEFVAR SYM-WALK-STELLA-NATIVE-OUTPUT-STREAM NULL)
(CL:DEFVAR KWD-WALK-CLASSES NULL)
(CL:DEFVAR KWD-WALK-FINALIZE-CLASSES NULL)
(CL:DEFVAR SYM-WALK-STELLA-FINALIZE-CLASSES NULL)
(CL:DEFVAR KWD-WALK-FINALIZE-METHODS NULL)
(CL:DEFVAR SYM-WALK-STELLA-FINALIZE-SLOTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-CLEANUP-UNFINALIZED-CLASSES NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR KWD-WALK-MACRO? NULL)
(CL:DEFVAR SYM-WALK-STELLA-OBJECT NULL)
(CL:DEFVAR KWD-WALK-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR KWD-WALK-GLOBALS NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFINE-GLOBAL-VARIABLE-OBJECT NULL)
(CL:DEFVAR SYM-WALK-STELLA-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR KWD-WALK-FINAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-CURRENT-STARTUP-TIME-PHASE? NULL)
(CL:DEFVAR KWD-WALK-MODULES NULL)
(CL:DEFVAR SYM-WALK-STELLA-WITHIN-MODULE NULL)
(CL:DEFVAR SYM-WALK-STELLA-*STELLA-MODULE* NULL)
(CL:DEFVAR SYM-WALK-STELLA-*STARTUP-TIME-PHASE* NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME NULL)
(CL:DEFVAR KWD-WALK-C-CALLABLE? NULL)
(CL:DEFVAR KWD-WALK-C-NAMESPACE-PREFIX NULL)
(CL:DEFVAR SYM-WALK-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-LOOKUP-FUNCTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-*BOOTSTRAP-LOCK* NULL)
(CL:DEFVAR SGT-WALK-STELLA-STELLA-ROOT-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-SIGNAL NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-HANDLER-CASE NULL)
(CL:DEFVAR SGT-WALK-STELLA-NATIVE-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-SYS-HANDLE-EXCEPTION NULL)
(CL:DEFVAR KWD-WALK-OTHERWISE NULL)
(CL:DEFVAR SYM-WALK-STELLA-INITIAL-ELEMENT NULL)
(CL:DEFVAR SYM-WALK-STELLA-SIZE NULL)
(CL:DEFVAR SYM-WALK-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SGT-WALK-STELLA-CODE NULL)
(CL:DEFVAR KWD-WALK-METHOD NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SGT-WALK-STELLA-COMPOUND-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR SYM-WALK-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-WALK-STELLA-EXPRESSION NULL)
(CL:DEFVAR SYM-WALK-STELLA-IGNORE NULL)
(CL:DEFVAR SYM-WALK-STELLA-*IGNORETRANSLATIONERRORS?* NULL)
(CL:DEFVAR SYM-WALK-STELLA-CL-INCREMENTALLY-TRANSLATE NULL)
(CL:DEFVAR SYM-WALK-STELLA-REGISTER-NATIVE-NAME NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-C-CALLABLE? NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-C-NAMESPACE-PREFIX NULL)
(CL:DEFVAR SYM-WALK-STELLA-*C-API-RESULT-BUFFER* NULL)
(CL:DEFVAR SYM-WALK-STELLA-NATIVE-OBJECT-POINTER NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-THROWS-EXCEPTIONS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-NATIVE-EXCEPTION NULL)
(CL:DEFVAR SYM-WALK-STELLA-E NULL)
(CL:DEFVAR SYM-WALK-STELLA-CALL-GLOBAL-EXCEPTION-HANDLER NULL)
(CL:DEFVAR KWD-WALK-DOCUMENTATION NULL)
(CL:DEFVAR SYM-WALK-STELLA-CPP_VAR_ARGS NULL)
(CL:DEFVAR SYM-WALK-STELLA-REST NULL)
(CL:DEFVAR SYM-WALK-STELLA-NTH-REST NULL)
(CL:DEFVAR SYM-WALK-STELLA-NTH NULL)
(CL:DEFVAR SYM-WALK-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SYM-WALK-STELLA-RESULT NULL)
(CL:DEFVAR SYM-WALK-STELLA-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-WALK-STELLA-EVALUATE NULL)
(CL:DEFVAR SYM-WALK-STELLA-APPEND NULL)
(CL:DEFVAR SYM-WALK-STELLA-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-WALK-STELLA-VARIABLE-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-WALK-STELLA-LIST* NULL)
(CL:DEFVAR SYM-WALK-STELLA-STARTUP-WALK NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL NULL-INTEGER-WRAPPER NULL-LONG-INTEGER-WRAPPER
  NULL-FLOAT-WRAPPER NULL-FUNCTION-CODE-WRAPPER *ROOT-MODULE*
  *CURRENTSYSTEMDEFINITION* *STELLA-MODULE* *STARTUP-TIME-PHASES*
  NIL-LIST *CPP-OPERATOR-TABLE* NULL-STRING-WRAPPER
  *INLININGMETHODCALL?* KEYWORD-SYM SURROGATE-SYM SYMBOL-SYM
  *MIXIN-IMPLEMENTATION-STYLE* *CURRENTFILENAME*
  *IGNORETRANSLATIONERRORS?* STANDARD-WARNING TRUE-WRAPPER
  FALSE-WRAPPER *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE *MODULE*
  NULL-INTEGER STANDARD-ERROR *TRANSLATOROUTPUTLANGUAGE*
  STANDARD-OUTPUT EOL NIL))

;;; (DEFGLOBAL *AVAILABLE-STELLA-FEATURES* ...)

(CL:DEFVAR *AVAILABLE-STELLA-FEATURES* NULL
  "List of available STELLA features.")

;;; (DEFSPECIAL *CURRENT-STELLA-FEATURES* ...)

(CL:DEFVAR *CURRENT-STELLA-FEATURES* NULL
  "List of currently enabled STELLA features.")

;;; (DEFGLOBAL *DEFAULT-STELLA-FEATURES* ...)

(CL:DEFVAR *DEFAULT-STELLA-FEATURES* NULL
  "List of STELLA features enabled by default and after resetting them
with `reset-stella-features'.")

;;; (DEFUN PRINT-STELLA-FEATURES ...)

(CL:DEFUN PRINT-STELLA-FEATURES ()
  "Print the list of enabled and disabled STELLA features."
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Enabled STELLA features:" EOL)
  (CL:LET*
   ((FEATURE NULL)
    (ITER-000 (%LIST.THE-CONS-LIST *CURRENT-STELLA-FEATURES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ FEATURE (%%VALUE ITER-000))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "  :" (STRING-DOWNCASE (%KEYWORD.SYMBOL-NAME FEATURE)) EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
   "Disabled STELLA features:" EOL)
  (CL:LET*
   ((FEATURE NULL)
    (ITER-001 (%LIST.THE-CONS-LIST *AVAILABLE-STELLA-FEATURES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ FEATURE (%%VALUE ITER-001))
    (CL:WHEN (CL:NOT (MEMBER? *CURRENT-STELLA-FEATURES* FEATURE))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "  :" (STRING-DOWNCASE (%KEYWORD.SYMBOL-NAME FEATURE)) EOL))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  :VOID)

;;; (DEFUN SET-STELLA-FEATURE ...)

(CL:DEFUN %SET-STELLA-FEATURE (FEATURES)
  "Enable all listed STELLA `features'."
  (CL:LET* ((F NULL) (ITER-000 FEATURES))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ F (%%VALUE ITER-000))
    (CL:TAGBODY
     (CL:COND ((CL:EQ F KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS))
      ((CL:EQ F KWD-WALK-WARN-ABOUT-MISSING-METHODS))
      ((CL:EQ F KWD-WALK-SUPPRESS-WARNINGS))
      ((CL:EQ F KWD-WALK-USE-HARDCODED-SYMBOLS))
      ((CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS)
       (REMOVE *CURRENT-STELLA-FEATURES*
        KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS))
      ((CL:EQ F KWD-WALK-USE-COMMON-LISP-CONSES))
      ((CL:EQ F KWD-WALK-USE-CPP-GARBAGE-COLLECTOR))
      ((CL:EQ F KWD-WALK-MINIMIZE-JAVA-PREFIXES))
      ((CL:EQ F KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER))
      ((CL:EQ F KWD-WALK-SUPPORT-UNEXEC))
      (CL:T
       (CL:IF (MEMBER? *AVAILABLE-STELLA-FEATURES* F)
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "STELLA feature `" F "' is valid but not yet implemented")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
        (CL:WARN "Invalid STELLA feature: `~A'" F))
       (CL:GO :CONTINUE)))
     (INSERT-NEW *CURRENT-STELLA-FEATURES* F) :CONTINUE)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

(CL:DEFUN SET-STELLA-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-STELLA-FEATURE ARGUMENTS)
  :VOID)

(CL:DEFMACRO SET-STELLA-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Enable all listed STELLA `features'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-STELLA-FEATURE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-STELLA-FEATURE)))

;;; (DEFUN UNSET-STELLA-FEATURE ...)

(CL:DEFUN %UNSET-STELLA-FEATURE (FEATURES)
  "Disable all listed STELLA `features'."
  (CL:LET* ((F NULL) (ITER-000 FEATURES))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ F (%%VALUE ITER-000))
    (CL:TAGBODY
     (CL:COND ((CL:EQ F KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS))
      ((CL:EQ F KWD-WALK-WARN-ABOUT-MISSING-METHODS))
      ((CL:EQ F KWD-WALK-SUPPRESS-WARNINGS))
      ((CL:EQ F KWD-WALK-USE-HARDCODED-SYMBOLS))
      ((CL:EQ F KWD-WALK-USE-COMMON-LISP-STRUCTS))
      ((CL:EQ F KWD-WALK-USE-COMMON-LISP-CONSES))
      ((CL:EQ F KWD-WALK-USE-CPP-GARBAGE-COLLECTOR))
      ((CL:EQ F KWD-WALK-MINIMIZE-JAVA-PREFIXES))
      ((CL:EQ F KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER))
      ((CL:EQ F KWD-WALK-SUPPORT-UNEXEC))
      (CL:T
       (CL:IF (MEMBER? *AVAILABLE-STELLA-FEATURES* F)
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "STELLA feature `" F "' is valid but not yet implemented")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
        (CL:WARN "Invalid STELLA feature: `~A'" F))
       (CL:GO :CONTINUE)))
     (REMOVE *CURRENT-STELLA-FEATURES* F) :CONTINUE)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

(CL:DEFUN UNSET-STELLA-FEATURE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%UNSET-STELLA-FEATURE ARGUMENTS)
  :VOID)

(CL:DEFMACRO UNSET-STELLA-FEATURE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Disable all listed STELLA `features'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/UNSET-STELLA-FEATURE|)) (CL:MACRO-FUNCTION (CL:QUOTE UNSET-STELLA-FEATURE)))

;;; (DEFUN RESET-STELLA-FEATURES ...)

(CL:DEFUN RESET-STELLA-FEATURES ()
  "Reset STELLA features to their default settings."
  (CL:LET*
   ((F NULL)
    (ITER-000 (%LIST.THE-CONS-LIST *CURRENT-STELLA-FEATURES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ F (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (MEMBER? *DEFAULT-STELLA-FEATURES* F))
     (%UNSET-STELLA-FEATURE (CONS-LIST F)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((F NULL)
    (ITER-001 (%LIST.THE-CONS-LIST *DEFAULT-STELLA-FEATURES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ F (%%VALUE ITER-001))
    (CL:WHEN (CL:NOT (MEMBER? *CURRENT-STELLA-FEATURES* F))
     (%SET-STELLA-FEATURE (CONS-LIST F)))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  :VOID)

;;; (DEFUN (ENABLED-STELLA-FEATURE? BOOLEAN) ...)

(CL:DEFUN ENABLED-STELLA-FEATURE? (FEATURE)
  "Return true if the STELLA `feature' is currently enabled."
  (CL:RETURN-FROM ENABLED-STELLA-FEATURE?
   (MEMB? *CURRENT-STELLA-FEATURES* FEATURE)))

;;; (DEFUN (DISABLED-STELLA-FEATURE? BOOLEAN) ...)

(CL:DEFUN DISABLED-STELLA-FEATURE? (FEATURE)
  "Return true if the STELLA `feature' is currently disabled."
  (CL:RETURN-FROM DISABLED-STELLA-FEATURE?
   (CL:NOT (MEMB? *CURRENT-STELLA-FEATURES* FEATURE))))

;;; (DEFGLOBAL *TRACED-KEYWORDS* ...)

(CL:DEFVAR *TRACED-KEYWORDS* NULL)

;;; (DEFMACRO TRACE-IF ...)

(CL:DEFUN TRACE-IF (KEYWORD BODY)
  "If `keyword' is a trace keyword that has been enabled with `add-trace'
print all the elements in `body' to standard output.  Otherwise, do nothing.
`keyword' can also be a list of keywords in which case printing is done if
one or more of them are trace enabled."
  (CL:LET* ((TEST NIL) (ELEMENTS (COPY-CONS-LIST BODY)))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE KEYWORD) SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((KWD NULL) (ITER-000 KEYWORD) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ KWD (%%VALUE ITER-000))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS
            (LIST* SYM-WALK-STELLA-MEMB?
             SYM-WALK-STELLA-*TRACED-KEYWORDS* KWD NIL)
            NIL))
          (CL:IF (CL:EQ TEST NIL) (CL:SETQ TEST COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST TEST COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS
            (LIST* SYM-WALK-STELLA-MEMB?
             SYM-WALK-STELLA-*TRACED-KEYWORDS* KWD NIL)
            NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:CASE (LENGTH TEST)
       (0
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Missing `trace-if' keyword." EOL)))
        (CL:RETURN-FROM TRACE-IF
         (WALK-DONT-CALL-ME-TREE NIL SGT-WALK-STELLA-VOID)))
       (1 (CL:SETQ TEST (%%VALUE TEST)))
       (CL:OTHERWISE (CL:SETQ TEST (CONS SYM-WALK-STELLA-OR TEST))))))
    (CL:T
     (CL:SETQ TEST
      (LIST* SYM-WALK-STELLA-MEMB? SYM-WALK-STELLA-*TRACED-KEYWORDS*
       KEYWORD NIL))))
   (CL:RETURN-FROM TRACE-IF
    (LIST* SYM-WALK-STELLA-WHEN
     (LIST* SYM-WALK-STELLA-AND
      (LIST* SYM-WALK-STELLA-DEFINED? SYM-WALK-STELLA-*TRACED-KEYWORDS*
       NIL)
      TEST NIL)
     (CONS SYM-WALK-STELLA-PRINT
      (CONCATENATE (COPY-CONS-LIST ELEMENTS) NIL))
     (CONCATENATE
      (CL:IF
       (CL:OR (CL:EQ (LAST ELEMENTS) SYM-WALK-STELLA-EOL)
        (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
       NIL
       (CONS
        (LIST* SYM-WALK-STELLA-FLUSH-OUTPUT
         SYM-WALK-STELLA-STANDARD-OUTPUT NIL)
        NIL))
      NIL)))))

;;; (DEFUN (TRACE-KEYWORD? BOOLEAN) ...)

(CL:DEFUN TRACE-KEYWORD? (KEYWORD)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((CHOOSE-VALUE-000 CL:NIL))
     (CL:IF (CONS? KEYWORD)
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET* ((KWD NULL) (ITER-000 KEYWORD))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ KWD (%%VALUE ITER-000))
         (CL:WHEN (MEMB? *TRACED-KEYWORDS* KWD)
          (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ CHOOSE-VALUE-000 FOUND?-000))
      (CL:SETQ CHOOSE-VALUE-000 (MEMB? *TRACED-KEYWORDS* KEYWORD)))
     (CL:SETQ TEST-VALUE-000 CHOOSE-VALUE-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM TRACE-KEYWORD? VALUE-000))))

;;; (DEFUN (ADD-TRACE LIST) ...)

(CL:DEFUN %ADD-TRACE (KEYWORDS)
  "Enable trace messages identified by any of the listed `keywords'.  After
calling (`add-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will be executed when it is encountered."
  (CL:WHEN (CL:EQ *TRACED-KEYWORDS* NULL)
   (CL:SETQ *TRACED-KEYWORDS* (LIST)))
  (CL:LET* ((K NULL) (ITER-000 KEYWORDS))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ K (%%VALUE ITER-000))
    (INSERT-NEW *TRACED-KEYWORDS*
     (KEYWORDIFY (%GENERALIZED-SYMBOL.SYMBOL-NAME K)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM %ADD-TRACE *TRACED-KEYWORDS*))

(CL:DEFUN ADD-TRACE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM ADD-TRACE-EVALUATOR-WRAPPER (%ADD-TRACE ARGUMENTS)))

(CL:DEFMACRO ADD-TRACE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Enable trace messages identified by any of the listed `keywords'.  After
calling (`add-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will be executed when it is encountered."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ADD-TRACE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-TRACE)))

;;; (DEFUN (DROP-TRACE LIST) ...)

(CL:DEFUN %DROP-TRACE (KEYWORDS)
  "Disable trace messages identified by any of the listed `keywords'.  After
calling (`drop-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will not be executed when it is encountered."
  (CL:WHEN (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
   (CL:LET* ((K NULL) (ITER-000 KEYWORDS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ K (%%VALUE ITER-000))
     (REMOVE *TRACED-KEYWORDS*
      (KEYWORDIFY (%GENERALIZED-SYMBOL.SYMBOL-NAME K)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (EMPTY? *TRACED-KEYWORDS*)
    (CL:SETQ *TRACED-KEYWORDS* NULL)))
  (CL:RETURN-FROM %DROP-TRACE *TRACED-KEYWORDS*))

(CL:DEFUN DROP-TRACE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DROP-TRACE-EVALUATOR-WRAPPER (%DROP-TRACE ARGUMENTS)))

(CL:DEFMACRO DROP-TRACE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Disable trace messages identified by any of the listed `keywords'.  After
calling (`drop-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will not be executed when it is encountered."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DROP-TRACE|)) (CL:MACRO-FUNCTION (CL:QUOTE DROP-TRACE)))

;;; (DEFUN CLEAR-TRACE ...)

(CL:DEFUN CLEAR-TRACE ()
  "Disable all tracing previously enabled with `add-trace'."
  (CLEAR *TRACED-KEYWORDS*)
  :VOID)

;;; (DEFSPECIAL *SAFETY* ...)

(CL:DEFVAR *SAFETY* 3
  "Integer between 0 and 3.  Higher levels call more
safety checks.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SAFETY*))

;;; (DEFSPECIAL *DEBUGLEVEL* ...)

(CL:DEFVAR *DEBUGLEVEL* 3
  "Integer between 0 and 3.  Higher levels generate more
code to aid debugging.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DEBUGLEVEL*))

;;; (DEFSPECIAL *OPTIMIZESPEEDLEVEL* ...)

(CL:DEFVAR *OPTIMIZESPEEDLEVEL* 3
  "Integer between 0 and 3.  Higher levels optimize for
greater execution speed.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *OPTIMIZESPEEDLEVEL*))

;;; (DEFSPECIAL *OPTIMIZESPACELEVEL* ...)

(CL:DEFVAR *OPTIMIZESPACELEVEL* 3
  "Integer between 0 and 3.  Higher levels optimize for
less code size and memory consumption.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *OPTIMIZESPACELEVEL*))

;;; (DEFUN SET-OPTIMIZATION-LEVELS ...)

(CL:DEFUN SET-OPTIMIZATION-LEVELS (SAFETY DEBUG SPEED SPACE)
  "Set optimization levels for the qualities `safety', `debug',
`speed', and `space'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SAFETY DEBUG SPEED SPACE))
  #+MCL
  (CL:CHECK-TYPE SAFETY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE DEBUG CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SPEED CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SPACE CL:FIXNUM)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:= SAFETY NULL-INTEGER)) (CL:>= SAFETY 0)
    (CL:<= SAFETY 3))
   (CL:SETQ *SAFETY* SAFETY))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:= DEBUG NULL-INTEGER)) (CL:>= DEBUG 0)
    (CL:<= DEBUG 3))
   (CL:SETQ *DEBUGLEVEL* DEBUG))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:= SPEED NULL-INTEGER)) (CL:>= SPEED 0)
    (CL:<= SPEED 3))
   (CL:SETQ *OPTIMIZESPEEDLEVEL* SPEED))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:= SPACE NULL-INTEGER)) (CL:>= SPACE 0)
    (CL:<= SPACE 3))
   (CL:SETQ *OPTIMIZESPACELEVEL* SPACE))
  :VOID)

;;; (DEFUN (PRESERVE-TAIL-MERGE-OPTIMIZABILITY? BOOLEAN) ...)

(CL:DEFUN PRESERVE-TAIL-MERGE-OPTIMIZABILITY? ()
  (CL:RETURN-FROM PRESERVE-TAIL-MERGE-OPTIMIZABILITY?
   (CL:AND (CL:>= *OPTIMIZESPEEDLEVEL* 3) (CL:<= *DEBUGLEVEL* 0))))

;;; (DEFUN (METHOD-CALL-INLINING-ENABLED? BOOLEAN) ...)

(CL:DEFUN METHOD-CALL-INLINING-ENABLED? ()
  (CL:RETURN-FROM METHOD-CALL-INLINING-ENABLED?
   (CL:AND (CL:>= *OPTIMIZESPEEDLEVEL* 3) (CL:<= *DEBUGLEVEL* 1))))

;;; (DEFUN (OPTIMIZE-BOOLEAN-TESTS? BOOLEAN) ...)

(CL:DEFUN OPTIMIZE-BOOLEAN-TESTS? ()
  (CL:RETURN-FROM OPTIMIZE-BOOLEAN-TESTS?
   (CL:AND (CL:>= *OPTIMIZESPEEDLEVEL* 2) (CL:<= *DEBUGLEVEL* 2))))

;;; (DEFUN (CHECK-FOR-ILLEGAL-RETURN? BOOLEAN) ...)

(CL:DEFUN CHECK-FOR-ILLEGAL-RETURN? ()
  (CL:RETURN-FROM CHECK-FOR-ILLEGAL-RETURN?
   (CL:AND (CL:>= *SAFETY* 3)
    (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA))
    (CL:NOT (PRESERVE-TAIL-MERGE-OPTIMIZABILITY?)))))

;;; (DEFUN (SUPPORT-UNEXEC? BOOLEAN) ...)

(CL:DEFUN SUPPORT-UNEXEC? ()
  (CL:RETURN-FROM SUPPORT-UNEXEC?
   (CL:AND (MEMB? *CURRENT-STELLA-FEATURES* KWD-WALK-SUPPORT-UNEXEC)
    (TRANSLATE-TO-CPP?))))

;;; (DEFUN (NAME-QUOTED-TREE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) NAME-QUOTED-TREE))
(CL:DEFUN NAME-QUOTED-TREE (TREE)
  (CL:LET*
   ((NAMETREE
     (CONS TREE
      (CONS (WRAP-STRING (%MODULE.MODULE-FULL-NAME *MODULE*)) NIL)))
    (NAME (STRINGIFY NAMETREE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:RETURN-FROM NAME-QUOTED-TREE NAME)))

;;; (DEFUN (GET-QUOTED-TREE CONS) ...)

(CL:DEFUN GET-QUOTED-TREE (TREE-NAME MODULENAME)
  "Return the quoted tree with name `tree-name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TREE-NAME MODULENAME))
  #+MCL
  (CL:CHECK-TYPE TREE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MODULENAME CL:SIMPLE-STRING)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-WALK-STELLA-F-GET-QUOTED-TREE-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-WALK-STELLA-F-GET-QUOTED-TREE-MEMO-TABLE-000
      "(:MAX-VALUES 200 :TIMESTAMPS (:MODULE-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-WALK-STELLA-F-GET-QUOTED-TREE-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 (WRAP-STRING TREE-NAME)
      MEMOIZED-NULL-VALUE NULL NULL 0))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (PERMANENTIFY-FORM
       (%%VALUE
        (UNSTRINGIFY-IN-MODULE TREE-NAME
         (GET-STELLA-MODULE MODULENAME CL:T)))))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (CL:RETURN-FROM GET-QUOTED-TREE VALUE-000))))

(CL:DEFUN NEW-TRANSLATION-UNIT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-TRANSLATION-UNIT))
   (CL:SETF (%TRANSLATION-UNIT.REFERENCED-GLOBALS SELF) (NEW-LIST))
   (CL:SETF (%TRANSLATION-UNIT.TRANSLATION SELF) NULL)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF) NULL)
   (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? SELF) CL:NIL)
   (CL:SETF (%TRANSLATION-UNIT.ANNOTATION SELF) STELLA::NULL-STRING)
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF) NULL)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF) NULL)
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF) NULL)
   (CL:RETURN-FROM NEW-TRANSLATION-UNIT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSLATION-UNIT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-WALK-STELLA-TRANSLATION-UNIT))

(CL:DEFMETHOD HOME-MODULE ((SELF TRANSLATION-UNIT))
  (CL:RETURN-FROM HOME-MODULE (%TRANSLATION-UNIT.TU-HOME-MODULE SELF)))

(CL:DEFUN ACCESS-TRANSLATION-UNIT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-TU-HOME-MODULE)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.TU-HOME-MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-THE-OBJECT)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.THE-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-CATEGORY)
    (CL:IF SETVALUE? (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.CATEGORY SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-ANNOTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.ANNOTATION SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%TRANSLATION-UNIT.ANNOTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-AUXILIARY?)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%TRANSLATION-UNIT.AUXILIARY? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-CODE-REGISTER)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.CODE-REGISTER SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-TRANSLATION)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.TRANSLATION SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.TRANSLATION SELF))))
   ((CL:EQ SLOTNAME SYM-WALK-STELLA-REFERENCED-GLOBALS)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSLATION-UNIT.REFERENCED-GLOBALS SELF) VALUE)
     (CL:SETQ VALUE (%TRANSLATION-UNIT.REFERENCED-GLOBALS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TRANSLATION-UNIT-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF TRANSLATION-UNIT) STREAM)
  (PRINT-TRANSLATION-UNIT SELF STREAM)
  :VOID)

;;; (DEFUN CLEAR-TRANSLATION-UNIT ...)

(CL:DEFUN CLEAR-TRANSLATION-UNIT (SELF)
  (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF) NULL)
  (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF) NULL)
  (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF) NULL)
  (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF) NULL)
  (CL:SETF (%TRANSLATION-UNIT.TRANSLATION SELF) NULL)
  :VOID)

;;; (DEFUN PRINT-TRANSLATION-UNIT ...)

(CL:DEFUN PRINT-TRANSLATION-UNIT (SELF STREAM)
  (%%PRINT-STREAM STREAM "|TU|[" (%TRANSLATION-UNIT.CATEGORY SELF))
  (CL:LET* ((TEST-VALUE-000 (%TRANSLATION-UNIT.CATEGORY SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CLASS)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-METHOD)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GLOBAL-VARIABLE))
     (%%PRINT-STREAM STREAM " " (%TRANSLATION-UNIT.THE-OBJECT SELF)))
    (CL:T)))
  (%%PRINT-STREAM STREAM "]")
  :VOID)

;;; (DEFSPECIAL *TRANSLATIONUNITS* ...)

(CL:DEFVAR *TRANSLATIONUNITS* NULL
  "List of objects representing partially walked
top-level definitions and auxiliary code.")

;;; (DEFSPECIAL *CURRENTTRANSLATIONUNIT* ...)

(CL:DEFVAR *CURRENTTRANSLATIONUNIT* NULL
  "The translation unit currently operated on.")

;;; (DEFSPECIAL *TRANSLATIONPHASE* ...)

(CL:DEFVAR *TRANSLATIONPHASE* NULL
  "Indicates the current translation phase which is one of
:DEFINE, :FINALIZE, :WALK, or :TRANSLATE.")

;;; (DEFSPECIAL *TRANSLATIONVERBOSITYLEVEL* ...)

(CL:DEFVAR *TRANSLATIONVERBOSITYLEVEL* 1
  "The higher the level, the more progress annotations are
generated during the translation of Stella declarations.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TRANSLATIONVERBOSITYLEVEL*))

;;; (DEFSPECIAL *USEHARDCODEDSYMBOLS?* ...)

(CL:DEFVAR *USEHARDCODEDSYMBOLS?* CL:NIL)

;;; (DEFUN (USE-HARDCODED-SYMBOLS? BOOLEAN) ...)

(CL:DEFUN USE-HARDCODED-SYMBOLS? ()
  (CL:RETURN-FROM USE-HARDCODED-SYMBOLS?
   (CL:OR
    (MEMBER? *CURRENT-STELLA-FEATURES* KWD-WALK-USE-HARDCODED-SYMBOLS)
    *USEHARDCODEDSYMBOLS?*)))

;;; (DEFSPECIAL *TRANSLATOROUTPUTLANGUAGE* ...)

(CL:DEFVAR *TRANSLATOROUTPUTLANGUAGE* NULL
  "Specifies the current translator output language; either
:common-lisp, :idl, :java, :cpp, or :cpp-standalone.  The initial value
points to the native implementation language of this STELLA instance.")

;;; (DEFUN (TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN TRANSLATOR-OUTPUT-LANGUAGE ()
  (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE *TRANSLATOROUTPUTLANGUAGE*))

;;; (DEFUN (TRANSLATOR-OUTPUT-LANGUAGE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING)
  TRANSLATOR-OUTPUT-LANGUAGE-NAME))
(CL:DEFUN TRANSLATOR-OUTPUT-LANGUAGE-NAME ()
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME "Common Lisp"))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME "C++"))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME "Java"))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME "standalone-C++"))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL)
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME "IDL"))
   (CL:T
    (CL:RETURN-FROM TRANSLATOR-OUTPUT-LANGUAGE-NAME
     (%KEYWORD.SYMBOL-NAME *TRANSLATOROUTPUTLANGUAGE*)))))

;;; (DEFUN (SET-TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN %SET-TRANSLATOR-OUTPUT-LANGUAGE (NEW-LANGUAGE)
  "Set output language to `new-language'.  Return previous language."
  (CL:LET* ((OLDLANGUAGE *TRANSLATOROUTPUTLANGUAGE*))
   (CL:WHEN
    (CL:NOT
     (MEMBER?
      (LIST* KWD-WALK-CPP KWD-WALK-CPP-STANDALONE KWD-WALK-COMMON-LISP
       KWD-WALK-JAVA KWD-WALK-IDL NIL)
      NEW-LANGUAGE))
    (CL:WARN "`~A' is not a legal translation language" NEW-LANGUAGE))
   (CL:SETQ *TRANSLATOROUTPUTLANGUAGE* NEW-LANGUAGE)
   (CL:RETURN-FROM %SET-TRANSLATOR-OUTPUT-LANGUAGE OLDLANGUAGE)))

(CL:DEFMACRO SET-TRANSLATOR-OUTPUT-LANGUAGE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set output language to `new-language'.  Return previous language."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-TRANSLATOR-OUTPUT-LANGUAGE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-TRANSLATOR-OUTPUT-LANGUAGE)))

;;; (DEFUN (TRANSLATE-TO-COMMON-LISP? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-COMMON-LISP? ()
  "Return `true' if current output language is Common-Lisp."
  (CL:RETURN-FROM TRANSLATE-TO-COMMON-LISP?
   (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)))

;;; (DEFUN (TRANSLATE-TO-CPP? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-CPP? ()
  "Return `true' if current output language is C++"
  (CL:RETURN-FROM TRANSLATE-TO-CPP?
   (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)))

;;; (DEFUN (TRANSLATE-TO-JAVA? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-JAVA? ()
  "Return `true' if current output language is Java"
  (CL:RETURN-FROM TRANSLATE-TO-JAVA?
   (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)))

;;; (DEFUN (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? ()
  (CL:COND
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA))
    (CL:RETURN-FROM TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? CL:T))
   (CL:T
    (CL:RETURN-FROM TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? CL:NIL))))

;;; (DEFUN (TOGGLE-OUTPUT-LANGUAGE KEYWORD) ...)

(CL:DEFUN TOGGLE-OUTPUT-LANGUAGE ()
  "Switch between Common Lisp and C++ as output languages."
  (CL:COND
   ((TRANSLATE-TO-COMMON-LISP?)
    (CL:SETQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
    (CL:RETURN-FROM TOGGLE-OUTPUT-LANGUAGE KWD-WALK-CPP))
   ((TRANSLATE-TO-CPP?)
    (CL:SETQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
    (CL:RETURN-FROM TOGGLE-OUTPUT-LANGUAGE KWD-WALK-JAVA))
   (CL:T (CL:SETQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM TOGGLE-OUTPUT-LANGUAGE KWD-WALK-COMMON-LISP))))

;;; (DEFUN (USE-BOOTSTRAP-TRANSLATOR? BOOLEAN) ...)

(CL:DEFUN USE-BOOTSTRAP-TRANSLATOR? ()
  (CL:RETURN-FROM USE-BOOTSTRAP-TRANSLATOR? CL:NIL))

;;; (DEFUN (TOGGLE-TRANSLATORS KEYWORD) ...)

(CL:DEFUN TOGGLE-TRANSLATORS ()
  (CL:RETURN-FROM TOGGLE-TRANSLATORS NULL))

;;; (DEFUN (DECLARATION-OPERATOR? BOOLEAN) ...)

(CL:DEFUN DECLARATION-OPERATOR? (OPERATOR)
  (CL:RETURN-FROM DECLARATION-OPERATOR?
   (MEMBER?
    (GET-QUOTED-TREE
     "((DEFCLASS DEFSLOT DEFMETHOD DEFUN DEFTYPE DEFGLOBAL DEFSPECIAL DEFCONSTANT DEFMACRO DEFMODULE STARTUP-TIME-PROGN) \"/STELLA\")"
     "/STELLA")
    OPERATOR)))

;;; (DEFUN (DECLARATION-TREE? BOOLEAN) ...)

(CL:DEFUN DECLARATION-TREE? (TREE)
  (CL:LET* ((OPERATOR (%%VALUE TREE)))
   (CL:WHEN (DECLARATION-OPERATOR? OPERATOR)
    (CL:RETURN-FROM DECLARATION-TREE? CL:T))
   (CL:WHEN (CL:EQ OPERATOR SYM-WALK-STELLA-PROGN)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET* ((SUBTREE NULL) (ITER-000 (%%REST TREE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUBTREE (%%VALUE ITER-000))
       (CL:WHEN (CL:AND (CONS? SUBTREE) (DECLARATION-TREE? SUBTREE))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET* ((VALUE-000 FOUND?-000))
      (CL:RETURN-FROM DECLARATION-TREE? VALUE-000))))
   (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-MACRO OPERATOR) NULL))
    (CL:LET* ((EXPANSION (EXPAND-MACRO (COPY-CONS-LIST TREE))))
     (CL:COND
      ((CL:NOT (CL:EQ EXPANSION NULL))
       (CL:COND
        ((CL:EQ (SAFE-PRIMARY-TYPE EXPANSION) SGT-WALK-STELLA-CONS)
         (CL:PROGN (CL:SETF (%%VALUE TREE) (%%VALUE EXPANSION))
          (CL:SETF (%%REST TREE) (%%REST EXPANSION))
          (CL:RETURN-FROM DECLARATION-TREE? (DECLARATION-TREE? TREE))))
        (CL:T (CL:RETURN-FROM DECLARATION-TREE? CL:NIL))))
      (CL:T (CL:SETF (%%VALUE TREE) SYM-WALK-STELLA-PROGN)
       (CL:SETF (%%REST TREE) NIL)
       (CL:RETURN-FROM DECLARATION-TREE? CL:NIL)))))
   (CL:RETURN-FROM DECLARATION-TREE? CL:NIL)))

;;; (DEFUN (CREATE-ANNOTATION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) CREATE-ANNOTATION))
(CL:DEFUN CREATE-ANNOTATION (TOP-LEVEL-TREE)
  (CL:RETURN-FROM CREATE-ANNOTATION
   (CONCATENATE "("
    (CONCATENATE (%SYMBOL.SYMBOL-NAME (%%VALUE TOP-LEVEL-TREE))
     (CONCATENATE " "
      (CONCATENATE (STRINGIFY (%%VALUE (%%REST TOP-LEVEL-TREE)))
       " ...)"))))))

;;; (DEFUN WALK-TOP-LEVEL-TREE ...)

(CL:DEFUN WALK-TOP-LEVEL-TREE (TREE CREATEANNOTATION?)
  (CL:LET* ((*CURRENTTRANSLATIONUNIT* NULL))
   (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
   (CL:LET* ((ANNOTATION STELLA::NULL-STRING))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ANNOTATION))
    (CL:WHEN CREATEANNOTATION?
     (CL:SETQ ANNOTATION (CREATE-ANNOTATION TREE))
     (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Defining `" ANNOTATION "'" EOL)))
    (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFCLASS)
       (WALK-DEFCLASS-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFSLOT)
       (WALK-DEFSLOT-TREE TREE))
      ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFMETHOD)
        (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFUN)
        (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFOPERATOR))
       (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-DEFOPERATOR)
        (FIRST-SETTER TREE SYM-WALK-STELLA-DEFMETHOD))
       (WALK-DEFMETHOD-TREE TREE))
      ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFGLOBAL)
        (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFSPECIAL)
        (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFCONSTANT))
       (WALK-DEFGLOBAL-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFTYPE)
       (WALK-DEFTYPE-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFMODULE)
       (WALK-DEFMODULE-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFMACRO)
       (WALK-DEFMACRO-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-STARTUP-TIME-PROGN)
       (WALK-STARTUP-TIME-PROGN-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VERBATIM)
       (WALK-VERBATIM-DEFINITION-TREE TREE))
      ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PROGN)
       (CL:LET* ((FORM NULL) (ITER-000 (%%REST TREE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ FORM (%%VALUE ITER-000))
         (WALK-TOP-LEVEL-TREE FORM CREATEANNOTATION?)
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:RETURN-FROM WALK-TOP-LEVEL-TREE))
      (CL:T
       (CL:COND
        ((CL:NOT (CL:EQ (LOOKUP-MACRO (%%VALUE TREE)) NULL))
         (CL:LET* ((EXPANSION (EXPAND-MACRO TREE)))
          (CL:WHEN (CL:NOT (CL:EQ EXPANSION NULL))
           (WALK-TOP-LEVEL-TREE EXPANSION CREATEANNOTATION?))))
        (CL:T
         (CL:WHEN
          (CL:NOT
           (CL:OR (INCREMENTAL-TRANSLATION?)
            (CL:NOT (CL:EQ (LOOKUP-COMMAND (%%VALUE TREE)) NULL))))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-WARNING)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
             " Illegal top-level statement:" EOL "   `"
             (DE-UGLIFY-PARSE-TREE TREE) "'" EOL
             " Wrapping it into a 'startup-time-progn'." EOL))))
         (CL:SETQ TREE
          (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN TREE NIL))
         (WALK-TOP-LEVEL-TREE TREE CL:NIL)))
       (CL:RETURN-FROM WALK-TOP-LEVEL-TREE))))
    (CL:WHEN (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
     (PUSH *TRANSLATIONUNITS* *CURRENTTRANSLATIONUNIT*)
     (CL:SETF (%TRANSLATION-UNIT.ANNOTATION *CURRENTTRANSLATIONUNIT*)
      ANNOTATION))))
  :VOID)

;;; (DEFUN (WALK-TOP-LEVEL-EXPRESSION OBJECT) ...)

(CL:DEFUN WALK-TOP-LEVEL-EXPRESSION (TREE)
  (CL:LET* ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST)))
   (CL:DECLARE (CL:SPECIAL *LOCALVARIABLETYPETABLE*))
   (CL:LET* ((OTREE (WALK-WITHOUT-TYPE-TREE TREE)))
    (CL:WHEN (VRLET-EXPRESSION? OTREE)
     (CL:RETURN-FROM WALK-TOP-LEVEL-EXPRESSION
      (WALK-WITHOUT-TYPE-TREE
       (LIST* SYM-WALK-STELLA-PROGN OTREE NIL))))
    (CL:RETURN-FROM WALK-TOP-LEVEL-EXPRESSION OTREE))))

;;; (DEFUN WALK-PHASE-ONE-UNIT ...)

(CL:DEFUN WALK-PHASE-ONE-UNIT (UNIT)
  (CL:LET*
   ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST))
    (*CURRENTTRANSLATIONUNIT* UNIT))
   (CL:DECLARE
    (CL:SPECIAL *LOCALVARIABLETYPETABLE* *CURRENTTRANSLATIONUNIT*))
   (CL:LET* ((TEST-VALUE-000 (%TRANSLATION-UNIT.CATEGORY UNIT)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GLOBAL-VARIABLE)
      (WALK-GLOBAL-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-MODULE)
      (WALK-MODULE-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPE)
      (WALK-TYPE-UNIT UNIT))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-METHOD)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PRINT-METHOD))
      (WALK-METHOD-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CLASS)
      (WALK-CLASS-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SLOT)
      (WALK-SLOT-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-STARTUP-TIME-PROGN)
      (WALK-STARTUP-TIME-PROGN-UNIT UNIT))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VERBATIM)
      (WALK-VERBATIM-UNIT UNIT))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
  :VOID)

;;; (DEFUN WALK-AUXILIARY-TREE ...)

(CL:DEFUN WALK-AUXILIARY-TREE (TREE)
  (HELP-WALK-AUXILIARY-TREE TREE CL:T)
  :VOID)

;;; (DEFUN (HELP-WALK-AUXILIARY-TREE TRANSLATION-UNIT) ...)

(CL:DEFUN HELP-WALK-AUXILIARY-TREE (TREE FINALIZE?)
  (CL:WHEN
   (CL:NOT
    (MEMBER?
     (GET-QUOTED-TREE
      "((DEFCLASS DEFMETHOD DEFUN DEFMACRO DEFGLOBAL DEFSPECIAL DEFCONSTANT STARTUP-TIME-PROGN VERBATIM) \"/STELLA\")"
      "/STELLA")
     (%%VALUE TREE)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "OOPS, illegal auxiliary statement:" EOL "   `" TREE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (WALK-TOP-LEVEL-TREE TREE CL:NIL)
  (CL:WHEN FINALIZE? (FINALIZE-CLASSES-AND-SLOTS))
  (CL:LET* ((UNIT (POP *TRANSLATIONUNITS*)))
   (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? UNIT) CL:T)
   (WALK-PHASE-ONE-UNIT UNIT)
   (CL:RETURN-FROM HELP-WALK-AUXILIARY-TREE UNIT)))

;;; (DEFUN WALK-ALL-PHASE-ONE-UNITS ...)

(CL:DEFUN WALK-ALL-PHASE-ONE-UNITS ()
  (CL:LET* ((PHASEONEUNITS *TRANSLATIONUNITS*))
   (CL:SETQ *TRANSLATIONUNITS* (NEW-LIST))
   (CL:LET*
    ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST PHASEONEUNITS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ UNIT (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
       (CL:NOT
        (CL:EQ (%TRANSLATION-UNIT.ANNOTATION UNIT)
         STELLA::NULL-STRING)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Walking `" (%TRANSLATION-UNIT.ANNOTATION UNIT) "'" EOL))
     (WALK-PHASE-ONE-UNIT UNIT) (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CREATE-FINALIZATION-UNITS) (CREATE-STARTUP-FUNCTION-UNITS)
   (CLEAR PHASEONEUNITS) (REVERSE *TRANSLATIONUNITS*))
  :VOID)

;;; (DEFUN TRANSLATE-ALL-UNITS ...)

(CL:DEFUN TRANSLATE-ALL-UNITS ()
  (CL:LET*
   ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ UNIT (%%VALUE ITER-000))
    (CL:LET* ((*CURRENTTRANSLATIONUNIT* UNIT))
     (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
     (CL:WHEN
      (CL:AND (CL:>= *TRANSLATIONVERBOSITYLEVEL* 2)
       (CL:NOT
        (CL:EQ (%TRANSLATION-UNIT.ANNOTATION UNIT)
         STELLA::NULL-STRING)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Translating `" (%TRANSLATION-UNIT.ANNOTATION UNIT) "'" EOL))
     (CL:COND
      ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
       (CL:SETF (%TRANSLATION-UNIT.TRANSLATION UNIT)
        (CL-TRANSLATE-UNIT UNIT)))
      ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL)
       (CL:SETF (%TRANSLATION-UNIT.TRANSLATION UNIT)
        (IDL-TRANSLATE-UNIT UNIT)))
      ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
        (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA-STANDALONE))
       (CL:WHEN (CL:EQ (%TRANSLATION-UNIT.TRANSLATION UNIT) NULL)
        (CL:SETF (%TRANSLATION-UNIT.TRANSLATION UNIT)
         (JAVA-TRANSLATE-UNIT UNIT))))
      ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
        (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE))
       (CL:SETF (%TRANSLATION-UNIT.TRANSLATION UNIT)
        (CPP-TRANSLATE-UNIT UNIT)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN (UNIT-INCLUDED-IN-OTHER-UNITS? BOOLEAN) ...)

(CL:DEFUN UNIT-INCLUDED-IN-OTHER-UNITS? (UNIT)
  (CL:LET* ((METHOD NULL))
   (CL:IF
    (CL:NOT
     (CL:EQ (%TRANSLATION-UNIT.CATEGORY UNIT) SYM-WALK-STELLA-METHOD))
    (CL:RETURN-FROM UNIT-INCLUDED-IN-OTHER-UNITS? CL:NIL)
    (CL:PROGN (CL:SETQ METHOD (%TRANSLATION-UNIT.THE-OBJECT UNIT))
     (CL:COND
      ((%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-METHOD-CONSTRUCTOR? FALSE-WRAPPER))
       (CL:LET*
        ((OTHER-UNIT NULL)
         (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ OTHER-UNIT (%%VALUE ITER-000))
         (CL:WHEN
          (CL:AND
           (CL:EQ (%TRANSLATION-UNIT.CATEGORY OTHER-UNIT)
            SYM-WALK-STELLA-CLASS)
           (CL:EQ (CANONICAL-TYPE (%METHOD-SLOT.SLOT-BASE-TYPE METHOD))
            (%CLASS.CLASS-TYPE
             (%TRANSLATION-UNIT.THE-OBJECT OTHER-UNIT))))
          (CL:RETURN-FROM UNIT-INCLUDED-IN-OTHER-UNITS? CL:T))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:RETURN-FROM UNIT-INCLUDED-IN-OTHER-UNITS? CL:NIL))
      (CL:T
       (CL:LET*
        ((OTHER-UNIT NULL)
         (ITER-001 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ OTHER-UNIT (%%VALUE ITER-001))
         (CL:WHEN
          (CL:AND
           (CL:EQ (%TRANSLATION-UNIT.CATEGORY OTHER-UNIT)
            SYM-WALK-STELLA-CLASS)
           (CL:EQ (CANONICAL-TYPE (%METHOD-SLOT.SLOT-OWNER METHOD))
            (%CLASS.CLASS-TYPE
             (%TRANSLATION-UNIT.THE-OBJECT OTHER-UNIT))))
          (CL:RETURN-FROM UNIT-INCLUDED-IN-OTHER-UNITS? CL:T))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:RETURN-FROM UNIT-INCLUDED-IN-OTHER-UNITS? CL:NIL)))))))

;;; (DEFUN (COMBINE-TRANSLATED-TREES CONS) ...)

(CL:DEFUN COMBINE-TRANSLATED-TREES ()
  (CL:LET* ((OTREE NIL))
   (CL:COND
    ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL))
     (CL:LET*
      ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ UNIT (%%VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS (%TRANSLATION-UNIT.TRANSLATION UNIT) NIL))
         (CL:IF (CL:EQ OTREE NIL) (CL:SETQ OTREE COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST OTREE COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS (%TRANSLATION-UNIT.TRANSLATION UNIT) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA-STANDALONE))
     (CL:LET*
      ((UNIT NULL) (ITER-001 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*))
       (COLLECT-001 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ UNIT (%%VALUE ITER-001))
       (CL:WHEN (CL:NOT (UNIT-INCLUDED-IN-OTHER-UNITS? UNIT))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001
           (CONS (%TRANSLATION-UNIT.TRANSLATION UNIT) NIL))
          (CL:IF (CL:EQ OTREE NIL) (CL:SETQ OTREE COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST OTREE COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS (%TRANSLATION-UNIT.TRANSLATION UNIT) NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
       (CL:SETQ ITER-001 (%%REST ITER-001)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
     (CL:SETQ OTREE
      (CONS (INTERN-COMMON-LISP-SYMBOL "PROGN")
       (CONCATENATE OTREE NIL))))
    ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL)))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
   (CL:RETURN-FROM COMBINE-TRANSLATED-TREES OTREE)))

;;; (DEFUN (TRANSLATE-WALKED-TREE OBJECT) ...)

(CL:DEFUN TRANSLATE-WALKED-TREE (CODETREE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM TRANSLATE-WALKED-TREE
     (CL-TRANSLATE-A-TREE CODETREE)))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL)
    (CL:RETURN-FROM TRANSLATE-WALKED-TREE
     (IDL-TRANSLATE-A-TREE CODETREE)))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
    (CL:RETURN-FROM TRANSLATE-WALKED-TREE
     (JAVA-TRANSLATE-A-TREE CODETREE)))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE))
    (CL:RETURN-FROM TRANSLATE-WALKED-TREE
     (CPP-TRANSLATE-A-TREE CODETREE)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (INCREMENTALLY-TRANSLATE OBJECT) ...)

(CL:DEFUN INCREMENTALLY-TRANSLATE (TREE)
  "Translate a single Stella expression `tree' and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead."
  (CL:LET*
   ((TOPLEVELINVOCATION? (CL:EQ *TRANSLATIONUNITS* NULL)) (OCODE NULL)
    (DECLARATION? (CL:AND (CONS? TREE) (DECLARATION-TREE? TREE))))
   (CL:LET*
    ((*TRANSLATIONUNITS* (NEW-LIST)) (*TRANSLATIONVERBOSITYLEVEL* 0)
     (*TRANSLATIONPHASE* NULL) (*TRANSLATIONERRORS* 0)
     (*TRANSLATIONWARNINGS* 0) (*TRANSLATIONNOTES* 0))
    (CL:DECLARE
     (CL:SPECIAL *TRANSLATIONUNITS* *TRANSLATIONVERBOSITYLEVEL*
      *TRANSLATIONPHASE* *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
      *TRANSLATIONNOTES*))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM *TRANSLATIONVERBOSITYLEVEL* *TRANSLATIONERRORS*
      *TRANSLATIONWARNINGS* *TRANSLATIONNOTES*))
    (CL:COND
     (DECLARATION? (CL:SETQ *TRANSLATIONPHASE* KWD-WALK-DEFINE)
      (WALK-TOP-LEVEL-TREE TREE CL:NIL)
      (CL:WHEN (TRANSLATION-ERRORS?) (SUMMARIZE-TRANSLATION-ERRORS)
       (CL:RETURN-FROM INCREMENTALLY-TRANSLATE NIL))
      (REVERSE *TRANSLATIONUNITS*)
      (CL:SETQ *TRANSLATIONPHASE* KWD-WALK-FINALIZE)
      (FINALIZE-CLASSES-AND-SLOTS)
      (CL:SETQ *TRANSLATIONPHASE* KWD-WALK-WALK)
      (CL:WHEN (CL:NOT (USE-HARDCODED-SYMBOLS?))
       (CLEAR-SYMBOL-REGISTRY))
      (WALK-ALL-PHASE-ONE-UNITS))
     (CL:T (CL:SETQ *TRANSLATIONPHASE* KWD-WALK-WALK)
      (CL:LET* ((*USEHARDCODEDSYMBOLS?* CL:T))
       (CL:DECLARE (CL:SPECIAL *USEHARDCODEDSYMBOLS?*))
       (CL:SETQ OCODE (WALK-TOP-LEVEL-EXPRESSION TREE)))))
    (CL:WHEN (TRANSLATION-ERRORS?) (SUMMARIZE-TRANSLATION-ERRORS)
     (CL:RETURN-FROM INCREMENTALLY-TRANSLATE NIL))
    (CL:SETQ *TRANSLATIONPHASE* KWD-WALK-TRANSLATE)
    (CL:COND
     (DECLARATION? (TRANSLATE-ALL-UNITS)
      (CL:SETQ OCODE (COMBINE-TRANSLATED-TREES)))
     (CL:T
      (CL:LET* ((*USEHARDCODEDSYMBOLS?* CL:T))
       (CL:DECLARE (CL:SPECIAL *USEHARDCODEDSYMBOLS?*))
       (CL:SETQ OCODE (TRANSLATE-WALKED-TREE OCODE)))))
    (CL:WHEN (TRANSLATION-ERRORS?) (SUMMARIZE-TRANSLATION-ERRORS)
     (CL:RETURN-FROM INCREMENTALLY-TRANSLATE NIL))
    (CL:COND ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL)
      (IDL-OUTPUT-PARSE-TREE OCODE) (CL:SETQ OCODE NIL))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (JAVA-OUTPUT-PARSE-TREE OCODE) (CL:SETQ OCODE NIL))
     ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
       (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE))
      (CPP-OUTPUT-PARSE-TREE OCODE) (CL:SETQ OCODE NIL))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:LET*
     ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ UNIT (%%VALUE ITER-000)) (FREE UNIT)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CLEAR *TRANSLATIONUNITS*)
    (CL:WHEN TOPLEVELINVOCATION? (SWEEP-TRANSIENTS))
    (SUMMARIZE-TRANSLATION-ERRORS)
    (CL:RETURN-FROM INCREMENTALLY-TRANSLATE OCODE))))

;;; (DEFSPECIAL *LOCALVARIABLETYPETABLE* ...)

(CL:DEFVAR *LOCALVARIABLETYPETABLE* NULL
  "Table mapping local variable names their declared types
(declared explicitly or implicitly).")

;;; (DEFSPECIAL *METHODBEINGWALKED* ...)

(CL:DEFVAR *METHODBEINGWALKED* NULL
  "Contains the method or function being walked, or else `null'.")

;;; (DEFSPECIAL *FOUNDRETURN?* ...)

(CL:DEFVAR *FOUNDRETURN?* CL:NIL
  "Indicates that one or more return statements have been found
during the walk of the current method.")

;;; (DEFSPECIAL *TARGETTYPE* ...)

(CL:DEFVAR *TARGETTYPE* NULL
  "Bound to the target type for an expression currently walked.
Used instead of an extra argument to `walk-a-tree', since only a few types
of expressions need to know about their expected type (e.g., FUNCALL).")

;;; (DEFSPECIAL *LOCALGENSYMTABLE* ...)

(CL:DEFVAR *LOCALGENSYMTABLE* NULL
  "Table that maps each prefix of a function-local gensym
to its own gensym counter and/or to related gensyms.")

;;; (DEFSPECIAL *TRANSLATIONERRORS* ...)

(CL:DEFVAR *TRANSLATIONERRORS* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS*))

;;; (DEFSPECIAL *TRANSLATIONWARNINGS* ...)

(CL:DEFVAR *TRANSLATIONWARNINGS* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TRANSLATIONWARNINGS*))

;;; (DEFSPECIAL *TRANSLATIONNOTES* ...)

(CL:DEFVAR *TRANSLATIONNOTES* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TRANSLATIONNOTES*))

;;; (DEFUN RESET-TRANSLATION-ERRORS ...)

(CL:DEFUN RESET-TRANSLATION-ERRORS ()
  (CL:SETQ *TRANSLATIONERRORS* 0)
  (CL:SETQ *TRANSLATIONWARNINGS* 0)
  (CL:SETQ *TRANSLATIONNOTES* 0)
  :VOID)

;;; (DEFUN SIGNAL-TRANSLATION-ERROR ...)

(CL:DEFUN SIGNAL-TRANSLATION-ERROR ()
  (CL:SETQ *TRANSLATIONERRORS* (CL:1+ *TRANSLATIONERRORS*))
  :VOID)

;;; (DEFUN SIGNAL-TRANSLATION-WARNING ...)

(CL:DEFUN SIGNAL-TRANSLATION-WARNING ()
  (CL:SETQ *TRANSLATIONWARNINGS* (CL:1+ *TRANSLATIONWARNINGS*))
  :VOID)

;;; (DEFUN SIGNAL-TRANSLATION-NOTE ...)

(CL:DEFUN SIGNAL-TRANSLATION-NOTE ()
  (CL:SETQ *TRANSLATIONNOTES* (CL:1+ *TRANSLATIONNOTES*))
  :VOID)

;;; (DEFUN (IGNORE-TRANSLATION-ERRORS? BOOLEAN) ...)

(CL:DEFUN IGNORE-TRANSLATION-ERRORS? ()
  (CL:RETURN-FROM IGNORE-TRANSLATION-ERRORS? *IGNORETRANSLATIONERRORS?*))

;;; (DEFUN (TRANSLATION-ERRORS? BOOLEAN) ...)

(CL:DEFUN TRANSLATION-ERRORS? ()
  (CL:RETURN-FROM TRANSLATION-ERRORS?
   (CL:AND (CL:> *TRANSLATIONERRORS* 0)
    (CL:NOT (IGNORE-TRANSLATION-ERRORS?)))))

;;; (DEFUN SUMMARIZE-TRANSLATION-ERRORS ...)

(CL:DEFUN SUMMARIZE-TRANSLATION-ERRORS ()
  (CL:WHEN (CL:> *TRANSLATIONERRORS* 0)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    *TRANSLATIONERRORS* " error")
   (CL:WHEN (CL:> *TRANSLATIONERRORS* 1)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "s")))
  (CL:WHEN (CL:> *TRANSLATIONWARNINGS* 0)
   (CL:WHEN (CL:> *TRANSLATIONERRORS* 0)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     ", "))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    *TRANSLATIONWARNINGS* " warning")
   (CL:WHEN (CL:> *TRANSLATIONWARNINGS* 1)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "s")))
  (CL:WHEN (CL:> *TRANSLATIONNOTES* 0)
   (CL:WHEN
    (CL:OR (CL:> *TRANSLATIONERRORS* 0) (CL:> *TRANSLATIONWARNINGS* 0))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     ", "))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    *TRANSLATIONNOTES* " note")
   (CL:WHEN (CL:> *TRANSLATIONNOTES* 1)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "s")))
  (CL:WHEN
   (CL:OR (CL:> *TRANSLATIONERRORS* 0) (CL:> *TRANSLATIONWARNINGS* 0)
    (CL:> *TRANSLATIONNOTES* 0))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "."
    EOL))
  :VOID)

;;; (DEFUN PRINT-ERROR-CONTEXT ...)

(CL:DEFUN PRINT-ERROR-CONTEXT (PREFIX STREAM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) PREFIX "While ")
  (CL:COND
   ((CL:NOT (CL:EQ *TRANSLATIONPHASE* NULL))
    (CL:COND
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-DEFINE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "defining "))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-FINALIZE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "finalizing "))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-WALK)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "walking "))
     ((CL:EQ *TRANSLATIONPHASE* KWD-WALK-TRANSLATE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       "translating "))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" *TRANSLATIONPHASE* "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "processing ")))
  (CL:COND
   ((CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
    (CL:LET*
     ((OBJECT (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*))
      (CATEGORY (%TRANSLATION-UNIT.CATEGORY *CURRENTTRANSLATIONUNIT*)))
     (CL:COND
      ((CL:EQ CATEGORY SYM-WALK-STELLA-CLASS)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "class ")
       (CL:COND
        ((SUBTYPE-OF-CLASS? (SAFE-PRIMARY-TYPE OBJECT))
         (CL:PROGN
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
           (NAME OBJECT))))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          OBJECT))))
      ((CL:EQ CATEGORY SYM-WALK-STELLA-SLOT)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        "external slot ")
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJECT)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%%VALUE (%%REST OBJECT)) "."
            (%%VALUE (%%REST (%%REST OBJECT))))))
         ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%STORAGE-SLOT.SLOT-OWNER OBJECT) "."
            (%SYMBOL.SYMBOL-NAME (%STORAGE-SLOT.SLOT-NAME OBJECT)))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
      ((CL:OR (CL:EQ CATEGORY SYM-WALK-STELLA-METHOD)
        (CL:EQ CATEGORY SYM-WALK-STELLA-PRINT-METHOD))
       (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE OBJECT)))
        (CL:COND
         ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-002)
          (CL:PROGN
           (CL:COND
            ((%BOOLEAN-WRAPPER.WRAPPER-VALUE
              (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS OBJECT)
               SYM-WALK-STELLA-METHOD-MACRO? FALSE-WRAPPER))
             (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
              "macro " (%METHOD-SLOT.SLOT-NAME OBJECT)))
            ((%METHOD-SLOT.METHOD-FUNCTION? OBJECT)
             (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
              "function " (%METHOD-SLOT.SLOT-NAME OBJECT)))
            (CL:T
             (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
              "method " (%METHOD-SLOT.SLOT-OWNER OBJECT) "."
              (%SYMBOL.SYMBOL-NAME
               (%METHOD-SLOT.SLOT-NAME OBJECT)))))))
         ((CL:EQ TEST-VALUE-002 SGT-WALK-STELLA-CONS)
          (CL:PROGN
           (CL:LET* ((TEST-VALUE-001 (%%VALUE OBJECT)))
            (CL:COND
             ((CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-DEFMETHOD)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
               "method "))
             ((CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-DEFUN)
              (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
               "function "))
             (CL:T)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (CL:IF (CONS? (%%VALUE (%%REST OBJECT)))
             (%%VALUE (%%VALUE (%%REST OBJECT)))
             (%%VALUE (%%REST OBJECT))))))
         (CL:T
          (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "`"
            TEST-VALUE-002 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))
      ((CL:EQ CATEGORY SYM-WALK-STELLA-GLOBAL-VARIABLE)
       (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE OBJECT)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-003 SGT-WALK-STELLA-GLOBAL-VARIABLE)
          (CL:PROGN
           (CL:IF (%GLOBAL-VARIABLE.VARIABLE-CONSTANT? OBJECT)
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
             "constant ")
            (CL:IF (%GLOBAL-VARIABLE.VARIABLE-SPECIAL? OBJECT)
             (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
              "special variable ")
             (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
              "global variable ")))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%GLOBAL-VARIABLE.VARIABLE-NAME OBJECT))))
         ((CL:EQ TEST-VALUE-003 SGT-WALK-STELLA-CONS)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%%VALUE OBJECT) " " (%%VALUE (%%REST OBJECT)))))
         (CL:T
          (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003) "`"
            TEST-VALUE-003 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-003))))))))
      ((CL:EQ CATEGORY SYM-WALK-STELLA-TYPE)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "type ")
       (CL:LET* ((TEST-VALUE-004 (SAFE-PRIMARY-TYPE OBJECT)))
        (CL:COND
         ((CL:EQ TEST-VALUE-004 SGT-WALK-STELLA-CONS)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%%VALUE (%%REST OBJECT)))))
         ((SUBTYPE-OF? TEST-VALUE-004 SGT-WALK-STELLA-TYPE-SPEC)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (YIELD-TYPE-SPEC-TREE OBJECT))))
         (CL:T
          (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004) "`"
            TEST-VALUE-004 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-004))))))))
      ((CL:EQ CATEGORY SYM-WALK-STELLA-MODULE)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "module ")
       (CL:LET* ((TEST-VALUE-005 (SAFE-PRIMARY-TYPE OBJECT)))
        (CL:COND
         ((SUBTYPE-OF? TEST-VALUE-005 SGT-WALK-STELLA-MODULE)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%MODULE.MODULE-NAME OBJECT))))
         ((CL:EQ TEST-VALUE-005 SGT-WALK-STELLA-CONS)
          (CL:PROGN
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
            (%%VALUE (%%REST OBJECT)))))
         (CL:T
          (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005) "`"
            TEST-VALUE-005 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-005))))))))
      (CL:T
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        CATEGORY)))))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
     "top-level statement")))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ":")
  :VOID)

;;; (DEFGLOBAL *FUNCTION-CALL-LOG-STREAM* ...)

(CL:DEFVAR *FUNCTION-CALL-LOG-STREAM* NULL
  "The current log file to which function calls should be logged.
A non-NULL value indicates that function call logging is enabled.")

;;; (DEFGLOBAL *LOG-FUNCTION-CALLS?* ...)

(CL:DEFVAR *LOG-FUNCTION-CALLS?* CL:NIL
  "Translation switch which indicates that methods should
be instrumented to log their calls to a file.")

;;; (DEFUN (LOG-FUNCTION-CALL? BOOLEAN) ...)

(CL:DEFUN LOG-FUNCTION-CALL? (METHOD)
  (CL:WHEN
   (CL:AND *LOG-FUNCTION-CALLS?*
    (CL:NOT
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER)))
    (CL:NOT
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-GLOBALLY-INLINE? FALSE-WRAPPER))))
   (CL:LET* ((TEST-VALUE-000 (%METHOD-SLOT.SLOT-NAME METHOD)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-LOG-FUNCTION-CALL)
       (CL:EQ TEST-VALUE-000
        SYM-WALK-STELLA-START-FUNCTION-CALL-LOGGING)
       (CL:EQ TEST-VALUE-000
        SYM-WALK-STELLA-STOP-FUNCTION-CALL-LOGGING)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SET-CALL-LOG-BREAK-POINT)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-BREAK-PROGRAM)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TERMINATE-PROGRAM)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PO)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFINED?)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NULL?)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQ?)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQL?)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<=)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->=)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CAST))
      (CL:RETURN-FROM LOG-FUNCTION-CALL? CL:NIL))
     (CL:T
      (CL:LET* ((TEST-VALUE-001 CL:NIL))
       (CL:IF
        (MEMBER? (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
         SGT-WALK-STELLA-UNKNOWN)
        (CL:SETQ TEST-VALUE-001 CL:T)
        (CL:IF
         (MEMBER? (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
          SGT-WALK-STELLA-LISP-CODE)
         (CL:SETQ TEST-VALUE-001 CL:T)
         (CL:IF
          (MEMBER? (METHOD-RETURN-TYPE-SPECIFIERS METHOD)
           SGT-WALK-STELLA-UNKNOWN)
          (CL:SETQ TEST-VALUE-001 CL:T)
          (CL:IF
           (MEMBER? (METHOD-RETURN-TYPE-SPECIFIERS METHOD)
            SGT-WALK-STELLA-LISP-CODE)
           (CL:SETQ TEST-VALUE-001 CL:T)
           (CL:PROGN
            (CL:LET* ((FOUND?-000 CL:NIL))
             (CL:LET*
              ((TSPEC NULL)
               (ITER-000
                (%LIST.THE-CONS-LIST
                 (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
               (CL:SETQ TSPEC (%%VALUE ITER-000))
               (CL:WHEN
                (SUB-TYPE-SPEC-OF? TSPEC SGT-WALK-STELLA-OUTPUT-STREAM)
                (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
               (CL:SETQ ITER-000 (%%REST ITER-000))))
             (CL:SETQ TEST-VALUE-001 FOUND?-000))
            (CL:WHEN (CL:NOT TEST-VALUE-001)
             (CL:LET* ((FOUND?-001 CL:NIL))
              (CL:LET*
               ((TSPEC NULL)
                (ITER-001
                 (%LIST.THE-CONS-LIST
                  (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
               (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
                (CL:SETQ TSPEC (%%VALUE ITER-001))
                (CL:WHEN
                 (SUB-TYPE-SPEC-OF? TSPEC
                  SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM)
                 (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
                (CL:SETQ ITER-001 (%%REST ITER-001))))
              (CL:SETQ TEST-VALUE-001 FOUND?-001))
             (CL:WHEN (CL:NOT TEST-VALUE-001)
              (CL:SETQ TEST-VALUE-001
               (CL:AND
                (CL:NOT (CL:EQ *CURRENTFILENAME* STELLA::NULL-STRING))
                (CL:OR
                 (CL:NOT
                  (CL:= (STRING-SEARCH *CURRENTFILENAME* "cl-primal" 0)
                   NULL-INTEGER))
                 (CL:NOT
                  (CL:=
                   (STRING-SEARCH *CURRENTFILENAME* "stella-to-cl" 0)
                   NULL-INTEGER))))))))))))
       (CL:WHEN TEST-VALUE-001
        (CL:RETURN-FROM LOG-FUNCTION-CALL? CL:NIL))))))
   (CL:RETURN-FROM LOG-FUNCTION-CALL? CL:T))
  (CL:RETURN-FROM LOG-FUNCTION-CALL? CL:NIL))

;;; (DEFUN (WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE CONS) ...)

(CL:DEFUN WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE (METHOD BODY)
  (CL:IF
   (CL:AND (CONS? (%%VALUE BODY))
    (CL:NOT (CL:EQ (%%VALUE (%%VALUE BODY)) SYM-WALK-STELLA-INLINE)))
   (CL:RETURN-FROM WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE
    (CONS
     (LIST* SYM-WALK-STELLA-LOG-FUNCTION-CALL
      (WRAP-STRING (STRINGIFY METHOD)) NIL)
     (CONCATENATE BODY NIL)))
   (CL:RETURN-FROM WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE BODY)))

;;; (DEFGLOBAL *LOG-BREAK-POINT-COUNTER* ...)

(CL:DEFVAR *LOG-BREAK-POINT-COUNTER* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *LOG-BREAK-POINT-COUNTER*))

;;; (DEFUN LOG-FUNCTION-CALL ...)

(CL:DEFUN LOG-FUNCTION-CALL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (CL:EQ *FUNCTION-CALL-LOG-STREAM* NULL))
   (%%PRINT-STREAM
    (%OUTPUT-STREAM.NATIVE-STREAM *FUNCTION-CALL-LOG-STREAM*) NAME EOL))
  (CL:WHEN (CL:NOT (CL:= *LOG-BREAK-POINT-COUNTER* NULL-INTEGER))
   (CL:SETQ *LOG-BREAK-POINT-COUNTER*
    (CL:1- *LOG-BREAK-POINT-COUNTER*))
   (CL:WHEN (CL:= *LOG-BREAK-POINT-COUNTER* 0)
    (CL:SETQ *LOG-BREAK-POINT-COUNTER* NULL-INTEGER)
    (%BREAK-PROGRAM "Call log break point")))
  :VOID)

;;; (DEFUN START-FUNCTION-CALL-LOGGING ...)

(CL:DEFUN %START-FUNCTION-CALL-LOGGING (FILENAME)
  "Start function call logging to `fileName'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((CURRENTLOGSTREAM *FUNCTION-CALL-LOG-STREAM*))
   (CL:SETQ *FUNCTION-CALL-LOG-STREAM* NULL)
   (CL:WHEN (CL:NOT (CL:EQ CURRENTLOGSTREAM NULL))
    (FREE CURRENTLOGSTREAM))
   (CL:SETQ *FUNCTION-CALL-LOG-STREAM*
    (NEW-OUTPUT-FILE-STREAM FILENAME)))
  :VOID)

(CL:DEFUN START-FUNCTION-CALL-LOGGING-EVALUATOR-WRAPPER (ARGUMENTS)
  (%START-FUNCTION-CALL-LOGGING
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO START-FUNCTION-CALL-LOGGING (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Start function call logging to `fileName'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/START-FUNCTION-CALL-LOGGING|)) (CL:MACRO-FUNCTION (CL:QUOTE START-FUNCTION-CALL-LOGGING)))

;;; (DEFUN STOP-FUNCTION-CALL-LOGGING ...)

(CL:DEFUN STOP-FUNCTION-CALL-LOGGING ()
  "Stop function call logging and close the current log file."
  (CL:LET* ((CURRENTLOGSTREAM *FUNCTION-CALL-LOG-STREAM*))
   (CL:SETQ *FUNCTION-CALL-LOG-STREAM* NULL)
   (CL:WHEN (CL:NOT (CL:EQ CURRENTLOGSTREAM NULL))
    (FREE CURRENTLOGSTREAM)))
  :VOID)

;;; (DEFUN SET-CALL-LOG-BREAK-POINT ...)

(CL:DEFUN %SET-CALL-LOG-BREAK-POINT (COUNT)
  "Set a call log break point to `count'.  Execution will be
interrupted right at the entry of the `count'th logged function call."
  (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
  #+MCL
  (CL:CHECK-TYPE COUNT CL:FIXNUM)
  (CL:SETQ *LOG-BREAK-POINT-COUNTER* COUNT)
  :VOID)

(CL:DEFUN SET-CALL-LOG-BREAK-POINT-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-CALL-LOG-BREAK-POINT
   (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO SET-CALL-LOG-BREAK-POINT (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set a call log break point to `count'.  Execution will be
interrupted right at the entry of the `count'th logged function call."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-CALL-LOG-BREAK-POINT|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-CALL-LOG-BREAK-POINT)))

;;; (DEFUN BREAK-PROGRAM ...)

(CL:DEFUN %BREAK-PROGRAM (MESSAGE)
  "Interrupt the program and print `message'.  Continue after
confirmation with the user."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:break message)
  :VOID)

(CL:DEFUN BREAK-PROGRAM-EVALUATOR-WRAPPER (ARGUMENTS)
  (%BREAK-PROGRAM (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO BREAK-PROGRAM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Interrupt the program and print `message'.  Continue after
confirmation with the user."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/BREAK-PROGRAM|)) (CL:MACRO-FUNCTION (CL:QUOTE BREAK-PROGRAM)))

;;; (DEFUN TERMINATE-PROGRAM ...)

(CL:DEFUN TERMINATE-PROGRAM ()
  "Terminate and exit the program with normal exit code."
  (%BREAK-PROGRAM "Don't know how to terminate the program!")
  :VOID)

;;; (DEFUN PO ...)

(CL:DEFUN PO (THING)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) THING
   EOL)
  :VOID)

;;; (DEFUN (VARIABLE-EQL? BOOLEAN) ...)

(CL:DEFUN VARIABLE-EQL? (VAR1 VAR2)
  (CL:RETURN-FROM VARIABLE-EQL?
   (CL:OR (CL:EQ VAR1 VAR2)
    (STRING-EQL? (%SYMBOL.SYMBOL-NAME VAR1)
     (%SYMBOL.SYMBOL-NAME VAR2)))))

;;; (DEFUN (LOOKUP-VARIABLE-TABLE (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN LOOKUP-VARIABLE-TABLE (SELF VARIABLE)
  (CL:LET*
   ((KEY NULL) (VALUE NULL)
    (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
    (CL:SETQ KEY (%KV-CONS.KEY ITER-000))
    (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
    (CL:WHEN (VARIABLE-EQL? KEY VARIABLE)
     (CL:RETURN-FROM LOOKUP-VARIABLE-TABLE VALUE))
    (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
  (CL:RETURN-FROM LOOKUP-VARIABLE-TABLE NULL))

;;; (DEFUN INSERT-AT-VARIABLE-TABLE ...)

(CL:DEFUN INSERT-AT-VARIABLE-TABLE (SELF VARIABLE VALUE)
  (CL:LET* ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST SELF)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
    (CL:WHEN (VARIABLE-EQL? (%KV-CONS.KEY CURSOR) VARIABLE)
     (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE)
     (CL:RETURN-FROM INSERT-AT-VARIABLE-TABLE))
    (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF)
    (KV-CONS VARIABLE VALUE (%KEY-VALUE-LIST.THE-KV-LIST SELF))))
  :VOID)

;;; (DEFUN PUSH-VARIABLE-BINDING ...)

(CL:DEFUN PUSH-VARIABLE-BINDING (VARIABLE TYPE)
  (CL:LET* ((CLASS (TYPE-SPEC-TO-CLASS TYPE)))
   (CL:WHEN (CL:EQ VARIABLE NULL)
    (CL:RETURN-FROM PUSH-VARIABLE-BINDING))
   (CL:WHEN
    (CL:AND (CL:EQ CLASS NULL)
     (CL:NOT (CL:EQ TYPE SGT-WALK-STELLA-UNINITIALIZED)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " No class defined for type: `" (TYPE-SPEC-TO-BASE-TYPE TYPE)
       "'." EOL)))
    (CL:SETQ TYPE SGT-WALK-STELLA-UNKNOWN))
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
       (CL:NOT
        (CL:EQ *MIXIN-IMPLEMENTATION-STYLE* KWD-WALK-SECOND-CLASS))))
     (CL:NOT (CL:EQ CLASS NULL)) (%CLASS.MIXIN? CLASS)
     (CL:OR (CL:EQ *METHODBEINGWALKED* NULL)
      (CL:NOT (MIXIN-METHOD? *METHODBEINGWALKED*))
      (NON-EMPTY? *LOCALVARIABLETYPETABLE*)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Variable `" (DE-UGLIFY-PARSE-TREE VARIABLE)
       "' is typed with a mixin class which is" EOL
       " illegal when translating to a single-inheritance language."
       EOL))))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST *LOCALVARIABLETYPETABLE*)
    (KV-CONS VARIABLE TYPE
     (%KEY-VALUE-LIST.THE-KV-LIST *LOCALVARIABLETYPETABLE*)))
   (MAYBE-RENAME-LOCAL-VARIABLE VARIABLE))
  :VOID)

;;; (DEFUN POP-VARIABLE-BINDING ...)

(CL:DEFUN POP-VARIABLE-BINDING ()
  (CL:LET*
   ((KVLIST (%KEY-VALUE-LIST.THE-KV-LIST *LOCALVARIABLETYPETABLE*)))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST *LOCALVARIABLETYPETABLE*)
    (%KV-CONS.REST KVLIST))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE (%KV-CONS.VALUE KVLIST))
      SGT-WALK-STELLA-KEY-VALUE-LIST)
     (FREE (%KV-CONS.VALUE KVLIST)))
    (CL:T))
   (FREE-KV-CONS KVLIST))
  :VOID)

;;; (DEFUN (LOOKUP-VARIABLE-TYPE TYPE-SPEC) ...)

(CL:DEFUN LOOKUP-VARIABLE-TYPE (VARIABLENAME)
  (CL:LET*
   ((ENTRY
     (CL:IF (CL:NOT (CL:EQ *LOCALVARIABLETYPETABLE* NULL))
      (LOOKUP-VARIABLE-TABLE *LOCALVARIABLETYPETABLE* VARIABLENAME)
      NULL))
    (TYPE NULL))
   (CL:COND
    ((CL:EQ ENTRY NULL)
     (CL:WHEN (CL:EQ VARIABLENAME SYM-WALK-STELLA-NULL)
      (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-STELLA-UNKNOWN))
     (CL:SETQ TYPE (LOOKUP-GLOBAL-VARIABLE-TYPE VARIABLENAME))
     (REGISTER-REFERENCE-TO-GLOBAL-VARIABLE VARIABLENAME))
    (CL:T
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ENTRY)
        SGT-WALK-STELLA-KEY-VALUE-LIST)
       (CL:PROGN (CL:SETQ TYPE (LOOKUP ENTRY KWD-WALK-TYPE))))
      (CL:T (CL:SETQ TYPE ENTRY)))))
   (CL:WHEN (CL:EQ TYPE NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Undeclared variable `" (DE-UGLIFY-PARSE-TREE VARIABLENAME)
       "'." EOL)))
    (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-STELLA-UNKNOWN))
   (CL:WHEN (CL:EQ TYPE SGT-WALK-STELLA-UNINITIALIZED)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Reference to defined but uninitialized variable `"
       (DE-UGLIFY-PARSE-TREE VARIABLENAME) "'." EOL)))
    (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE SGT-WALK-STELLA-UNKNOWN))
   (CL:RETURN-FROM LOOKUP-VARIABLE-TYPE TYPE)))

;;; (DEFUN SET-LOCAL-VARIABLE-INFO ...)

(CL:DEFUN SET-LOCAL-VARIABLE-INFO (VARIABLE KEY INFO)
  (CL:LET*
   ((ENTRY (LOOKUP-VARIABLE-TABLE *LOCALVARIABLETYPETABLE* VARIABLE)))
   (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ENTRY)
       SGT-WALK-STELLA-KEY-VALUE-LIST)
      (CL:PROGN (INSERT-AT ENTRY KEY INFO)))
     (CL:T
      (CL:LET* ((VARIABLEINFO (NEW-KEY-VALUE-LIST)))
       (INSERT-AT VARIABLEINFO KEY INFO)
       (INSERT-AT VARIABLEINFO KWD-WALK-TYPE ENTRY)
       (INSERT-AT-VARIABLE-TABLE *LOCALVARIABLETYPETABLE* VARIABLE
        VARIABLEINFO))))))
  :VOID)

;;; (DEFUN (GET-LOCAL-VARIABLE-INFO OBJECT) ...)

(CL:DEFUN GET-LOCAL-VARIABLE-INFO (VARIABLE KEY)
  (CL:LET*
   ((ENTRY
     (CL:IF (CL:NOT (CL:EQ *LOCALVARIABLETYPETABLE* NULL))
      (LOOKUP-VARIABLE-TABLE *LOCALVARIABLETYPETABLE* VARIABLE) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ENTRY)
       SGT-WALK-STELLA-KEY-VALUE-LIST)
      (CL:PROGN
       (CL:RETURN-FROM GET-LOCAL-VARIABLE-INFO (LOOKUP ENTRY KEY))))
     (CL:T
      (CL:WHEN (CL:EQ KEY KWD-WALK-TYPE)
       (CL:RETURN-FROM GET-LOCAL-VARIABLE-INFO ENTRY)))))
   (CL:RETURN-FROM GET-LOCAL-VARIABLE-INFO NULL)))

;;; (DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE ...)

(CL:DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE (VARIABLENAME)
  (CL:WHEN (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
   (CL:LET*
    ((GLOBAL (LOOKUP-GLOBAL-VARIABLE VARIABLENAME))
     (REFERENCEDGLOBALS
      (%TRANSLATION-UNIT.REFERENCED-GLOBALS *CURRENTTRANSLATIONUNIT*)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ GLOBAL NULL))
      (CL:NOT (MEMBER? REFERENCEDGLOBALS GLOBAL)))
     (INSERT REFERENCEDGLOBALS GLOBAL))))
  :VOID)

;;; (DEFUN (LOCAL-GENSYM SYMBOL) ...)

(CL:DEFUN LOCAL-GENSYM (PREFIX)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ *LOCALGENSYMTABLE* NULL)
   (CL:RETURN-FROM LOCAL-GENSYM (GENSYM PREFIX)))
  (CL:LET*
   ((PREFIXCOUNTER (LOOKUP *LOCALGENSYMTABLE* (WRAP-STRING PREFIX))))
   (CL:IF (CL:EQ PREFIXCOUNTER NULL)
    (CL:SETQ PREFIXCOUNTER (WRAP-INTEGER 0))
    (CL:SETQ PREFIXCOUNTER
     (WRAP-INTEGER
      (CL:1+ (%INTEGER-WRAPPER.WRAPPER-VALUE PREFIXCOUNTER)))))
   (INSERT-AT *LOCALGENSYMTABLE* (WRAP-STRING PREFIX) PREFIXCOUNTER)
   (CL:RETURN-FROM LOCAL-GENSYM
    (INTERN-TRANSIENT-SYMBOL
     (YIELD-GENSYM-NAME PREFIX
      (%INTEGER-WRAPPER.WRAPPER-VALUE PREFIXCOUNTER))))))

;;; (DEFUN (METHOD-GENSYM SYMBOL) ...)

(CL:DEFUN METHOD-GENSYM (PREFIX)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:LET* ((METHOD *METHODBEINGWALKED*) (LOCAL? CL:NIL))
   (CL:WHEN (CL:NOT (CL:EQ METHOD NULL))
    (CL:IF (%METHOD-SLOT.METHOD-FUNCTION? METHOD)
     (CL:SETQ PREFIX
      (CONCATENATE "F-"
       (%SYMBOL.SYMBOL-NAME (%METHOD-SLOT.SLOT-NAME METHOD)) "-"
       PREFIX))
     (CL:SETQ PREFIX
      (CONCATENATE "M-"
       (%SURROGATE.SYMBOL-NAME (%METHOD-SLOT.SLOT-OWNER METHOD)) "."
       (%SYMBOL.SYMBOL-NAME (%METHOD-SLOT.SLOT-NAME METHOD)) "-"
       PREFIX)))
    (CL:SETQ LOCAL? CL:T))
   (CL:IF LOCAL? (CL:RETURN-FROM METHOD-GENSYM (LOCAL-GENSYM PREFIX))
    (CL:RETURN-FROM METHOD-GENSYM (GENSYM PREFIX)))))

;;; (DEFUN (YIELD-LOCAL-VARIABLE-ALIAS SYMBOL) ...)

(CL:DEFUN YIELD-LOCAL-VARIABLE-ALIAS (VARIABLE LEVEL)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
  #+MCL
  (CL:CHECK-TYPE LEVEL CL:FIXNUM)
  (CL:WHEN (CL:< LEVEL 1)
   (CL:ERROR
    "Safety violation: INTERNAL ERROR: Variable level must be >= 1"))
  (CL:WHEN (CL:EQ *LOCALGENSYMTABLE* NULL)
   (CL:RETURN-FROM YIELD-LOCAL-VARIABLE-ALIAS
    (LOCAL-GENSYM (%SYMBOL.SYMBOL-NAME VARIABLE))))
  (CL:LET*
   ((ALIASES (LOOKUP *LOCALGENSYMTABLE* VARIABLE)) (ALIAS NULL))
   (CL:WHEN (CL:EQ ALIASES NULL) (CL:SETQ ALIASES NIL))
   (CL:COND
    ((CL:< (LENGTH ALIASES) LEVEL)
     (CL:SETQ ALIAS (LOCAL-GENSYM (%SYMBOL.SYMBOL-NAME VARIABLE)))
     (INSERT-AT *LOCALGENSYMTABLE* VARIABLE
      (CONCATENATE ALIASES (CONS ALIAS NIL)))
     (CL:RETURN-FROM YIELD-LOCAL-VARIABLE-ALIAS ALIAS))
    (CL:T
     (CL:RETURN-FROM YIELD-LOCAL-VARIABLE-ALIAS
      (NTH ALIASES (CL:1- LEVEL)))))))

;;; (DEFUN (RENAME-SHADOWING-LOCAL-VARIABLES? BOOLEAN) ...)

(CL:DEFUN RENAME-SHADOWING-LOCAL-VARIABLES? ()
  (CL:RETURN-FROM RENAME-SHADOWING-LOCAL-VARIABLES?
   (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)))

;;; (DEFUN MAYBE-RENAME-LOCAL-VARIABLE ...)

(CL:DEFUN MAYBE-RENAME-LOCAL-VARIABLE (VARIABLE)
  (CL:WHEN (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
   (CL:LET*
    ((CURSOR (%KEY-VALUE-LIST.THE-KV-LIST *LOCALVARIABLETYPETABLE*))
     (LEVEL -1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
     (CL:WHEN (VARIABLE-EQL? (%KV-CONS.KEY CURSOR) VARIABLE)
      (CL:SETQ LEVEL (CL:1+ LEVEL)))
     (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
    (CL:WHEN (CL:>= LEVEL 1)
     (SET-LOCAL-VARIABLE-INFO VARIABLE KWD-WALK-ALIAS
      (YIELD-LOCAL-VARIABLE-ALIAS VARIABLE LEVEL)))))
  :VOID)

;;; (DEFUN (TRUE-VARIABLE-NAME SYMBOL) ...)

(CL:DEFUN TRUE-VARIABLE-NAME (VARIABLE)
  (CL:WHEN (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
   (CL:LET* ((ALIAS (GET-LOCAL-VARIABLE-INFO VARIABLE KWD-WALK-ALIAS)))
    (CL:WHEN (CL:NOT (CL:EQ ALIAS NULL))
     (CL:RETURN-FROM TRUE-VARIABLE-NAME ALIAS))))
  (CL:RETURN-FROM TRUE-VARIABLE-NAME VARIABLE))

;;; (DEFUN (SUPPRESS-WARNINGS? BOOLEAN) ...)

(CL:DEFUN SUPPRESS-WARNINGS? ()
  (CL:RETURN-FROM SUPPRESS-WARNINGS?
   (MEMBER? *CURRENT-STELLA-FEATURES* KWD-WALK-SUPPRESS-WARNINGS)))

;;; (DEFUN (BAD-ARGUMENT-RANGE? BOOLEAN) ...)

(CL:DEFUN BAD-ARGUMENT-RANGE? (TREE MINARITY MAXARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MINARITY MAXARITY))
  #+MCL
  (CL:CHECK-TYPE MINARITY CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXARITY CL:FIXNUM)
  (CL:LET* ((ARGNUM (CL:1- (LENGTH TREE))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARGNUM))
   (CL:COND
    ((CL:< ARGNUM MINARITY)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Missing arguments in the expression: " EOL " `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
     (CL:RETURN-FROM BAD-ARGUMENT-RANGE? CL:T))
    ((CL:AND (CL:NOT (CL:= MAXARITY NULL-INTEGER))
      (CL:> ARGNUM MAXARITY))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Too many arguments in the expression: " EOL " `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
     (CL:RETURN-FROM BAD-ARGUMENT-RANGE? CL:T))
    (CL:T (CL:RETURN-FROM BAD-ARGUMENT-RANGE? CL:NIL)))))

;;; (DEFUN (BAD-ARGUMENT-COUNT? BOOLEAN) ...)

(CL:DEFUN BAD-ARGUMENT-COUNT? (TREE ARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:RETURN-FROM BAD-ARGUMENT-COUNT?
   (BAD-ARGUMENT-RANGE? TREE ARITY ARITY)))

;;; (DEFUN (YIELD-ILLEGAL-STATEMENT-TREE CONS) ...)

(CL:DEFUN YIELD-ILLEGAL-STATEMENT-TREE ()
  (CL:LET* ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST)))
   (CL:DECLARE (CL:SPECIAL *LOCALVARIABLETYPETABLE*))
   (CL:RETURN-FROM YIELD-ILLEGAL-STATEMENT-TREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST* SYM-WALK-STELLA-ERROR
      (WRAP-STRING
       "Attempt to execute illegal statement flagged by the translator")
      SYM-WALK-STELLA-EOL (WRAP-STRING "    but not yet fixed.") NIL)))))

;;; (DEFUN (YIELD-ILLEGAL-EXPRESSION-TREE OBJECT) ...)

(CL:DEFUN YIELD-ILLEGAL-EXPRESSION-TREE ()
  (CL:RETURN-FROM YIELD-ILLEGAL-EXPRESSION-TREE
   SYM-WALK-STELLA-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR))

;;; (DEFUN (WALK-DONT-CALL-ME-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-DONT-CALL-ME-TREE (TREE RETURNTYPE)
  (CL:RETURN-FROM WALK-DONT-CALL-ME-TREE
   (CL:VALUES
    (LIST* SYM-WALK-STELLA-BAD-SYS TREE
     (CONS (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE) NIL))
    RETURNTYPE)))

;;; (DEFUN (ILLEGAL-TREE? BOOLEAN) ...)

(CL:DEFUN ILLEGAL-TREE? (TREE)
  (CL:RETURN-FROM ILLEGAL-TREE?
   (CL:AND (CONS? TREE) (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-BAD-SYS))))

;;; (DEFUN (NATIVE-CLASS-METHOD-INLINING? BOOLEAN) ...)

(CL:DEFUN NATIVE-CLASS-METHOD-INLINING? ()
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM NATIVE-CLASS-METHOD-INLINING? CL:NIL))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL))
    (CL:RETURN-FROM NATIVE-CLASS-METHOD-INLINING? CL:T))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (PROGNIFY OBJECT) ...)

(CL:DEFUN PROGNIFY (TREES)
  (CL:CASE (LENGTH TREES) (0 (CL:RETURN-FROM PROGNIFY NIL))
   (1
    (CL:LET* ((TREE (%%VALUE TREES))) (FIRST-SETTER TREES NULL)
     (CL:RETURN-FROM PROGNIFY TREE)))
   (CL:OTHERWISE
    (CL:RETURN-FROM PROGNIFY
     (CONS SYM-WALK-STELLA-PROGN (CONCATENATE TREES NIL))))))

;;; (DEFUN (OPTIMIZE-PROGN OBJECT) ...)

(CL:DEFUN OPTIMIZE-PROGN (PROGN-TREE)
  (CL:CASE (LENGTH (%%REST PROGN-TREE))
   (0 (CL:RETURN-FROM OPTIMIZE-PROGN NIL))
   (1
    (CL:LET* ((TREE (%%VALUE (%%REST PROGN-TREE))))
     (SECOND-SETTER PROGN-TREE NULL)
     (CL:RETURN-FROM OPTIMIZE-PROGN TREE)))
   (CL:OTHERWISE (CL:RETURN-FROM OPTIMIZE-PROGN PROGN-TREE))))

;;; (DEFUN (TREE-TO-TREES CONS) ...)

(CL:DEFUN TREE-TO-TREES (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-PROGN)
      (CL:RETURN-FROM TREE-TO-TREES (%%REST TREE)))))
   (CL:T))
  (CL:RETURN-FROM TREE-TO-TREES (CONS TREE NIL)))

;;; (DEFGLOBAL *WRAPPED-TYPE-TABLE* ...)

(CL:DEFVAR *WRAPPED-TYPE-TABLE* NULL
  "Table of pairs used by `wrapper-value-type' and
`type-to-wrapped-type'.")

;;; (DEFUN (WRAPPED-TYPE-TO-TYPE TYPE) ...)

(CL:DEFUN WRAPPED-TYPE-TO-TYPE (SELF)
  "Return the unwrapped type for the wrapped type `self',
or `self' if it is not a wrapped type."
  (CL:LET* ((ENTRY NULL) (ITER-000 *WRAPPED-TYPE-TABLE*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ENTRY (%%VALUE ITER-000))
    (CL:WHEN (CL:EQ (%%VALUE ENTRY) SELF)
     (CL:RETURN-FROM WRAPPED-TYPE-TO-TYPE (%%VALUE (%%REST ENTRY))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM WRAPPED-TYPE-TO-TYPE SELF))

;;; (DEFUN (WRAPPER-VALUE-TYPE TYPE) ...)

(CL:DEFUN WRAPPER-VALUE-TYPE (SELF)
  "Return the type of the value stored in the wrapper `self'."
  (CL:LET*
   ((WRAPPERTYPE (PRIMARY-TYPE SELF))
    (VALUETYPE (WRAPPED-TYPE-TO-TYPE WRAPPERTYPE)))
   (CL:IF (CL:EQ VALUETYPE WRAPPERTYPE)
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Missing *wrapped-type-table* entry"))
    (CL:RETURN-FROM WRAPPER-VALUE-TYPE VALUETYPE))))

;;; (DEFMETHOD (TYPE-TO-WRAPPED-TYPE TYPE) ...)

(CL:DEFMETHOD TYPE-TO-WRAPPED-TYPE ((SELF SURROGATE))
  "Return the wrapped type for the type `self',
or 'self' if it is not a bare literal type."
  (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Can't find a class named `" (DE-UGLIFY-PARSE-TREE SELF) "'."
      EOL)))
   (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE SGT-WALK-STELLA-UNKNOWN))
  (CL:WHEN (SUBTYPE-OF? SELF SGT-WALK-STELLA-OBJECT)
   (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE SELF))
  (CL:LET* ((ENTRY NULL) (ITER-000 *WRAPPED-TYPE-TABLE*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ENTRY (%%VALUE ITER-000))
    (CL:WHEN (CL:EQ (%%VALUE (%%REST ENTRY)) SELF)
     (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE (%%VALUE ENTRY)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((REALTYPE (%CLASS.CLASS-TYPE (%SURROGATE.SURROGATE-VALUE SELF))))
   (CL:WHEN (CL:NOT (CL:EQ SELF REALTYPE))
    (CL:LET* ((ENTRY NULL) (ITER-001 *WRAPPED-TYPE-TABLE*))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ ENTRY (%%VALUE ITER-001))
      (CL:WHEN (CL:EQ (%%VALUE (%%REST ENTRY)) REALTYPE)
       (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE (%%VALUE ENTRY)))
      (CL:SETQ ITER-001 (%%REST ITER-001))))))
  (CL:RETURN-FROM TYPE-TO-WRAPPED-TYPE NULL))

;;; (DEFGLOBAL *COERSION-TABLE* ...)

(CL:DEFVAR *COERSION-TABLE* NULL
  "Table of triples used by `lookup-coersion-method' to
locate a coersion method.")

;;; (DEFUN (LOOKUP-COERSION-METHOD OBJECT) ...)

(CL:DEFUN LOOKUP-COERSION-METHOD (SOURCETYPE TARGETTYPE EXPRESSION)
  (CL:SETQ EXPRESSION EXPRESSION)
  (CL:SETQ SOURCETYPE (CANONICAL-TYPE SOURCETYPE))
  (CL:LET* ((TRIPLE NULL) (ITER-000 *COERSION-TABLE*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ TRIPLE (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (SUBTYPE-OF? SOURCETYPE (%%VALUE TRIPLE))
      (SUBTYPE-OF? (%%VALUE (%%REST TRIPLE)) TARGETTYPE))
     (CL:RETURN-FROM LOOKUP-COERSION-METHOD
      (%%VALUE (%%REST (%%REST TRIPLE)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM LOOKUP-COERSION-METHOD NULL))

;;; (DEFUN (APPLY-COERCION-METHOD OBJECT TYPE-SPEC) ...)

(CL:DEFUN APPLY-COERCION-METHOD (EXPRESSION SOURCETYPE TARGETTYPE COERCIONMETHOD)
  (CL:WHEN (CL:EQ COERCIONMETHOD NULL)
   (CL:SETQ COERCIONMETHOD
    (LOOKUP-COERSION-METHOD SOURCETYPE TARGETTYPE EXPRESSION)))
  (CL:WHEN (CL:EQ COERCIONMETHOD NULL)
   (CL:RETURN-FROM APPLY-COERCION-METHOD
    (CL:VALUES EXPRESSION SOURCETYPE)))
  (CL:WHEN (CL:EQ COERCIONMETHOD SYM-WALK-STELLA-IDENTITY)
   (CL:RETURN-FROM APPLY-COERCION-METHOD
    (CL:VALUES EXPRESSION TARGETTYPE)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COERCIONMETHOD)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM APPLY-COERCION-METHOD
       (WALK-EXPRESSION-TREE
        (CONS COERCIONMETHOD (CONS EXPRESSION NIL)) TARGETTYPE
        COERCIONMETHOD CL:NIL))))
    ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:RETURN-FROM APPLY-COERCION-METHOD
       (WALK-EXPRESSION-TREE
        (COPY-CONS-TREE
         (SUBSTITUTE-CONS-TREE (COPY-CONS-TREE COERCIONMETHOD)
          EXPRESSION SYM-WALK-STELLA-<X>))
        TARGETTYPE (%%VALUE COERCIONMETHOD) CL:NIL))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (TRANSLATING-CODE? BOOLEAN) ...)

(CL:DEFUN TRANSLATING-CODE? ()
  (CL:RETURN-FROM TRANSLATING-CODE?
   (CL:OR (CL:EQ *TRANSLATIONPHASE* KWD-WALK-WALK)
    (CL:EQ *TRANSLATIONPHASE* KWD-WALK-TRANSLATE))))

;;; (DEFUN (VERIFY-TYPE TYPE) ...)

(CL:DEFUN VERIFY-TYPE (SELF)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL))
    (CL:NOT (STELLA-CLASS? (%SURROGATE.SURROGATE-VALUE SELF))))
   (CL:WARN
    "Illegal object `~A' found~%   where STELLA class expected~%"
    (%SURROGATE.SURROGATE-VALUE SELF))
   (CL:SETF (%SURROGATE.SURROGATE-VALUE SELF)
    (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-UNKNOWN)))
  (CL:WHEN
   (CL:AND (TRANSLATING-CODE?)
    (CL:OR (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL)
     (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF)
      (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-UNKNOWN))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-WARNING)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
      EOL " Reference to undefined class `"
      (%SURROGATE.SYMBOL-NAME SELF) "'." EOL)))
   (CL:SETF (%SURROGATE.SURROGATE-VALUE SELF)
    (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-UNKNOWN)))
  (CL:RETURN-FROM VERIFY-TYPE SELF))

;;; (DEFUN (SAFE-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN SAFE-SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  (VERIFY-TYPE SUBTYPE)
  (VERIFY-TYPE SUPERTYPE)
  (CL:RETURN-FROM SAFE-SUBTYPE-OF? (SUBTYPE-OF? SUBTYPE SUPERTYPE)))

;;; (DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE ...)

(CL:DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE (TREE)
  (CL:WHEN (WARN-ABOUT-UNDEFINED-METHODS?)
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
      (CL:PROGN (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
     ((CL:EQ TEST-VALUE-001 SGT-WALK-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VERBATIM)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VRLET))
          (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD)
          (CL:WHEN
           (CL:OR
            (SYMBOL-COMMON-LISP? (%%VALUE (%%REST (%%REST TREE))))
            (CL:EQ
             (LOOKUP-SLOT
              (%SURROGATE.SURROGATE-VALUE (%%VALUE (%%REST TREE)))
              (%%VALUE (%%REST (%%REST TREE))))
             NULL))
           (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-FUNCTION)
          (CL:WHEN
           (CL:EQ
            (%METHOD-SLOT.SLOT-BASE-TYPE
             (LOOKUP-FUNCTION (%%VALUE (%%REST TREE))))
            SGT-WALK-STELLA-UNKNOWN)
           (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-INLINE-CALL))
          (WARN-ABOUT-UNKNOWN-SOURCE-TYPE (%%VALUE (%%REST TREE)))
          (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE))
         (CL:T)))))
     (CL:T
      (CL:WHEN (CL:EQ TREE NULL)
       (CL:RETURN-FROM WARN-ABOUT-UNKNOWN-SOURCE-TYPE)))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " The expression" EOL "   `" (DE-UGLIFY-PARSE-TREE TREE) "'" EOL
      " has UNKNOWN type." EOL))))
  :VOID)

;;; (DEFUN (COERCE-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN COERCE-A-TREE (TREE SOURCETYPE TARGETTYPE)
  (CL:LET* ((OTREE NULL) (OTYPE NULL) (COERCIBLE? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE COERCIBLE?)
    (HELP-COERCE-A-TREE TREE SOURCETYPE TARGETTYPE CL:NIL))
   (CL:WHEN (CL:NOT COERCIBLE?)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Type conflict: the expression:" EOL "   `"
       (DE-UGLIFY-PARSE-TREE TREE) "'" EOL " has type `"
       (YIELD-TYPE-SPEC-TREE SOURCETYPE) "' but should have type `"
       (YIELD-TYPE-SPEC-TREE TARGETTYPE) "'." EOL))))
   (CL:RETURN-FROM COERCE-A-TREE (CL:VALUES OTREE OTYPE))))

;;; (DEFUN (HELP-COERCE-A-TREE OBJECT TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN HELP-COERCE-A-TREE (TREE SOURCETYPE TARGETTYPE TESTONLY?)
  (CL:LET*
   ((COERSIONFUNCTION NULL)
    (REALSOURCETYPE (TARGET-LANGUAGE-TYPE TREE))
    (SOURCEBASETYPE (TYPE-SPEC-TO-BASE-TYPE SOURCETYPE))
    (TARGETBASETYPE (TYPE-SPEC-TO-BASE-TYPE TARGETTYPE)))
   (CL:WHEN (CL:EQ SOURCETYPE SGT-WALK-STELLA-UNKNOWN)
    (WARN-ABOUT-UNKNOWN-SOURCE-TYPE TREE)
    (CL:IF
     (CL:AND (CL:EQ TREE SYM-WALK-STELLA-NULL)
      (CL:NOT (CL:EQ TARGETBASETYPE NULL)))
     (CL:RETURN-FROM HELP-COERCE-A-TREE
      (CL:VALUES
       (TYPE-TO-WALKED-NULL-VALUE-TREE TARGETTYPE TARGETBASETYPE)
       TARGETTYPE CL:T))
     (CL:RETURN-FROM HELP-COERCE-A-TREE
      (CL:VALUES TREE TARGETTYPE CL:T))))
   (CL:WHEN (CL:NOT (CL:EQ REALSOURCETYPE NULL))
    (SET-TARGET-LANGUAGE-TYPE TREE NULL)
    (CL:SETQ TREE (COERCE-A-TREE TREE REALSOURCETYPE SOURCETYPE)))
   (CL:WHEN (CL:EQ TARGETTYPE SGT-WALK-STELLA-UNKNOWN)
    (CL:RETURN-FROM HELP-COERCE-A-TREE
     (CL:VALUES TREE SOURCETYPE CL:T)))
   (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE SOURCEBASETYPE) NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " No class defined for type: `"
       (DE-UGLIFY-PARSE-TREE SOURCEBASETYPE) "'." EOL)))
    (CL:RETURN-FROM HELP-COERCE-A-TREE
     (CL:VALUES TREE TARGETTYPE CL:T)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ TARGETBASETYPE NULL))
     (CL:EQ (%SURROGATE.SURROGATE-VALUE TARGETBASETYPE) NULL))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " No class defined for type: `"
       (DE-UGLIFY-PARSE-TREE TARGETBASETYPE) "'." EOL)))
    (CL:RETURN-FROM HELP-COERCE-A-TREE
     (CL:VALUES TREE SOURCETYPE CL:T)))
   (CL:WHEN (SUB-TYPE-SPEC-OF? SOURCETYPE TARGETTYPE)
    (CL:RETURN-FROM HELP-COERCE-A-TREE
     (CL:VALUES TREE SOURCETYPE CL:T)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ TARGETBASETYPE NULL))
     (CL:OR (COMPATIBLE-PARAMETER-TYPES? SOURCETYPE TARGETTYPE)
      (CL:AND (CL:NOT (ARRAY-TYPE-SPECIFIER? SOURCETYPE))
       (SUBTYPE-OF? TARGETBASETYPE SOURCEBASETYPE)
       (COMPATIBLE-PARAMETER-TYPES? TARGETTYPE SOURCETYPE))))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (TYPE? SOURCETYPE))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ()
       (CL:SETQ COERSIONFUNCTION
        (LOOKUP-COERSION-METHOD SOURCETYPE TARGETBASETYPE TREE))
       (CL:SETQ TEST-VALUE-000
        (CL:NOT (CL:EQ COERSIONFUNCTION NULL)))))
     (CL:WHEN TEST-VALUE-000
      (CL:WHEN (CL:NOT TESTONLY?)
       (CL:MULTIPLE-VALUE-SETQ (TREE TARGETTYPE)
        (APPLY-COERCION-METHOD TREE SOURCETYPE TARGETBASETYPE
         COERSIONFUNCTION)))
      (CL:RETURN-FROM HELP-COERCE-A-TREE
       (CL:VALUES TREE TARGETTYPE CL:T))))
    (CL:WHEN (SUBTYPE-OF? TARGETBASETYPE SOURCEBASETYPE)
     (CL:WHEN TESTONLY?
      (CL:RETURN-FROM HELP-COERCE-A-TREE
       (CL:VALUES TREE TARGETTYPE CL:T)))
     (CL:RETURN-FROM HELP-COERCE-A-TREE
      (CL:VALUES
       (WALK-WITHOUT-TYPE-TREE
        (CONS
         (CL:IF (CL:NOT (CL:EQ REALSOURCETYPE NULL))
          SYM-WALK-STELLA-SAFE-CAST SYM-WALK-STELLA-CAST)
         (CONS TREE (CONS TARGETTYPE NIL))))
       TARGETTYPE CL:T)))
    (CL:WHEN
     (CL:AND (SUBTYPE-OF? TARGETBASETYPE SGT-WALK-STELLA-NON-OBJECT)
      (CL:AND (TYPE? SOURCETYPE)
       (SUBTYPE-OF? SGT-WALK-STELLA-WRAPPER SOURCETYPE)))
     (CL:LET* ((WRAPPERTYPE (TYPE-TO-WRAPPED-TYPE TARGETBASETYPE)))
      (CL:WHEN (CL:NOT (CL:EQ WRAPPERTYPE NULL))
       (CL:WHEN TESTONLY?
        (CL:RETURN-FROM HELP-COERCE-A-TREE
         (CL:VALUES TREE TARGETTYPE CL:T)))
       (CL:SETQ COERSIONFUNCTION
        (LOOKUP-COERSION-METHOD WRAPPERTYPE TARGETBASETYPE TREE))
       (CL:WHEN (CL:NOT (CL:EQ COERSIONFUNCTION NULL))
        (CL:MULTIPLE-VALUE-SETQ (TREE TARGETTYPE)
         (APPLY-COERCION-METHOD
          (LIST* SYM-WALK-STELLA-CAST TREE (CONS WRAPPERTYPE NIL))
          SOURCETYPE TARGETBASETYPE COERSIONFUNCTION))
        (CL:RETURN-FROM HELP-COERCE-A-TREE
         (CL:VALUES TREE TARGETTYPE CL:T)))))))
   (CL:RETURN-FROM HELP-COERCE-A-TREE
    (CL:VALUES TREE SOURCETYPE CL:NIL))))

;;; (DEFUN (COERCIBLE? BOOLEAN) ...)

(CL:DEFUN COERCIBLE? (TREE SOURCETYPE TARGETTYPE)
  (CL:LET* ((OTREE NULL) (OTYPE NULL) (COERCIBLE? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE COERCIBLE?)
    (HELP-COERCE-A-TREE TREE SOURCETYPE TARGETTYPE CL:T))
   (CL:PROGN (CL:SETQ OTREE OTREE) (CL:SETQ OTYPE OTYPE))
   (CL:RETURN-FROM COERCIBLE? COERCIBLE?)))

;;; (DEFUN (WALKING-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN WALKING-EXPRESSION? ()
  (CL:RETURN-FROM WALKING-EXPRESSION?
   (CL:NOT (CL:EQ *TARGETTYPE* SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-EXPRESSION-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-EXPRESSION-TREE (EXPTREE TARGETTYPE OPERATORNAME VRLETISOK?)
  (CL:LET*
   ((*TARGETTYPE*
     (CL:IF (CL:NOT (CL:EQ TARGETTYPE NULL)) TARGETTYPE
      SGT-WALK-STELLA-UNKNOWN)))
   (CL:DECLARE (CL:SPECIAL *TARGETTYPE*))
   (CL:LET* ((OEXP NULL) (SOURCETYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OEXP SOURCETYPE) (WALK-A-TREE EXPTREE))
    (CL:WHEN (VRLET-EXPRESSION? OEXP)
     (CL:WHEN (CL:NOT VRLETISOK?)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal procedural expression as argument to `"
         (DE-UGLIFY-PARSE-TREE OPERATORNAME) "':" EOL "   `"
         (DE-UGLIFY-PARSE-TREE EXPTREE) "'." EOL))))
     (CL:RETURN-FROM WALK-EXPRESSION-TREE (CL:VALUES OEXP SOURCETYPE)))
    (CL:WHEN (CL:AND (VOID? SOURCETYPE) (CL:NOT (VOID? TARGETTYPE)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal argument to `"
        (DE-UGLIFY-PARSE-TREE OPERATORNAME) "':" EOL "   `"
        (DE-UGLIFY-PARSE-TREE OEXP) "'" EOL
        "The argument must be an expression, not a statement." EOL)))
     (CL:RETURN-FROM WALK-EXPRESSION-TREE
      (WALK-DONT-CALL-ME-TREE OEXP SOURCETYPE)))
    (CL:WHEN (CL:EQ SOURCETYPE NULL)
     (CL:SETQ SOURCETYPE SGT-WALK-STELLA-UNKNOWN))
    (CL:WHEN (CL:EQ TARGETTYPE NULL) (CL:SETQ TARGETTYPE SOURCETYPE))
    (CL:RETURN-FROM WALK-EXPRESSION-TREE
     (COERCE-A-TREE OEXP SOURCETYPE TARGETTYPE)))))

;;; (DEFUN (COMPUTE-EXPRESSION-TYPE TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-EXPRESSION-TYPE (EXPRESSION WRAP?)
  (CL:LET*
   ((WALKEDTREE
     (WALK-A-TREE
      (LIST* SYM-WALK-STELLA-LET
       (CONS (LIST* SYM-WALK-STELLA-X (COPY-CONS-TREE EXPRESSION) NIL)
        NIL)
       NIL)))
    (TYPESPEC (CONS-TREE-NTH WALKEDTREE 1 1 0 1)))
   (CL:IF WRAP?
    (CL:RETURN-FROM COMPUTE-EXPRESSION-TYPE
     (CL:IF (SUB-TYPE-SPEC-OF? TYPESPEC SGT-WALK-STELLA-LITERAL)
      (TYPE-TO-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE TYPESPEC))
      TYPESPEC))
    (CL:RETURN-FROM COMPUTE-EXPRESSION-TYPE TYPESPEC))))

;;; (DEFUN (WALK-WITHOUT-TYPE-TREE OBJECT) ...)

(CL:DEFUN WALK-WITHOUT-TYPE-TREE (TREE)
  (CL:LET* ((OTREE NULL) (UNUSEDTYPESPEC NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE UNUSEDTYPESPEC) (WALK-A-TREE TREE))
   (CL:SETQ UNUSEDTYPESPEC UNUSEDTYPESPEC)
   (CL:RETURN-FROM WALK-WITHOUT-TYPE-TREE OTREE)))

;;; (DEFUN (WALK-LIST-OF-TREES CONS) ...)

(CL:DEFUN WALK-LIST-OF-TREES (TREES)
  (CL:LET* ((CURSOR TREES))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR) (WALK-STATEMENT (%%VALUE CURSOR) CL:NIL))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:RETURN-FROM WALK-LIST-OF-TREES TREES)))

;;; (DEFUN (WALK-LIST-OF-STATEMENTS CONS) ...)

(CL:DEFUN WALK-LIST-OF-STATEMENTS (TREES)
  (CL:LET* ((OTREES NIL))
   (CL:LET*
    ((OTREE NULL) (ITER-000 (WALK-LIST-OF-TREES TREES))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ OTREE (%%VALUE ITER-000))
     (CL:WHEN (CONS? OTREE)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS OTREE NIL))
        (CL:IF (CL:EQ OTREES NIL) (CL:SETQ OTREES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST OTREES COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS OTREE NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM WALK-LIST-OF-STATEMENTS OTREES)))

;;; (DEFUN (WALK-STATEMENT OBJECT) ...)

(CL:DEFUN WALK-STATEMENT (TREE WARNONATOM?)
  (CL:LET* ((OTREE NULL) (UNUSEDTYPESPEC NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE UNUSEDTYPESPEC) (WALK-A-TREE TREE))
   (CL:SETQ UNUSEDTYPESPEC UNUSEDTYPESPEC)
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE OTREE) SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%%VALUE OTREE) SYM-WALK-STELLA-VRLET)
       (CL:SETQ OTREE (ELIMINATE-VRLET-STATEMENT OTREE)))))
    (CL:T
     (CL:WHEN
      (CL:AND WARNONATOM? (CL:NOT (CL:EQ OTREE NULL))
       (CL:NOT (CL:EQ OTREE SYM-WALK-STELLA-NULL)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL " Expression found where statement expected: `"
         (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))))
   (CL:RETURN-FROM WALK-STATEMENT OTREE)))

;;; (DEFUN (ELIMINATE-VRLET-STATEMENT CONS) ...)

(CL:DEFUN ELIMINATE-VRLET-STATEMENT (TREE)
  (FIRST-SETTER TREE SYM-WALK-STELLA-LET)
  (CL:RETURN-FROM ELIMINATE-VRLET-STATEMENT (WALK-A-TREE TREE)))

;;; (DEFUN (SYS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN SYS-TREE (TREE TYPESPEC)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VOID-SYS)
        (CL:WHEN (VOID? TYPESPEC)
         (CL:RETURN-FROM SYS-TREE (CL:VALUES TREE TYPESPEC))))
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
        (CL:WHEN (CL:EQ (%%VALUE (%%REST (%%REST TREE))) TYPESPEC)
         (CL:RETURN-FROM SYS-TREE (CL:VALUES TREE TYPESPEC))))
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VRLET)
        (CL:RETURN-FROM SYS-TREE (CL:VALUES TREE TYPESPEC)))
       (CL:T)))))
   (CL:T))
  (CL:IF (VOID? TYPESPEC)
   (CL:RETURN-FROM SYS-TREE
    (CL:VALUES (LIST* SYM-WALK-STELLA-VOID-SYS TREE NIL)
     SGT-WALK-STELLA-VOID))
   (CL:RETURN-FROM SYS-TREE
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-TYPED-SYS TREE (CONS TYPESPEC NIL))
     TYPESPEC))))

;;; (DEFUN (WALKED-EXPRESSION-TYPE TYPE-SPEC) ...)

(CL:DEFUN WALKED-EXPRESSION-TYPE (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-TYPED-SYS)
       (CL:RETURN-FROM WALKED-EXPRESSION-TYPE
        (%%VALUE (%%REST (%%REST TREE)))))))
    ((SUBTYPE-OF-WRAPPER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM WALKED-EXPRESSION-TYPE
       (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE)))))
    (CL:T)))
  (CL:RETURN-FROM WALKED-EXPRESSION-TYPE SGT-WALK-STELLA-UNKNOWN))

;;; (DEFUN (WALKED-EXPRESSION-EXPRESSION OBJECT) ...)

(CL:DEFUN WALKED-EXPRESSION-EXPRESSION (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VOID-SYS)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS))
        (CL:RETURN-FROM WALKED-EXPRESSION-EXPRESSION
         (%%VALUE (%%REST TREE))))
       (CL:T)))))
   (CL:T))
  (CL:RETURN-FROM WALKED-EXPRESSION-EXPRESSION TREE))

;;; (DEFUN (NEED-IDENTICAL-METHOD-SIGNATURES? BOOLEAN) ...)

(CL:DEFUN NEED-IDENTICAL-METHOD-SIGNATURES? ()
  (CL:COND
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA))
    (CL:RETURN-FROM NEED-IDENTICAL-METHOD-SIGNATURES? CL:T))
   (CL:T (CL:RETURN-FROM NEED-IDENTICAL-METHOD-SIGNATURES? CL:NIL))))

;;; (DEFUN (COMPUTE-MOST-GENERAL-RETURN-TYPE TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-MOST-GENERAL-RETURN-TYPE (METHOD RETURNTYPE)
  (CL:LET*
   ((MOSTGENERALRETURNTYPE RETURNTYPE) (MOSTGENERALMETHOD METHOD))
   (CL:LOOP WHILE
    (CL:NOT
     (CL:EQ (%METHOD-SLOT.SLOT-DIRECT-EQUIVALENT MOSTGENERALMETHOD)
      NULL))
    DO
    (CL:SETQ MOSTGENERALMETHOD
     (%METHOD-SLOT.SLOT-DIRECT-EQUIVALENT MOSTGENERALMETHOD))
    (CL:WHEN
     (CL:NOT
      (CL:EQ (%METHOD-SLOT.SLOT-BASE-TYPE MOSTGENERALMETHOD)
       SGT-WALK-STELLA-UNKNOWN))
     (CL:IF (ARRAY-TYPE-SPECIFIER? MOSTGENERALRETURNTYPE)
      (CL:SETQ MOSTGENERALRETURNTYPE
       (COMPUTE-RETURN-TYPE-SPEC MOSTGENERALMETHOD
        (%METHOD-SLOT.SLOT-OWNER MOSTGENERALMETHOD)))
      (CL:SETQ MOSTGENERALRETURNTYPE
       (%METHOD-SLOT.SLOT-BASE-TYPE MOSTGENERALMETHOD)))))
   (CL:RETURN-FROM COMPUTE-MOST-GENERAL-RETURN-TYPE
    MOSTGENERALRETURNTYPE)))

;;; (DEFUN (COMPUTE-REAL-SLOT-TYPE TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-REAL-SLOT-TYPE (SLOT FIRSTARGTYPE RETURNTYPE)
  (CL:LET*
   ((SLOTTYPE RETURNTYPE) (CANONICALSLOT (CANONICAL-SLOT SLOT))
    (NATIVESLOTHOME NULL))
   (CL:WHEN (NATIVE-SLOT? CANONICALSLOT)
    (CL:SETQ NATIVESLOTHOME
     (NATIVE-SLOT-HOME SLOT (TYPE-SPEC-TO-CLASS FIRSTARGTYPE))))
   (CL:IF (CL:NOT (CL:EQ NATIVESLOTHOME NULL))
    (CL:SETQ SLOTTYPE
     (TYPE-SPEC-TO-BASE-TYPE
      (COMPUTE-RETURN-TYPE-SPEC
       (LOOKUP-SLOT NATIVESLOTHOME
        (%STORAGE-SLOT.SLOT-NAME CANONICALSLOT))
       (%CLASS.CLASS-TYPE NATIVESLOTHOME))))
    (CL:SETQ SLOTTYPE
     (TYPE-SPEC-TO-BASE-TYPE
      (COMPUTE-RETURN-TYPE-SPEC SLOT
       (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE)))))
   (CL:WHEN (CL:EQ SLOTTYPE (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE))
    (CL:SETQ SLOTTYPE RETURNTYPE))
   (CL:RETURN-FROM COMPUTE-REAL-SLOT-TYPE SLOTTYPE)))

;;; (DEFUN (SYS-TREE-IF-NEEDED OBJECT TYPE-SPEC) ...)

(CL:DEFUN SYS-TREE-IF-NEEDED (SLOT TREE FIRSTARGTYPE RETURNTYPE)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ SLOT NULL))
    (CL:NOT (PROCEDURAL-EXPRESSION? TREE)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SLOT)))
    (CL:COND
     ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? SLOT))
         (NEED-IDENTICAL-METHOD-SIGNATURES?))
        (CL:LET*
         ((MOSTGENERALRETURNTYPE
           (COMPUTE-MOST-GENERAL-RETURN-TYPE SLOT RETURNTYPE)))
         (CL:WHEN (CL:NOT (CL:EQ RETURNTYPE MOSTGENERALRETURNTYPE))
          (CL:RETURN-FROM SYS-TREE-IF-NEEDED
           (SET-TARGET-LANGUAGE-TYPE (SYS-TREE TREE RETURNTYPE)
            MOSTGENERALRETURNTYPE)))))))
     ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000)
      (CL:PROGN
       (CL:LET*
        ((REALSLOTTYPE
          (COMPUTE-REAL-SLOT-TYPE SLOT FIRSTARGTYPE RETURNTYPE))
         (REALSLOT NULL))
        (CL:WHEN (CL:NOT (CL:EQ RETURNTYPE REALSLOTTYPE))
         (CL:WHEN
          (CL:AND (CL:EQ REALSLOTTYPE SGT-WALK-STELLA-UNKNOWN)
           (CL:NOT
            (CL:EQ SLOT
             (CL:SETQ REALSLOT (SLOT-FROM-EXPRESSION-TREE TREE))))
           (METHOD-SLOT? REALSLOT))
          (CL:RETURN-FROM SYS-TREE-IF-NEEDED
           (SYS-TREE-IF-NEEDED REALSLOT TREE FIRSTARGTYPE RETURNTYPE)))
         (CL:RETURN-FROM SYS-TREE-IF-NEEDED
          (SET-TARGET-LANGUAGE-TYPE (SYS-TREE TREE RETURNTYPE)
           REALSLOTTYPE))))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET*
    ((SLOTTYPE
      (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
       SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)))
    (CL:LET* ((TEST-VALUE-001 CL:NIL))
     (CL:SETQ TEST-VALUE-001 (CL:NOT (CL:EQ SLOTTYPE NULL)))
     (CL:WHEN TEST-VALUE-001
      (CL:IF (ANCHORED-TYPE-SPECIFIER? SLOTTYPE)
       (CL:SETQ TEST-VALUE-001 CL:T)
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((TS NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST
            (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
             SLOTTYPE))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ TS (%%VALUE ITER-000))
          (CL:WHEN (ANCHORED-TYPE-SPECIFIER? TS)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-001 FOUND?-000))))
     (CL:WHEN TEST-VALUE-001
      (CL:IF
       (CL:AND (ANCHORED-TYPE-SPECIFIER? SLOTTYPE)
        (CL:NOT
         (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)))
       (CL:RETURN-FROM SYS-TREE-IF-NEEDED
        (SET-TARGET-LANGUAGE-TYPE (SYS-TREE TREE RETURNTYPE)
         (CL:IF
          (CL:EQ (%SLOT.SLOT-BASE-TYPE SLOT) SGT-WALK-STELLA-UNKNOWN)
          (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE)
          (%SLOT.SLOT-BASE-TYPE SLOT))))
       (CL:RETURN-FROM SYS-TREE-IF-NEEDED
        (SYS-TREE TREE RETURNTYPE)))))))
  (CL:RETURN-FROM SYS-TREE-IF-NEEDED (CL:VALUES TREE RETURNTYPE)))

;;; (DEFUN (TARGET-LANGUAGE-TYPE TYPE) ...)

(CL:DEFUN TARGET-LANGUAGE-TYPE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-TYPED-SYS)
       (CL:= (LENGTH TREE) 4))
      (CL:RETURN-FROM TARGET-LANGUAGE-TYPE (FOURTH TREE)))))
   (CL:T))
  (CL:RETURN-FROM TARGET-LANGUAGE-TYPE NULL))

;;; (DEFUN (SET-TARGET-LANGUAGE-TYPE CONS TYPE-SPEC) ...)

(CL:DEFUN SET-TARGET-LANGUAGE-TYPE (SYSTREE TYPE)
  (CL:IF (CL:= (LENGTH SYSTREE) 4) (FOURTH-SETTER SYSTREE TYPE)
   (CL:SETF (%%REST (%%REST (%%REST SYSTREE))) (CONS-LIST TYPE)))
  (CL:RETURN-FROM SET-TARGET-LANGUAGE-TYPE
   (CL:VALUES SYSTREE (%%VALUE (%%REST (%%REST SYSTREE))))))

;;; (DEFUN (WALK-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-A-TREE (TREE)
  (CL:RETURN-FROM WALK-A-TREE (HELP-WALK-A-TREE TREE)))

;;; (DEFUN (HELP-WALK-A-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN HELP-WALK-A-TREE (TREE)
  (CL:IF (CL:EQ TREE NULL)
   (CL:RETURN-FROM HELP-WALK-A-TREE
    (CL:VALUES NULL SGT-WALK-STELLA-UNKNOWN))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:EQ TREE NIL)
       (CL:RETURN-FROM HELP-WALK-A-TREE
        (CL:VALUES NIL SGT-WALK-STELLA-CONS)))
      (CL:WHEN (CONS? (%%VALUE TREE))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Unimplemented or illegal parse tree: `"
          (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
       (CL:RETURN-FROM HELP-WALK-A-TREE
        (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
      (CL:WHEN (CL:NOT (CONS? (%%REST TREE)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Illegal dotted pair or list*." EOL)))
       (CL:RETURN-FROM HELP-WALK-A-TREE
        (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VOID-SYS)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE (%%VALUE (%%REST (%%REST TREE))))))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-FOREACH)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-BAD-SYS)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE (%%VALUE (%%REST (%%REST TREE))))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SETQ)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SET-DEFAULT))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SETQ-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SETF)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SETF-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SLOT-VALUE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SLOT-VALUE-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SLOT-VALUE-SETTER)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-SLOT-VALUE-SETTER-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AREF)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AREF-SETTER))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-AREF-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PROGN)
         (CL:SETF (%%REST TREE)
          (WALK-LIST-OF-STATEMENTS (%%REST TREE)))
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (SYS-TREE TREE SGT-WALK-STELLA-VOID)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-WITH-PROCESS-LOCK)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-WITH-PROCESS-LOCK-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-LOOP)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LOOP-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-LET)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LET-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VRLET)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE SGT-WALK-STELLA-UNKNOWN)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VALUES)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-VALUES-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SPECIAL)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SPECIAL))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SPECIAL-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CAST)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SAFE-CAST))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CAST-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-RETURN)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-RETURN-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-MV-SETQ)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MV-SETQ-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-MV-BIND)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MV-BIND-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-BREAK)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CONTINUE))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-LOOP-EXIT-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-WHILE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-WHILE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-FOREACH)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EXISTS)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-FORALL)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SOME)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SETOF)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SET-OF)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SELECT))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-FOREACH-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-IF)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-WHEN)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-UNLESS))
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-CONDITIONAL-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CHOOSE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CHOOSE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-BOOLEAN-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-COND)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-COND-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CASE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CASE-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPECASE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-TYPECASE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQ?)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQL?)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-=))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-EQUALITY-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-+)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA--)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-*)
          (CL:EQ TEST-VALUE-000 |SYM-WALK-STELLA-/|))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-ARITHMETIC-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-QUOTE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-QUOTED-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-BQUOTE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-BQUOTE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PRINT-STREAM)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-PRINT-NATIVE-STREAM))
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-PRINT-STREAM-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NEW)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-ALLOCATE)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-LOCAL-NEW))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-NEW-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-MAKE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-MAKE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-FUNCALL)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-FUNCTION-CODE)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD-CODE))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-FUNCALL-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-THE-CODE)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-THE-CODE-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CALL-SUPER-METHOD)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-CALL-SUPER-METHOD-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SIGNAL-EXCEPTION)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-SIGNAL-EXCEPTION-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EXCEPTION-CASE)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-EXCEPTION-CASE-TREE TREE)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-UNWIND-PROTECT)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-UNWIND-PROTECT))
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (WALK-UNWIND-PROTECT-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VERBATIM)
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-VERBATIM-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-INLINE)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-SUPER-METHOD)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD-SETTER)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-FUNCTION))
         (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-SYS-CALL-TREE TREE)))
        ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-NEW)
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES TREE (%%VALUE (%%REST TREE)))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFCLASS)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFMETHOD)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFUN)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFMACRO)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-STARTUP-TIME-PROGN)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFGLOBAL)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFSPECIAL)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-DEFCONSTANT))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal declaration -- must appear as a top-level statement;"
            EOL "   not nested within other statements.." EOL)))
         (CL:RETURN-FROM HELP-WALK-A-TREE
          (CL:VALUES NULL SGT-WALK-STELLA-VOID)))
        (CL:T
         (CL:IF (SYMBOL? (%%VALUE TREE))
          (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-CALL-SLOT-TREE TREE))
          (CL:PROGN
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
              " Illegal expression where method name expected:" EOL
              "   `" (%%VALUE TREE) "'." EOL)))
           (CL:RETURN-FROM HELP-WALK-A-TREE
            (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))))))))
    (CL:T (CL:RETURN-FROM HELP-WALK-A-TREE (WALK-ATOMIC-TREE TREE))))))

;;; (DEFUN (WALK-A-CONS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-A-CONS-TREE (TREE)
  (CL:LET* ((OTREE NULL) (OTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-A-TREE TREE))
   (CL:RETURN-FROM WALK-A-CONS-TREE (CL:VALUES OTREE OTYPE))))

;;; (DEFGLOBAL *SYMBOL-REGISTRY* ...)

(CL:DEFVAR *SYMBOL-REGISTRY* NULL)

;;; (DEFGLOBAL *SYMBOL-SET* ...)

(CL:DEFVAR *SYMBOL-SET* NULL)

;;; (DEFSPECIAL *CURRENTFILENAME* ...)

(CL:DEFVAR *CURRENTFILENAME* STELLA::NULL-STRING
  "Basename of file that is currently being translated.
A NULL value indicates an incremental translation.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CURRENTFILENAME*))

;;; (DEFUN (INCREMENTAL-TRANSLATION? BOOLEAN) ...)

(CL:DEFUN INCREMENTAL-TRANSLATION? ()
  (CL:RETURN-FROM INCREMENTAL-TRANSLATION?
   (CL:EQ *CURRENTFILENAME* STELLA::NULL-STRING)))

;;; (DEFUN (CONSTRUCT-SYMBOL-CONSTANT-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  CONSTRUCT-SYMBOL-CONSTANT-NAME))
(CL:DEFUN CONSTRUCT-SYMBOL-CONSTANT-NAME (SYMBOL)
  (CL:LET* ((PREFIX STELLA::NULL-STRING) (ENVIRONMENTNAME ""))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX ENVIRONMENTNAME))
   (CL:WHEN
    (CL:NOT (CL:EQ (%GENERALIZED-SYMBOL.HOME-CONTEXT SYMBOL) NULL))
    (CL:SETQ ENVIRONMENTNAME
     (CONCATENATE
      (%MODULE.MODULE-NAME (%GENERALIZED-SYMBOL.HOME-CONTEXT SYMBOL))
      "-")))
   (CL:WHEN
    (CL:NOT
     (CL:OR (INCREMENTAL-TRANSLATION?)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)))
    (CL:SETQ ENVIRONMENTNAME
     (CONCATENATE (STRING-UPCASE *CURRENTFILENAME*) "-"
      ENVIRONMENTNAME)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SYMBOL)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ PREFIX "SYM-")))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ PREFIX "SGT-")))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ PREFIX "KWD-")))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM CONSTRUCT-SYMBOL-CONSTANT-NAME
    (CONCATENATE PREFIX ENVIRONMENTNAME
     (%GENERALIZED-SYMBOL.SYMBOL-NAME SYMBOL)))))

;;; (DEFUN (YIELD-SYMBOL-CONSTANT-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SYMBOL-CONSTANT-NAME (SYMBOL)
  (CL:RETURN-FROM YIELD-SYMBOL-CONSTANT-NAME
   (INTERN-SYMBOL-IN-MODULE
    (CONSTRUCT-SYMBOL-CONSTANT-NAME (PERMANENTIFY SYMBOL)) *MODULE*
    CL:T)))

;;; (DEFUN (CREATE-STARTUP-SYMBOL SYMBOL) ...)

(CL:DEFUN CREATE-STARTUP-SYMBOL (SYMBOL)
  (CL:LET*
   ((SYMBOLMODULE *MODULE*)
    (SYMBOLCONSTANT (YIELD-SYMBOL-CONSTANT-NAME SYMBOL))
    (SYMBOLCONSTANTNAME (%SYMBOL.SYMBOL-NAME SYMBOLCONSTANT))
    (SYMBOLCONSTANTTYPETREE
     (YIELD-TYPE-SPEC-TREE (PRIMARY-TYPE SYMBOL)))
    (LISPPACKAGE (LISP-PACKAGE SYMBOLMODULE)) (TREE NULL))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING SYMBOLCONSTANTNAME LISPPACKAGE))
   (CL:WHEN (INCREMENTAL-TRANSLATION?) (CL:proclaim 
             `(CL:special ,(CL:intern symbolConstantName lispPackage))))
   (CL:SETQ TREE
    (LIST* SYM-WALK-STELLA-DEFGLOBAL SYMBOLCONSTANT
     (CONS SYMBOLCONSTANTTYPETREE
      (LIST* SYM-WALK-STELLA-NULL KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE
       NIL))))
   (WALK-AUXILIARY-TREE TREE)
   (CL:SETQ TREE
    (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-SYMBOLS
     (LIST* SYM-WALK-STELLA-SETQ SYMBOLCONSTANT
      (CONS
       (LIST* SYM-WALK-STELLA-SAFE-CAST
        (LIST* SYM-WALK-STELLA-INTERN-RIGID-SYMBOL-WRT-MODULE
         (WRAP-STRING (%GENERALIZED-SYMBOL.SYMBOL-NAME SYMBOL))
         (CONS
          (CL:IF
           (CL:OR
            (CL:EQ (%GENERALIZED-SYMBOL.HOME-CONTEXT SYMBOL) *MODULE*)
            (KEYWORD? SYMBOL))
           SYM-WALK-STELLA-NULL
           (LIST* SYM-WALK-STELLA-GET-STELLA-MODULE
            (WRAP-STRING
             (%MODULE.MODULE-FULL-NAME
              (%GENERALIZED-SYMBOL.HOME-CONTEXT SYMBOL)))
            (CONS SYM-WALK-STELLA-TRUE NIL)))
          (CONS
           (WRAP-INTEGER
            (CL:IF (KEYWORD? SYMBOL) KEYWORD-SYM
             (CL:IF (SURROGATE? SYMBOL) SURROGATE-SYM SYMBOL-SYM)))
           NIL)))
        SYMBOLCONSTANTTYPETREE NIL)
       NIL))
     NIL))
   (WALK-AUXILIARY-TREE TREE)
   (CL:RETURN-FROM CREATE-STARTUP-SYMBOL SYMBOLCONSTANT)))

;;; (DEFUN (REGISTER-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN REGISTER-SYMBOL (SYMBOL)
  (CL:SETQ SYMBOL (PERMANENTIFY SYMBOL))
  (CL:LET* ((REGISTEREDSYMBOL (LOOKUP *SYMBOL-REGISTRY* SYMBOL)))
   (CL:WHEN (CL:EQ REGISTEREDSYMBOL NULL) (INSERT *SYMBOL-SET* SYMBOL)
    (CL:IF (USE-HARDCODED-SYMBOLS?) (CL:SETQ REGISTEREDSYMBOL SYMBOL)
     (CL:SETQ REGISTEREDSYMBOL (CREATE-STARTUP-SYMBOL SYMBOL)))
    (INSERT-AT *SYMBOL-REGISTRY* SYMBOL REGISTEREDSYMBOL))
   (CL:RETURN-FROM REGISTER-SYMBOL REGISTEREDSYMBOL)))

;;; (DEFUN CLEAR-SYMBOL-REGISTRY ...)

(CL:DEFUN CLEAR-SYMBOL-REGISTRY ()
  (CL:LET*
   ((SYMBOL NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYMBOL-SET*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SYMBOL (%%VALUE ITER-000))
    (REMOVE-AT *SYMBOL-REGISTRY* SYMBOL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CLEAR *SYMBOL-SET*)
  :VOID)

;;; (DEFUN (YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE CONS) ...)

(CL:DEFUN YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE ()
  (CL:LET*
   ((INTERNTREES
     (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-SYMBOLS NIL)))
   (CL:LET*
    ((SYMBOL NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYMBOL-SET*))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYMBOL (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CONS
          (CL:IF (SYMBOL? SYMBOL) SYM-WALK-STELLA-INTERN-SYMBOL-AT
           (CL:IF (SURROGATE? SYMBOL)
            SYM-WALK-STELLA-INTERN-SURROGATE-AT
            SYM-WALK-STELLA-INTERN-KEYWORD-AT))
          (CONS (WRAP-STRING (%GENERALIZED-SYMBOL.SYMBOL-NAME SYMBOL))
           (CONS (WRAP-INTEGER (%GENERALIZED-SYMBOL.SYMBOL-ID SYMBOL))
            NIL)))
         NIL))
       (CL:IF (CL:EQ INTERNTREES NIL) (CL:SETQ INTERNTREES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST INTERNTREES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CONS
          (CL:IF (SYMBOL? SYMBOL) SYM-WALK-STELLA-INTERN-SYMBOL-AT
           (CL:IF (SURROGATE? SYMBOL)
            SYM-WALK-STELLA-INTERN-SURROGATE-AT
            SYM-WALK-STELLA-INTERN-KEYWORD-AT))
          (CONS (WRAP-STRING (%GENERALIZED-SYMBOL.SYMBOL-NAME SYMBOL))
           (CONS (WRAP-INTEGER (%GENERALIZED-SYMBOL.SYMBOL-ID SYMBOL))
            NIL)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE
    INTERNTREES)))

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(%%DEFCONSMETHOD WALK-ATOMIC-TREE ((SELF OBJECT))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "walk-atomic-tree: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF WRAPPER))
  (CL:RETURN-FROM WALK-ATOMIC-TREE
   (CL:VALUES SELF (WRAPPER-VALUE-TYPE SELF))))

;;; (DEFUN (LOOKUP-CONSTANT-SYMBOL TYPE) ...)

(CL:DEFUN LOOKUP-CONSTANT-SYMBOL (SELF)
  (CL:COND
   ((CL:EQ SELF SYM-WALK-STELLA-NULL)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-STELLA-UNKNOWN))
   ((CL:EQ SELF SYM-WALK-STELLA-TRUE)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-STELLA-BOOLEAN))
   ((CL:EQ SELF SYM-WALK-STELLA-FALSE)
    (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL SGT-WALK-STELLA-BOOLEAN))
   (CL:T (CL:RETURN-FROM LOOKUP-CONSTANT-SYMBOL NULL))))

;;; (DEFUN (CONSTANT-SYMBOL? BOOLEAN) ...)

(CL:DEFUN CONSTANT-SYMBOL? (SYMBOL)
  (CL:RETURN-FROM CONSTANT-SYMBOL?
   (CL:NOT (CL:EQ (LOOKUP-CONSTANT-SYMBOL SYMBOL) NULL))))

;;; (DEFUN (WALK-CONSTANT-SYMBOL SYMBOL TYPE) ...)

(CL:DEFUN WALK-CONSTANT-SYMBOL (SELF)
  (CL:RETURN-FROM WALK-CONSTANT-SYMBOL
   (CL:VALUES SELF (LOOKUP-CONSTANT-SYMBOL SELF))))

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF SYMBOL))
  (CL:WHEN (CONSTANT-SYMBOL? SELF)
   (CL:RETURN-FROM WALK-ATOMIC-TREE (WALK-CONSTANT-SYMBOL SELF)))
  (CL:WHEN
   (CL:AND *INLININGMETHODCALL?*
    (CL:NOT
     (CL:EQ (GET-LOCAL-VARIABLE-INFO SELF KWD-WALK-INLINE-ARGUMENT)
      NULL)))
   (CL:RETURN-FROM WALK-ATOMIC-TREE
    (WALK-INLINE-VARIABLE-REFERENCE SELF)))
  (CL:LET*
   ((TRUENAME (TRUE-VARIABLE-NAME SELF))
    (TYPE (LOOKUP-VARIABLE-TYPE SELF)))
   (CL:IF (CL:EQ TRUENAME SELF)
    (CL:RETURN-FROM WALK-ATOMIC-TREE (CL:VALUES SELF TYPE))
    (CL:RETURN-FROM WALK-ATOMIC-TREE
     (CL:VALUES (SYS-TREE TRUENAME TYPE) TYPE)))))

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF KEYWORD))
  (REGISTER-SYMBOL SELF)
  (CL:RETURN-FROM WALK-ATOMIC-TREE
   (CL:VALUES SELF SGT-WALK-STELLA-KEYWORD)))

;;; (DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD WALK-ATOMIC-TREE ((SELF SURROGATE))
  (REGISTER-SYMBOL SELF)
  (CL:RETURN-FROM WALK-ATOMIC-TREE
   (CL:VALUES SELF SGT-WALK-STELLA-SURROGATE)))

;;; (DEFUN (ATOMIC-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN ATOMIC-EXPRESSION? (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:COND
      ((CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-TYPED-SYS)
       (CL:RETURN-FROM ATOMIC-EXPRESSION?
        (ATOMIC-EXPRESSION? (%%VALUE (%%REST TREE)))))
      (CL:T))
     (CL:RETURN-FROM ATOMIC-EXPRESSION? CL:NIL)))
   (CL:T (CL:RETURN-FROM ATOMIC-EXPRESSION? CL:T))))

;;; (DEFUN (VARIABLE-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN VARIABLE-EXPRESSION? (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:COND
       ((CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-TYPED-SYS)
        (CL:RETURN-FROM VARIABLE-EXPRESSION?
         (VARIABLE-EXPRESSION? (%%VALUE (%%REST TREE)))))
       (CL:T))
      (CL:RETURN-FROM VARIABLE-EXPRESSION? CL:NIL)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM VARIABLE-EXPRESSION? CL:T)))
    (CL:T (CL:RETURN-FROM VARIABLE-EXPRESSION? CL:NIL)))))

;;; (DEFUN (VRLET-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN VRLET-EXPRESSION? (TREE)
  (CL:RETURN-FROM VRLET-EXPRESSION?
   (CL:AND (CONS? TREE) (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-VRLET))))

;;; (DEFUN (PROCEDURAL-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN PROCEDURAL-EXPRESSION? (TREE)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (CONS? TREE))
   (CL:WHEN TEST-VALUE-000
    (CL:IF (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-VRLET)
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((TERM NULL) (ITER-000 (%%REST TREE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ TERM (%%VALUE ITER-000))
        (CL:WHEN (PROCEDURAL-EXPRESSION? TERM)
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM PROCEDURAL-EXPRESSION? VALUE-000))))

;;; (DEFUN (SUBSTITUTE-ONCE BOOLEAN) ...)

(CL:DEFUN SUBSTITUTE-ONCE (EXPRESSION NEWTREE OLDTREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE EXPRESSION) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (CL:NOT (CL:EQ EXPRESSION NIL))
      (CL:WHEN (EQL? (%%VALUE EXPRESSION) OLDTREE)
       (CL:SETF (%%VALUE EXPRESSION) NEWTREE)
       (CL:RETURN-FROM SUBSTITUTE-ONCE CL:T))
      (CL:RETURN-FROM SUBSTITUTE-ONCE
       (CL:OR (SUBSTITUTE-ONCE (%%VALUE EXPRESSION) NEWTREE OLDTREE)
        (SUBSTITUTE-ONCE (%%REST EXPRESSION) NEWTREE OLDTREE))))))
   (CL:T))
  (CL:RETURN-FROM SUBSTITUTE-ONCE CL:NIL))

;;; (DEFUN (TRANSFORM-VRLET-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-VRLET-EXPRESSION (STATEMENT VREXPRESSION)
  (CL:LET* ((CURSOR NULL) (LASTSTATEMENT NULL))
   (SUBSTITUTE-ONCE STATEMENT KWD-WALK-PLACE-WHERE-VRLET-WAS
    VREXPRESSION)
   (CL:SETF (%%VALUE VREXPRESSION) SYM-WALK-STELLA-LET)
   (CL:SETQ CURSOR (%%REST (%%REST VREXPRESSION)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (CL:EQ (%%REST CURSOR) NIL)
     (CL:SETQ LASTSTATEMENT (%%VALUE CURSOR))
     (CL:SETF (%%VALUE CURSOR) STATEMENT) (CL:RETURN))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (SUBSTITUTE-ONCE STATEMENT LASTSTATEMENT
    KWD-WALK-PLACE-WHERE-VRLET-WAS)
   (CL:RETURN-FROM TRANSFORM-VRLET-EXPRESSION
    (WALK-A-CONS-TREE VREXPRESSION))))

;;; (DEFUN (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS) ...)

(CL:DEFUN HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION (EXPRESSION TESTVARIABLE)
  (CL:WHEN
   (CL:OR (CL:NOT (CONS? EXPRESSION))
    (CL:NOT (PROCEDURAL-EXPRESSION? EXPRESSION)))
   (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (CONS
     (LIST* SYM-WALK-STELLA-SETQ TESTVARIABLE (CONS EXPRESSION NIL))
     NIL)))
  (CL:LET*
   ((EXP EXPRESSION) (OPERATOR (%%VALUE EXP))
    (FIRSTARG (%%VALUE (%%REST EXP)))
    (OTHERARGS (%%REST (%%REST EXP))))
   (CL:LET* ((TEST-VALUE-000 OPERATOR))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
      (CL:COND
       ((CL:EQ OTHERARGS NIL)
        (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG
          TESTVARIABLE)))
       ((PROCEDURAL-EXPRESSION? FIRSTARG)
        (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (CONCATENATE
          (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG
           TESTVARIABLE)
          (CONS
           (LIST* SYM-WALK-STELLA-WHEN TESTVARIABLE
            (CONCATENATE
             (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
              (CONS SYM-WALK-STELLA-AND (CONCATENATE OTHERARGS NIL))
              TESTVARIABLE)
             NIL))
           NIL))))
       (CL:T
        (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (LIST*
          (LIST* SYM-WALK-STELLA-SETQ TESTVARIABLE (CONS FIRSTARG NIL))
          (LIST* SYM-WALK-STELLA-WHEN TESTVARIABLE
           (CONCATENATE
            (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
             (CONS SYM-WALK-STELLA-AND (CONCATENATE OTHERARGS NIL))
             TESTVARIABLE)
            NIL))
          NIL)))))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
      (CL:COND
       ((CL:EQ OTHERARGS NIL)
        (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG
          TESTVARIABLE)))
       ((PROCEDURAL-EXPRESSION? FIRSTARG)
        (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
         (CONCATENATE
          (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG
           TESTVARIABLE)
          (CONS
           (LIST* SYM-WALK-STELLA-WHEN
            (LIST* SYM-WALK-STELLA-NOT TESTVARIABLE NIL)
            (CONCATENATE
             (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
              (CONS SYM-WALK-STELLA-OR (CONCATENATE OTHERARGS NIL))
              TESTVARIABLE)
             NIL))
           NIL))))
       (CL:T
        (CL:LET*
         ((OTHERARGSTEST
           (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
            (CONS SYM-WALK-STELLA-OR (CONCATENATE OTHERARGS NIL))
            TESTVARIABLE)))
         (CL:WHEN (CL:NOT (CL:EQ (%%REST OTHERARGSTEST) NIL))
          (CL:SETQ OTHERARGSTEST
           (CONS
            (CONS SYM-WALK-STELLA-PROGN
             (CONCATENATE OTHERARGSTEST NIL))
            NIL)))
         (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
          (CONS
           (LIST* SYM-WALK-STELLA-IF FIRSTARG
            (CONS
             (LIST* SYM-WALK-STELLA-SETQ TESTVARIABLE
              (CONS SYM-WALK-STELLA-TRUE NIL))
             (CONCATENATE OTHERARGSTEST NIL)))
           NIL))))))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT)
      (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
       (CONCATENATE
        (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION FIRSTARG
         TESTVARIABLE)
        (CONS
         (LIST* SYM-WALK-STELLA-SETQ TESTVARIABLE
          (CONS (LIST* SYM-WALK-STELLA-NOT TESTVARIABLE NIL) NIL))
         NIL))))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VRLET)
      (CL:LET* ((CURSOR OTHERARGS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ (%%REST CURSOR) NIL)) DO
        (CL:SETQ CURSOR (%%REST CURSOR)))
       (CL:SETF (%%VALUE CURSOR)
        (LIST* SYM-WALK-STELLA-SETQ TESTVARIABLE
         (CONS (%%VALUE CURSOR) NIL))))
      (CL:RETURN-FROM HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
       (CONS
        (LIST* SYM-WALK-STELLA-LET FIRSTARG
         (CONCATENATE OTHERARGS NIL))
        NIL)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION (STATEMENT VREXPRESSION)
  (CL:WHEN (CL:EQ (%%VALUE VREXPRESSION) SYM-WALK-STELLA-VRLET)
   (CL:RETURN-FROM TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (TRANSFORM-VRLET-EXPRESSION STATEMENT VREXPRESSION)))
  (CL:LET* ((TESTVARIABLE (LOCAL-GENSYM "TEST-VALUE")) (OTREE NULL))
   (SUBSTITUTE-ONCE STATEMENT TESTVARIABLE VREXPRESSION)
   (CL:SETQ OTREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST* SYM-WALK-STELLA-LET
      (CONS (CONS TESTVARIABLE (CONS SYM-WALK-STELLA-FALSE NIL)) NIL)
      (CONCATENATE
       (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION VREXPRESSION
        TESTVARIABLE)
       (CONS STATEMENT NIL)))))
   (CL:RETURN-FROM TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION
    (CL:VALUES OTREE SGT-WALK-STELLA-BOOLEAN))))

;;; (DEFUN (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS CONS) ...)

(CL:DEFUN PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS (BOOLEANEXPRESSION)
  (CL:LET* ((TESTVARIABLE (LOCAL-GENSYM "TEST-VALUE")) (OTREE NULL))
   (CL:SETQ OTREE
    (LIST* SYM-WALK-STELLA-VRLET
     (CONS (CONS TESTVARIABLE (CONS SYM-WALK-STELLA-FALSE NIL)) NIL)
     (CONCATENATE
      (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION BOOLEANEXPRESSION
       TESTVARIABLE)
      (CONS TESTVARIABLE NIL))))
   (CL:RETURN-FROM PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS OTREE)))

;;; (DEFUN (TRANSFORM-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN TRANSFORM-PROCEDURAL-EXPRESSION (STATEMENT VREXPRESSION TYPE)
  (CL:IF (CL:EQ (TYPE-SPEC-TO-BASE-TYPE TYPE) SGT-WALK-STELLA-BOOLEAN)
   (CL:RETURN-FROM TRANSFORM-PROCEDURAL-EXPRESSION
    (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION STATEMENT VREXPRESSION))
   (CL:RETURN-FROM TRANSFORM-PROCEDURAL-EXPRESSION
    (TRANSFORM-VRLET-EXPRESSION STATEMENT VREXPRESSION))))

;;; (DEFUN (PERCOLATE-OUT-VRLET-EXPRESSION CONS TYPE-SPEC) ...)

(CL:DEFUN PERCOLATE-OUT-VRLET-EXPRESSION (STATEMENT VREXPRESSION TYPE)
  (CL:LET*
   ((LASTSTATEMENT NULL) (CURSOR (%%REST (%%REST VREXPRESSION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (CL:EQ (%%REST CURSOR) NIL)
     (CL:SETQ LASTSTATEMENT (%%VALUE CURSOR))
     (CL:SETF (%%VALUE CURSOR)
      KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS)
     (CL:RETURN))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (SUBSTITUTE-ONCE STATEMENT LASTSTATEMENT VREXPRESSION)
   (SUBSTITUTE-ONCE VREXPRESSION STATEMENT
    KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS)
   (CL:RETURN-FROM PERCOLATE-OUT-VRLET-EXPRESSION
    (CL:VALUES VREXPRESSION TYPE))))

;;; (DEFUN (WALK-SETQ-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SETQ-TREE (TREE)
  (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 2)
   (CL:RETURN-FROM WALK-SETQ-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:LET*
   ((VARIABLE (%%VALUE (%%REST TREE)))
    (VALUE (%%VALUE (%%REST (%%REST TREE)))) (VARIABLETYPE NULL)
    (OVALUE NULL) (OTYPE NULL))
   (CL:WHEN (CL:NOT (SYMBOL? VARIABLE))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal first argument to 'setq'; should be a symbol: `"
       (DE-UGLIFY-PARSE-TREE VARIABLE) "'." EOL)))
    (CL:RETURN-FROM WALK-SETQ-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
   (CL:SETQ VARIABLETYPE (LOOKUP-VARIABLE-TYPE VARIABLE))
   (CL:MULTIPLE-VALUE-SETQ (OVALUE OTYPE)
    (WALK-EXPRESSION-TREE VALUE VARIABLETYPE SYM-WALK-STELLA-SETQ
     CL:T))
   (THIRD-SETTER TREE OVALUE)
   (CL:WHEN (CL:NOT (PROCEDURAL-EXPRESSION? OVALUE))
    (SECOND-SETTER TREE (TRUE-VARIABLE-NAME VARIABLE))
    (CL:WHEN
     (CL:AND (WALKING-EXPRESSION?)
      (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)))
     (CL:RETURN-FROM WALK-SETQ-TREE
      (SET-TARGET-LANGUAGE-TYPE (SYS-TREE TREE OTYPE)
       (TYPE-SPEC-TO-BASE-TYPE VARIABLETYPE))))
    (CL:IF (CL:NOT (EQL? VARIABLE (%%VALUE (%%REST TREE))))
     (CL:RETURN-FROM WALK-SETQ-TREE (SYS-TREE TREE OTYPE))
     (CL:RETURN-FROM WALK-SETQ-TREE (CL:VALUES TREE OTYPE))))
   (CL:RETURN-FROM WALK-SETQ-TREE
    (TRANSFORM-PROCEDURAL-EXPRESSION TREE OVALUE
     (CL:IF (CL:EQ OTYPE SGT-WALK-STELLA-UNKNOWN) VARIABLETYPE OTYPE)))))

;;; (DEFUN (YIELD-FIXED-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-FIXED-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUETREE)
  (CL:RETURN-FROM YIELD-FIXED-SLOT-VALUE-SETTER-TREE
   (LIST* SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER (%SLOT.SLOT-OWNER SLOT)
    (CONS (%SLOT.SLOT-NAME SLOT)
     (CONS OBJECTREF
      (CONS
       (WALK-EXPRESSION-TREE VALUETREE (TYPE SLOT)
        SYM-WALK-STELLA-SLOT-VALUE-SETTER CL:NIL)
       NIL))))))

;;; (DEFUN (WALK-SETF-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SETF-TREE (TREE)
  (CL:LET* ((PLACE NULL))
   (CL:WHEN (CONS? (%%VALUE (%%REST TREE)))
    (CL:SETQ PLACE (%%VALUE (%%REST TREE))))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ PLACE NULL)) (SYMBOL? (%%VALUE PLACE))
      (CL:>= (LENGTH PLACE)
       (CL:IF (CL:EQ (%%VALUE PLACE) SYM-WALK-STELLA-SLOT-VALUE) 3
        2))))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal place argument in 'setf' expression: `"
       (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
    (CL:RETURN-FROM WALK-SETF-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
   (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 2)
    (CL:RETURN-FROM WALK-SETF-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
   (CL:LET* ((OBJECTREF NULL) (OBJECTTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OBJECTREF OBJECTTYPE)
     (WALK-A-TREE (%%VALUE (%%REST PLACE))))
    (CL:SETQ OBJECTREF (COERCE-A-TREE OBJECTREF OBJECTTYPE OBJECTTYPE))
    (CL:LET*
     ((OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
      (SLOTNAME (%%VALUE PLACE))
      (SLOT (LOOKUP-SLOT OBJECTCLASS SLOTNAME)) (SLOTTYPE NULL)
      (OTHERPLACEARGUMENTS (%%REST (%%REST PLACE))) (OTREE NIL))
     (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
      (CL:SETQ SLOTTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE)))
     (CL:LET* ((VALUEREF NULL) (VALUETYPESPEC NULL))
      (CL:MULTIPLE-VALUE-SETQ (VALUEREF VALUETYPESPEC)
       (WALK-EXPRESSION-TREE (%%VALUE (%%REST (%%REST TREE))) SLOTTYPE
        SYM-WALK-STELLA-SETF CL:T))
      (CL:WHEN (PROCEDURAL-EXPRESSION? VALUEREF)
       (THIRD-SETTER TREE VALUEREF)
       (CL:LET* ((OOTREE NULL) (OTYPESPEC NULL))
        (CL:MULTIPLE-VALUE-SETQ (OOTREE OTYPESPEC)
         (TRANSFORM-PROCEDURAL-EXPRESSION TREE VALUEREF VALUETYPESPEC))
        (CL:RETURN-FROM WALK-SETF-TREE (CL:VALUES OOTREE OTYPESPEC))))
      (CL:WHEN (CL:EQ SLOTNAME SYM-WALK-STELLA-SLOT-VALUE)
       (CL:RETURN-FROM WALK-SETF-TREE
        (WALK-A-CONS-TREE
         (LIST* SYM-WALK-STELLA-SLOT-VALUE-SETTER OBJECTREF
          (CONS VALUEREF (CONCATENATE OTHERPLACEARGUMENTS NIL))))))
      (CL:COND
       ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE SLOT))
        (CL:PROGN
         (CL:WHEN
          (CL:OR (CL:NOT (CL:EQ (WRITER SLOT) NULL))
           (CL:NOT
            (CL:EQ
             (LOOKUP-SLOT OBJECTCLASS
              (YIELD-SETTER-METHOD-NAME SLOTNAME))
             NULL)))
          (CL:RETURN-FROM WALK-SETF-TREE
           (WALK-A-CONS-TREE
            (CONS
             (CL:IF (CL:NOT (CL:EQ (WRITER SLOT) NULL)) (WRITER SLOT)
              (YIELD-SETTER-METHOD-NAME SLOTNAME))
             (CONS OBJECTREF
              (CONS VALUEREF
               (CONCATENATE OTHERPLACEARGUMENTS NIL)))))))
         (CL:WHEN (SYSTEM-DEFINED-SLOT-WRITER? SLOT)
          (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
           (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
            (SYS-TREE-IF-NEEDED SLOT
             (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
              (%STORAGE-SLOT.SLOT-OWNER SLOT)
              (CONS (YIELD-SETTER-METHOD-NAME SLOTNAME)
               (CONS OBJECTREF
                (CONS
                 (WALK-EXPRESSION-TREE VALUEREF SLOTTYPE
                  SYM-WALK-STELLA-SETF CL:NIL)
                 NIL))))
             OBJECTTYPE SLOTTYPE))
           (CL:RETURN-FROM WALK-SETF-TREE
            (CL:VALUES VALUE-000 VALUE-001))))
         (CL:SETQ OTREE
          (YIELD-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF OBJECTTYPE
           VALUEREF SLOTTYPE NULL))
         (CL:IF (PROCEDURAL-EXPRESSION? OTREE)
          (CL:RETURN-FROM WALK-SETF-TREE (CL:VALUES OTREE SLOTTYPE))
          (CL:LET* ((VALUE-002 NULL) (VALUE-003 NULL))
           (CL:MULTIPLE-VALUE-SETQ (VALUE-002 VALUE-003)
            (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE SLOTTYPE))
           (CL:RETURN-FROM WALK-SETF-TREE
            (CL:VALUES VALUE-002 VALUE-003))))))
       (CL:T
        (CL:RETURN-FROM WALK-SETF-TREE
         (WALK-A-CONS-TREE
          (CONS (YIELD-SETTER-METHOD-NAME SLOTNAME)
           (CONS OBJECTREF
            (CONS VALUEREF
             (CONCATENATE OTHERPLACEARGUMENTS NIL)))))))))))))

;;; (DEFUN (YIELD-DYNAMIC-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN YIELD-DYNAMIC-SLOT-VALUE-TREE (SLOT OBJECTREF RETURNTYPE)
  (CL:WHEN (STANDARD-DYNAMIC-SLOT-ACCESS? SLOT)
   (CL:RETURN-FROM YIELD-DYNAMIC-SLOT-VALUE-TREE
    (YIELD-STANDARD-DYNAMIC-SLOT-VALUE-TREE SLOT OBJECTREF RETURNTYPE)))
  (CL:LET* ((TEST-VALUE-000 (ALLOCATION SLOT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-WALK-DYNAMIC)
     (CL:LET* ((ANSWERVAR (LOCAL-GENSYM "ANSWER")))
      (CL:RETURN-FROM YIELD-DYNAMIC-SLOT-VALUE-TREE
       (LIST* SYM-WALK-STELLA-VRLET
        (CONS
         (CONS ANSWERVAR
          (CONS RETURNTYPE
           (CONS
            (TYPE-TO-WALKED-NULL-VALUE-TREE (TYPE-SPECIFIER SLOT)
             (TYPE SLOT))
            NIL)))
         NIL)
        (LIST* SYM-WALK-STELLA-FOREACH SYM-WALK-STELLA-IT
         SYM-WALK-STELLA-ON
         (LIST* SYM-WALK-STELLA-DYNAMIC-SLOTS OBJECTREF NIL)
         SYM-WALK-STELLA-WHERE
         (LIST* SYM-WALK-STELLA-EQ?
          (LIST* SYM-WALK-STELLA-KEY SYM-WALK-STELLA-IT NIL)
          (LIST* SYM-WALK-STELLA-BQUOTE (%STORAGE-SLOT.SLOT-NAME SLOT)
           NIL)
          NIL)
         SYM-WALK-STELLA-DO
         (CL:IF (SLOT-VALUE-IS-BARE-LITERAL? SLOT)
          (LIST* SYM-WALK-STELLA-LET
           (CONS
            (LIST* SYM-WALK-STELLA-WRAPPEDVALUE
             (TYPE-TO-WRAPPED-TYPE (TYPE SLOT))
             (CONS (LIST* SYM-WALK-STELLA-VALUE SYM-WALK-STELLA-IT NIL)
              NIL))
            NIL)
           (LIST* SYM-WALK-STELLA-SETQ ANSWERVAR
            (CONS
             (LIST* SYM-WALK-STELLA-WRAPPER-VALUE
              SYM-WALK-STELLA-WRAPPEDVALUE NIL)
             NIL))
           NIL)
          (LIST* SYM-WALK-STELLA-SETQ ANSWERVAR
           (CONS (LIST* SYM-WALK-STELLA-VALUE SYM-WALK-STELLA-IT NIL)
            NIL)))
         (CONS (CONS SYM-WALK-STELLA-BREAK NIL) NIL))
        ANSWERVAR NIL))))
    ((CL:EQ TEST-VALUE-000 KWD-WALK-BIT)
     (CL:ERROR
      (NEW-STELLA-EXCEPTION "Allocation :bit IS NOT YET IMPLEMENTED")))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUEREF RETURNTYPE)
  (CL:LET* ((SLOTNAME (%STORAGE-SLOT.SLOT-NAME SLOT)))
   (CL:WHEN (STANDARD-DYNAMIC-SLOT-ACCESS? SLOT)
    (CL:RETURN-FROM YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE
     (YIELD-STANDARD-DYNAMIC-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF
      VALUEREF RETURNTYPE)))
   (CL:LET* ((TEST-VALUE-000 (ALLOCATION SLOT)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-WALK-DYNAMIC)
      (CL:RETURN-FROM YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE
       (LIST* SYM-WALK-STELLA-VRLET
        (LIST*
         (LIST* SYM-WALK-STELLA-DYNAMICSLOTS
          (LIST* SYM-WALK-STELLA-DYNAMIC-SLOTS OBJECTREF NIL) NIL)
         (LIST* SYM-WALK-STELLA-NEWVALUE VALUEREF NIL)
         (LIST* SYM-WALK-STELLA-FOUNDMATCHINGENTRY?
          SYM-WALK-STELLA-FALSE NIL)
         NIL)
        (LIST* SYM-WALK-STELLA-FOREACH SYM-WALK-STELLA-IT
         SYM-WALK-STELLA-ON SYM-WALK-STELLA-DYNAMICSLOTS
         SYM-WALK-STELLA-WHERE
         (LIST* SYM-WALK-STELLA-EQ?
          (LIST* SYM-WALK-STELLA-KEY SYM-WALK-STELLA-IT NIL)
          (LIST* SYM-WALK-STELLA-BQUOTE SLOTNAME NIL) NIL)
         SYM-WALK-STELLA-DO
         (CL:IF (SLOT-VALUE-IS-BARE-LITERAL? SLOT)
          (LIST* SYM-WALK-STELLA-LET
           (CONS
            (LIST* SYM-WALK-STELLA-OLDVALUE
             (TYPE-TO-SYMBOL (TYPE-TO-WRAPPED-TYPE (TYPE SLOT)))
             (CONS (LIST* SYM-WALK-STELLA-VALUE SYM-WALK-STELLA-IT NIL)
              NIL))
            NIL)
           (LIST* SYM-WALK-STELLA-SETF
            (LIST* SYM-WALK-STELLA-WRAPPER-VALUE
             SYM-WALK-STELLA-OLDVALUE NIL)
            SYM-WALK-STELLA-NEWVALUE NIL)
           NIL)
          (LIST* SYM-WALK-STELLA-SETF
           (LIST* SYM-WALK-STELLA-VALUE SYM-WALK-STELLA-IT NIL)
           SYM-WALK-STELLA-NEWVALUE NIL))
         (CONS
          (LIST* SYM-WALK-STELLA-SETQ
           SYM-WALK-STELLA-FOUNDMATCHINGENTRY? SYM-WALK-STELLA-TRUE
           NIL)
          NIL))
        (LIST* SYM-WALK-STELLA-WHEN
         (LIST* SYM-WALK-STELLA-AND
          (LIST* SYM-WALK-STELLA-NOT
           SYM-WALK-STELLA-FOUNDMATCHINGENTRY? NIL)
          (LIST* SYM-WALK-STELLA-DEFINED? SYM-WALK-STELLA-NEWVALUE NIL)
          NIL)
         (LIST* SYM-WALK-STELLA-SETF
          (LIST* SYM-WALK-STELLA-THE-KV-LIST
           SYM-WALK-STELLA-DYNAMICSLOTS NIL)
          (LIST* SYM-WALK-STELLA-KV-CONS
           (LIST* SYM-WALK-STELLA-BQUOTE SLOTNAME NIL)
           (CL:IF (SLOT-VALUE-IS-BARE-LITERAL? SLOT)
            (LIST* SYM-WALK-STELLA-WRAP-LITERAL
             SYM-WALK-STELLA-NEWVALUE NIL)
            SYM-WALK-STELLA-NEWVALUE)
           (CONS
            (LIST* SYM-WALK-STELLA-THE-KV-LIST
             SYM-WALK-STELLA-DYNAMICSLOTS NIL)
            NIL))
          NIL)
         NIL)
        SYM-WALK-STELLA-NEWVALUE NIL)))
     ((CL:EQ TEST-VALUE-000 KWD-WALK-BIT)
      (CL:ERROR
       (NEW-STELLA-EXCEPTION
        "Allocation :bit IS NOT YET IMPLEMENTED")))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (YIELD-NATIVE-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN YIELD-NATIVE-SLOT-VALUE-TREE (SLOT OBJECTREF OBJECTTYPE)
  (CL:SETQ SLOT (CANONICAL-SLOT SLOT))
  (CL:LET*
   ((MIXINSLOT?
     (%CLASS.MIXIN?
      (%SURROGATE.SURROGATE-VALUE (%STORAGE-SLOT.SLOT-OWNER SLOT))))
    (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE)))
   (CL:WHEN
    (CL:AND MIXINSLOT? (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
    (CL:WHEN (%CLASS.MIXIN? OBJECTCLASS)
     (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-TREE
      (SYS-TREE
       (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD SGT-WALK-STELLA-OBJECT
        (YIELD-NATIVE-SLOT-READER-NAME SLOT) (CONS OBJECTREF NIL))
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
           SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)
          NULL))
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)
        (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))))))
   (CL:IF (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
    (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-TREE
     (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
      (%CLASS.CLASS-TYPE OBJECTCLASS)
      (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) (CONS OBJECTREF NIL))))
    (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-TREE
     (LIST* SYM-WALK-STELLA-SYS-SLOT-VALUE
      (%CLASS.CLASS-TYPE OBJECTCLASS)
      (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) (CONS OBJECTREF NIL)))))))

;;; (DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE (SLOT OBJECTREF RETURNTYPE CSOPTIONS)
  (CL:LET*
   ((CONTEXTSENSITIVE?
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ (SEARCH-PLIST CSOPTIONS KWD-WALK-CONTEXT-SENSITIVE?)
        SYM-WALK-STELLA-FALSE))))
    (DONTINHERIT?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ (SEARCH-PLIST CSOPTIONS KWD-WALK-DONT-INHERIT?)
        SYM-WALK-STELLA-TRUE))
      SYM-WALK-STELLA-TRUE SYM-WALK-STELLA-FALSE))
    (OBJECTREFCOPY OBJECTREF)
    (ONCEONLYWRAPPER?
     (CL:AND CONTEXTSENSITIVE?
      (CL:NOT (SIDE-EFFECT-FREE-EXPRESSION? OBJECTREF))))
    (LITERALSLOT? (SLOT-VALUE-IS-BARE-LITERAL? SLOT))
    (REALBASETYPE (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))
    (REALTYPESPEC
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
      SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (OLDVALUETREE NULL) (OLDVALUEREF (LOCAL-GENSYM "OLD-VALUE"))
    (ACCESSTREE NULL))
   (CL:COND
    (ONCEONLYWRAPPER? (CL:SETQ OBJECTREF (LOCAL-GENSYM "OBJECT"))
     (PUSH-VARIABLE-BINDING OBJECTREF (%STORAGE-SLOT.SLOT-OWNER SLOT)))
    (CL:T
     (CL:SETQ OBJECTREF
      (SYS-TREE (WALK-WITHOUT-TYPE-TREE OBJECTREF)
       (%STORAGE-SLOT.SLOT-OWNER SLOT)))))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) SGT-WALK-STELLA-OBJECT)
   (CL:WHEN (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT) CL:NIL)
   (CL:SETQ OLDVALUETREE
    (SYS-TREE
     (WALK-WITHOUT-TYPE-TREE
      (LIST* SYM-WALK-STELLA-SLOT-VALUE
       (CL:IF CONTEXTSENSITIVE? (COPY-CONS-TREE OBJECTREF) OBJECTREF)
       (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) NIL)))
     SGT-WALK-STELLA-OBJECT))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) REALBASETYPE)
   (CL:WHEN (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER REALTYPESPEC NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT) CL:T)
   (CL:WHEN (CL:NOT CONTEXTSENSITIVE?)
    (CL:RETURN-FROM YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES OLDVALUETREE SGT-WALK-STELLA-OBJECT)))
   (CL:WHEN ONCEONLYWRAPPER? (POP-VARIABLE-BINDING))
   (CL:SETQ ACCESSTREE
    (LIST* SYM-WALK-STELLA-SAFE-CAST
     (LIST* SYM-WALK-STELLA-ACCESS-IN-CONTEXT
      (CL:IF ONCEONLYWRAPPER? OLDVALUEREF OLDVALUETREE)
      (LIST* (LIST* SYM-WALK-STELLA-HOME-CONTEXT OBJECTREF NIL)
       DONTINHERIT? NIL))
     (YIELD-TYPE-SPEC-TREE
      (CL:IF LITERALSLOT? (TYPE-TO-WRAPPED-TYPE (TYPE SLOT))
       RETURNTYPE))
     NIL))
   (CL:WHEN LITERALSLOT?
    (CL:SETQ ACCESSTREE
     (LIST* SYM-WALK-STELLA-WRAPPER-VALUE ACCESSTREE NIL)))
   (CL:IF ONCEONLYWRAPPER?
    (CL:RETURN-FROM YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES
      (LIST* SYM-WALK-STELLA-VRLET
       (LIST* (CONS OBJECTREF (CONS OBJECTREFCOPY NIL))
        (CONS OLDVALUEREF (CONS OLDVALUETREE NIL)) NIL)
       ACCESSTREE NIL)
      RETURNTYPE))
    (CL:RETURN-FROM YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE
     (CL:VALUES (WALK-WITHOUT-TYPE-TREE ACCESSTREE) RETURNTYPE)))))

;;; (DEFUN (YIELD-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-SLOT-VALUE-TREE (SLOT OBJECTREF OBJECTTYPE RETURNTYPE CSOPTIONS)
  (CL:IF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT)
   (CL:RETURN-FROM YIELD-SLOT-VALUE-TREE
    (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE SLOT OBJECTREF RETURNTYPE
     CSOPTIONS))
   (CL:IF (DYNAMIC-STORAGE? SLOT)
    (CL:RETURN-FROM YIELD-SLOT-VALUE-TREE
     (CL:VALUES
      (WALK-WITHOUT-TYPE-TREE
       (YIELD-DYNAMIC-SLOT-VALUE-TREE SLOT OBJECTREF RETURNTYPE))
      RETURNTYPE))
    (CL:RETURN-FROM YIELD-SLOT-VALUE-TREE
     (CL:VALUES
      (YIELD-NATIVE-SLOT-VALUE-TREE SLOT OBJECTREF OBJECTTYPE)
      RETURNTYPE)))))

;;; (DEFUN (WALK-SLOT-VALUE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-VALUE-TREE (TREE)
  (CL:LET* ((OBJECTREF NULL) (OBJECTTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OBJECTREF OBJECTTYPE)
    (WALK-A-TREE (%%VALUE (%%REST TREE))))
   (CL:LET*
    ((SLOTNAME (%%VALUE (%%REST (%%REST TREE))))
     (CSOPTIONS (NTH-REST TREE 3))
     (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
     (SLOT (LOOKUP-SLOT OBJECTCLASS SLOTNAME)) (OTREE NULL)
     (OTYPE NULL))
    (CL:WHEN (CL:EQ SLOT NULL)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Can't read a non-existent slot `"
        (DE-UGLIFY-PARSE-TREE SLOTNAME) "'" EOL "   on the class `"
        (CLASS-NAME OBJECTCLASS) "'." EOL)))
     (CL:RETURN-FROM WALK-SLOT-VALUE-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SLOT)))
     (CL:COND
      ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
       (CL:PROGN
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Can't read the method slot `"
           (DE-UGLIFY-PARSE-TREE SLOT) "' by calling 'slot-value'."
           EOL)))
        (CL:RETURN-FROM WALK-SLOT-VALUE-TREE (CL:VALUES NULL NULL))))
      ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ OTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE))
        (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
         (YIELD-SLOT-VALUE-TREE SLOT OBJECTREF OBJECTTYPE OTYPE
          CSOPTIONS))
        (CL:IF (PROCEDURAL-EXPRESSION? OTREE)
         (CL:RETURN-FROM WALK-SLOT-VALUE-TREE (CL:VALUES OTREE OTYPE))
         (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
          (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
           (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE OTYPE))
          (CL:RETURN-FROM WALK-SLOT-VALUE-TREE
           (CL:VALUES VALUE-000 VALUE-001))))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))))

;;; (DEFUN (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN YIELD-NATIVE-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF OBJECTTYPE VALUEREF)
  (CL:SETQ SLOT (CANONICAL-SLOT SLOT))
  (CL:LET*
   ((MIXINSLOT?
     (%CLASS.MIXIN?
      (%SURROGATE.SURROGATE-VALUE (%STORAGE-SLOT.SLOT-OWNER SLOT))))
    (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE)))
   (CL:WHEN
    (CL:AND MIXINSLOT? (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
    (CL:WHEN (%CLASS.MIXIN? OBJECTCLASS)
     (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
      (SYS-TREE
       (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD SGT-WALK-STELLA-OBJECT
        (YIELD-NATIVE-SLOT-READER-NAME SLOT)
        (CONS OBJECTREF (CONS VALUEREF NIL)))
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
           SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)
          NULL))
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL)
        (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))))))
   (CL:WHEN (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Can't set the value of the hardwired slot `"
       (%STORAGE-SLOT.SLOT-OWNER SLOT) "'.`"
       (%STORAGE-SLOT.SLOT-NAME SLOT) "'." EOL)))
    (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
     (WALK-DONT-CALL-ME-TREE NULL
      (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))))
   (CL:RETURN-FROM YIELD-NATIVE-SLOT-VALUE-SETTER-TREE
    (LIST* SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER
     (%CLASS.CLASS-TYPE OBJECTCLASS)
     (CONS (%STORAGE-SLOT.SLOT-NAME SLOT)
      (CONS OBJECTREF (CONS VALUEREF NIL)))))))

;;; (DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF VALUEREF RETURNTYPE CSOPTIONS)
  (CL:LET*
   ((CONTEXTSENSITIVE?
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ (SEARCH-PLIST CSOPTIONS KWD-WALK-CONTEXT-SENSITIVE?)
        SYM-WALK-STELLA-FALSE))))
    (COPYTOCHILDREN
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ CSOPTIONS NULL))
       (CL:EQ (SEARCH-PLIST CSOPTIONS KWD-WALK-COPY-TO-CHILDREN?)
        SYM-WALK-STELLA-TRUE))
      SYM-WALK-STELLA-TRUE SYM-WALK-STELLA-FALSE))
    (REALBASETYPE (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))
    (REALTYPESPEC
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
      SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (OBJECTVAR NULL) (VALUEVAR NULL) (OLDVALUEVAR NULL)
    (NEWVALUEVAR NULL) (OLDVALUETREE NULL) (SETNEWVALUETREE NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) SGT-WALK-STELLA-OBJECT)
   (CL:WHEN (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT) CL:NIL)
   (CL:COND
    (CONTEXTSENSITIVE? (CL:SETQ OBJECTVAR (LOCAL-GENSYM "OBJECT"))
     (CL:SETQ VALUEVAR (LOCAL-GENSYM "VALUE"))
     (CL:SETQ OLDVALUEVAR (LOCAL-GENSYM "OLD-VALUE"))
     (CL:SETQ NEWVALUEVAR (LOCAL-GENSYM "NEW-VALUE"))
     (PUSH-VARIABLE-BINDING OBJECTVAR (%STORAGE-SLOT.SLOT-OWNER SLOT))
     (PUSH-VARIABLE-BINDING NEWVALUEVAR SGT-WALK-STELLA-OBJECT)
     (CL:SETQ OLDVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST* SYM-WALK-STELLA-SLOT-VALUE OBJECTVAR
         (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) NIL)))
       SGT-WALK-STELLA-OBJECT))
     (CL:SETQ SETNEWVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST* SYM-WALK-STELLA-SETF
         (LIST* SYM-WALK-STELLA-SLOT-VALUE OBJECTVAR
          (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) NIL))
         NEWVALUEVAR NIL))
       SGT-WALK-STELLA-OBJECT)))
    (CL:T
     (CL:SETQ SETNEWVALUETREE
      (SYS-TREE
       (WALK-WITHOUT-TYPE-TREE
        (LIST* SYM-WALK-STELLA-SETF
         (LIST* SYM-WALK-STELLA-SLOT-VALUE OBJECTREF
          (CONS (%STORAGE-SLOT.SLOT-NAME SLOT) NIL))
         VALUEREF NIL))
       SGT-WALK-STELLA-OBJECT))))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) REALBASETYPE)
   (CL:WHEN (CL:NOT (CL:EQ REALTYPESPEC NULL))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER REALTYPESPEC NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT) CL:T)
   (CL:WHEN (CL:NOT CONTEXTSENSITIVE?)
    (CL:RETURN-FROM YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE
     (CL:VALUES SETNEWVALUETREE SGT-WALK-STELLA-OBJECT)))
   (POP-VARIABLE-BINDING) (POP-VARIABLE-BINDING)
   (CL:RETURN-FROM YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-VRLET
      (LIST* (CONS OBJECTVAR (CONS OBJECTREF NIL))
       (CONS VALUEVAR (CONS REALBASETYPE (CONS VALUEREF NIL)))
       (CONS OLDVALUEVAR (CONS OLDVALUETREE NIL))
       (CONS NEWVALUEVAR
        (CONS
         (LIST* SYM-WALK-STELLA-UPDATE-IN-CONTEXT OLDVALUEVAR
          (CONS VALUEVAR
           (LIST* (LIST* SYM-WALK-STELLA-HOME-CONTEXT OBJECTVAR NIL)
            COPYTOCHILDREN NIL)))
         NIL))
       NIL)
      (LIST* SYM-WALK-STELLA-WHEN
       (LIST* SYM-WALK-STELLA-NOT
        (LIST* SYM-WALK-STELLA-CS-VALUE? OLDVALUEVAR NIL) NIL)
       SETNEWVALUETREE NIL)
      VALUEVAR NIL)
     RETURNTYPE))))

;;; (DEFUN (YIELD-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN YIELD-SLOT-VALUE-SETTER-TREE (SLOT OBJECTREF OBJECTTYPE VALUEREF RETURNTYPE CSOPTIONS)
  (CL:IF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT)
   (CL:RETURN-FROM YIELD-SLOT-VALUE-SETTER-TREE
    (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF
     VALUEREF RETURNTYPE CSOPTIONS))
   (CL:IF (DYNAMIC-STORAGE? SLOT)
    (CL:RETURN-FROM YIELD-SLOT-VALUE-SETTER-TREE
     (CL:VALUES
      (WALK-WITHOUT-TYPE-TREE
       (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF VALUEREF
        RETURNTYPE))
      RETURNTYPE))
    (CL:RETURN-FROM YIELD-SLOT-VALUE-SETTER-TREE
     (CL:VALUES
      (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF OBJECTTYPE
       VALUEREF)
      RETURNTYPE)))))

;;; (DEFUN (WALK-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-VALUE-SETTER-TREE (TREE)
  (CL:LET* ((OBJECTREF NULL) (OBJECTTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OBJECTREF OBJECTTYPE)
    (WALK-A-TREE (%%VALUE (%%REST TREE))))
   (CL:LET*
    ((SLOTNAME (FOURTH TREE)) (CSOPTIONS (NTH-REST TREE 4))
     (OBJECTCLASS (TYPE-SPEC-TO-CLASS OBJECTTYPE))
     (SLOT (LOOKUP-SLOT OBJECTCLASS SLOTNAME)) (VALUEREF NULL)
     (OTREE NULL) (OTYPE NULL))
    (CL:WHEN (CL:EQ SLOT NULL)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Can't set a non-existent slot `"
        (DE-UGLIFY-PARSE-TREE SLOTNAME) "'" EOL "   on the class `"
        (CLASS-NAME OBJECTCLASS) "'." EOL)))
     (CL:RETURN-FROM WALK-SLOT-VALUE-SETTER-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SLOT)))
     (CL:COND
      ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-000)
       (CL:PROGN
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Can't set the method slot `"
           (DE-UGLIFY-PARSE-TREE SLOT)
           "' by calling 'slot-value-setter'." EOL)))
        (CL:RETURN-FROM WALK-SLOT-VALUE-SETTER-TREE
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
      ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-000)
       (CL:PROGN
        (CL:SETQ OTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT OBJECTTYPE))
        (CL:SETQ VALUEREF
         (WALK-EXPRESSION-TREE (%%VALUE (%%REST (%%REST TREE))) OTYPE
          SYM-WALK-STELLA-SLOT-VALUE-SETTER CL:NIL))
        (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
         (YIELD-SLOT-VALUE-SETTER-TREE SLOT OBJECTREF OBJECTTYPE
          VALUEREF OTYPE CSOPTIONS))
        (CL:IF (PROCEDURAL-EXPRESSION? OTREE)
         (CL:RETURN-FROM WALK-SLOT-VALUE-SETTER-TREE
          (CL:VALUES OTREE OTYPE))
         (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
          (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
           (SYS-TREE-IF-NEEDED SLOT OTREE OBJECTTYPE OTYPE))
          (CL:RETURN-FROM WALK-SLOT-VALUE-SETTER-TREE
           (CL:VALUES VALUE-000 VALUE-001))))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))))

;;; (DEFUN (WALK-AREF-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-AREF-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (OTREE NULL) (OTYPE NULL)
    (ARRAYTYPE NULL) (ELEMENTTYPE NULL) (ARGUMENTS (%%REST TREE)))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
    (WALK-EXPRESSION-TREE (%%VALUE ARGUMENTS) SGT-WALK-STELLA-ARRAY
     OPERATOR CL:T))
   (CL:WHEN (VRLET-EXPRESSION? OTREE) (FIRST-SETTER ARGUMENTS OTREE)
    (CL:RETURN-FROM WALK-AREF-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE OTREE
      SGT-WALK-STELLA-UNKNOWN)))
   (CL:WHEN (CL:NOT (ARRAY-TYPE-SPECIFIER? OTYPE))
    (CL:RETURN-FROM WALK-AREF-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:SETQ ARRAYTYPE OTYPE)
   (CL:SETQ ELEMENTTYPE
    (EXTRACT-PARAMETER-TYPE ARRAYTYPE SYM-WALK-STELLA-ANY-VALUE))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 (INDEFINITE-ARRAY-TYPE? ARRAYTYPE))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((DIM NULL) (ITER-000 (REST (ARRAY-TYPE-DIMENSIONS ARRAYTYPE))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ DIM (%%VALUE ITER-000))
        (CL:WHEN (CL:EQ DIM NULL) (CL:SETQ ALWAYS?-000 CL:NIL)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
     (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Can't AREF underspecified array type" EOL "   `"
        (DE-UGLIFY-PARSE-TREE ARRAYTYPE) "' in" EOL "   `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
     (CL:RETURN-FROM WALK-AREF-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN))))
   (FIRST-SETTER ARGUMENTS OTREE)
   (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
   (CL:WHEN (CL:EQ OPERATOR SYM-WALK-STELLA-AREF-SETTER)
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-EXPRESSION-TREE (%%VALUE ARGUMENTS) ELEMENTTYPE OPERATOR
      CL:T))
    (FIRST-SETTER ARGUMENTS OTREE)
    (CL:WHEN (VRLET-EXPRESSION? OTREE)
     (CL:RETURN-FROM WALK-AREF-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE OTREE
       SGT-WALK-STELLA-UNKNOWN)))
    (CL:SETQ ARGUMENTS (%%REST ARGUMENTS)))
   (CL:WHEN
    (CL:NOT (CL:= (LENGTH ARGUMENTS) (ARRAY-TYPE-RANK ARRAYTYPE)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " AREF indices don't match the rank of the array in" EOL "   `"
       (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ARGUMENTS NIL)) DO
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-EXPRESSION-TREE (%%VALUE ARGUMENTS) SGT-WALK-STELLA-INTEGER
      OPERATOR CL:T))
    (FIRST-SETTER ARGUMENTS OTREE)
    (CL:WHEN (VRLET-EXPRESSION? OTREE)
     (CL:RETURN-FROM WALK-AREF-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE OTREE
       SGT-WALK-STELLA-UNKNOWN)))
    (CL:SETQ ARGUMENTS (%%REST ARGUMENTS)))
   (CL:RETURN-FROM WALK-AREF-TREE
    (SYS-TREE
     (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
      (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE ARRAYTYPE)
      (CONS OPERATOR
       (CONS (SYS-TREE (%%VALUE (%%REST TREE)) ARRAYTYPE)
        (CONCATENATE (%%REST (%%REST TREE)) NIL))))
     ELEMENTTYPE))))

;;; (DEFUN (SAFE-YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFUN SAFE-YIELD-TYPE-SPECIFIER (TYPETREE)
  (CL:IF (CL:NOT (CL:EQ TYPETREE NULL))
   (CL:LET* ((TYPESPEC (YIELD-TYPE-SPECIFIER TYPETREE)))
    (VALIDATE-TYPE-SPECIFIER TYPESPEC NULL CL:T)
    (CL:RETURN-FROM SAFE-YIELD-TYPE-SPECIFIER TYPESPEC))
   (CL:RETURN-FROM SAFE-YIELD-TYPE-SPECIFIER NULL)))

;;; (DEFUN (WALK-A-DECLARATION CONS) ...)

(CL:DEFUN WALK-A-DECLARATION (VARIABLE TYPETREE VALUE INPUTPARAMETER?)
  (CL:LET*
   ((SOURCETYPE NULL) (TARGETTYPE (SAFE-YIELD-TYPE-SPECIFIER TYPETREE))
    (METHODOWNERTYPE
     (CL:IF (CL:NOT (CL:EQ *METHODBEINGWALKED* NULL))
      (%METHOD-SLOT.SLOT-OWNER *METHODBEINGWALKED*) NULL))
    (OVALUE NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ TARGETTYPE NULL))
     (CL:NOT (CL:EQ METHODOWNERTYPE NULL))
     (CL:NOT (VOID? METHODOWNERTYPE)))
    (CL:SETQ TARGETTYPE
     (COMPUTE-RELATIVE-TYPE-SPEC TARGETTYPE METHODOWNERTYPE)))
   (CL:WHEN (CL:NOT INPUTPARAMETER?)
    (PUSH-VARIABLE-BINDING VARIABLE SGT-WALK-STELLA-UNINITIALIZED)
    (CL:MULTIPLE-VALUE-SETQ (OVALUE SOURCETYPE)
     (WALK-EXPRESSION-TREE VALUE TARGETTYPE
      SYM-WALK-STELLA-VARIABLE-DECLARATION CL:T))
    (CL:WHEN (CL:EQ TARGETTYPE NULL) (CL:SETQ TARGETTYPE SOURCETYPE))
    (POP-VARIABLE-BINDING))
   (PUSH-VARIABLE-BINDING VARIABLE TARGETTYPE)
   (CL:IF INPUTPARAMETER?
    (CL:RETURN-FROM WALK-A-DECLARATION
     (CONS VARIABLE (CONS TARGETTYPE NIL)))
    (CL:RETURN-FROM WALK-A-DECLARATION
     (CONS (TRUE-VARIABLE-NAME VARIABLE)
      (CONS TARGETTYPE (CONS OVALUE NIL)))))))

;;; (DEFUN (WALK-VARIABLE-DECLARATIONS CONS) ...)

(CL:DEFUN WALK-VARIABLE-DECLARATIONS (DECLARATIONS)
  (CL:LET*
   ((ODECLARATIONS NIL) (VARIABLE NULL) (VRLETENCOUNTERED? CL:NIL))
   (CL:LET* ((DECL NULL) (ITER-000 DECLARATIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DECL (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:COND
       ((CL:EQ (SAFE-PRIMARY-TYPE DECL) SGT-WALK-STELLA-CONS)
        (CL:PROGN
         (CL:COND
          (VRLETENCOUNTERED?
           (CL:SETQ ODECLARATIONS (CONS DECL ODECLARATIONS))
           (CL:GO :CONTINUE))
          ((CL:NOT (SYMBOL? (%%VALUE DECL)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
              " Illegal variable in `let' declaration: `"
              (DE-UGLIFY-PARSE-TREE DECL) "'." EOL)))
           (CL:SETQ VARIABLE SYM-WALK-STELLA-ILLEGAL-VARIABLE))
          (CL:T (CL:SETQ VARIABLE (%%VALUE DECL))
           (CL:WHEN
            (CL:OR
             (CL:NOT (CL:EQ (LOOKUP-GLOBAL-VARIABLE VARIABLE) NULL))
             (CONSTANT-SYMBOL? VARIABLE))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL " `"
               (CL:IF (CONSTANT-SYMBOL? VARIABLE)
                "Illegal binding of constant value "
                "Illegal binding of global or special variable ")
               "'in `let' declaration:" EOL "    `"
               (DE-UGLIFY-PARSE-TREE DECL) "'." EOL)))
            (CL:SETQ VARIABLE SYM-WALK-STELLA-ILLEGAL-VARIABLE))))
         (CL:CASE (LENGTH DECL)
          (1
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
              " Missing argument(s) in `let' declaration: `"
              (DE-UGLIFY-PARSE-TREE DECL) "'." EOL))))
          (2
           (CL:WHEN
            (CL:EQ (%%VALUE (%%REST DECL)) SYM-WALK-STELLA-NULL)
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
               " Missing type specifier in `let' declaration: `"
               (DE-UGLIFY-PARSE-TREE DECL) "'." EOL))))
           (CL:SETQ ODECLARATIONS
            (CONS
             (WALK-A-DECLARATION VARIABLE NULL (%%VALUE (%%REST DECL))
              CL:NIL)
             ODECLARATIONS)))
          (3
           (CL:SETQ ODECLARATIONS
            (CONS
             (WALK-A-DECLARATION VARIABLE (%%VALUE (%%REST DECL))
              (%%VALUE (%%REST (%%REST DECL))) CL:NIL)
             ODECLARATIONS)))
          (CL:OTHERWISE
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
              " Too many terms in `let' declaration:`"
              (DE-UGLIFY-PARSE-TREE DECL) "'." EOL)))))
         (CL:WHEN
          (PROCEDURAL-EXPRESSION?
           (%%VALUE (%%REST (%%REST (%%VALUE ODECLARATIONS)))))
          (CL:SETQ VRLETENCOUNTERED? CL:T) (POP-VARIABLE-BINDING))))
       (CL:T
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Illegal `let' declaration: `"
           (DE-UGLIFY-PARSE-TREE DECL) "'." EOL)))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM WALK-VARIABLE-DECLARATIONS (REVERSE ODECLARATIONS))))

;;; (DEFUN (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION CONS) ...)

(CL:DEFUN TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION (TREE)
  (CL:LET*
   ((FIRSTDECLARATION (%%VALUE (%%VALUE (%%REST TREE))))
    (TYPETREE (%%VALUE (%%REST FIRSTDECLARATION)))
    (VRLETTREE
     (WALK-WITHOUT-TYPE-TREE
      (%%VALUE (%%REST (%%REST FIRSTDECLARATION))))))
   (CL:WHEN (CL:EQ TYPETREE SGT-WALK-STELLA-UNKNOWN)
    (CL:SETF (%%REST FIRSTDECLARATION)
     (%%REST (%%REST FIRSTDECLARATION))))
   (CL:LET* ((OTREE NULL) (UNUSEDTYPESPEC NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE UNUSEDTYPESPEC)
     (TRANSFORM-PROCEDURAL-EXPRESSION TREE VRLETTREE TYPETREE))
    (CL:SETQ UNUSEDTYPESPEC UNUSEDTYPESPEC)
    (CL:RETURN-FROM TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION OTREE))))

;;; (DEFUN POP-LOCAL-VARIABLE-BINDINGS ...)

(CL:DEFUN POP-LOCAL-VARIABLE-BINDINGS (DECLARATIONS)
  (CL:LET* ((D NULL) (ITER-000 DECLARATIONS))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ D (%%VALUE ITER-000)) (CL:SETQ D D) (POP-VARIABLE-BINDING)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN (WALK-LET-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LET-TREE (TREE)
  (SECOND-SETTER TREE
   (WALK-VARIABLE-DECLARATIONS (%%VALUE (%%REST TREE))))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET* ((D NULL) (ITER-000 (%%VALUE (%%REST TREE))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ D (%%VALUE ITER-000))
      (CL:WHEN (PROCEDURAL-EXPRESSION? (%%VALUE (%%REST (%%REST D))))
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ TEST-VALUE-000 FOUND?-000))
   (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETF (%%REST (%%REST TREE))
     (WALK-LIST-OF-STATEMENTS (%%REST (%%REST TREE))))
    (POP-LOCAL-VARIABLE-BINDINGS (%%VALUE (%%REST TREE)))
    (CL:RETURN-FROM WALK-LET-TREE
     (SYS-TREE TREE SGT-WALK-STELLA-VOID))))
  (CL:LET*
   ((ORIGINALDECLARATIONS (%%VALUE (%%REST TREE)))
    (LEADINGDECLARATIONS NIL) (TRAILINGDECLARATIONS NIL)
    (LEADING? CL:T))
   (CL:LET* ((D NULL) (ITER-001 ORIGINALDECLARATIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ D (%%VALUE ITER-001))
     (CL:WHEN (PROCEDURAL-EXPRESSION? (%%VALUE (%%REST (%%REST D))))
      (CL:SETQ LEADING? CL:NIL))
     (CL:COND
      (LEADING?
       (CL:SETQ LEADINGDECLARATIONS (CONS D LEADINGDECLARATIONS)))
      (CL:T
       (CL:SETQ TRAILINGDECLARATIONS (CONS D TRAILINGDECLARATIONS))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:SETQ LEADINGDECLARATIONS (REVERSE LEADINGDECLARATIONS))
   (CL:SETQ TRAILINGDECLARATIONS (REVERSE TRAILINGDECLARATIONS))
   (SECOND-SETTER TREE TRAILINGDECLARATIONS)
   (CL:SETQ TREE (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION TREE))
   (CL:WHEN (CL:NOT (CL:EQ LEADINGDECLARATIONS NIL))
    (POP-LOCAL-VARIABLE-BINDINGS LEADINGDECLARATIONS)
    (CL:SETQ TREE
     (LIST* SYM-WALK-STELLA-LET LEADINGDECLARATIONS (CONS TREE NIL))))
   (CL:RETURN-FROM WALK-LET-TREE (WALK-A-CONS-TREE TREE))))

;;; (DEFSPECIAL *SPECIALVARIABLESTACK* ...)

(CL:DEFVAR *SPECIALVARIABLESTACK* NULL
  "Stack mirroring the current state of bound specials
with their associated old-value variables.")

;;; (DEFSPECIAL *SPECIALSENABLED?* ...)

(CL:DEFVAR *SPECIALSENABLED?* CL:T
  "`true' if using specials is enabled and legal.")

;;; (DEFSPECIAL *NOFSPECIALSATLOOPENTRY* ...)

(CL:DEFVAR *NOFSPECIALSATLOOPENTRY* 0
  "Number of specials bound at the most recent entry
to a LOOP/WHILE/FOREACH construct.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NOFSPECIALSATLOOPENTRY*))

;;; (DEFUN (SPECIAL-IMPLEMENTATION-STYLE KEYWORD) ...)

(CL:DEFUN SPECIAL-IMPLEMENTATION-STYLE ()
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE KWD-WALK-COMMON-LISP))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
    (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE
     KWD-WALK-UNBIND-WITH-DESTRUCTORS))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
    (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE KWD-WALK-COMMON-LISP))
   (CL:T
    (CL:RETURN-FROM SPECIAL-IMPLEMENTATION-STYLE
     KWD-WALK-UNWIND-PROTECT))))

;;; (DEFUN PUSH-SPECIAL ...)

(CL:DEFUN PUSH-SPECIAL (VARIABLE OLDVALUEVARIABLE)
  (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST *SPECIALVARIABLESTACK*)
   (KV-CONS VARIABLE OLDVALUEVARIABLE
    (%KEY-VALUE-LIST.THE-KV-LIST *SPECIALVARIABLESTACK*)))
  :VOID)

;;; (DEFUN POP-SPECIAL ...)

(CL:DEFUN POP-SPECIAL ()
  (CL:LET*
   ((KVLIST (%KEY-VALUE-LIST.THE-KV-LIST *SPECIALVARIABLESTACK*)))
   (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST *SPECIALVARIABLESTACK*)
    (%KV-CONS.REST KVLIST))
   (FREE-KV-CONS KVLIST))
  :VOID)

;;; (DEFUN (LOOKUP-OLD-VALUE-VARIABLE SYMBOL) ...)

(CL:DEFUN LOOKUP-OLD-VALUE-VARIABLE (VARIABLE)
  (CL:RETURN-FROM LOOKUP-OLD-VALUE-VARIABLE
   (LOOKUP-VARIABLE-TABLE *SPECIALVARIABLESTACK* VARIABLE)))

;;; (DEFUN (NEED-TO-UNBIND-SPECIALS? BOOLEAN) ...)

(CL:DEFUN NEED-TO-UNBIND-SPECIALS? ()
  (CL:RETURN-FROM NEED-TO-UNBIND-SPECIALS?
   (CL:AND *SPECIALSENABLED?* (CL:> (LENGTH *SPECIALVARIABLESTACK*) 0)
    (CL:NOT
     (MEMBER?
      (GET-QUOTED-TREE
       "((:COMMON-LISP :UNBIND-WITH-DESTRUCTORS) \"/STELLA\")"
       "/STELLA")
      (SPECIAL-IMPLEMENTATION-STYLE))))))

;;; (DEFUN (YIELD-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-SPECIAL-UNBIND-TREE (NOFBINDINGS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOFBINDINGS))
  #+MCL
  (CL:CHECK-TYPE NOFBINDINGS CL:FIXNUM)
  (CL:LET* ((OTREE NIL))
   (CL:COND
    ((CL:EQ (SPECIAL-IMPLEMENTATION-STYLE) KWD-WALK-UNWIND-PROTECT)
     (CL:LET*
      ((VARIABLE NULL) (OLDVALUEVARIABLE NULL)
       (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST *SPECIALVARIABLESTACK*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
       (CL:SETQ VARIABLE (%KV-CONS.KEY ITER-000))
       (CL:SETQ OLDVALUEVARIABLE (%KV-CONS.VALUE ITER-000))
       (CL:WHEN (CL:>= (CL:SETQ NOFBINDINGS (CL:1- NOFBINDINGS)) 0)
        (CL:LET* ((VALUE-000 NULL))
         (CL:LET* ((TREE NULL) (ITER-001 OTREE))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ TREE (%%VALUE ITER-001))
           (CL:WHEN (CL:EQ (%%VALUE (%%REST TREE)) VARIABLE)
            (CL:SETQ VALUE-000 TREE) (CL:RETURN))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:SETQ OTREE (REMOVE OTREE VALUE-000)))
        (CL:SETQ OTREE
         (CONS
          (LIST* SYM-WALK-STELLA-SETQ VARIABLE
           (CONS OLDVALUEVARIABLE NIL))
          OTREE)))
       (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
     (CL:RETURN-FROM YIELD-SPECIAL-UNBIND-TREE
      (PROGNIFY (REVERSE OTREE))))
    (CL:T (CL:RETURN-FROM YIELD-SPECIAL-UNBIND-TREE NULL)))))

;;; (DEFUN (YIELD-RETURN-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-RETURN-SPECIAL-UNBIND-TREE ()
  (CL:RETURN-FROM YIELD-RETURN-SPECIAL-UNBIND-TREE
   (YIELD-SPECIAL-UNBIND-TREE (LENGTH *SPECIALVARIABLESTACK*))))

;;; (DEFUN (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE CONS) ...)

(CL:DEFUN YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE ()
  (CL:RETURN-FROM YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE
   (YIELD-SPECIAL-UNBIND-TREE
    (CL:- (LENGTH *SPECIALVARIABLESTACK*) *NOFSPECIALSATLOOPENTRY*))))

;;; (DEFUN (WALK-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SPECIAL-TREE (TREE)
  (CL:WHEN (CL:NOT *SPECIALSENABLED?*)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " 'special' statement not legal in the current context: " EOL "`"
      (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
   (CL:RETURN-FROM WALK-SPECIAL-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (CL:< (LENGTH TREE) 2) (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:IF (CL:NOT (CONS? (%%VALUE (%%REST TREE))))
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((BINDING NULL) (ITER-000 (%%VALUE (%%REST TREE))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ BINDING (%%VALUE ITER-000))
         (CL:WHEN
          (CL:NOT
           (CL:AND (CONS? BINDING) (SYMBOL? (%%VALUE BINDING))
            (CL:= (LENGTH BINDING) 2)))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
      (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal 'special' statement: `" (DE-UGLIFY-PARSE-TREE TREE)
       "'." EOL)))
    (CL:RETURN-FROM WALK-SPECIAL-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
  (CL:WHEN (CL:= (LENGTH (%%VALUE (%%REST TREE))) 0)
   (FIRST-SETTER TREE SYM-WALK-STELLA-LET)
   (CL:RETURN-FROM WALK-SPECIAL-TREE (WALK-LET-TREE TREE)))
  (CL:LET* ((VARIABLE NULL))
   (CL:LET* ((BINDING NULL) (ITER-001 (%%VALUE (%%REST TREE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-001))
     (CL:SETQ VARIABLE (LOOKUP-GLOBAL-VARIABLE (%%VALUE BINDING)))
     (CL:WHEN
      (CL:OR (CL:EQ VARIABLE NULL)
       (CL:NOT (%GLOBAL-VARIABLE.VARIABLE-SPECIAL? VARIABLE)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Trying to bind non-special variable `" (%%VALUE BINDING)
         "'" EOL " in 'special' statement." EOL))))
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  (CL:LET* ((TEST-VALUE-001 (SPECIAL-IMPLEMENTATION-STYLE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 KWD-WALK-COMMON-LISP)
     (CL:RETURN-FROM WALK-SPECIAL-TREE (WALK-CL-SPECIAL-TREE TREE)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-UNBIND-WITH-DESTRUCTORS)
     (CL:RETURN-FROM WALK-SPECIAL-TREE (WALK-CL-SPECIAL-TREE TREE)))
    ((CL:EQ TEST-VALUE-001 KWD-WALK-UNWIND-PROTECT)
     (CL:RETURN-FROM WALK-SPECIAL-TREE
      (WALK-UNWIND-PROTECT-SPECIAL-TREE TREE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-001 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (WALK-CL-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CL-SPECIAL-TREE (TREE)
  (CL:LET*
   ((BINDINGS (%%VALUE (%%REST TREE))) (BODY (%%REST (%%REST TREE)))
    (VARIABLENAME NULL) (VARIABLETYPE NULL) (BINDVIASETQ? CL:NIL)
    (BINDVIASETQTREES NIL) (OTREE NULL))
   (CL:LET* ((BINDING NULL) (ITER-000 BINDINGS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-000))
     (CL:SETQ VARIABLENAME (%%VALUE BINDING))
     (CL:SETQ VARIABLETYPE (LOOKUP-GLOBAL-VARIABLE-TYPE VARIABLENAME))
     (CL:COND
      (BINDVIASETQ?
       (CL:SETQ BINDVIASETQTREES
        (CONS
         (WALK-A-TREE
          (LIST* SYM-WALK-STELLA-SETQ VARIABLENAME
           (CONS (%%VALUE (%%REST BINDING)) NIL)))
         BINDVIASETQTREES))
       (SECOND-SETTER BINDING VARIABLETYPE)
       (CL:SETF (%%REST (%%REST BINDING))
        (CONS SYM-WALK-STELLA-NULL NIL)))
      (CL:T
       (CL:SETQ OTREE
        (WALK-EXPRESSION-TREE (%%VALUE (%%REST BINDING)) VARIABLETYPE
         SYM-WALK-STELLA-SPECIAL CL:T))
       (CL:WHEN (PROCEDURAL-EXPRESSION? OTREE)
        (CL:SETQ BINDVIASETQ? CL:T)
        (CL:SETQ BINDVIASETQTREES
         (CONS
          (WALK-A-TREE
           (LIST* SYM-WALK-STELLA-SETQ VARIABLENAME (CONS OTREE NIL)))
          BINDVIASETQTREES))
        (CL:SETQ OTREE SYM-WALK-STELLA-NULL))
       (SECOND-SETTER BINDING VARIABLETYPE)
       (CL:SETF (%%REST (%%REST BINDING)) (CONS OTREE NIL))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (FIRST-SETTER TREE SYM-WALK-STELLA-SPECIAL)
   (CL:SETF (%%REST (%%REST TREE))
    (CONCATENATE (REVERSE BINDVIASETQTREES)
     (WALK-LIST-OF-STATEMENTS BODY)))
   (CL:RETURN-FROM WALK-CL-SPECIAL-TREE
    (SYS-TREE TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-UNWIND-PROTECT-SPECIAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-UNWIND-PROTECT-SPECIAL-TREE (TREE)
  (CL:LET*
   ((BINDINGS (%%VALUE (%%REST TREE))) (BODY (%%REST (%%REST TREE)))
    (VARIABLE NULL) (OLDVALUEVARIABLE NULL) (OLDVALUEBINDINGS NIL)
    (BINDTREES NIL) (UNBINDTREES NIL))
   (CL:LET* ((BINDING NULL) (ITER-000 BINDINGS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-000))
     (CL:SETQ VARIABLE (%%VALUE BINDING))
     (CL:SETQ BINDTREES
      (CONS
       (LIST* SYM-WALK-STELLA-SETQ VARIABLE
        (CONS (%%VALUE (%%REST BINDING)) NIL))
       BINDTREES))
     (CL:SETQ OLDVALUEVARIABLE
      (LOCAL-GENSYM
       (CONCATENATE "OLD-" (%SYMBOL.SYMBOL-NAME VARIABLE))))
     (PUSH-SPECIAL VARIABLE OLDVALUEVARIABLE)
     (CL:SETQ OLDVALUEBINDINGS
      (CONS (CONS OLDVALUEVARIABLE (CONS VARIABLE NIL))
       OLDVALUEBINDINGS))
     (CL:SETQ UNBINDTREES
      (CONS
       (LIST* SYM-WALK-STELLA-SETQ VARIABLE
        (CONS OLDVALUEVARIABLE NIL))
       UNBINDTREES))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ TREE
    (WALK-A-TREE
     (LIST* SYM-WALK-STELLA-LET (REVERSE OLDVALUEBINDINGS)
      (CONCATENATE (REVERSE BINDTREES)
       (CONS
        (LIST* SYM-WALK-STELLA-UNWIND-PROTECT (PROGNIFY BODY)
         (CONCATENATE UNBINDTREES NIL))
        NIL)))))
   (CL:LET* ((BINDING NULL) (ITER-001 BINDINGS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-001)) (CL:SETQ BINDING BINDING)
     (POP-SPECIAL) (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:RETURN-FROM WALK-UNWIND-PROTECT-SPECIAL-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-CAST-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CAST-TREE (TREE)
  (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 2)
   (CL:RETURN-FROM WALK-CAST-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
  (CL:LET*
   ((TYPESPEC (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST (%%REST TREE))))))
   (SECOND-SETTER TREE
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
     SGT-WALK-STELLA-UNKNOWN SYM-WALK-STELLA-CAST CL:T))
   (CL:WHEN (VRLET-EXPRESSION? (%%VALUE (%%REST TREE)))
    (CL:RETURN-FROM WALK-CAST-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE (%%VALUE (%%REST TREE))
      TYPESPEC)))
   (THIRD-SETTER TREE TYPESPEC)
   (CL:WHEN
    (CL:AND (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
     (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-CAST) (CL:>= *SAFETY* 2))
    (REGISTER-SYMBOL (TYPE-SPEC-TO-BASE-TYPE TYPESPEC)))
   (CL:RETURN-FROM WALK-CAST-TREE (CL:VALUES TREE TYPESPEC))))

;;; (DEFUN (VALUES-TREE? BOOLEAN) ...)

(CL:DEFUN VALUES-TREE? (TREE)
  (CL:RETURN-FROM VALUES-TREE?
   (CL:AND (CONS? TREE) (CL:EQ SYM-WALK-STELLA-VALUES (%%VALUE TREE)))))

;;; (DEFUN (WALK-VALUES-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-VALUES-TREE (TREE)
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (BINDTREE NIL) (VALUEVAR NULL)
    (HASPROCEDURALVALUE? CL:NIL))
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST TREE))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (WALK-A-TREE (%CONS-ITERATOR.VALUE IT)))
     (CL:WHEN (VRLET-EXPRESSION? OTREE) (VALUE-SETTER IT OTREE)
      (CL:SETQ HASPROCEDURALVALUE? CL:T) (CL:RETURN))
     (CL:SETQ OTREE (SYS-TREE OTREE OTYPE))
     (CL:WHEN (VOID? OTYPE)
      (CL:SETQ OTREE
       (CONCATENATE OTREE (CONS SGT-WALK-STELLA-VOID NIL))))
     (VALUE-SETTER IT OTREE)))
   (CL:WHEN (CL:NOT HASPROCEDURALVALUE?)
    (FIRST-SETTER TREE SYM-WALK-STELLA-PROGN)
    (CL:RETURN-FROM WALK-VALUES-TREE
     (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST TREE))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:LET* ((VALUE (%CONS-ITERATOR.VALUE IT)))
      (CL:WHEN
       (CL:OR (PROCEDURAL-EXPRESSION? VALUE)
        (CL:NOT (ATOMIC-EXPRESSION? (%%VALUE (%%REST VALUE)))))
       (CL:SETQ VALUEVAR (LOCAL-GENSYM "VALUE"))
       (CL:SETQ BINDTREE
        (CONS
         (CONS VALUEVAR
          (CONS
           (CL:IF (PROCEDURAL-EXPRESSION? VALUE) VALUE
            (%%VALUE (%%REST VALUE)))
           NIL))
         BINDTREE))
       (CL:COND
        ((PROCEDURAL-EXPRESSION? VALUE) (VALUE-SETTER IT VALUEVAR)
         (CL:RETURN))
        (CL:T (SECOND-SETTER VALUE VALUEVAR)))))))
   (CL:RETURN-FROM WALK-VALUES-TREE
    (WALK-A-CONS-TREE
     (LIST* SYM-WALK-STELLA-LET (REVERSE BINDTREE) (CONS TREE NIL))))))

;;; (DEFUN (WALK-MV-EXPRESSION-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-EXPRESSION-TREE (TREE TARGETTYPES OPERATOR)
  (CL:LET*
   ((*TARGETTYPE*
     (CL:IF (CL:= (LENGTH TARGETTYPES) 1) (FIRST TARGETTYPES)
      SGT-WALK-STELLA-UNKNOWN)))
   (CL:DECLARE (CL:SPECIAL *TARGETTYPE*))
   (CL:LET* ((OTREE NULL) (VALUESTREE NULL) (SOURCETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE VALUESTREE SOURCETYPES)
     (WALK-MV-TREE TREE))
    (CL:WHEN (CL:NOT (CL:= (LENGTH SOURCETYPES) (LENGTH TARGETTYPES)))
     (CL:IF
      (CL:AND (CL:= (LENGTH SOURCETYPES) 1)
       (CL:EQ SGT-WALK-STELLA-UNKNOWN (FIRST SOURCETYPES)))
      (WARN-ABOUT-UNKNOWN-SOURCE-TYPE OTREE)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " `" (DE-UGLIFY-PARSE-TREE OPERATOR)
         "' operator expected `" (LENGTH TARGETTYPES)
         "' value(s) from `" (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))
     (CL:RETURN-FROM WALK-MV-EXPRESSION-TREE
      (CL:VALUES OTREE VALUESTREE (COPY TARGETTYPES))))
    (CL:WHEN (EMPTY? SOURCETYPES)
     (CL:RETURN-FROM WALK-MV-EXPRESSION-TREE
      (CL:VALUES OTREE VALUESTREE SOURCETYPES)))
    (CL:IF (CL:NOT (CL:EQ VALUESTREE NULL))
     (CL:MULTIPLE-VALUE-SETQ (TREE VALUESTREE TARGETTYPES)
      (COERCE-MV-TREE VALUESTREE OPERATOR SOURCETYPES TARGETTYPES))
     (CL:MULTIPLE-VALUE-SETQ (OTREE VALUESTREE TARGETTYPES)
      (COERCE-MV-TREE OTREE OPERATOR SOURCETYPES TARGETTYPES)))
    (FREE SOURCETYPES)
    (CL:RETURN-FROM WALK-MV-EXPRESSION-TREE
     (CL:VALUES OTREE VALUESTREE TARGETTYPES)))))

;;; (DEFUN (LISTIFY-TYPE-SPEC (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN LISTIFY-TYPE-SPEC (TYPESPEC)
  (CL:IF (VOID? TYPESPEC) (CL:RETURN-FROM LISTIFY-TYPE-SPEC (LIST))
   (CL:RETURN-FROM LISTIFY-TYPE-SPEC (LIST TYPESPEC))))

;;; (DEFUN (SLOT-FROM-EXPRESSION-TREE SLOT) ...)

(CL:DEFUN SLOT-FROM-EXPRESSION-TREE (TREE)
  (CL:WHEN (CL:EQ SYM-WALK-STELLA-TYPED-SYS (%%VALUE TREE))
   (CL:SETQ TREE (%%VALUE (%%REST TREE))))
  (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-SUPER-METHOD)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER)
      (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD-SETTER))
     (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE
      (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE (%%VALUE (%%REST TREE)))
       (%%VALUE (%%REST (%%REST TREE))))))
    ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-FUNCTION)
     (CL:LET* ((FUNCTION (LOOKUP-FUNCTION (%%VALUE (%%REST TREE)))))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
        (ISA? FUNCTION SGT-WALK-STELLA-METHOD-SLOT))
       (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE FUNCTION))))
    (CL:T (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE NULL))))
  (CL:RETURN-FROM SLOT-FROM-EXPRESSION-TREE NULL))

;;; (DEFUN (WALK-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-TREE (TREE)
  (CL:LET* ((OTREE NULL) (OTYPE NULL) (SLOT NULL))
   (CL:WHEN (VALUES-TREE? TREE)
    (CL:RETURN-FROM WALK-MV-TREE (WALK-MV-VALUES-TREE TREE)))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-A-TREE TREE))
   (CL:WHEN (CONS? OTREE)
    (CL:SETQ SLOT (SLOT-FROM-EXPRESSION-TREE OTREE)))
   (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
    (CL:COND
     ((SUBTYPE-OF-METHOD-SLOT? (SAFE-PRIMARY-TYPE SLOT))
      (CL:PROGN
       (CL:RETURN-FROM WALK-MV-TREE
        (CL:VALUES OTREE NULL
         (COPY (METHOD-RETURN-TYPE-SPECIFIERS SLOT))))))
     (CL:T)))
   (CL:RETURN-FROM WALK-MV-TREE
    (CL:VALUES OTREE NULL (LISTIFY-TYPE-SPEC OTYPE)))))

;;; (DEFUN (WALK-MV-VALUES-TREE CONS CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN WALK-MV-VALUES-TREE (TREE)
  (CL:WHEN (CL:= (LENGTH TREE) 1)
   (CL:RETURN-FROM WALK-MV-VALUES-TREE
    (CL:VALUES TREE TREE (LISTIFY-TYPE-SPEC SGT-WALK-STELLA-VOID))))
  (CL:LET*
   ((OTREE NULL) (OTYPE NULL) (RETURNTYPES (NEW-LIST))
    (TYPEDSYSTREE NULL))
   (CL:SETQ OTYPE OTYPE)
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-VALUES-TREE TREE))
   (FIRST-SETTER TREE SYM-WALK-STELLA-VALUES)
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST TREE))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:SETQ TYPEDSYSTREE (%CONS-ITERATOR.VALUE IT))
     (PUSH RETURNTYPES (%%VALUE (%%REST (%%REST TYPEDSYSTREE))))
     (CL:WHEN
      (CL:EQ SGT-WALK-STELLA-UNKNOWN
       (%%VALUE (%%REST (%%REST TYPEDSYSTREE))))
      (VALUE-SETTER IT (%%VALUE (%%REST TYPEDSYSTREE))))))
   (CL:RETURN-FROM WALK-MV-VALUES-TREE
    (CL:VALUES OTREE TREE (REVERSE RETURNTYPES)))))

;;; (DEFUN (COERCE-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ...)

(CL:DEFUN COERCE-MV-TREE (TREE OPERATOR SOURCETYPES TARGETTYPES)
  (CL:LET*
   ((VALUESTREE? (VALUES-TREE? TREE)) (VALUESTREE NIL)
    (NEEDTEMPORARIES? CL:NIL) (SUCCESS? CL:NIL) (OTREE NULL)
    (OTYPE NULL) (RETURNTYPES (NEW-LIST)))
   (CL:COND (VALUESTREE? (CL:SETQ VALUESTREE TREE))
    (CL:T (CL:SETQ VALUESTREE (CONS SYM-WALK-STELLA-VALUES NIL))
     (CL:LET*
      ((TYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST SOURCETYPES))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ TYPE (%%VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS (SYS-TREE NULL TYPE) NIL))
         (CL:IF (CL:EQ VALUESTREE NIL) (CL:SETQ VALUESTREE COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUESTREE COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000) (CONS (SYS-TREE NULL TYPE) NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))))
   (CL:LET*
    ((TGTTS NULL) (ITER-001 (%LIST.THE-CONS-LIST TARGETTYPES))
     (SRCTS NULL) (ITER-002 (%LIST.THE-CONS-LIST SOURCETYPES))
     (I NULL-INTEGER) (ITER-003 1)
     (IT (ALLOCATE-ITERATOR (%%REST VALUESTREE))) (COLLECT-001 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
      (CL:NOT (CL:EQ ITER-002 NIL)) (NEXT? IT))
     DO (CL:SETQ TGTTS (%%VALUE ITER-001))
     (CL:SETQ SRCTS (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE SUCCESS?)
      (HELP-COERCE-A-TREE (%CONS-ITERATOR.VALUE IT) SRCTS TGTTS
       CL:NIL))
     (CL:WHEN (CL:NOT SUCCESS?)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Type clash on argument `"
         (DE-UGLIFY-PARSE-TREE (WRAP-INTEGER I)) "' of `"
         (DE-UGLIFY-PARSE-TREE OPERATOR) "' operator." EOL " `"
         (DE-UGLIFY-PARSE-TREE SRCTS) "' found where `"
         (DE-UGLIFY-PARSE-TREE TGTTS) "' expected." EOL)))
      (CL:RETURN-FROM COERCE-MV-TREE
       (CL:VALUES TREE (CL:IF VALUESTREE? TREE NULL)
        (COPY TARGETTYPES))))
     (CL:WHEN
      (CL:OR (CL:NOT (EQL? OTREE (%CONS-ITERATOR.VALUE IT)))
       (CL:AND (CL:> I 1) (CL:NOT VALUESTREE?)
        (CL:NOT
         (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
        (CL:NOT
         (CL:EQ (TYPE-SPEC-TO-BASE-TYPE TGTTS)
          SGT-WALK-STELLA-UNKNOWN))
        (CL:NOT
         (CL:EQ (TYPE-SPEC-TO-BASE-TYPE SRCTS)
          (TYPE-SPEC-TO-BASE-TYPE TGTTS)))))
      (CL:SETQ NEEDTEMPORARIES? CL:T))
     (VALUE-SETTER IT OTREE)
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN (CL:SETQ COLLECT-001 (CONS OTYPE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RETURNTYPES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RETURNTYPES) COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RETURNTYPES)
         COLLECT-001)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS OTYPE NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (%%REST ITER-002))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:WHEN VALUESTREE?
    (CL:RETURN-FROM COERCE-MV-TREE (CL:VALUES TREE TREE RETURNTYPES)))
   (CL:WHEN (CL:NOT NEEDTEMPORARIES?)
    (CL:RETURN-FROM COERCE-MV-TREE (CL:VALUES TREE NULL RETURNTYPES)))
   (CL:SETQ VALUESTREE (CONS SYM-WALK-STELLA-VALUES NIL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-004 1)
     (UPPER-BOUND-000 (LENGTH TARGETTYPES)) (COLLECT-002 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-004) (CL:SETQ I I)
     (CL:IF (CL:EQ COLLECT-002 NULL)
      (CL:PROGN (CL:SETQ COLLECT-002 (CONS (LOCAL-GENSYM "VALUE") NIL))
       (CL:IF (CL:EQ VALUESTREE NIL) (CL:SETQ VALUESTREE COLLECT-002)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUESTREE COLLECT-002)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-002) (CONS (LOCAL-GENSYM "VALUE") NIL))
       (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
     (CL:SETQ ITER-004 (CL:1+ ITER-004))))
   (CL:SETQ OTREE
    (WALK-WITHOUT-TYPE-TREE
     (LIST* SYM-WALK-STELLA-MV-BIND
      (COPY-CONS-LIST (%%REST VALUESTREE))
      (CONS TREE (CONS VALUESTREE NIL)))))
   (FIRST-SETTER VALUESTREE
    (GET-QUOTED-TREE "((VALUES) \"/STELLA\")" "/STELLA"))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR (%%REST VALUESTREE))) (SRCTS NULL)
     (ITER-005 (%LIST.THE-CONS-LIST SOURCETYPES)) (TGTTS NULL)
     (ITER-006 (%LIST.THE-CONS-LIST TARGETTYPES)))
    (CL:LOOP WHILE
     (CL:AND (NEXT? IT) (CL:NOT (CL:EQ ITER-005 NIL))
      (CL:NOT (CL:EQ ITER-006 NIL)))
     DO (CL:SETQ SRCTS (%%VALUE ITER-005))
     (CL:SETQ TGTTS (%%VALUE ITER-006))
     (VALUE-SETTER IT
      (COERCE-A-TREE (%CONS-ITERATOR.VALUE IT) SRCTS TGTTS))
     (CL:SETQ ITER-005 (%%REST ITER-005))
     (CL:SETQ ITER-006 (%%REST ITER-006))))
   (CL:RETURN-FROM COERCE-MV-TREE
    (CL:VALUES OTREE VALUESTREE RETURNTYPES))))

;;; (DEFUN (WALK-RETURN-AND-UNBIND-SPECIALS CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-RETURN-AND-UNBIND-SPECIALS (TREE)
  (CL:LET*
   ((UNBINDTREE (YIELD-RETURN-SPECIAL-UNBIND-TREE))
    (VALUETREES (%%REST TREE)) (VALUEVARIABLES NIL)
    (VALUEBINDINGS NIL))
   (CL:LET* ((*SPECIALSENABLED?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *SPECIALSENABLED?*))
    (CL:WHEN (CL:= (LENGTH VALUETREES) 0)
     (CL:RETURN-FROM WALK-RETURN-AND-UNBIND-SPECIALS
      (WALK-A-CONS-TREE
       (LIST* SYM-WALK-STELLA-PROGN UNBINDTREE (CONS TREE NIL)))))
    (CL:WHEN
     (CL:AND (CL:= (LENGTH VALUETREES) 1)
      (CL:NOT
       (CL:EQ
        (REST (METHOD-RETURN-TYPE-SPECIFIERS *METHODBEINGWALKED*))
        NIL)))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000
        (CL:1-
         (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS *METHODBEINGWALKED*))))
       (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000) (CL:SETQ I I)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000 (CONS (LOCAL-GENSYM "RETURN-VALUE") NIL))
         (CL:IF (CL:EQ VALUEVARIABLES NIL)
          (CL:SETQ VALUEVARIABLES COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST VALUEVARIABLES COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS (LOCAL-GENSYM "RETURN-VALUE") NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (CL:SETF (%%REST TREE) VALUEVARIABLES)
     (CL:RETURN-FROM WALK-RETURN-AND-UNBIND-SPECIALS
      (WALK-A-CONS-TREE
       (LIST* SYM-WALK-STELLA-MV-BIND (COPY-CONS-LIST VALUEVARIABLES)
        (CONS (%%VALUE VALUETREES)
         (CONCATENATE (TREE-TO-TREES UNBINDTREE) (CONS TREE NIL)))))))
    (CL:LET* ((IT (ALLOCATE-ITERATOR VALUETREES)))
     (CL:LOOP WHILE (NEXT? IT) DO
      (CL:WHEN
       (CL:OR (CONS? (%CONS-ITERATOR.VALUE IT))
        (CL:AND (SYMBOL? (%CONS-ITERATOR.VALUE IT))
         (CL:NOT
          (CL:EQ (LOOKUP-OLD-VALUE-VARIABLE (%CONS-ITERATOR.VALUE IT))
           NULL))))
       (CL:SETQ VALUEBINDINGS
        (CONS
         (CONS (LOCAL-GENSYM "RETURN-VALUE")
          (CONS (%CONS-ITERATOR.VALUE IT) NIL))
         VALUEBINDINGS))
       (VALUE-SETTER IT (%%VALUE (%%VALUE VALUEBINDINGS))))))
    (CL:RETURN-FROM WALK-RETURN-AND-UNBIND-SPECIALS
     (WALK-A-CONS-TREE
      (LIST* SYM-WALK-STELLA-LET (REVERSE VALUEBINDINGS)
       (CONCATENATE (TREE-TO-TREES UNBINDTREE) (CONS TREE NIL))))))))

;;; (DEFUN (WALK-RETURN-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-RETURN-TREE (TREE)
  (CL:WHEN (CL:EQ *METHODBEINGWALKED* NULL)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Return statement encountered outside of method or function definition."
      EOL)))
   (CL:RETURN-FROM WALK-RETURN-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:SETQ *FOUNDRETURN?* CL:T)
  (CL:WHEN (NEED-TO-UNBIND-SPECIALS?)
   (CL:RETURN-FROM WALK-RETURN-TREE
    (WALK-RETURN-AND-UNBIND-SPECIALS TREE)))
  (CL:LET* ((METHOD *METHODBEINGWALKED*) (TARGETTYPES (NEW-LIST)))
   (CL:LET*
    ((RTYPE NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ RTYPE (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (COMPUTE-RELATIVE-TYPE-SPEC RTYPE
          (%METHOD-SLOT.SLOT-OWNER METHOD))
         NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TARGETTYPES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST TARGETTYPES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST TARGETTYPES)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (COMPUTE-RELATIVE-TYPE-SPEC RTYPE
          (%METHOD-SLOT.SLOT-OWNER METHOD))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((OTREE NULL) (VALUESTREE NULL) (VALUETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE VALUESTREE VALUETYPES)
     (WALK-MV-EXPRESSION-TREE
      (CL:IF
       (CL:AND (CL:= (LENGTH (%%REST TREE)) 1)
        (CL:NOT (CL:EQ (REST TARGETTYPES) NIL)))
       (%%VALUE (%%REST TREE))
       (CONS SYM-WALK-STELLA-VALUES (CONCATENATE (%%REST TREE) NIL)))
      TARGETTYPES SYM-WALK-STELLA-RETURN))
    (FREE TARGETTYPES) (FREE VALUETYPES)
    (CL:WHEN (CL:EQ VALUESTREE NULL)
     (CL:WHEN (CL:NOT (CL:EQ (%%REST TREE) NIL))
      (SECOND-SETTER TREE OTREE))
     (CL:RETURN-FROM WALK-RETURN-TREE
      (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
    (FIRST-SETTER VALUESTREE SYM-WALK-STELLA-RETURN)
    (CL:RETURN-FROM WALK-RETURN-TREE
     (CL:VALUES OTREE SGT-WALK-STELLA-VOID)))))

;;; (DEFUN (WALK-MV-SETQ-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MV-SETQ-TREE (TREE)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (BAD-ARGUMENT-COUNT? TREE 2) (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:IF (CL:NOT (CONS? (%%VALUE (%%REST TREE))))
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((V NULL) (ITER-000 (%%VALUE (%%REST TREE))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ V (%%VALUE ITER-000))
         (CL:WHEN (CL:NOT (SYMBOL? V)) (CL:SETQ ALWAYS?-000 CL:NIL)
          (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
      (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal 'mv-setq' expression: `" (DE-UGLIFY-PARSE-TREE TREE)
       "'." EOL)))
    (CL:RETURN-FROM WALK-MV-SETQ-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
  (CL:LET*
   ((VARIABLES (%%VALUE (%%REST TREE))) (TARGETTYPES (NEW-LIST)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR VARIABLES)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? IT) DO
     (VALUE-SETTER IT (TRUE-VARIABLE-NAME (%CONS-ITERATOR.VALUE IT)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (LOOKUP-VARIABLE-TYPE (%CONS-ITERATOR.VALUE IT)) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TARGETTYPES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST TARGETTYPES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST TARGETTYPES)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (LOOKUP-VARIABLE-TYPE (%CONS-ITERATOR.VALUE IT)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET* ((OTREE NULL) (VALUESTREE NULL) (VALUETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE VALUESTREE VALUETYPES)
     (WALK-MV-EXPRESSION-TREE (%%VALUE (%%REST (%%REST TREE)))
      TARGETTYPES SYM-WALK-STELLA-MV-SETQ))
    (FREE VALUETYPES) (FREE TARGETTYPES)
    (CL:WHEN (CL:NOT (CL:EQ VALUESTREE NULL))
     (FIRST-SETTER VALUESTREE SYM-WALK-STELLA-PROGN)
     (CL:LET*
      ((IT (ALLOCATE-ITERATOR (%%REST VALUESTREE))) (VAR NULL)
       (ITER-001 VARIABLES))
      (CL:LOOP WHILE (CL:AND (NEXT? IT) (CL:NOT (CL:EQ ITER-001 NIL)))
       DO (CL:SETQ VAR (%%VALUE ITER-001))
       (VALUE-SETTER IT
        (LIST* SYM-WALK-STELLA-SETQ VAR
         (CONS (%CONS-ITERATOR.VALUE IT) NIL)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETF (%%REST (%%REST TREE)) NIL)
     (CL:RETURN-FROM WALK-MV-SETQ-TREE
      (SYS-TREE OTREE SGT-WALK-STELLA-VOID)))
    (THIRD-SETTER TREE OTREE)
    (CL:RETURN-FROM WALK-MV-SETQ-TREE
     (SYS-TREE TREE SGT-WALK-STELLA-VOID)))))

;;; (DEFUN (WALK-MV-BIND-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MV-BIND-TREE (TREE)
  (CL:WHEN
   (CL:OR (CL:< (LENGTH TREE) 3)
    (CL:NOT (CONS? (%%VALUE (%%REST TREE)))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal 'mv-bind' expression: `" (DE-UGLIFY-PARSE-TREE TREE)
      "'." EOL)))
   (CL:RETURN-FROM WALK-MV-BIND-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:LET*
   ((DECLARATIONS (%%VALUE (%%REST TREE)))
    (MVTREE (%%VALUE (%%REST (%%REST TREE))))
    (BODY (%%REST (%%REST (%%REST TREE)))) (VARIABLES NIL) (DECL NULL)
    (TARGETTYPES (NEW-LIST)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR DECLARATIONS)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:SETQ DECL (%CONS-ITERATOR.VALUE IT))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DECL)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
        (CL:PROGN
         (CL:WHEN
          (CL:NOT
           (CL:AND (SYMBOL? (%%VALUE DECL)) (CL:= (LENGTH DECL) 2)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal variable declaration `"
             (DE-UGLIFY-PARSE-TREE DECL) "' in 'mv-bind' expression: `"
             (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
          (CL:RETURN-FROM WALK-MV-BIND-TREE
           (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
         (PUSH TARGETTYPES
          (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST DECL))))
         (CL:SETF (%%REST (%%REST DECL))
          (CONS SYM-WALK-STELLA-NULL NIL))
         (CL:SETQ VARIABLES (CONS (%%VALUE DECL) VARIABLES))))
       ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
        (CL:PROGN (PUSH TARGETTYPES SGT-WALK-STELLA-UNKNOWN)
         (VALUE-SETTER IT
          (CONS DECL
           (LIST* SGT-WALK-STELLA-UNKNOWN SYM-WALK-STELLA-NULL NIL)))
         (CL:SETQ VARIABLES (CONS DECL VARIABLES))))
       (CL:T
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Illegal variable `" (DE-UGLIFY-PARSE-TREE DECL)
           "' in 'mv-bind' expression: `" (DE-UGLIFY-PARSE-TREE TREE)
           "'." EOL)))
        (CL:RETURN-FROM WALK-MV-BIND-TREE
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))))))
   (CL:SETQ VARIABLES (REVERSE VARIABLES))
   (CL:LET* ((VARIABLE NULL) (ITER-000 VARIABLES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VARIABLE (%%VALUE ITER-000))
     (PUSH-VARIABLE-BINDING VARIABLE SGT-WALK-STELLA-UNINITIALIZED)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((OMVTREE NULL) (VALUESTREE NULL) (VARIABLETYPES NULL))
    (CL:MULTIPLE-VALUE-SETQ (OMVTREE VALUESTREE VARIABLETYPES)
     (WALK-MV-EXPRESSION-TREE MVTREE (REVERSE TARGETTYPES)
      SYM-WALK-STELLA-MV-BIND))
    (CL:LET* ((VARIABLE NULL) (ITER-001 VARIABLES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ VARIABLE (%%VALUE ITER-001)) (CL:SETQ VARIABLE VARIABLE)
      (POP-VARIABLE-BINDING) (CL:SETQ ITER-001 (%%REST ITER-001))))
    (FREE TARGETTYPES) (CL:SETF (%%REST (%%REST (%%REST TREE))) NIL)
    (CL:LET*
     ((DECL NULL) (ITER-002 DECLARATIONS) (TYPE NULL)
      (ITER-003 (%LIST.THE-CONS-LIST VARIABLETYPES)))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
       (CL:NOT (CL:EQ ITER-003 NIL)))
      DO (CL:SETQ DECL (%%VALUE ITER-002))
      (CL:SETQ TYPE (%%VALUE ITER-003))
      (CL:WHEN (CL:EQ SGT-WALK-STELLA-UNKNOWN (%%VALUE (%%REST DECL)))
       (SECOND-SETTER DECL TYPE))
      (CL:SETQ ITER-002 (%%REST ITER-002))
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (FREE VARIABLETYPES)
    (CL:COND
     ((CL:NOT (CL:EQ VALUESTREE NULL))
      (FIRST-SETTER VALUESTREE SYM-WALK-STELLA-PROGN)
      (CL:LET*
       ((IT (ALLOCATE-ITERATOR (%%REST VALUESTREE))) (VAR NULL)
        (ITER-004 VARIABLES))
       (CL:LOOP WHILE (CL:AND (NEXT? IT) (CL:NOT (CL:EQ ITER-004 NIL)))
        DO (CL:SETQ VAR (%%VALUE ITER-004))
        (VALUE-SETTER IT
         (LIST* SYM-WALK-STELLA-SETQ VAR
          (CONS (%CONS-ITERATOR.VALUE IT) NIL)))
        (CL:SETQ ITER-004 (%%REST ITER-004))))
      (CL:SETQ VALUESTREE OMVTREE))
     (CL:T
      (CL:SETQ VALUESTREE
       (LIST* SYM-WALK-STELLA-MV-SETQ VARIABLES (CONS OMVTREE NIL)))))
    (CL:RETURN-FROM WALK-MV-BIND-TREE
     (WALK-A-CONS-TREE
      (LIST* SYM-WALK-STELLA-LET DECLARATIONS
       (CONS VALUESTREE (CONCATENATE BODY NIL))))))))

;;; (DEFUN (WALK-LOOP-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LOOP-TREE (TREE)
  (CL:LET* ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *NOFSPECIALSATLOOPENTRY*))
   (CL:SETF (%%REST TREE) (WALK-LIST-OF-STATEMENTS (%%REST TREE)))
   (CL:RETURN-FROM WALK-LOOP-TREE (SYS-TREE TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-LOOP-EXIT-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-LOOP-EXIT-TREE (TREE)
  (BAD-ARGUMENT-COUNT? TREE 0)
  (CL:IF (NEED-TO-UNBIND-SPECIALS?)
   (CL:LET* ((UNBINDTREE (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE)))
    (CL:LET* ((*SPECIALSENABLED?* CL:NIL))
     (CL:DECLARE (CL:SPECIAL *SPECIALSENABLED?*))
     (CL:RETURN-FROM WALK-LOOP-EXIT-TREE
      (WALK-A-CONS-TREE
       (LIST* SYM-WALK-STELLA-PROGN UNBINDTREE (CONS TREE NIL))))))
   (CL:RETURN-FROM WALK-LOOP-EXIT-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-WHILE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-WHILE-TREE (TREE)
  (CL:LET* ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *NOFSPECIALSATLOOPENTRY*))
   (CL:LET*
    ((TEST
      (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
       SGT-WALK-STELLA-BOOLEAN SYM-WALK-STELLA-WHILE CL:T))
     (BODY (%%REST (%%REST TREE))))
    (SECOND-SETTER TREE TEST)
    (CL:WHEN (PROCEDURAL-EXPRESSION? TEST)
     (CL:SETF (%%REST (%%REST TREE)) NIL)
     (CL:RETURN-FROM WALK-WHILE-TREE
      (WALK-A-CONS-TREE
       (LIST* SYM-WALK-STELLA-LOOP
        (LIST* SYM-WALK-STELLA-UNLESS TEST
         (CONS (CONS SYM-WALK-STELLA-BREAK NIL) NIL))
        (CONCATENATE BODY NIL)))))
    (CL:SETF (%%REST (%%REST TREE))
     (WALK-LIST-OF-STATEMENTS (%%REST (%%REST TREE))))
    (CL:RETURN-FROM WALK-WHILE-TREE
     (CL:VALUES TREE SGT-WALK-STELLA-VOID)))))

;;; (DEFUN (WALK-CONDITIONAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CONDITIONAL-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE))
    (TEST
     (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
      SGT-WALK-STELLA-BOOLEAN OPERATOR CL:T)))
   (SECOND-SETTER TREE TEST)
   (CL:WHEN (PROCEDURAL-EXPRESSION? TEST)
    (CL:RETURN-FROM WALK-CONDITIONAL-TREE
     (CL:VALUES (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION TREE TEST)
      SGT-WALK-STELLA-VOID)))
   (CL:LET* ((TEST-VALUE-000 OPERATOR))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-IF)
      (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 3)
       (CL:RETURN-FROM WALK-CONDITIONAL-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
      (THIRD-SETTER TREE
       (WALK-STATEMENT (%%VALUE (%%REST (%%REST TREE))) CL:T))
      (FOURTH-SETTER TREE (WALK-STATEMENT (FOURTH TREE) CL:T)))
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-WHEN)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-UNLESS))
      (CL:SETF (%%REST (%%REST TREE))
       (WALK-LIST-OF-STATEMENTS (%%REST (%%REST TREE)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM WALK-CONDITIONAL-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-CHOOSE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CHOOSE-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE))
    (TEST
     (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
      SGT-WALK-STELLA-BOOLEAN OPERATOR CL:T))
    (TEMP NULL) (TYPE1 NULL) (TYPE2 NULL) (TYPE NULL))
   (SECOND-SETTER TREE TEST)
   (CL:WHEN (VRLET-EXPRESSION? TEST)
    (CL:RETURN-FROM WALK-CHOOSE-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE TEST
      SGT-WALK-STELLA-BOOLEAN)))
   (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 3)
    (CL:RETURN-FROM WALK-CHOOSE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:MULTIPLE-VALUE-SETQ (TEMP TYPE1)
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST (%%REST TREE))) *TARGETTYPE*
     SYM-WALK-STELLA-CHOOSE CL:T))
   (THIRD-SETTER TREE TEMP)
   (CL:MULTIPLE-VALUE-SETQ (TEMP TYPE2)
    (WALK-EXPRESSION-TREE (FOURTH TREE) *TARGETTYPE*
     SYM-WALK-STELLA-CHOOSE CL:T))
   (FOURTH-SETTER TREE TEMP)
   (CL:COND
    ((CL:EQ TYPE1 SGT-WALK-STELLA-UNKNOWN) (CL:SETQ TYPE TYPE2)
     (THIRD-SETTER TREE
      (COERCE-A-TREE (%%VALUE (%%REST (%%REST TREE))) TYPE1 TYPE)))
    ((CL:EQ TYPE2 SGT-WALK-STELLA-UNKNOWN) (CL:SETQ TYPE TYPE1)
     (FOURTH-SETTER TREE (COERCE-A-TREE (FOURTH TREE) TYPE2 TYPE)))
    (CL:T
     (CL:SETQ TYPE (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE1 TYPE2))))
   (CL:WHEN
    (CL:OR (CL:EQ TYPE SGT-WALK-STELLA-VOID)
     (CL:AND (CL:NOT (SUB-TYPE-SPEC-OF? TYPE SGT-WALK-STELLA-OBJECT))
      (%CLASS.ABSTRACT? (TYPE-SPEC-TO-CLASS TYPE))))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Incompatible subexpression types `"
       (DE-UGLIFY-PARSE-TREE TYPE1) "' and `"
       (DE-UGLIFY-PARSE-TREE TYPE2) "'" EOL " in 'choose' expression.."
       EOL))))
   (CL:WHEN
    (CL:OR (VRLET-EXPRESSION? (%%VALUE (%%REST (%%REST TREE))))
     (VRLET-EXPRESSION? (FOURTH TREE)))
    (CL:LET* ((RESULTVARIABLE (LOCAL-GENSYM "CHOOSE-VALUE")))
     (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
      (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
       (WALK-A-TREE
        (LIST* SYM-WALK-STELLA-VRLET
         (CONS
          (CONS RESULTVARIABLE
           (CONS TYPE (CONS SYM-WALK-STELLA-NULL NIL)))
          NIL)
         (LIST* SYM-WALK-STELLA-IF (%%VALUE (%%REST TREE))
          (LIST*
           (LIST* SYM-WALK-STELLA-SETQ RESULTVARIABLE
            (CONS (%%VALUE (%%REST (%%REST TREE))) NIL))
           (LIST* SYM-WALK-STELLA-SETQ RESULTVARIABLE
            (CONS (FOURTH TREE) NIL))
           NIL))
         RESULTVARIABLE NIL)))
      (CL:RETURN-FROM WALK-CHOOSE-TREE
       (CL:VALUES VALUE-000 VALUE-001)))))
   (CL:COND ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
    (CL:T
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ TYPE1 TYPE))
       (CL:NOT (SUB-TYPE-SPEC-OF? TYPE1 TYPE2)))
      (THIRD-SETTER TREE
       (LIST* SYM-WALK-STELLA-CAST (%%VALUE (%%REST (%%REST TREE)))
        (CONS TYPE NIL))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ TYPE2 TYPE))
       (CL:NOT (SUB-TYPE-SPEC-OF? TYPE2 TYPE1)))
      (FOURTH-SETTER TREE
       (LIST* SYM-WALK-STELLA-CAST (FOURTH TREE) (CONS TYPE NIL))))))
   (CL:RETURN-FROM WALK-CHOOSE-TREE (CL:VALUES TREE TYPE))))

;;; (DEFUN (WALK-BOOLEAN-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-BOOLEAN-TREE (TREE)
  (CL:LET* ((OTREE (HELP-WALK-BOOLEAN-TREE TREE)))
   (CL:WHEN (PROCEDURAL-EXPRESSION? OTREE)
    (CL:SETQ OTREE (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS OTREE)))
   (CL:RETURN-FROM WALK-BOOLEAN-TREE
    (CL:VALUES OTREE SGT-WALK-STELLA-BOOLEAN))))

;;; (DEFUN (AND-OR-NOT-TREE? BOOLEAN) ...)

(CL:DEFUN AND-OR-NOT-TREE? (TREE)
  (CL:IF (CONS? TREE)
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT))
      (CL:RETURN-FROM AND-OR-NOT-TREE? CL:T))
     (CL:T (CL:RETURN-FROM AND-OR-NOT-TREE? CL:NIL))))
   (CL:RETURN-FROM AND-OR-NOT-TREE? CL:NIL)))

;;; (DEFUN (HELP-WALK-BOOLEAN-TREE OBJECT) ...)

(CL:DEFUN HELP-WALK-BOOLEAN-TREE (TREE)
  (CL:LET* ((CURSOR (%%REST TREE)) (TEMP NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR)
     (CL:IF (AND-OR-NOT-TREE? (%%VALUE CURSOR))
      (HELP-WALK-BOOLEAN-TREE (%%VALUE CURSOR))
      (WALK-EXPRESSION-TREE (%%VALUE CURSOR) SGT-WALK-STELLA-BOOLEAN
       (%%VALUE TREE) CL:T)))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
      (CL:WHEN (CL:EQ (%%REST TREE) NIL)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TRUE-WRAPPER))
      (CL:WHEN (CL:EQ (%%REST (%%REST TREE)) NIL)
       (CL:SETQ TEMP (%%VALUE (%%REST TREE)))
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TEMP)))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
      (CL:WHEN (CL:EQ (%%REST TREE) NIL)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE FALSE-WRAPPER))
      (CL:WHEN (CL:EQ (%%REST (%%REST TREE)) NIL)
       (CL:SETQ TEMP (%%VALUE (%%REST TREE)))
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TEMP)))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT)
      (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 1)
       (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-BOOLEAN))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM HELP-WALK-BOOLEAN-TREE TREE)))

;;; (DEFUN (WALK-COND-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-COND-TREE (TREE)
  (CL:LET* ((CONDITION NULL) (ITER-000 (%%REST TREE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CONDITION (%%VALUE ITER-000))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE CONDITION) SGT-WALK-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN
        (CL:NOT (CL:EQ (%%VALUE CONDITION) SYM-WALK-STELLA-OTHERWISE))
        (CL:SETF (%%VALUE CONDITION)
         (WALK-EXPRESSION-TREE (%%VALUE CONDITION)
          SGT-WALK-STELLA-BOOLEAN SYM-WALK-STELLA-COND CL:T))
        (CL:WHEN (PROCEDURAL-EXPRESSION? (%%VALUE CONDITION))
         (CL:RETURN-FROM WALK-COND-TREE
          (WALK-A-CONS-TREE (COND-TREE-TO-IF-TREE TREE)))))
       (CL:SETF (%%REST CONDITION)
        (WALK-LIST-OF-STATEMENTS (%%REST CONDITION)))))
     (CL:T
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal condition in COND statement: `"
         (DE-UGLIFY-PARSE-TREE CONDITION) "'." EOL)))
      (CL:RETURN-FROM WALK-COND-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM WALK-COND-TREE (CL:VALUES TREE SGT-WALK-STELLA-VOID)))

;;; (DEFUN (COND-TREE-TO-IF-TREE CONS) ...)

(CL:DEFUN COND-TREE-TO-IF-TREE (TREE)
  (CL:LET*
   ((FIRSTCONDITION (%%VALUE (%%REST TREE)))
    (OTHERCONDITIONS (%%REST (%%REST TREE))) (FIRSTTEST NULL))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE FIRSTCONDITION) SGT-WALK-STELLA-CONS)
     (CL:PROGN (CL:SETQ FIRSTTEST (%%VALUE FIRSTCONDITION))
      (CL:COND
       ((CL:EQ FIRSTTEST SYM-WALK-STELLA-OTHERWISE)
        (CL:COND
         ((CL:EQ OTHERCONDITIONS NIL)
          (FIRST-SETTER TREE SYM-WALK-STELLA-PROGN)
          (CL:SETF (%%REST TREE) (%%REST FIRSTCONDITION))
          (CL:RETURN-FROM COND-TREE-TO-IF-TREE TREE))
         (CL:T (CL:SETF (%%VALUE FIRSTCONDITION) SYM-WALK-STELLA-TRUE)
          (CL:RETURN-FROM COND-TREE-TO-IF-TREE
           (COND-TREE-TO-IF-TREE TREE)))))
       ((CL:EQ OTHERCONDITIONS NIL)
        (FIRST-SETTER TREE SYM-WALK-STELLA-WHEN)
        (CL:SETF (%%REST TREE) FIRSTCONDITION)
        (CL:RETURN-FROM COND-TREE-TO-IF-TREE TREE))
       (CL:T (CL:SETF (%%VALUE FIRSTCONDITION) SYM-WALK-STELLA-PROGN)
        (SECOND-SETTER TREE SYM-WALK-STELLA-COND)
        (CL:RETURN-FROM COND-TREE-TO-IF-TREE
         (LIST* SYM-WALK-STELLA-IF FIRSTTEST
          (CONS FIRSTCONDITION
           (CONS (COND-TREE-TO-IF-TREE (%%REST TREE)) NIL))))))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal condition in COND statement: `"
        (DE-UGLIFY-PARSE-TREE FIRSTCONDITION) "'." EOL)))
     (CL:RETURN-FROM COND-TREE-TO-IF-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))))

;;; (DEFUN (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS OBJECT) ...)

(CL:DEFUN YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS (CASETEST)
  (CL:WHEN (CL:EQ CASETEST SYM-WALK-STELLA-OTHERWISE)
   (CL:RETURN-FROM YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS CASETEST))
  (CL:LET* ((SYMBOL NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CASETEST)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((IT (ALLOCATE-ITERATOR CASETEST)))
        (CL:LOOP WHILE (NEXT? IT) DO
         (CL:SETQ SYMBOL (%CONS-ITERATOR.VALUE IT))
         (CL:WHEN (CL:= (%SYMBOL.SYMBOL-ID SYMBOL) NULL-INTEGER)
          (CL:SETQ SYMBOL
           (INTERN-PERMANENT-SYMBOL (%SYMBOL.SYMBOL-NAME SYMBOL))))
         (VALUE-SETTER IT (WRAP-INTEGER (%SYMBOL.SYMBOL-ID SYMBOL)))
         (REGISTER-SYMBOL SYMBOL)))
       (CL:RETURN-FROM YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS
        CASETEST)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SYMBOL CASETEST)
       (CL:WHEN (CL:= (%SYMBOL.SYMBOL-ID SYMBOL) NULL-INTEGER)
        (CL:SETQ SYMBOL
         (INTERN-PERMANENT-SYMBOL (%SYMBOL.SYMBOL-NAME SYMBOL))))
       (REGISTER-SYMBOL CASETEST)
       (CL:RETURN-FROM YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS
        (WRAP-INTEGER (%SYMBOL.SYMBOL-ID SYMBOL)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (WALK-HARDCODED-SYMBOL-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-HARDCODED-SYMBOL-CASE-TREE (TREE)
  (SECOND-SETTER TREE
   (LIST* SYM-WALK-STELLA-SYMBOL-ID
    (LIST* SYM-WALK-STELLA-CAST (%%VALUE (%%REST TREE))
     (CONS SYM-WALK-STELLA-GENERALIZED-SYMBOL NIL))
    NIL))
  (CL:LET* ((COND NULL) (ITER-000 (%%REST (%%REST TREE))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ COND (%%VALUE ITER-000))
    (FIRST-SETTER COND
     (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS (%%VALUE COND)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM WALK-HARDCODED-SYMBOL-CASE-TREE (WALK-CASE-TREE TREE)))

;;; (DEFGLOBAL *TYPE-PREDICATE-TABLE* ...)

(CL:DEFVAR *TYPE-PREDICATE-TABLE* NULL
  "Table of specialized type predicates for various types.
These predicates have to be used instead of `isa?', since they also work
during bootstrap when only some class objects are defined.")

;;; (DEFUN (YIELD-ISA?-CASE-TEST CONS) ...)

(CL:DEFUN YIELD-ISA?-CASE-TEST (CASEKEY TESTEXPRESSION)
  (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-PREDICATE-TABLE*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ENTRY (%%VALUE ITER-000))
    (CL:WHEN (CL:EQ (%%VALUE ENTRY) CASEKEY)
     (CL:RETURN-FROM YIELD-ISA?-CASE-TEST
      (CONS (%%VALUE (%%REST ENTRY))
       (CONS (COPY-CONS-TREE TESTEXPRESSION) NIL))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM YIELD-ISA?-CASE-TEST
   (LIST* SYM-WALK-STELLA-ISA? (COPY-CONS-TREE TESTEXPRESSION)
    (CONS CASEKEY NIL))))

;;; (DEFUN (YIELD-SUBTYPE-OF?-CASE-TEST CONS) ...)

(CL:DEFUN YIELD-SUBTYPE-OF?-CASE-TEST (CASEKEY TESTEXPRESSION)
  (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-PREDICATE-TABLE*))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ENTRY (%%VALUE ITER-000))
    (CL:WHEN (CL:EQ (%%VALUE ENTRY) CASEKEY)
     (CL:RETURN-FROM YIELD-SUBTYPE-OF?-CASE-TEST
      (CONS (%%VALUE (%%REST (%%REST ENTRY)))
       (CONS (COPY-CONS-TREE TESTEXPRESSION) NIL))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM YIELD-SUBTYPE-OF?-CASE-TEST
   (LIST* SYM-WALK-STELLA-SUBTYPE-OF? (COPY-CONS-TREE TESTEXPRESSION)
    (CONS CASEKEY NIL))))

;;; (DEFUN (YIELD-COND-TEST CONS) ...)

(CL:DEFUN YIELD-COND-TEST (CASETEST TESTVARIABLE EQUALITYTEST)
  (CL:WHEN
   (CL:AND (SYMBOL? CASETEST) (CL:NOT (USE-HARDCODED-SYMBOLS?)))
   (CL:SETQ CASETEST
    (LIST* SYM-WALK-STELLA-TYPED-SYS (REGISTER-SYMBOL CASETEST)
     (CONS SGT-WALK-STELLA-SYMBOL NIL))))
  (CL:COND
   ((CL:EQ EQUALITYTEST SYM-WALK-STELLA-ISA?)
    (CL:RETURN-FROM YIELD-COND-TEST
     (YIELD-ISA?-CASE-TEST (TYPIFY CASETEST) TESTVARIABLE)))
   ((CL:EQ EQUALITYTEST SYM-WALK-STELLA-SUBTYPE-OF?)
    (CL:RETURN-FROM YIELD-COND-TEST
     (YIELD-SUBTYPE-OF?-CASE-TEST (TYPIFY CASETEST) TESTVARIABLE)))
   (CL:T
    (CL:RETURN-FROM YIELD-COND-TEST
     (CONS EQUALITYTEST
      (CONS (COPY-CONS-TREE TESTVARIABLE) (CONS CASETEST NIL)))))))

;;; (DEFUN (YIELD-COND-TEST-OR-TESTS OBJECT) ...)

(CL:DEFUN YIELD-COND-TEST-OR-TESTS (CASETEST TESTVARIABLE EQUALITYTEST)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE CASETEST) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((IT (ALLOCATE-ITERATOR CASETEST)))
      (CL:LOOP WHILE (NEXT? IT) DO
       (VALUE-SETTER IT
        (YIELD-COND-TEST (%CONS-ITERATOR.VALUE IT) TESTVARIABLE
         EQUALITYTEST))))
     (CL:SETQ CASETEST (CONS SYM-WALK-STELLA-OR CASETEST))
     (CL:RETURN-FROM YIELD-COND-TEST-OR-TESTS CASETEST)))
   (CL:T
    (CL:IF (CL:EQ CASETEST SYM-WALK-STELLA-OTHERWISE)
     (CL:RETURN-FROM YIELD-COND-TEST-OR-TESTS CASETEST)
     (CL:RETURN-FROM YIELD-COND-TEST-OR-TESTS
      (YIELD-COND-TEST CASETEST TESTVARIABLE EQUALITYTEST))))))

;;; (DEFUN (COUNT-CASE-TEST-CLAUSES INTEGER BOOLEAN) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) (CL:VALUES CL:FIXNUM CL:T))
  COUNT-CASE-TEST-CLAUSES))
(CL:DEFUN COUNT-CASE-TEST-CLAUSES (TREE)
  (CL:LET*
   ((CLAUSES (%%REST (%%REST TREE))) (NOFCLAUSES 0)
    (OTHERWISE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFCLAUSES))
   (CL:LET* ((CLAUSE NULL) (ITER-000 CLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE (%%VALUE CLAUSE))
        SGT-WALK-STELLA-CONS)
       (CL:SETQ NOFCLAUSES
        (CL:+ NOFCLAUSES (LENGTH (%%VALUE CLAUSE)))))
      (CL:T
       (CL:IF (CL:EQ (%%VALUE CLAUSE) SYM-WALK-STELLA-OTHERWISE)
        (CL:SETQ OTHERWISE? CL:T)
        (CL:SETQ NOFCLAUSES (CL:1+ NOFCLAUSES)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM COUNT-CASE-TEST-CLAUSES
    (CL:VALUES NOFCLAUSES OTHERWISE?))))

;;; (DEFUN (ATTACH-UNHANDLED-CASE-ERROR-CLAUSE CONS) ...)

(CL:DEFUN ATTACH-UNHANDLED-CASE-ERROR-CLAUSE (CASETREE TESTTREE)
  (CL:LET* ((LASTCLAUSE (LAST CASETREE)))
   (CL:IF
    (CL:AND (CONS? LASTCLAUSE)
     (CL:NOT (CL:EQ (%%VALUE LASTCLAUSE) SYM-WALK-STELLA-OTHERWISE)))
    (CL:RETURN-FROM ATTACH-UNHANDLED-CASE-ERROR-CLAUSE
     (CONCATENATE CASETREE
      (CONS
       (LIST* SYM-WALK-STELLA-OTHERWISE
        (LIST* SYM-WALK-STELLA-ERROR (COPY-CONS-TREE TESTTREE)
         (CONS (WRAP-STRING " is not a valid case option") NIL))
        NIL)
       NIL)))
    (CL:RETURN-FROM ATTACH-UNHANDLED-CASE-ERROR-CLAUSE CASETREE))))

;;; (DEFUN (WALK-NON-BUILT-IN-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-NON-BUILT-IN-CASE-TREE (TREE EQUALITYTEST)
  (CL:LET*
   ((TESTEXPRESSION (%%VALUE (%%REST TREE)))
    (TESTVARIABLE
     (CL:IF
      (CL:OR (ATOMIC-EXPRESSION? TESTEXPRESSION)
       (CL:<= (COUNT-CASE-TEST-CLAUSES TREE) 1))
      (%%VALUE (%%REST TREE)) (LOCAL-GENSYM "TEST-VALUE")))
    (CONDITIONS (%%REST (%%REST TREE))))
   (CL:LET* ((COND NULL) (ITER-000 CONDITIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ COND (%%VALUE ITER-000))
     (FIRST-SETTER COND
      (YIELD-COND-TEST-OR-TESTS (%%VALUE COND) TESTVARIABLE
       EQUALITYTEST))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ CONDITIONS
    (ATTACH-UNHANDLED-CASE-ERROR-CLAUSE CONDITIONS TESTVARIABLE))
   (CL:RETURN-FROM WALK-NON-BUILT-IN-CASE-TREE
    (WALK-A-CONS-TREE
     (CL:IF (EQL? TESTEXPRESSION TESTVARIABLE)
      (CONS SYM-WALK-STELLA-COND (CONCATENATE CONDITIONS NIL))
      (LIST* SYM-WALK-STELLA-LET
       (CONS (CONS TESTVARIABLE (CONS TESTEXPRESSION NIL)) NIL)
       (CONS SYM-WALK-STELLA-COND (CONCATENATE CONDITIONS NIL)) NIL))))))

;;; (DEFUN (WALK-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CASE-TREE (TREE)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (>= (LENGTH TREE) 3))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((CLAUSE NULL) (ITER-000 (%%REST (%%REST TREE))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ CLAUSE (%%VALUE ITER-000))
       (CL:WHEN (CL:NOT (CONS? CLAUSE)) (CL:SETQ ALWAYS?-000 CL:NIL)
        (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal `case' statement: `" (DE-UGLIFY-PARSE-TREE TREE) "'."
       EOL)))
    (CL:RETURN-FROM WALK-CASE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
  (CL:LET*
   ((CLAUSES (%%REST (%%REST TREE)))
    (FIRSTTESTTREE
     (CL:IF (CONS? (%%VALUE (%%VALUE CLAUSES)))
      (%%VALUE (%%VALUE (%%VALUE CLAUSES)))
      (%%VALUE (%%VALUE CLAUSES))))
    (CASECONSTANTTYPE SGT-WALK-STELLA-UNKNOWN))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE FIRSTTESTTREE)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-GENERALIZED-SYMBOL)))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-GENERALIZED-SYMBOL)))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-GENERALIZED-SYMBOL)))
     ((SUBTYPE-OF-STRING? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-STRING)))
     ((SUBTYPE-OF-CHARACTER? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-CHARACTER)))
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-INTEGER)))
     ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-LONG-INTEGER)))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ CASECONSTANTTYPE SGT-WALK-STELLA-FLOAT)))
     (CL:T
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " `case' statement contains illegal constant of type `"
         (PRIMARY-TYPE FIRSTTESTTREE) "'" EOL "    `"
         (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
      (CL:RETURN-FROM WALK-CASE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))))
   (SECOND-SETTER TREE
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE)) CASECONSTANTTYPE
     SYM-WALK-STELLA-CASE CL:T))
   (CL:WHEN (VRLET-EXPRESSION? (%%VALUE (%%REST TREE)))
    (CL:RETURN-FROM WALK-CASE-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE (%%VALUE (%%REST TREE))
      CASECONSTANTTYPE)))
   (CL:WHEN
    (CL:AND (CL:EQ CASECONSTANTTYPE SGT-WALK-STELLA-GENERALIZED-SYMBOL)
     (USE-HARDCODED-SYMBOLS?))
    (CL:RETURN-FROM WALK-CASE-TREE
     (WALK-HARDCODED-SYMBOL-CASE-TREE TREE)))
   (CL:WHEN
    (CL:NOT
     (CL:OR (CL:EQ CASECONSTANTTYPE SGT-WALK-STELLA-INTEGER)
      (CL:EQ CASECONSTANTTYPE SGT-WALK-STELLA-LONG-INTEGER)
      (CL:EQ CASECONSTANTTYPE SGT-WALK-STELLA-CHARACTER)))
    (CL:RETURN-FROM WALK-CASE-TREE
     (WALK-NON-BUILT-IN-CASE-TREE TREE
      (CL:IF (CL:EQ CASECONSTANTTYPE SGT-WALK-STELLA-STRING)
       SYM-WALK-STELLA-STRING-EQL? SYM-WALK-STELLA-EQL?))))
   (CL:WHEN
    (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
    (CL:SETQ TREE
     (ATTACH-UNHANDLED-CASE-ERROR-CLAUSE TREE
      (%%VALUE (%%REST TREE)))))
   (CL:LET* ((CURSOR (%%REST (%%REST TREE))) (CONDITIONTREE NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
     (CL:SETQ CONDITIONTREE (%%VALUE CURSOR))
     (CL:WHEN
      (CL:NOT
       (CL:EQ (%%VALUE CONDITIONTREE) SYM-WALK-STELLA-OTHERWISE))
      (FIRST-SETTER CONDITIONTREE
       (CL:IF (CONS? (%%VALUE CONDITIONTREE))
        (WALK-LIST-OF-TREES (%%VALUE CONDITIONTREE))
        (WALK-A-TREE (%%VALUE CONDITIONTREE)))))
     (CL:SETF (%%REST CONDITIONTREE)
      (WALK-LIST-OF-STATEMENTS (%%REST CONDITIONTREE)))
     (CL:SETQ CURSOR (%%REST CURSOR)))
    (CL:RETURN-FROM WALK-CASE-TREE
     (CL:VALUES TREE SGT-WALK-STELLA-VOID)))))

;;; (DEFUN (WALK-TYPECASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-TYPECASE-TREE (TREE)
  (CL:LET*
   ((TESTTREE (%%VALUE (%%REST TREE))) (TESTEXPRESSIONTYPE NULL)
    (TESTVARIABLE NULL) (EXPANDEDCASES NIL)
    (NEEDCAST?
     (CL:AND (SYMBOL? TESTTREE)
      (CL:EQ (LOOKUP-GLOBAL-VARIABLE TESTTREE) NULL)))
    (PRECEDINGCLAUSETYPES (NEW-LIST)))
   (CL:WHEN NEEDCAST? (CL:SETQ TESTVARIABLE TESTTREE))
   (CL:MULTIPLE-VALUE-SETQ (TESTTREE TESTEXPRESSIONTYPE)
    (WALK-A-TREE TESTTREE))
   (SECOND-SETTER TREE TESTTREE)
   (CL:SETQ TESTEXPRESSIONTYPE
    (TYPE-SPEC-TO-BASE-TYPE TESTEXPRESSIONTYPE))
   (CL:WHEN (UNKNOWN-TYPE? TESTEXPRESSIONTYPE)
    (CL:SETQ TESTEXPRESSIONTYPE SGT-WALK-STELLA-UNKNOWN))
   (SECOND-SETTER TREE (SYS-TREE TESTTREE TESTEXPRESSIONTYPE))
   (CL:WHEN NEEDCAST?
    (CL:LET* ((CASETREE NULL) (ITER-000 (%%REST (%%REST TREE))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ CASETREE (%%VALUE ITER-000))
      (CL:COND
       ((CL:EQ (SAFE-PRIMARY-TYPE CASETREE) SGT-WALK-STELLA-CONS)
        (CL:PROGN
         (CL:LET* ((TYPETREE (%%VALUE CASETREE)))
          (CL:COND
           ((CL:EQ (SAFE-PRIMARY-TYPE TYPETREE) SGT-WALK-STELLA-CONS)
            (CL:PROGN (FIRST-SETTER CASETREE (%%VALUE TYPETREE))
             (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES))
             (CL:LET* ((TYPE NULL) (ITER-001 (%%REST TYPETREE)))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
               (CL:SETQ TYPE (%%VALUE ITER-001))
               (CL:SETQ EXPANDEDCASES
                (CONS
                 (CONS TYPE
                  (CONCATENATE (COPY-CONS-TREE (%%REST CASETREE)) NIL))
                 EXPANDEDCASES))
               (CL:SETQ ITER-001 (%%REST ITER-001))))))
           (CL:T
            (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES)))))))
       (CL:T (CL:SETQ EXPANDEDCASES (CONS CASETREE EXPANDEDCASES))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETF (%%REST (%%REST TREE)) (REVERSE EXPANDEDCASES)))
   (CL:LET* ((CASETREE NULL) (ITER-002 (%%REST (%%REST TREE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ CASETREE (%%VALUE ITER-002))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE CASETREE) SGT-WALK-STELLA-CONS)
       (CL:PROGN
        (CL:LET* ((TYPETREE (%%VALUE CASETREE)))
         (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TYPETREE)))
          (CL:COND
           ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
            (CL:PROGN
             (CL:WHEN
              (CL:NOT
               (STRING-EQL? (%SYMBOL.SYMBOL-NAME TYPETREE)
                "OTHERWISE"))
              (CL:LET*
               ((TYPE
                 (TYPE-SPEC-TO-BASE-TYPE
                  (YIELD-TYPE-SPECIFIER TYPETREE))))
               (VERIFY-TYPECASE-CLAUSE-TYPE TESTEXPRESSIONTYPE TYPE
                PRECEDINGCLAUSETYPES CASETREE)
               (FIRST-SETTER CASETREE TYPE)
               (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
               (CL:WHEN
                (CL:AND NEEDCAST?
                 (CL:NOT (CL:EQ (%%REST CASETREE) NIL)))
                (CL:SETF (%%REST CASETREE)
                 (YIELD-CASTED-TYPECASE-CLAUSE-TREES TESTVARIABLE TYPE
                  (%%REST CASETREE))))))))
           ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
            (CL:PROGN
             (CL:WHEN
              (CL:NOT
               (STRING-EQL? (%SURROGATE.SYMBOL-NAME TYPETREE)
                "OTHERWISE"))
              (CL:LET*
               ((TYPE
                 (TYPE-SPEC-TO-BASE-TYPE
                  (YIELD-TYPE-SPECIFIER TYPETREE))))
               (VERIFY-TYPECASE-CLAUSE-TYPE TESTEXPRESSIONTYPE TYPE
                PRECEDINGCLAUSETYPES CASETREE)
               (FIRST-SETTER CASETREE TYPE)
               (CL:SETQ TYPE (TYPE-TO-WRAPPED-TYPE TYPE))
               (CL:WHEN
                (CL:AND NEEDCAST?
                 (CL:NOT (CL:EQ (%%REST CASETREE) NIL)))
                (CL:SETF (%%REST CASETREE)
                 (YIELD-CASTED-TYPECASE-CLAUSE-TREES TESTVARIABLE TYPE
                  (%%REST CASETREE))))))))
           ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
            (CL:PROGN
             (CL:LET* ((IT (ALLOCATE-ITERATOR TYPETREE)))
              (CL:LOOP WHILE (NEXT? IT) DO
               (CL:WHEN (CONS? (%CONS-ITERATOR.VALUE IT))
                (CL:LET* ((*PRINTREADABLY?* CL:T))
                 (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
                 (SIGNAL-TRANSLATION-ERROR)
                 (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
                  (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
                  (%%PRINT-STREAM
                   (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
                   " Illegal type expression in 'typecase': `"
                   (DE-UGLIFY-PARSE-TREE TYPETREE) "'." EOL)))
                (CL:RETURN-FROM WALK-TYPECASE-TREE
                 (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
               (VALUE-SETTER IT
                (TYPE-SPEC-TO-BASE-TYPE
                 (YIELD-TYPE-SPECIFIER (%CONS-ITERATOR.VALUE IT))))
               (VERIFY-TYPECASE-CLAUSE-TYPE TESTEXPRESSIONTYPE
                (%CONS-ITERATOR.VALUE IT) PRECEDINGCLAUSETYPES
                CASETREE)))))
           (CL:T
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
               " Illegal type expression in 'typecase': `"
               (DE-UGLIFY-PARSE-TREE TYPETREE) "'." EOL)))
            (CL:RETURN-FROM WALK-TYPECASE-TREE
             (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))))))
      (CL:T
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Illegal case expression in 'typecase': `"
          (DE-UGLIFY-PARSE-TREE CASETREE) "'." EOL)))
       (CL:RETURN-FROM WALK-TYPECASE-TREE
        (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:RETURN-FROM WALK-TYPECASE-TREE
    (WALK-NON-BUILT-IN-CASE-TREE
     (LIST* SYM-WALK-STELLA-CASE
      (LIST* SYM-WALK-STELLA-SAFE-PRIMARY-TYPE (%%VALUE (%%REST TREE))
       NIL)
      (CONCATENATE (%%REST (%%REST TREE)) NIL))
     SYM-WALK-STELLA-SUBTYPE-OF?))))

;;; (DEFUN (YIELD-CASTED-TYPECASE-CLAUSE-TREES CONS) ...)

(CL:DEFUN YIELD-CASTED-TYPECASE-CLAUSE-TREES (TESTVARIABLE CLAUSETYPE CLAUSETREES)
  (CL:LET*
   ((TESTVARIABLETYPE (LOOKUP-VARIABLE-TYPE TESTVARIABLE))
    (NEEDREALCAST?
     (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)))
    (AUXVARIABLE
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA))
       NEEDREALCAST?)
      (LOCAL-GENSYM (%SYMBOL.SYMBOL-NAME TESTVARIABLE)) NULL))
    (CASTEDCLAUSETREES NULL))
   (CL:COND
    ((CL:NOT NEEDREALCAST?)
     (PUSH-VARIABLE-BINDING TESTVARIABLE CLAUSETYPE)
     (CL:SETQ CASTEDCLAUSETREES
      (CONS
       (LIST* SYM-WALK-STELLA-VOID-SYS
        (CONS SYM-WALK-STELLA-PROGN
         (CONCATENATE (WALK-LIST-OF-STATEMENTS CLAUSETREES) NIL))
        NIL)
       NIL))
     (POP-VARIABLE-BINDING))
    (CL:T
     (CL:WHEN (CL:NOT (CL:EQ AUXVARIABLE NULL))
      (PUSH-VARIABLE-BINDING AUXVARIABLE TESTVARIABLETYPE))
     (CL:SETQ CASTEDCLAUSETREES
      (CONS
       (LIST* SYM-WALK-STELLA-LET
        (CL:IF (CL:NOT (CL:EQ AUXVARIABLE NULL))
         (LIST* (CONS AUXVARIABLE (CONS TESTVARIABLE NIL))
          (CONS TESTVARIABLE (CONS CLAUSETYPE (CONS AUXVARIABLE NIL)))
          NIL)
         (CONS
          (CONS TESTVARIABLE
           (CONS
            (LIST* SYM-WALK-STELLA-SAFE-CAST
             (SYS-TREE (WALK-WITHOUT-TYPE-TREE TESTVARIABLE)
              CLAUSETYPE)
             (CONS CLAUSETYPE NIL))
            NIL))
          NIL))
        (CONCATENATE CLAUSETREES NIL))
       NIL))
     (CL:WHEN (CL:NOT (CL:EQ AUXVARIABLE NULL))
      (POP-VARIABLE-BINDING))))
   (CL:RETURN-FROM YIELD-CASTED-TYPECASE-CLAUSE-TREES
    CASTEDCLAUSETREES)))

;;; (DEFUN VERIFY-TYPECASE-CLAUSE-TYPE ...)

(CL:DEFUN VERIFY-TYPECASE-CLAUSE-TYPE (TESTTYPE CLAUSETYPE PRECEDINGCLAUSETYPES CLAUSE)
  (CL:LET*
   ((SHADOWINGTYPE NULL)
    (WRAPPEDCLAUSETYPE (TYPE-TO-WRAPPED-TYPE CLAUSETYPE)))
   (CL:WHEN (CL:NOT (CL:EQ WRAPPEDCLAUSETYPE NULL))
    (CL:SETQ CLAUSETYPE WRAPPEDCLAUSETYPE))
   (CL:IF (UNKNOWN-TYPE? CLAUSETYPE)
    (CL:PROGN
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL
        " Reference to undefined or unwrappable non-object type in `typecase': `"
        (DE-UGLIFY-PARSE-TREE CLAUSETYPE) "'." EOL))))
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ TESTTYPE SGT-WALK-STELLA-UNKNOWN))
      (CL:NOT (SUB-TYPE-SPEC-OF? CLAUSETYPE TESTTYPE)))
     (CL:PROGN
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL " Type `" (DE-UGLIFY-PARSE-TREE CLAUSETYPE)
         "' of `typecase' clause " EOL "    `"
         (DE-UGLIFY-PARSE-TREE CLAUSE) "'" EOL
         " is not a subtype of the test expression type `"
         (DE-UGLIFY-PARSE-TREE TESTTYPE) "'." EOL))))
     (CL:LET* ()
      (CL:LET* ((VALUE-000 NULL))
       (CL:LET*
        ((TYPE NULL)
         (ITER-000 (%LIST.THE-CONS-LIST PRECEDINGCLAUSETYPES)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TYPE (%%VALUE ITER-000))
         (CL:WHEN (SUBTYPE-OF? CLAUSETYPE TYPE)
          (CL:SETQ VALUE-000 TYPE) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ SHADOWINGTYPE VALUE-000))
      (CL:IF (CL:NOT (CL:EQ SHADOWINGTYPE NULL))
       (CL:PROGN
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
           " Type `" (DE-UGLIFY-PARSE-TREE CLAUSETYPE)
           "' of `typecase' clause " EOL "    `"
           (DE-UGLIFY-PARSE-TREE CLAUSE) "'" EOL
           " is shadowed by type `"
           (DE-UGLIFY-PARSE-TREE SHADOWINGTYPE) "'." EOL))))
       (CL:PROGN (PUSH PRECEDINGCLAUSETYPES CLAUSETYPE)))))))
  :VOID)

;;; (DEFUN (WALK-WITH-PROCESS-LOCK-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-WITH-PROCESS-LOCK-TREE (TREE)
  (SECOND-SETTER TREE
   (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
    SGT-WALK-STELLA-PROCESS-LOCK-OBJECT (%%VALUE TREE) CL:T))
  (CL:SETF (%%REST (%%REST TREE))
   (WALK-LIST-OF-STATEMENTS (%%REST (%%REST TREE))))
  (CL:RETURN-FROM WALK-WITH-PROCESS-LOCK-TREE
   (SYS-TREE TREE SGT-WALK-STELLA-VOID)))

;;; (DEFUN (FINISH-WALKING-EQL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN FINISH-WALKING-EQL-TREE (TREE TYPE1 TYPE2)
  (CL:WHEN
   (CL:OR (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-STANDARD-OBJECT)
    (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-STANDARD-OBJECT)
    (CL:AND (CL:EQ TYPE1 SGT-WALK-STELLA-BOOLEAN-WRAPPER)
     (CL:EQ TYPE2 SGT-WALK-STELLA-BOOLEAN-WRAPPER))
    (CL:AND (CL:NOT (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-OBJECT))
     (CL:NOT (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-LITERAL)))
    (CL:AND (CL:NOT (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-OBJECT))
     (CL:NOT (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-LITERAL))))
   (FIRST-SETTER TREE SYM-WALK-STELLA-EQ?)
   (SECOND-SETTER TREE (SYS-TREE (%%VALUE (%%REST TREE)) TYPE1))
   (THIRD-SETTER TREE
    (SYS-TREE (%%VALUE (%%REST (%%REST TREE))) TYPE2))
   (CL:RETURN-FROM FINISH-WALKING-EQL-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-BOOLEAN)))
  (CL:WHEN
   (CL:AND (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-LITERAL)
    (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-LITERAL))
   (CL:IF (CL:EQ TYPE1 SGT-WALK-STELLA-STRING)
    (FIRST-SETTER TREE SYM-WALK-STELLA-STRING-EQL?)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQ?))
   (CL:RETURN-FROM FINISH-WALKING-EQL-TREE (WALK-A-CONS-TREE TREE)))
  (CL:WHEN
   (CL:AND (CL:NOT (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-LITERAL))
    (CL:NOT (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-LITERAL)))
   (CL:LET* ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE) (WALK-CALL-SLOT-TREE TREE))
    (CL:RETURN-FROM FINISH-WALKING-EQL-TREE (CL:VALUES OTREE OTYPE))))
  (CL:WHEN (CL:NOT (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-LITERAL))
   (CL:LET*
    ((TEMPARG (%%VALUE (%%REST (%%REST TREE)))) (TEMPTYPE TYPE2))
    (THIRD-SETTER TREE (%%VALUE (%%REST TREE)))
    (SECOND-SETTER TREE TEMPARG) (CL:SETQ TYPE2 TYPE1)
    (CL:SETQ TYPE1 TEMPTYPE)))
  (CL:COND
   ((CL:EQ TYPE2 SGT-WALK-STELLA-BOOLEAN)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQL-TO-BOOLEAN?))
   ((CL:EQ TYPE2 SGT-WALK-STELLA-INTEGER)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQL-TO-INTEGER?))
   ((CL:EQ TYPE2 SGT-WALK-STELLA-LONG-INTEGER)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQL-TO-LONG-INTEGER?))
   ((CL:EQ TYPE2 SGT-WALK-STELLA-FLOAT)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQL-TO-FLOAT?))
   ((CL:EQ TYPE2 SGT-WALK-STELLA-STRING)
    (FIRST-SETTER TREE SYM-WALK-STELLA-EQL-TO-STRING?))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" TYPE2 "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM FINISH-WALKING-EQL-TREE
   (CL:VALUES (WALK-WITHOUT-TYPE-TREE TREE) SGT-WALK-STELLA-BOOLEAN)))

;;; (DEFUN (FINISH-WALKING-EQUAL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN FINISH-WALKING-EQUAL-TREE (TREE TYPE1 TYPE2)
  (CL:PROGN (CL:SETQ TREE TREE) (CL:SETQ TYPE1 TYPE1)
   (CL:SETQ TYPE2 TYPE2))
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (SIGNAL-TRANSLATION-ERROR)
   (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
    (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
     " finish-walking-equal-tree: NOT YET IMPLEMENTED.." EOL)))
  (CL:RETURN-FROM FINISH-WALKING-EQUAL-TREE
   (CL:VALUES NULL SGT-WALK-STELLA-BOOLEAN)))

;;; (DEFUN (WALK-EQUALITY-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-EQUALITY-TREE (TREE)
  (CL:LET* ((ARG1 NULL) (ARG2 NULL) (TYPE1 NULL) (TYPE2 NULL))
   (CL:MULTIPLE-VALUE-SETQ (ARG1 TYPE1)
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
     SGT-WALK-STELLA-UNKNOWN (%%VALUE TREE) CL:T))
   (CL:MULTIPLE-VALUE-SETQ (ARG2 TYPE2)
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST (%%REST TREE)))
     SGT-WALK-STELLA-UNKNOWN (%%VALUE TREE) CL:T))
   (SECOND-SETTER TREE ARG1) (THIRD-SETTER TREE ARG2)
   (CL:WHEN (VRLET-EXPRESSION? ARG1)
    (CL:RETURN-FROM WALK-EQUALITY-TREE
     (WALK-A-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG1
       SGT-WALK-STELLA-BOOLEAN))))
   (CL:WHEN (VRLET-EXPRESSION? ARG2)
    (CL:RETURN-FROM WALK-EQUALITY-TREE
     (WALK-A-TREE
      (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG2
       SGT-WALK-STELLA-BOOLEAN))))
   (CL:SETQ TYPE1 (CANONICAL-TYPE (TYPE-SPEC-TO-BASE-TYPE TYPE1)))
   (CL:SETQ TYPE2 (CANONICAL-TYPE (TYPE-SPEC-TO-BASE-TYPE TYPE2)))
   (CL:WHEN
    (CL:NOT
     (CL:OR (CL:EQ TYPE1 SGT-WALK-STELLA-UNKNOWN)
      (CL:EQ TYPE2 SGT-WALK-STELLA-UNKNOWN) (SUBTYPE-OF? TYPE1 TYPE2)
      (SUBTYPE-OF? TYPE2 TYPE1)
      (CL:AND (SUBTYPE-OF? TYPE1 SGT-WALK-STELLA-NUMBER)
       (SUBTYPE-OF? TYPE2 SGT-WALK-STELLA-NUMBER))
      (SUBTYPE-OF? (TYPE-TO-WRAPPED-TYPE TYPE1) TYPE2)
      (SUBTYPE-OF? (TYPE-TO-WRAPPED-TYPE TYPE2) TYPE1)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-WARNING)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
       EOL
       " This equality test will always fail due to disjoint argument types:"
       EOL "    `" (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQ?)
       (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-=))
      (FIRST-SETTER TREE SYM-WALK-STELLA-EQ?)
      (SECOND-SETTER TREE (SYS-TREE (%%VALUE (%%REST TREE)) TYPE1))
      (THIRD-SETTER TREE
       (SYS-TREE (%%VALUE (%%REST (%%REST TREE))) TYPE2))
      (CL:RETURN-FROM WALK-EQUALITY-TREE
       (CL:VALUES TREE SGT-WALK-STELLA-BOOLEAN)))
     ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQL?)
      (CL:RETURN-FROM WALK-EQUALITY-TREE
       (FINISH-WALKING-EQL-TREE TREE TYPE1 TYPE2)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFGLOBAL *NUMERIC-TYPE-HIERARCHY* ...)

(CL:DEFVAR *NUMERIC-TYPE-HIERARCHY* NULL)

;;; (DEFUN (MORE-GENERAL-NUMERIC-TYPE TYPE) ...)

(CL:DEFUN MORE-GENERAL-NUMERIC-TYPE (TYPE1 TYPE2)
  (CL:LET*
   ((POSITION1 (POSITION *NUMERIC-TYPE-HIERARCHY* TYPE1 0))
    (POSITION2 (POSITION *NUMERIC-TYPE-HIERARCHY* TYPE2 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION1 POSITION2))
   (CL:WHEN
    (CL:OR (CL:= POSITION1 NULL-INTEGER) (CL:= POSITION2 NULL-INTEGER))
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE SGT-WALK-STELLA-NUMBER))
   (CL:IF (CL:> POSITION1 POSITION2)
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE TYPE1)
    (CL:RETURN-FROM MORE-GENERAL-NUMERIC-TYPE TYPE2))))

;;; (DEFUN (YIELD-ARITHMETIC-OPERATOR-CALL-TREE CONS) ...)

(CL:DEFUN YIELD-ARITHMETIC-OPERATOR-CALL-TREE (OPERATOR OPERANDS)
  (CL:RETURN-FROM YIELD-ARITHMETIC-OPERATOR-CALL-TREE
   (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD SGT-WALK-STELLA-NUMBER
    OPERATOR (CONCATENATE OPERANDS NIL))))

;;; (DEFUN (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE CONS) ...)

(CL:DEFUN YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE (OPERATOR OPERANDS)
  (CL:LET*
   ((NOFOPERANDS (LENGTH OPERANDS))
    (PARENTHESIZEDTREE
     (YIELD-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR
      (CONS-LIST (%%VALUE OPERANDS) (%%VALUE (%%REST OPERANDS))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFOPERANDS))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 2)
     (UPPER-BOUND-000 (CL:1- NOFOPERANDS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ PARENTHESIZEDTREE
      (YIELD-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR
       (CONS-LIST PARENTHESIZEDTREE (NTH OPERANDS I))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE
    PARENTHESIZEDTREE)))

;;; (DEFUN (WALK-ARITHMETIC-TREE OBJECT TYPE) ...)

(CL:DEFUN WALK-ARITHMETIC-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (OPERANDS (%%REST TREE))
    (NOFOPERANDS (LENGTH OPERANDS)) (OPERAND NULL) (OPERANDTYPE NULL)
    (RETURNTYPE SGT-WALK-STELLA-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFOPERANDS))
   (CL:CASE NOFOPERANDS
    (0
     (CL:LET* ((TEST-VALUE-000 OPERATOR))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-+)
        (CL:RETURN-FROM WALK-ARITHMETIC-TREE
         (CL:VALUES (WRAP-INTEGER 0) SGT-WALK-STELLA-INTEGER)))
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-*)
        (CL:RETURN-FROM WALK-ARITHMETIC-TREE
         (CL:VALUES (WRAP-INTEGER 1) SGT-WALK-STELLA-INTEGER)))
       (CL:T (BAD-ARGUMENT-COUNT? TREE 1)
        (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
         (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
          (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-NUMBER))
         (CL:RETURN-FROM WALK-ARITHMETIC-TREE
          (CL:VALUES VALUE-000 VALUE-001)))))))
    (1
     (CL:LET* ((TEST-VALUE-001 OPERATOR))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-+)
         (CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-*))
        (CL:LET* ((VALUE-002 NULL) (VALUE-003 NULL))
         (CL:MULTIPLE-VALUE-SETQ (VALUE-002 VALUE-003)
          (WALK-EXPRESSION-TREE (%%VALUE OPERANDS)
           SGT-WALK-STELLA-NUMBER OPERATOR CL:NIL))
         (CL:RETURN-FROM WALK-ARITHMETIC-TREE
          (CL:VALUES VALUE-002 VALUE-003))))
       ((CL:OR (CL:EQ TEST-VALUE-001 SYM-WALK-STELLA--)
         (CL:EQ TEST-VALUE-001 |SYM-WALK-STELLA-/|))
        (CL:SETF (%%REST OPERANDS) (CONS (%%VALUE OPERANDS) NIL))
        (FIRST-SETTER OPERANDS
         (CL:IF (CL:EQ OPERATOR SYM-WALK-STELLA--) (WRAP-INTEGER 0)
          (WRAP-INTEGER 1))))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          TEST-VALUE-001 "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
    (CL:OTHERWISE))
   (CL:LET* ((IT (ALLOCATE-ITERATOR OPERANDS)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:MULTIPLE-VALUE-SETQ (OPERAND OPERANDTYPE)
      (WALK-EXPRESSION-TREE (%CONS-ITERATOR.VALUE IT)
       SGT-WALK-STELLA-NUMBER OPERATOR CL:NIL))
     (CL:SETQ RETURNTYPE
      (MORE-GENERAL-NUMERIC-TYPE RETURNTYPE
       (TYPE-SPEC-TO-BASE-TYPE OPERANDTYPE)))
     (VALUE-SETTER IT OPERAND)))
   (CL:WHEN
    (CL:AND (CL:EQ OPERATOR |SYM-WALK-STELLA-/|)
     (CL:OR (CL:EQ RETURNTYPE SGT-WALK-STELLA-INTEGER)
      (CL:EQ RETURNTYPE SGT-WALK-STELLA-LONG-INTEGER)))
    (CL:COND
     ((WRAPPER? (%%VALUE OPERANDS))
      (FIRST-SETTER OPERANDS
       (WRAP-FLOAT (COERCE-TO-FLOAT (%%VALUE OPERANDS)))))
     ((WRAPPER? (%%VALUE (%%REST OPERANDS)))
      (SECOND-SETTER OPERANDS
       (WRAP-FLOAT (COERCE-TO-FLOAT (%%VALUE (%%REST OPERANDS))))))
     (CL:T
      (CL:SETQ OPERANDS
       (CONS
        (LIST* SYM-WALK-STELLA-CAST (%%VALUE OPERANDS)
         (CONS SGT-WALK-STELLA-FLOAT NIL))
        (CONCATENATE (%%REST OPERANDS) NIL)))
      (CL:SETQ NOFOPERANDS (CL:1+ NOFOPERANDS))))
    (CL:SETQ RETURNTYPE SGT-WALK-STELLA-FLOAT))
   (CL:IF
    (CL:AND (CL:> NOFOPERANDS 2)
     (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)))
    (CL:LET* ((VALUE-004 NULL) (VALUE-005 NULL))
     (CL:MULTIPLE-VALUE-SETQ (VALUE-004 VALUE-005)
      (SYS-TREE
       (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR OPERANDS)
       RETURNTYPE))
     (CL:RETURN-FROM WALK-ARITHMETIC-TREE
      (CL:VALUES VALUE-004 VALUE-005)))
    (CL:LET* ((VALUE-006 NULL) (VALUE-007 NULL))
     (CL:MULTIPLE-VALUE-SETQ (VALUE-006 VALUE-007)
      (SYS-TREE (YIELD-ARITHMETIC-OPERATOR-CALL-TREE OPERATOR OPERANDS)
       RETURNTYPE))
     (CL:RETURN-FROM WALK-ARITHMETIC-TREE
      (CL:VALUES VALUE-006 VALUE-007))))))

;;; (DEFUN (WALK-QUOTED-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-QUOTED-TREE (TREE)
  (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 1)
   (CL:RETURN-FROM WALK-QUOTED-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
  (CL:LET*
   ((ARGUMENT (%%VALUE (%%REST TREE)))
    (QUOTEDLITERAL?
     (CL:OR (CL:NOT (CONS? ARGUMENT)) (CL:EQ ARGUMENT NIL)))
    (OBJECTNAME STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OBJECTNAME))
   (CL:WHEN QUOTEDLITERAL?
    (CL:LET* ((OTREE NULL) (OTYPE NULL))
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (WALK-A-TREE (BQUOTIFY ARGUMENT)))
     (CL:RETURN-FROM WALK-QUOTED-TREE (CL:VALUES OTREE OTYPE))))
   (CL:SETQ OBJECTNAME (NAME-QUOTED-TREE ARGUMENT))
   (CL:RETURN-FROM WALK-QUOTED-TREE
    (WALK-A-TREE
     (LIST* SYM-WALK-STELLA-GET-QUOTED-TREE (WRAP-STRING OBJECTNAME)
      (CONS (WRAP-STRING (%MODULE.MODULE-FULL-NAME *MODULE*)) NIL))))))

;;; (DEFUN (WALK-BQUOTE-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-BQUOTE-TREE (TREE)
  (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 1)
   (CL:RETURN-FROM WALK-BQUOTE-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
  (CL:LET* ((OTREE NULL) (OTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
    (WALK-A-TREE
     (SIMPLIFY-BQUOTE-TREE
      (EXPAND-BQUOTE-TREE (%%VALUE (%%REST TREE))))))
   (CL:RETURN-FROM WALK-BQUOTE-TREE (CL:VALUES OTREE OTYPE))))

;;; (DEFUN (EXPAND-MACRO OBJECT) ...)

(CL:DEFUN EXPAND-MACRO (TREE)
  (CL:LET*
   ((MACRONAME (%%VALUE TREE))
    (EXPANDEROBJECT (LOOKUP-MACRO MACRONAME))
    (EXPANDERCODE (%METHOD-SLOT.FUNCTION-CODE EXPANDEROBJECT))
    (ARGS (%%REST TREE)) (EXPANSION NULL))
   (CL:WHEN (CL:EQ EXPANDERCODE NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Macro expander code for `" (DE-UGLIFY-PARSE-TREE MACRONAME)
       "' is not available." EOL)))
    (CL:RETURN-FROM EXPAND-MACRO
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:IF
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS EXPANDEROBJECT)
      SYM-WALK-STELLA-METHOD-BODY-ARGUMENT? FALSE-WRAPPER))
    (CL:CASE (METHOD-ARGUMENT-COUNT EXPANDEROBJECT)
     (1 (CL:SETQ EXPANSION (CL:FUNCALL EXPANDERCODE ARGS))
      (CL:SETF (%%REST TREE) NIL))
     (2
      (CL:SETQ EXPANSION
       (CL:FUNCALL EXPANDERCODE (%%VALUE ARGS) (%%REST ARGS)))
      (CL:SETF (%%REST ARGS) NIL))
     (3
      (CL:SETQ EXPANSION
       (CL:FUNCALL EXPANDERCODE (%%VALUE ARGS) (%%VALUE (%%REST ARGS))
        (%%REST (%%REST ARGS))))
      (CL:SETF (%%REST (%%REST ARGS)) NIL))
     (4
      (CL:SETQ EXPANSION
       (CL:FUNCALL EXPANDERCODE (%%VALUE ARGS) (%%VALUE (%%REST ARGS))
        (%%VALUE (%%REST (%%REST ARGS))) (NTH-REST ARGS 3)))
      (NTH-REST-SETTER ARGS NIL 3))
     (5
      (CL:SETQ EXPANSION
       (CL:FUNCALL EXPANDERCODE (%%VALUE ARGS) (%%VALUE (%%REST ARGS))
        (%%VALUE (%%REST (%%REST ARGS))) (FOURTH ARGS)
        (NTH-REST ARGS 4)))
      (NTH-REST-SETTER ARGS NIL 4))
     (CL:OTHERWISE
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Too many arguments in definition of macro `"
         (DE-UGLIFY-PARSE-TREE MACRONAME) "'." EOL)))
      (CL:RETURN-FROM EXPAND-MACRO
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN))))
    (CL:SETQ EXPANSION (APPLY EXPANDERCODE (%%REST TREE))))
   (CL:RETURN-FROM EXPAND-MACRO EXPANSION)))

;;; (DEFUN (WALK-MACRO-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-MACRO-TREE (TREE)
  (CL:RETURN-FROM WALK-MACRO-TREE (WALK-A-TREE (EXPAND-MACRO TREE))))

;;; (DEFUN (WALK-PRINT-STREAM-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-PRINT-STREAM-TREE (TREE)
  (CL:WHEN (CL:<= (LENGTH TREE) 2)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Missing arguments in print statement: `"
      (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
   (CL:RETURN-FROM WALK-PRINT-STREAM-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (STREAMTREE (%%VALUE (%%REST TREE)))
    (OTREE NULL) (OTYPE NULL))
   (CL:COND
    ((KEYWORD? STREAMTREE)
     (CL:WHEN
      (CL:NOT
       (CL:OR (CL:EQ STREAMTREE KWD-WALK-WARN)
        (CL:EQ STREAMTREE KWD-WALK-ERROR)
        (CL:EQ STREAMTREE KWD-WALK-CONTINUABLE-ERROR)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal stream argument in print statement: `"
         (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
      (CL:RETURN-FROM WALK-PRINT-STREAM-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID))))
    (CL:T
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (WALK-EXPRESSION-TREE STREAMTREE
       SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM (%%VALUE TREE) CL:NIL))
     (FIRST-SETTER TREE SYM-WALK-STELLA-PRINT-NATIVE-STREAM)
     (SECOND-SETTER TREE OTREE)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST (%%REST TREE)))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (WALK-EXPRESSION-TREE (%CONS-ITERATOR.VALUE IT)
       SGT-WALK-STELLA-UNKNOWN OPERATOR CL:NIL))
     (VALUE-SETTER IT OTREE)
     (CL:WHEN (CL:NOT (CL:EQ OTREE SYM-WALK-STELLA-EOL))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OTREE)))
       (CL:COND ((SUBTYPE-OF-STRING? TEST-VALUE-000) (CL:PROGN))
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (VALUE-SETTER IT (WRAP-STRING (STRINGIFY OTREE)))))
        ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
         (CL:PROGN (VALUE-SETTER IT (WRAP-STRING (STRINGIFY OTREE)))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN (VALUE-SETTER IT (WRAP-STRING (STRINGIFY OTREE)))))
        ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
         (CL:PROGN
          (VALUE-SETTER IT
           (WRAP-STRING
            (MAKE-STRING 1
             (%CHARACTER-WRAPPER.WRAPPER-VALUE OTREE))))))
        (CL:T (VALUE-SETTER IT (SYS-TREE OTREE OTYPE))))))))
   (CL:RETURN-FROM WALK-PRINT-STREAM-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WARN-ABOUT-UNDEFINED-METHODS? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-UNDEFINED-METHODS? ()
  (CL:RETURN-FROM WARN-ABOUT-UNDEFINED-METHODS?
   (MEMBER? *CURRENT-STELLA-FEATURES*
    KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS)))

;;; (DEFUN (WARN-ABOUT-MISSING-METHODS? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-MISSING-METHODS? ()
  (CL:RETURN-FROM WARN-ABOUT-MISSING-METHODS?
   (CL:OR
    (CL:NOT (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP))
    (MEMBER? *CURRENT-STELLA-FEATURES*
     KWD-WALK-WARN-ABOUT-MISSING-METHODS))))

;;; (DEFUN (WALK-TYPE-SPEC-IS-NATIVE-TYPE? BOOLEAN) ...)

(CL:DEFUN WALK-TYPE-SPEC-IS-NATIVE-TYPE? (THETYPE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
    (CL:RETURN-FROM WALK-TYPE-SPEC-IS-NATIVE-TYPE?
     (CL:NOT
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%CLASS.DYNAMIC-SLOTS (TYPE-SPEC-TO-CLASS THETYPE))
         SYM-WALK-STELLA-CLASS-CL-NATIVE-TYPE NULL-STRING-WRAPPER))
       STELLA::NULL-STRING))))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
    (CL:RETURN-FROM WALK-TYPE-SPEC-IS-NATIVE-TYPE?
     (CL:NOT
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%CLASS.DYNAMIC-SLOTS (TYPE-SPEC-TO-CLASS THETYPE))
         SYM-WALK-STELLA-CLASS-CPP-NATIVE-TYPE NULL-STRING-WRAPPER))
       STELLA::NULL-STRING))))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
    (CL:RETURN-FROM WALK-TYPE-SPEC-IS-NATIVE-TYPE?
     (CL:NOT
      (CL:EQ
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%CLASS.DYNAMIC-SLOTS (TYPE-SPEC-TO-CLASS THETYPE))
         SYM-WALK-STELLA-CLASS-JAVA-NATIVE-TYPE NULL-STRING-WRAPPER))
       STELLA::NULL-STRING))))
   (CL:T (CL:RETURN-FROM WALK-TYPE-SPEC-IS-NATIVE-TYPE? CL:NIL))))

;;; (DEFUN (WALK-UNDEFINED-SLOT-TREE CONS TYPE) ...)

(CL:DEFUN WALK-UNDEFINED-SLOT-TREE (TREE FIRSTARGTYPE WARN?)
  (CL:LET*
   ((CURSOR (%%REST (%%REST TREE)))
    (TYPE (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE))
    (OPERATORNAME (%%VALUE TREE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR)
     (WALK-EXPRESSION-TREE (%%VALUE CURSOR) NULL OPERATORNAME CL:T))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:WHEN (CL:AND WARN? (CL:NOT (SYMBOL-COMMON-LISP? OPERATORNAME)))
    (CL:IF
     (CL:OR (CL:EQ OPERATORNAME SYM-WALK-STELLA-NULL?)
      (CL:EQ OPERATORNAME SYM-WALK-STELLA-DEFINED?))
     (CL:WHEN (CL:NOT (WALK-TYPE-SPEC-IS-NATIVE-TYPE? TYPE))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Using default native test for `" OPERATORNAME
       "' in the expression:" EOL "  `" TREE "'" EOL))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Reference to undefined method or function named `"
        (DE-UGLIFY-PARSE-TREE OPERATORNAME) "'" EOL
        "   in the expression:" EOL "   `" (DE-UGLIFY-PARSE-TREE TREE)
        "'." EOL)))))
   (CL:RETURN-FROM WALK-UNDEFINED-SLOT-TREE
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD TYPE
      (CONCATENATE TREE NIL))
     SGT-WALK-STELLA-UNKNOWN))))

;;; (DEFUN (WALK-SLOT-ON-ABSTRACT-TYPE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SLOT-ON-ABSTRACT-TYPE-TREE (TREE ABSTRACTTYPE)
  (CL:LET*
   ((METHODNAME (%%VALUE TREE))
    (PROTOTYPEMETHOD (FIND-PROTOTYPE-METHOD METHODNAME ABSTRACTTYPE))
    (UNDEFINEDMETHOD? CL:T) (OTREE NULL) (OTYPE NULL))
   (CL:WHEN (CL:NOT (CL:EQ PROTOTYPEMETHOD NULL))
    (CL:SETQ UNDEFINEDMETHOD? CL:NIL)
    (CL:WHEN (WARN-ABOUT-MISSING-METHODS?)
     (CL:LET*
      ((NOFSUBS NULL-INTEGER) (NOFMETHODS NULL-INTEGER)
       (COMPATIBLE? CL:NIL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSUBS NOFMETHODS))
      (CL:MULTIPLE-VALUE-SETQ (NOFSUBS NOFMETHODS COMPATIBLE?)
       (COMPATIBLE-REAL-METHODS PROTOTYPEMETHOD ABSTRACTTYPE))
      (CL:COND
       ((CL:AND (CL:= NOFSUBS NOFMETHODS) COMPATIBLE?)
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-NOTE)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
           " Inferred the method `" (DE-UGLIFY-PARSE-TREE METHODNAME)
           "' on the abstract" EOL "   type `"
           (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) "', since `"
           (DE-UGLIFY-PARSE-TREE METHODNAME) "' is implemented" EOL
           "   on all non-abstract subtypes of `"
           (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) "'." EOL)))
        (SECOND-SETTER TREE
         (SYS-TREE (%%VALUE (%%REST TREE))
          (%METHOD-SLOT.SLOT-OWNER PROTOTYPEMETHOD)))
        (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
         (WALK-CALL-SLOT-TREE TREE)))
       ((CL:= NOFSUBS NOFMETHODS)
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
           " Could not infer `" (DE-UGLIFY-PARSE-TREE METHODNAME)
           "' on abstract type `" (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE)
           "'," EOL "   since the implementations of `"
           (DE-UGLIFY-PARSE-TREE METHODNAME) "' on the non-abstract"
           EOL "   subtypes of `" (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE)
           "' are not all compatible." EOL))))
       (CL:T
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
           " Could not infer `" (DE-UGLIFY-PARSE-TREE METHODNAME)
           "' on abstract type `" (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE)
           "'," EOL "   since `" (DE-UGLIFY-PARSE-TREE METHODNAME)
           "' is only implemented on `"
           (DE-UGLIFY-PARSE-TREE (WRAP-INTEGER NOFMETHODS))
           "' of the `" (DE-UGLIFY-PARSE-TREE (WRAP-INTEGER NOFSUBS))
           "'" EOL "   non-abstract subtypes of `"
           (DE-UGLIFY-PARSE-TREE ABSTRACTTYPE) "'." EOL)))
        (CL:WHEN (CL:NOT COMPATIBLE?)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          " Additionally, the method signatures are not compatible."
          EOL)))))))
   (CL:IF UNDEFINEDMETHOD?
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-UNDEFINED-SLOT-TREE TREE ABSTRACTTYPE
      (WARN-ABOUT-UNDEFINED-METHODS?)))
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-UNDEFINED-SLOT-TREE TREE ABSTRACTTYPE CL:NIL)))
   (CL:RETURN-FROM WALK-SLOT-ON-ABSTRACT-TYPE-TREE
    (CL:VALUES OTREE OTYPE))))

;;; (DEFUN (FIND-PROTOTYPE-METHOD METHOD-SLOT) ...)

(CL:DEFUN FIND-PROTOTYPE-METHOD (METHODNAME ABSTRACTTYPE)
  (CL:LET* ((METHOD NULL))
   (CL:LET*
    ((SUB NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (%CLASS.CLASS-DIRECT-SUBS
        (%SURROGATE.SURROGATE-VALUE ABSTRACTTYPE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUB (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUB) NULL))
      (CL:IF (%CLASS.ABSTRACT? (%SURROGATE.SURROGATE-VALUE SUB))
       (CL:SETQ METHOD (FIND-PROTOTYPE-METHOD METHODNAME SUB))
       (CL:SETQ METHOD
        (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE SUB) METHODNAME)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ METHOD NULL))
        (CL:NOT (STORAGE-SLOT? METHOD)))
       (CL:RETURN-FROM FIND-PROTOTYPE-METHOD METHOD)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM FIND-PROTOTYPE-METHOD NULL)))

;;; (DEFUN (COMPATIBLE-REAL-METHODS INTEGER INTEGER BOOLEAN) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:T) (CL:VALUES CL:FIXNUM CL:FIXNUM CL:T))
  COMPATIBLE-REAL-METHODS))
(CL:DEFUN COMPATIBLE-REAL-METHODS (PROTOTYPEMETHOD ABSTRACTTYPE)
  (CL:LET*
   ((METHODNAME (%METHOD-SLOT.SLOT-NAME PROTOTYPEMETHOD))
    (NOFREALSUBTYPES 0) (NOFREALMETHODS 0)
    (COMPATIBLESIGNATURES? CL:T))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFREALSUBTYPES NOFREALMETHODS))
   (CL:LET*
    ((SUB NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (%CLASS.CLASS-DIRECT-SUBS
        (%SURROGATE.SURROGATE-VALUE ABSTRACTTYPE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUB (%%VALUE ITER-000))
     (CL:IF (%CLASS.ABSTRACT? (%SURROGATE.SURROGATE-VALUE SUB))
      (CL:LET*
       ((NOFSUBS NULL-INTEGER) (NOFMETHODS NULL-INTEGER)
        (COMPATIBLE? CL:NIL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSUBS NOFMETHODS))
       (CL:MULTIPLE-VALUE-SETQ (NOFSUBS NOFMETHODS COMPATIBLE?)
        (COMPATIBLE-REAL-METHODS PROTOTYPEMETHOD SUB))
       (CL:SETQ NOFREALSUBTYPES (CL:+ NOFREALSUBTYPES NOFSUBS))
       (CL:SETQ NOFREALMETHODS (CL:+ NOFREALMETHODS NOFMETHODS))
       (CL:WHEN (CL:NOT COMPATIBLE?)
        (CL:SETQ COMPATIBLESIGNATURES? CL:NIL)))
      (CL:LET* ((THISMETHOD NULL))
       (CL:SETQ NOFREALSUBTYPES (CL:1+ NOFREALSUBTYPES))
       (CL:SETQ THISMETHOD
        (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE SUB) METHODNAME))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ THISMETHOD NULL))
         (CL:NOT (STORAGE-SLOT? THISMETHOD)))
        (CL:SETQ NOFREALMETHODS (CL:1+ NOFREALMETHODS))
        (CL:WHEN
         (CL:NOT (IDENTICAL-SIGNATURES? PROTOTYPEMETHOD THISMETHOD))
         (CL:SETQ COMPATIBLESIGNATURES? CL:NIL)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM COMPATIBLE-REAL-METHODS
    (CL:VALUES NOFREALSUBTYPES NOFREALMETHODS COMPATIBLESIGNATURES?))))

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF SLOT) TREE FIRSTARGTYPE)
  (CL:PROGN (CL:SETQ TREE TREE) (CL:SETQ FIRSTARGTYPE FIRSTARGTYPE))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "finish-walking-call-slot-tree: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF STORAGE-SLOT) TREE FIRSTARGTYPE)
  (CL:LET*
   ((OBJECTREF (%%VALUE (%%REST TREE)))
    (OTYPE (COMPUTE-RETURN-TYPE-SPEC SELF FIRSTARGTYPE)))
   (CL:WHEN (CL:NOT (CL:EQ (READER SELF) NULL))
    (FIRST-SETTER TREE (READER SELF))
    (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
     (WALK-A-CONS-TREE TREE)))
   (CL:IF (SYSTEM-DEFINED-SLOT-READER? SELF)
    (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
     (CL:VALUES
      (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
       (%STORAGE-SLOT.SLOT-OWNER SELF)
       (CONS (%STORAGE-SLOT.SLOT-NAME SELF) (CONS OBJECTREF NIL)))
      OTYPE))
    (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
     (CL:VALUES
      (YIELD-SLOT-VALUE-TREE SELF OBJECTREF FIRSTARGTYPE OTYPE NULL)
      OTYPE)))))

;;; (DEFUN (STRING-CONCATENATE-METHOD? BOOLEAN) ...)

(CL:DEFUN STRING-CONCATENATE-METHOD? (METHOD)
  (CL:RETURN-FROM STRING-CONCATENATE-METHOD?
   (CL:AND
    (CL:EQ (%METHOD-SLOT.SLOT-NAME METHOD) SYM-WALK-STELLA-CONCATENATE)
    (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD) SGT-WALK-STELLA-STRING))))

;;; (DEFUN (PASS-VARIABLE-ARGUMENTS-AS-LIST? BOOLEAN) ...)

(CL:DEFUN PASS-VARIABLE-ARGUMENTS-AS-LIST? (METHOD)
  (CL:RETURN-FROM PASS-VARIABLE-ARGUMENTS-AS-LIST?
   (CL:OR (METHOD-MUST-BE-EVALUABLE? METHOD)
    (CL:AND (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
     (CL:OR (CL:EQ *METHODBEINGWALKED* METHOD)
      (CL:NOT (STRING-CONCATENATE-METHOD? METHOD)))))))

;;; (DEFUN (VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ...)

(CL:DEFUN VARIABLE-ARGUMENTS-TYPE (METHOD)
  (CL:RETURN-FROM VARIABLE-ARGUMENTS-TYPE
   (EXTRACT-PARAMETER-TYPE
    (LAST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    SYM-WALK-STELLA-ANY-VALUE)))

;;; (DEFUN (VARIABLE-ARGUMENTS-NAME SYMBOL) ...)

(CL:DEFUN VARIABLE-ARGUMENTS-NAME (METHOD)
  (CL:RETURN-FROM VARIABLE-ARGUMENTS-NAME
   (LAST (METHOD-PARAMETER-NAMES METHOD))))

;;; (DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ...)

(CL:DEFUN YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE (METHOD)
  (CL:LET*
   ((LISTBASETYPE SGT-WALK-STELLA-CONS)
    (ELEMENTTYPE (VARIABLE-ARGUMENTS-TYPE METHOD)))
   (CL:WHEN
    (CL:AND (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
     (CL:NOT (METHOD-MUST-BE-EVALUABLE? METHOD))))
   (CL:WHEN (TYPE? ELEMENTTYPE)
    (CL:SETQ ELEMENTTYPE (TYPE-TO-WRAPPED-TYPE ELEMENTTYPE)))
   (CL:LET* ((SELF-000 (NEW-PARAMETRIC-TYPE-SPECIFIER)))
    (CL:SETF (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF-000)
     LISTBASETYPE)
    (CL:SETF
     (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES SELF-000)
     (LIST ELEMENTTYPE))
    (CL:LET* ((VALUE-000 SELF-000))
     (CL:RETURN-FROM YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE
      VALUE-000)))))

;;; (DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS CONS) ...)

(CL:DEFUN YIELD-LISTIFIED-VARIABLE-ARGUMENTS (WALKEDARGS TARGETTYPE WRAPARGS?)
  (CL:IF (CL:NOT (CL:EQ WALKEDARGS NIL))
   (CL:LET* ((LISTIFIEDARGS SYM-WALK-STELLA-NIL))
    (CL:LET* ((IT (ALLOCATE-ITERATOR WALKEDARGS)))
     (CL:LOOP WHILE (NEXT? IT) DO
      (CL:LET* ((ARG (%CONS-ITERATOR.VALUE IT)))
       (CL:SETQ ARG (SYS-TREE ARG TARGETTYPE))
       (CL:WHEN WRAPARGS?
        (CL:SETQ ARG
         (CONS
          (CL:IF (CL:EQ TARGETTYPE SGT-WALK-STELLA-BOOLEAN)
           SYM-WALK-STELLA-WRAP-BOOLEAN SYM-WALK-STELLA-WRAP-LITERAL)
          (CONS ARG NIL))))
       (VALUE-SETTER IT ARG))))
    (CL:COND
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (CL:LET* ((ARG NULL) (ITER-000 (REVERSE WALKEDARGS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ARG (%%VALUE ITER-000))
        (CL:SETQ LISTIFIEDARGS
         (LIST* SYM-WALK-STELLA-CONS ARG (CONS LISTIFIEDARGS NIL)))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:T
      (CL:SETQ LISTIFIEDARGS
       (LIST* SYM-WALK-STELLA-CONS-LIST (%%VALUE WALKEDARGS)
        (CONCATENATE (%%REST WALKEDARGS) NIL)))))
    (CL:RETURN-FROM YIELD-LISTIFIED-VARIABLE-ARGUMENTS
     (WALK-WITHOUT-TYPE-TREE LISTIFIEDARGS)))
   (CL:RETURN-FROM YIELD-LISTIFIED-VARIABLE-ARGUMENTS
    (CONS SYM-WALK-STELLA-NIL NIL))))

;;; (DEFUN (FINISH-WALKING-ARGUMENT-LIST-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN FINISH-WALKING-ARGUMENT-LIST-TREE (SELF TREE FIRSTARGTYPE)
  (CL:WHEN
   (CL:EQ (%SLOT.SLOT-NAME SELF) SYM-WALK-STELLA-ALLOCATE-ITERATOR)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Cannot invoke `" (DE-UGLIFY-PARSE-TREE SELF)
      "' directly, use `foreach' instead." EOL)))
   (CL:RETURN-FROM FINISH-WALKING-ARGUMENT-LIST-TREE
    (WALK-DONT-CALL-ME-TREE TREE
     SGT-WALK-STELLA-ARGUMENT-LIST-ITERATOR)))
  (CL:WHEN (CL:EQ (%SLOT.SLOT-OWNER SELF) SGT-WALK-STELLA-CONS)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-NOTE)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
      " Applying CONS-methods to &rest-arguments is deprecated." EOL
      "   `" (DE-UGLIFY-PARSE-TREE TREE) "'" EOL
      " Use `foreach' or explicitly coerce with `coerce-&rest-to-cons'."
      EOL)))
   (CL:SETQ FIRSTARGTYPE
    (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE *METHODBEINGWALKED*)))
  (CL:COND
   ((PASS-VARIABLE-ARGUMENTS-AS-LIST? *METHODBEINGWALKED*)
    (CL:COND
     ((CL:EQ (%SLOT.SLOT-NAME SELF) SYM-WALK-STELLA-LENGTH)
      (CL:RETURN-FROM FINISH-WALKING-ARGUMENT-LIST-TREE
       (SYS-TREE
        (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
         (TYPE-SPEC-TO-BASE-TYPE
          (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE
           *METHODBEINGWALKED*))
         (CONCATENATE TREE NIL))
        SGT-WALK-STELLA-INTEGER)))
     (CL:T
      (CL:RETURN-FROM FINISH-WALKING-ARGUMENT-LIST-TREE
       (FINISH-WALKING-CALL-SLOT-TREE SELF TREE FIRSTARGTYPE)))))
   (CL:T
    (CL:RETURN-FROM FINISH-WALKING-ARGUMENT-LIST-TREE
     (FINISH-WALKING-CALL-SLOT-TREE SELF TREE FIRSTARGTYPE)))))

;;; (DEFUN (WALK-VARIABLE-ARGUMENTS CONS) ...)

(CL:DEFUN WALK-VARIABLE-ARGUMENTS (ARGUMENTS METHOD FIRSTARGTYPE)
  (CL:LET*
   ((TARGETTYPE (VARIABLE-ARGUMENTS-TYPE METHOD))
    (LISTIFYARGS? (PASS-VARIABLE-ARGUMENTS-AS-LIST? METHOD))
    (WRAPARGS? CL:NIL) (CURSOR ARGUMENTS))
   (CL:WHEN
    (CL:AND (CL:NOT (TYPE? TARGETTYPE))
     (CL:NOT (CL:EQ FIRSTARGTYPE NULL)))
    (CL:SETQ TARGETTYPE
     (COMPUTE-RELATIVE-TYPE-SPEC TARGETTYPE FIRSTARGTYPE)))
   (CL:SETQ WRAPARGS?
    (CL:AND LISTIFYARGS?
     (SUB-TYPE-SPEC-OF? TARGETTYPE SGT-WALK-STELLA-LITERAL)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR)
     (WALK-EXPRESSION-TREE (%%VALUE CURSOR) TARGETTYPE
      (%METHOD-SLOT.SLOT-NAME METHOD) CL:NIL))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:WHEN LISTIFYARGS?
    (CL:LET*
     ((LISTIFIEDARGS
       (YIELD-LISTIFIED-VARIABLE-ARGUMENTS ARGUMENTS TARGETTYPE
        WRAPARGS?)))
     (CL:WHEN (CL:EQ ARGUMENTS NIL)
      (CL:RETURN-FROM WALK-VARIABLE-ARGUMENTS LISTIFIEDARGS))
     (CL:SETF (%%VALUE ARGUMENTS) LISTIFIEDARGS)
     (CL:SETF (%%REST ARGUMENTS) NIL)))
   (CL:RETURN-FROM WALK-VARIABLE-ARGUMENTS ARGUMENTS)))

;;; (DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFMETHOD FINISH-WALKING-CALL-SLOT-TREE ((SELF METHOD-SLOT) TREE FIRSTARGTYPE)
  (CL:LET*
   ((METHODNAME (%METHOD-SLOT.SLOT-NAME SELF))
    (OTYPESPEC (COMPUTE-RETURN-TYPE-SPEC SELF FIRSTARGTYPE))
    (OTREE NULL))
   (CL:LET*
    ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))
     (NOFPARAMETERS (LENGTH PTYPESPECS))
     (CURSOR (%%REST (%%REST TREE))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NOFPARAMETERS))
    (CL:LET*
     ((TARGETTS NULL) (ITER-000 (REST PTYPESPECS))
      (PINDEX NULL-INTEGER) (ITER-001 2)
      (UPPER-BOUND-000 NOFPARAMETERS)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM PINDEX ITER-001 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
       (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
      DO (CL:SETQ TARGETTS (%%VALUE ITER-000))
      (CL:SETQ PINDEX ITER-001)
      (CL:SETQ TARGETTS
       (COMPUTE-RELATIVE-TYPE-SPEC TARGETTS FIRSTARGTYPE))
      (CL:WHEN
       (CL:AND (CL:= PINDEX NOFPARAMETERS)
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
          SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER)))
       (NTH-REST-SETTER TREE
        (WALK-VARIABLE-ARGUMENTS CURSOR SELF FIRSTARGTYPE) PINDEX)
       (CL:RETURN))
      (CL:SETF (%%VALUE CURSOR)
       (WALK-EXPRESSION-TREE (%%VALUE CURSOR) TARGETTS METHODNAME
        CL:T))
      (CL:SETQ CURSOR (%%REST CURSOR))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:LET* ((ARG NULL) (ITER-002 (%%REST TREE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-002))
     (CL:WHEN (VRLET-EXPRESSION? ARG)
      (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
       (PERCOLATE-OUT-VRLET-EXPRESSION TREE ARG OTYPESPEC)))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:WHEN (INLINE-METHOD-CALL? SELF)
    (CL:SETQ OTREE
     (WALK-INLINE-METHOD-CALL SELF (%%REST TREE) FIRSTARGTYPE))
    (CL:WHEN (CL:NOT (CL:EQ OTREE NULL))
     (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
      (SYS-TREE OTREE OTYPESPEC))))
   (CL:IF (%METHOD-SLOT.METHOD-FUNCTION? SELF)
    (CL:SETQ OTREE
     (CONS SYM-WALK-STELLA-SYS-CALL-FUNCTION (CONCATENATE TREE NIL)))
    (CL:SETQ OTREE
     (LIST* SYM-WALK-STELLA-SYS-CALL-METHOD
      (%METHOD-SLOT.SLOT-OWNER SELF) (CONCATENATE TREE NIL))))
   (CL:RETURN-FROM FINISH-WALKING-CALL-SLOT-TREE
    (CL:VALUES OTREE OTYPESPEC))))

;;; (DEFUN (QUOTE-ARGUMENTS CONS) ...)

(CL:DEFUN QUOTE-ARGUMENTS (METHOD ARGUMENTS)
  (CL:LET*
   ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (LASTPARAMETERINDEX (CL:1- (LENGTH PTYPESPECS)))
    (VARARGSTYPE
     (CL:IF
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
      (VARIABLE-ARGUMENTS-TYPE METHOD) NULL))
    (PTYPE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTPARAMETERINDEX))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR ARGUMENTS)) (ARGINDEX NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ARGINDEX ITER-000))
    (CL:LOOP WHILE (NEXT? IT) DO (CL:SETQ ARGINDEX ITER-000)
     (CL:TAGBODY
      (CL:WHEN
       (CL:NOT
        (CL:OR (SURROGATE? (%CONS-ITERATOR.VALUE IT))
         (KEYWORD? (%CONS-ITERATOR.VALUE IT))))
       (CL:IF
        (CL:AND (CL:>= ARGINDEX LASTPARAMETERINDEX)
         (CL:NOT (CL:EQ VARARGSTYPE NULL)))
        (CL:SETQ PTYPE VARARGSTYPE)
        (CL:SETQ PTYPE (NTH PTYPESPECS ARGINDEX)))
       (CL:WHEN
        (CL:OR (CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-WALK-STELLA-NULL)
         (CL:AND (CL:EQ PTYPE SGT-WALK-STELLA-BOOLEAN)
          (CL:OR (CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-WALK-STELLA-TRUE)
           (CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-WALK-STELLA-FALSE)))
         (CL:AND (WRAPPER? (%CONS-ITERATOR.VALUE IT))
          (CL:NOT (CL:EQ PTYPE NULL))
          (SUB-TYPE-SPEC-OF? PTYPE SGT-WALK-STELLA-LITERAL)))
        (CL:GO :CONTINUE))
       (VALUE-SETTER IT
        (LIST* SYM-WALK-STELLA-COPY-CONS-TREE
         (LIST* SYM-WALK-STELLA-QUOTE (%CONS-ITERATOR.VALUE IT) NIL)
         NIL)))
      :CONTINUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM QUOTE-ARGUMENTS ARGUMENTS)))

;;; (DEFUN (WALK-FIRST-ARGUMENT-TO-FUNCTION TYPE-SPEC) ...)

(CL:DEFUN WALK-FIRST-ARGUMENT-TO-FUNCTION (FNSLOT TREE)
  (CL:LET*
   ((PTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS FNSLOT))
    (TARGETTS (FIRST PTYPESPECS)))
   (CL:WHEN (CL:NOT (METHOD-EVALUATE-ARGUMENTS? FNSLOT))
    (CL:SETF (%%REST TREE) (QUOTE-ARGUMENTS FNSLOT (%%REST TREE))))
   (CL:WHEN
    (CL:AND
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FNSLOT)
       SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
     (CL:= (LENGTH PTYPESPECS) 1))
    (CL:SETF (%%REST TREE)
     (WALK-VARIABLE-ARGUMENTS (%%REST TREE) FNSLOT NULL))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION
     SGT-WALK-STELLA-UNKNOWN))
   (CL:WHEN
    (CL:OR (CL:EQ (%%REST TREE) NIL)
     (EMPTY? (METHOD-PARAMETER-TYPE-SPECIFIERS FNSLOT)))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION
     SGT-WALK-STELLA-UNKNOWN))
   (CL:LET* ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE)) TARGETTS
      (%METHOD-SLOT.SLOT-NAME FNSLOT) CL:T))
    (SECOND-SETTER TREE OTREE)
    (CL:COND
     ((SUBTYPE-OF-INTEGER? (SAFE-PRIMARY-TYPE OTREE))
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (%METHOD-SLOT.SLOT-NAME FNSLOT)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-SYM)
          (REGISTER-SYMBOL
           (GET-SYM-FROM-OFFSET
            (%INTEGER-WRAPPER.WRAPPER-VALUE OTREE))))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-SGT)
          (REGISTER-SYMBOL
           (GET-SGT-FROM-OFFSET
            (%INTEGER-WRAPPER.WRAPPER-VALUE OTREE))))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-KWD)
          (REGISTER-SYMBOL
           (GET-KWD-FROM-OFFSET
            (%INTEGER-WRAPPER.WRAPPER-VALUE OTREE))))
         (CL:T)))))
     (CL:T))
    (CL:RETURN-FROM WALK-FIRST-ARGUMENT-TO-FUNCTION OTYPE))))

;;; (DEFUN (WALK-CALL-SLOT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-CALL-SLOT-TREE (TREE)
  (CL:LET*
   ((SLOTNAME (%%VALUE TREE)) (WALKEDFIRSTARG NULL)
    (FIRSTARGTYPE SGT-WALK-STELLA-VOID) (FIRSTARGCLASS NULL)
    (ILLEGALFIRSTARG? CL:NIL) (PREVIOUSERRORS *TRANSLATIONERRORS*)
    (SLOT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PREVIOUSERRORS))
   (CL:WHEN (CL:EQ SLOTNAME SYM-WALK-STELLA-ERROR)
    (CL:SETQ *FOUNDRETURN?* CL:T))
   (CL:SETQ SLOT (LOOKUP-FUNCTION SLOTNAME))
   (CL:IF (CL:NOT (CL:EQ SLOT NULL))
    (CL:IF
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SLOT)
       SYM-WALK-STELLA-METHOD-MACRO? FALSE-WRAPPER))
     (CL:RETURN-FROM WALK-CALL-SLOT-TREE (WALK-MACRO-TREE TREE))
     (CL:SETQ FIRSTARGTYPE
      (WALK-FIRST-ARGUMENT-TO-FUNCTION SLOT TREE)))
    (CL:WHEN (CL:NOT (CL:EQ (%%REST TREE) NIL))
     (CL:MULTIPLE-VALUE-SETQ (WALKEDFIRSTARG FIRSTARGTYPE)
      (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
       SGT-WALK-STELLA-UNKNOWN SLOTNAME CL:T))
     (SECOND-SETTER TREE
      (COERCE-A-TREE WALKEDFIRSTARG FIRSTARGTYPE FIRSTARGTYPE))
     (CL:WHEN (VOID? FIRSTARGTYPE)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " First argument in call to `"
         (DE-UGLIFY-PARSE-TREE SLOTNAME) "' returns @VOID." EOL)))
      (CL:RETURN-FROM WALK-CALL-SLOT-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
     (CL:SETQ FIRSTARGCLASS (TYPE-SPEC-TO-CLASS FIRSTARGTYPE))
     (CL:SETQ SLOT (LOOKUP-SLOT FIRSTARGCLASS SLOTNAME))))
   (CL:SETQ ILLEGALFIRSTARG? (> *TRANSLATIONERRORS* PREVIOUSERRORS))
   (CL:WHEN (VRLET-EXPRESSION? (%%VALUE (%%REST TREE)))
    (CL:RETURN-FROM WALK-CALL-SLOT-TREE
     (PERCOLATE-OUT-VRLET-EXPRESSION TREE (%%VALUE (%%REST TREE))
      SGT-WALK-STELLA-UNKNOWN)))
   (CL:WHEN
    (CL:AND (CL:EQ SLOT NULL)
     (SUB-TYPE-SPEC-OF? FIRSTARGTYPE SGT-WALK-STELLA-ARGUMENT-LIST))
    (CL:SETQ SLOT
     (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-CONS)
      SLOTNAME)))
   (CL:WHEN (CL:EQ SLOT NULL)
    (CL:IF
     (CL:AND (WARN-ABOUT-UNDEFINED-METHODS?)
      (CL:NOT (CL:EQ FIRSTARGTYPE SGT-WALK-STELLA-UNKNOWN))
      (CL:NOT (CL:EQ FIRSTARGCLASS NULL))
      (%CLASS.ABSTRACT? FIRSTARGCLASS))
     (CL:RETURN-FROM WALK-CALL-SLOT-TREE
      (WALK-SLOT-ON-ABSTRACT-TYPE-TREE TREE
       (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE)))
     (CL:RETURN-FROM WALK-CALL-SLOT-TREE
      (WALK-UNDEFINED-SLOT-TREE TREE
       (CL:IF (VOID? FIRSTARGTYPE) SGT-WALK-STELLA-UNKNOWN
        FIRSTARGTYPE)
       (CL:AND (CL:NOT ILLEGALFIRSTARG?)
        (WARN-ABOUT-UNDEFINED-METHODS?))))))
   (CL:LET* ((MINARGS (METHOD-ARGUMENT-COUNT SLOT)) (MAXARGS MINARGS))
    (CL:DECLARE (CL:TYPE CL:FIXNUM MINARGS MAXARGS))
    (CL:COND
     ((SUBTYPE-OF-METHOD-SLOT? (SAFE-PRIMARY-TYPE SLOT))
      (CL:PROGN
       (CL:WHEN
        (CL:OR
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SLOT)
           SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SLOT)
           SYM-WALK-STELLA-METHOD-BODY-ARGUMENT? FALSE-WRAPPER)))
        (CL:SETQ MINARGS (CL:1- MINARGS))
        (CL:SETQ MAXARGS NULL-INTEGER))))
     (CL:T))
    (CL:WHEN (BAD-ARGUMENT-RANGE? TREE MINARGS MAXARGS)
     (CL:RETURN-FROM WALK-CALL-SLOT-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN))))
   (CL:LET* ((OTREE NULL) (OTYPE NULL))
    (CL:IF
     (SUB-TYPE-SPEC-OF? FIRSTARGTYPE SGT-WALK-STELLA-ARGUMENT-LIST)
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (FINISH-WALKING-ARGUMENT-LIST-TREE SLOT TREE FIRSTARGTYPE))
     (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
      (FINISH-WALKING-CALL-SLOT-TREE SLOT TREE FIRSTARGTYPE)))
    (CL:RETURN-FROM WALK-CALL-SLOT-TREE
     (SYS-TREE-IF-NEEDED SLOT OTREE FIRSTARGTYPE OTYPE)))))

;;; (DEFUN (INLINE-METHOD-CALL? BOOLEAN) ...)

(CL:DEFUN INLINE-METHOD-CALL? (METHOD)
  (CL:RETURN-FROM INLINE-METHOD-CALL?
   (CL:AND (METHOD-CALL-INLINING-ENABLED?)
    (CL:OR
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-GLOBALLY-INLINE? FALSE-WRAPPER))
     (CL:AND (CL:NOT (CL:EQ *METHODBEINGWALKED* NULL))
      (MEMBER? (METHOD-INLINED-FUNCTIONS *METHODBEINGWALKED*)
       (%METHOD-SLOT.SLOT-NAME METHOD))))
    (METHOD-INLINABLE? METHOD))))

;;; (DEFUN (METHOD-INLINABLE? BOOLEAN) ...)

(CL:DEFUN METHOD-INLINABLE? (METHOD)
  (CL:WHEN
   (CL:OR (VOID? (TYPE METHOD))
    (CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER)))
   (CL:RETURN-FROM METHOD-INLINABLE? CL:NIL))
  (CL:COND
   ((CL:OR (%METHOD-SLOT.METHOD-FUNCTION? METHOD)
     (MOST-SPECIFIC-METHOD? METHOD))
    (CL:RETURN-FROM METHOD-INLINABLE?
     (CL:NOT (CL:EQ (INLINABLE-METHOD-BODY METHOD) NULL))))
   (CL:T
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-NOTE)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       EOL " Cannot inline method `" (DE-UGLIFY-PARSE-TREE METHOD)
       "', since there are" EOL
       " one or more methods that specialize it." EOL)))
    (CL:RETURN-FROM METHOD-INLINABLE? CL:NIL))))

;;; (DEFUN (MOST-SPECIFIC-METHOD? BOOLEAN) ...)

(CL:DEFUN MOST-SPECIFIC-METHOD? (METHOD)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((SUB NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (%CLASS.CLASS-DIRECT-SUBS
        (%SURROGATE.SURROGATE-VALUE
         (%METHOD-SLOT.SLOT-OWNER METHOD))))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUB (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (HELP-MOST-SPECIFIC-METHOD? (%SURROGATE.SURROGATE-VALUE SUB)
        METHOD))
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((VALUE-000 ALWAYS?-000))
    (CL:RETURN-FROM MOST-SPECIFIC-METHOD? VALUE-000))))

;;; (DEFUN (HELP-MOST-SPECIFIC-METHOD? BOOLEAN) ...)

(CL:DEFUN HELP-MOST-SPECIFIC-METHOD? (CLASS METHOD)
  (CL:WHEN (CL:EQ CLASS NULL)
   (CL:RETURN-FROM HELP-MOST-SPECIFIC-METHOD? CL:T))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET*
     ((SLOT NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SLOT (%%VALUE ITER-000))
      (CL:WHEN (CL:EQ (%SLOT.SLOT-DIRECT-EQUIVALENT SLOT) METHOD)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ TEST-VALUE-000 FOUND?-000))
   (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((SUB NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SUB (%%VALUE ITER-001))
       (CL:WHEN
        (CL:NOT
         (HELP-MOST-SPECIFIC-METHOD? (%SURROGATE.SURROGATE-VALUE SUB)
          METHOD))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM HELP-MOST-SPECIFIC-METHOD? VALUE-000))))

;;; (DEFUN (INLINABLE-METHOD-BODY OBJECT) ...)

(CL:DEFUN INLINABLE-METHOD-BODY (METHOD)
  (CL:LET*
   ((DEFINITION NULL)
    (BODY
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-CACHED-INLINABLE-METHOD-BODY NULL)))
   (CL:WHEN (CL:EQ BODY METHOD)
    (CL:RETURN-FROM INLINABLE-METHOD-BODY NULL))
   (CL:WHEN (CL:NOT (CL:EQ BODY NULL))
    (CL:RETURN-FROM INLINABLE-METHOD-BODY BODY))
   (CL:SETQ DEFINITION
    (UNSTRINGIFY-STELLA-SOURCE
     (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE METHOD)
     (HOME-MODULE METHOD)))
   (EXTRACT-OPTIONS DEFINITION NULL)
   (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
    SYM-WALK-STELLA-CACHED-INLINABLE-METHOD-BODY METHOD NULL)
   (CL:WHEN (CL:= (LENGTH DEFINITION) 4)
    (CL:SETQ BODY (LAST DEFINITION))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE BODY) SGT-WALK-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (CL:EQ (%%VALUE BODY) SYM-WALK-STELLA-RETURN)
         (CL:OR (VERBATIM-TREE? (%%VALUE (%%REST BODY)))
          (CL:NOT (SEARCH-CONS-TREE? BODY SYM-WALK-STELLA-VERBATIM))))
        (CL:RETURN-FROM INLINABLE-METHOD-BODY
         (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
          SYM-WALK-STELLA-CACHED-INLINABLE-METHOD-BODY
          (PERMANENTIFY-FORM (%%VALUE (%%REST BODY))) NULL)))))
     (CL:T)))
   (CL:RETURN-FROM INLINABLE-METHOD-BODY NULL)))

;;; (DEFSPECIAL *INLININGMETHODCALL?* ...)

(CL:DEFVAR *INLININGMETHODCALL?* CL:NIL)

;;; (DEFUN (WALK-INLINE-METHOD-CALL OBJECT) ...)

(CL:DEFUN WALK-INLINE-METHOD-CALL (METHOD WALKEDARGS FIRSTARGTYPE)
  (CL:LET*
   ((BODY (INLINABLE-METHOD-BODY METHOD)) (NOFREFERENCES NULL-INTEGER)
    (INLINEARG NULL) (SUCCESS? CL:T))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFREFERENCES))
   (CL:WHEN
    (CL:AND (VERBATIM-TREE? BODY)
     (CL:NOT (CL:EQ (LOOKUP-VERBATIM-TREE BODY NULL) NULL)))
    (CL:RETURN-FROM WALK-INLINE-METHOD-CALL
     (YIELD-VERBATIM-INLINE-CALL-TREE METHOD WALKEDARGS)))
   (CL:SETQ BODY (COPY-CONS-TREE BODY))
   (CL:LET* ((*INLININGMETHODCALL?* CL:T) (*METHODBEINGWALKED* METHOD))
    (CL:DECLARE (CL:SPECIAL *INLININGMETHODCALL?* *METHODBEINGWALKED*))
    (CL:LET*
     ((VAR NULL)
      (ITER-000 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
      (TSPEC NULL)
      (ITER-001
       (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
      (ARG NULL) (ITER-002 WALKEDARGS) (I NULL-INTEGER) (ITER-003 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
       (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
      DO (CL:SETQ VAR (%%VALUE ITER-000))
      (CL:SETQ TSPEC (%%VALUE ITER-001))
      (CL:SETQ ARG (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
      (CL:IF
       (CL:AND (CL:= I 0) (MIXIN-METHOD? METHOD)
        (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
       (CL:SETQ TSPEC FIRSTARGTYPE)
       (CL:SETQ TSPEC (COMPUTE-RELATIVE-TYPE-SPEC TSPEC FIRSTARGTYPE)))
      (WALK-A-DECLARATION VAR TSPEC NULL CL:T)
      (SET-LOCAL-VARIABLE-INFO VAR KWD-WALK-INLINE-ARGUMENT ARG)
      (SET-LOCAL-VARIABLE-INFO VAR KWD-WALK-INLINE-REFERENCES
       (WRAP-INTEGER 0))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (%%REST ITER-002))
      (CL:SETQ ITER-003 (CL:1+ ITER-003))))
    (CL:SETQ BODY
     (WALK-EXPRESSION-TREE BODY (TYPE METHOD)
      SYM-WALK-STELLA-INLINE-CALL CL:T)))
   (CL:WHEN (PROCEDURAL-EXPRESSION? BODY) (CL:SETQ SUCCESS? CL:NIL))
   (CL:WHEN SUCCESS?
    (CL:LET*
     ((VAR NULL)
      (ITER-004 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
      (CL:SETQ VAR (%%VALUE ITER-004))
      (CL:SETQ INLINEARG
       (GET-LOCAL-VARIABLE-INFO VAR KWD-WALK-INLINE-ARGUMENT))
      (CL:SETQ NOFREFERENCES
       (%INTEGER-WRAPPER.WRAPPER-VALUE
        (GET-LOCAL-VARIABLE-INFO VAR KWD-WALK-INLINE-REFERENCES)))
      (CL:CASE NOFREFERENCES
       (0
        (CL:WHEN (CL:NOT (SIDE-EFFECT-FREE-EXPRESSION? INLINEARG))
         (CL:SETQ SUCCESS? CL:NIL) (CL:RETURN)))
       (1)
       (CL:OTHERWISE
        (CL:WHEN
         (CL:NOT
          (CL:AND (SIDE-EFFECT-FREE-EXPRESSION? INLINEARG)
           (CL:<=
            (CL:* (ESTIMATED-EVALUATION-COST INLINEARG) NOFREFERENCES)
            2)))
         (CL:SETQ SUCCESS? CL:NIL) (CL:RETURN))))
      (CL:SETQ ITER-004 (%%REST ITER-004)))))
   (CL:LET*
    ((VAR NULL)
     (ITER-005 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-005)) (CL:SETQ VAR VAR)
     (POP-VARIABLE-BINDING) (CL:SETQ ITER-005 (%%REST ITER-005))))
   (CL:RETURN-FROM WALK-INLINE-METHOD-CALL (CL:IF SUCCESS? BODY NULL))))

;;; (DEFUN (YIELD-VERBATIM-INLINE-CALL-TREE CONS) ...)

(CL:DEFUN YIELD-VERBATIM-INLINE-CALL-TREE (METHOD WALKEDARGS)
  (CL:RETURN-FROM YIELD-VERBATIM-INLINE-CALL-TREE
   (LIST* SYM-WALK-STELLA-SYS-INLINE-CALL
    (CONS
     (CL:IF (%METHOD-SLOT.METHOD-FUNCTION? METHOD)
      SYM-WALK-STELLA-SYS-CALL-FUNCTION
      SYM-WALK-STELLA-SYS-CALL-METHOD)
     (CONCATENATE
      (CL:IF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) NIL
       (CONS (%METHOD-SLOT.SLOT-OWNER METHOD) NIL))
      (CONS (%METHOD-SLOT.SLOT-NAME METHOD)
       (CONCATENATE WALKEDARGS NIL))))
    NIL)))

;;; (DEFUN (INLINE-VARIABLE-REFERENCE? BOOLEAN) ...)

(CL:DEFUN INLINE-VARIABLE-REFERENCE? (SELF)
  (CL:RETURN-FROM INLINE-VARIABLE-REFERENCE?
   (CL:AND *INLININGMETHODCALL?*
    (CL:NOT
     (CL:EQ (GET-LOCAL-VARIABLE-INFO SELF KWD-WALK-INLINE-ARGUMENT)
      NULL)))))

;;; (DEFUN (WALK-INLINE-VARIABLE-REFERENCE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-INLINE-VARIABLE-REFERENCE (SELF)
  (SET-LOCAL-VARIABLE-INFO SELF KWD-WALK-INLINE-REFERENCES
   (WRAP-INTEGER
    (CL:1+
     (%INTEGER-WRAPPER.WRAPPER-VALUE
      (GET-LOCAL-VARIABLE-INFO SELF KWD-WALK-INLINE-REFERENCES)))))
  (CL:RETURN-FROM WALK-INLINE-VARIABLE-REFERENCE
   (SYS-TREE
    (COPY-CONS-TREE
     (GET-LOCAL-VARIABLE-INFO SELF KWD-WALK-INLINE-ARGUMENT))
    (LOOKUP-VARIABLE-TYPE SELF))))

;;; (DEFUN (SIDE-EFFECT-FREE-EXPRESSION? BOOLEAN) ...)

(CL:DEFUN SIDE-EFFECT-FREE-EXPRESSION? (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CAST)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SAFE-CAST))
        (CL:RETURN-FROM SIDE-EFFECT-FREE-EXPRESSION?
         (SIDE-EFFECT-FREE-EXPRESSION? (%%VALUE (%%REST TREE)))))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQ?)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQL?)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-=)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-+)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA--)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-*)
         (CL:EQ TEST-VALUE-000 |SYM-WALK-STELLA-/|)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->=)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<=)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-THE-CODE)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE)
         (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER))
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:WHEN (CL:NOT (SIDE-EFFECT-FREE-EXPRESSION? ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:LET* ((VALUE-000 ALWAYS?-000))
          (CL:RETURN-FROM SIDE-EFFECT-FREE-EXPRESSION? VALUE-000))))
       (CL:T)))))
   (CL:T (CL:RETURN-FROM SIDE-EFFECT-FREE-EXPRESSION? CL:T)))
  (CL:RETURN-FROM SIDE-EFFECT-FREE-EXPRESSION? CL:NIL))

;;; (DEFUN (ESTIMATED-EVALUATION-COST INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) ESTIMATED-EVALUATION-COST))
(CL:DEFUN ESTIMATED-EVALUATION-COST (TREE)
  (CL:LET* ((COST 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COST))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-CAST)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SAFE-CAST))
         (CL:RETURN-FROM ESTIMATED-EVALUATION-COST
          (ESTIMATED-EVALUATION-COST (%%VALUE (%%REST TREE)))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-AND)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-OR)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-NOT)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQ?)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-EQL?)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-=)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-+)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA--)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-*)
          (CL:EQ TEST-VALUE-000 |SYM-WALK-STELLA-/|)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA->=)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-<=)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-THE-CODE)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE)
          (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER))
         (CL:SETQ COST (CL:1+ COST))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:SETQ COST (CL:+ COST (ESTIMATED-EVALUATION-COST ARG)))
           (CL:SETQ ITER-000 (%%REST ITER-000)))))
        (CL:T)))))
    (CL:T))
   (CL:RETURN-FROM ESTIMATED-EVALUATION-COST COST)))

;;; (DEFUN (YIELD-SYNTHESIZED-METHOD-BODY CONS) ...)

(CL:DEFUN YIELD-SYNTHESIZED-METHOD-BODY (UNIT)
  (CL:LET*
   ((METHOD (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (BODY (%TRANSLATION-UNIT.CODE-REGISTER UNIT)))
   (CL:WHEN (CL:EQ (METHOD-PARAMETER-NAMES METHOD) NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Missing parameters for :inherits-through method." EOL))))
   (CL:COND
    ((CL:NOT (CL:EQ BODY NIL))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Over-specified definition of :inherits-through method."
        EOL)))
     (CL:RETURN-FROM YIELD-SYNTHESIZED-METHOD-BODY BODY))
    (CL:T
     (CL:RETURN-FROM YIELD-SYNTHESIZED-METHOD-BODY
      (SYNTHESIZE-METHOD-BODY METHOD))))))

;;; (DEFUN (WALK-METHOD-OBJECT CONS) ...)

(CL:DEFUN WALK-METHOD-OBJECT (UNIT)
  (CL:LET*
   ((METHOD (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (BODY (%TRANSLATION-UNIT.CODE-REGISTER UNIT)))
   (CL:LET*
    ((*LOCALVARIABLETYPETABLE* (NEW-KEY-VALUE-LIST))
     (*LOCALGENSYMTABLE* (NEW-KEY-VALUE-LIST))
     (*SPECIALVARIABLESTACK* (NEW-KEY-VALUE-LIST))
     (*METHODBEINGWALKED* METHOD) (*FOUNDRETURN?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *LOCALVARIABLETYPETABLE* *LOCALGENSYMTABLE*
      *SPECIALVARIABLESTACK* *METHODBEINGWALKED* *FOUNDRETURN?*))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-METHOD-INHERITS-THROUGH NULL)
       NULL))
     (CL:SETQ BODY (YIELD-SYNTHESIZED-METHOD-BODY UNIT)))
    (CL:LET*
     ((NAME NULL)
      (ITER-000 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
      (TYPESPEC NULL)
      (ITER-001
       (%LIST.THE-CONS-LIST
        (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
       (CL:NOT (CL:EQ ITER-001 NIL)))
      DO (CL:SETQ NAME (%%VALUE ITER-000))
      (CL:SETQ TYPESPEC (%%VALUE ITER-001))
      (WALK-A-DECLARATION NAME TYPESPEC NULL CL:T)
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:WHEN (CL:NOT (CL:EQ BODY NIL))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:SETQ TEST-VALUE-000 (CHECK-FOR-ILLEGAL-RETURN?))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000 (CL:NOT (VOID? (TYPE METHOD))))
       (CL:WHEN TEST-VALUE-000
        (CL:SETQ TEST-VALUE-000
         (CL:NOT (%TRANSLATION-UNIT.AUXILIARY? UNIT)))
        (CL:WHEN TEST-VALUE-000
         (CL:SETQ TEST-VALUE-000
          (CL:NOT
           (%BOOLEAN-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-WALK-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET* ((FORM NULL) (ITER-002 BODY))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
             (CL:SETQ FORM (%%VALUE ITER-002))
             (CL:WHEN
              (CL:AND (CONS? FORM)
               (CL:EQ (%%VALUE FORM) SYM-WALK-STELLA-RETURN))
              (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
             (CL:SETQ ITER-002 (%%REST ITER-002))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000))
          (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))))))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ BODY
        (CONCATENATE BODY
         (CONS
          (LIST* SYM-WALK-STELLA-ERROR (WRAP-STRING "Returned from `")
           (WRAP-STRING (STRINGIFY METHOD))
           (CONS (WRAP-STRING "' without a `return'.") NIL))
          NIL)))))
     (CL:WHEN
      (CL:AND (LOG-FUNCTION-CALL? METHOD)
       (CL:NOT (%TRANSLATION-UNIT.AUXILIARY? UNIT)))
      (CL:SETQ BODY
       (WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE METHOD BODY)))
     (CL:SETQ BODY (WALK-LIST-OF-STATEMENTS BODY))
     (CL:WHEN
      (CL:AND (CL:NOT (VOID? (TYPE METHOD)))
       (CL:NOT (%METHOD-SLOT.ABSTRACT? METHOD))
       (CL:NOT *FOUNDRETURN?*))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Missing return statement." EOL)))))
    (FREE *LOCALVARIABLETYPETABLE*) (FREE *LOCALGENSYMTABLE*)
    (FREE *SPECIALVARIABLESTACK*)
    (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER UNIT) BODY)
    (CL:RETURN-FROM WALK-METHOD-OBJECT BODY))))

;;; (DEFUN WALK-DEFMETHOD-TREE ...)

(CL:DEFUN WALK-DEFMETHOD-TREE (TREE)
  (CL:LET* ((METHOD NULL))
   (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
    (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
     SYM-WALK-STELLA-METHOD)
    (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) TREE)
    (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
   (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE TREE))
   (CL:COND
    ((CL:AND (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
      (CL:OR (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD) NULL)
       (CL:EQ
        (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER METHOD))
        NULL)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Can't define method `" (%METHOD-SLOT.SLOT-NAME METHOD)
        "' on the non-existent class `"
        (%METHOD-SLOT.SLOT-OWNER METHOD) "'." EOL)))
     (FREE METHOD) (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
     (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL))
    (CL:T
     (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
      METHOD)
     (CL:SETF
      (%TRANSLATION-UNIT.CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
      (NTH-REST TREE 3))
     (CL:WHEN (METHOD-NEEDS-LISP-MACRO? METHOD)
      (REGISTER-NATIVE-NAME (%METHOD-SLOT.SLOT-NAME METHOD)
       KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)))))
  :VOID)

;;; (DEFUN (METHOD-STORES-NATIVE-CODE-POINTER? BOOLEAN) ...)

(CL:DEFUN METHOD-STORES-NATIVE-CODE-POINTER? (METHOD)
  (CL:LET*
   ((NAME (%METHOD-SLOT.SLOT-NAME METHOD))
    (OWNER (%METHOD-SLOT.SLOT-OWNER METHOD)))
   (CL:COND
    ((%METHOD-SLOT.ABSTRACT? METHOD)
     (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:NIL))
    ((CL:EQ NAME SYM-WALK-STELLA-MAIN)
     (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:NIL))
    ((%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-NATIVE? FALSE-WRAPPER))
     (CL:WHEN
      (MEMBER?
       (GET-QUOTED-TREE "((NULL? DEFINED?) \"/STELLA\")" "/STELLA")
       NAME)
      (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:NIL))
     (CL:WHEN (CL:NOT (CL:EQ (LOOKUP *CPP-OPERATOR-TABLE* NAME) NULL))
      (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:NIL))
     (CL:LET*
      ((TYPE NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST
         (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ TYPE (%%VALUE ITER-000))
       (CL:SETQ TYPE
        (TYPE-SPEC-TO-BASE-TYPE
         (COMPUTE-RELATIVE-TYPE-SPEC TYPE OWNER)))
       (CL:WHEN
        (CL:AND (SUBTYPE-OF? TYPE SGT-WALK-STELLA-LITERAL)
         (%CLASS.ABSTRACT? (TYPE-TO-CLASS TYPE)))
        (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:NIL))
       (CL:SETQ ITER-000 (%%REST ITER-000))))))
   (CL:RETURN-FROM METHOD-STORES-NATIVE-CODE-POINTER? CL:T)))

;;; (DEFUN WALK-METHOD-UNIT ...)

(CL:DEFUN WALK-METHOD-UNIT (UNIT)
  (CL:LET* ((*CURRENTTRANSLATIONUNIT* UNIT))
   (CL:DECLARE (CL:SPECIAL *CURRENTTRANSLATIONUNIT*))
   (CL:LET*
    ((METHOD (%TRANSLATION-UNIT.THE-OBJECT UNIT))
     (NAME (%METHOD-SLOT.SLOT-NAME METHOD))
     (BODY (%TRANSLATION-UNIT.CODE-REGISTER UNIT))
     (CREATEMETHODOBJECT? CL:T) (STORECODEPOINTER? CL:T)
     (EVALUATORWRAPPERMETHOD NULL))
    (CL:WHEN
     (CL:AND (MIXIN-METHOD? METHOD)
      (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
     (CLEAR-TRANSLATION-UNIT UNIT)
     (WALK-AUXILIARY-TREE
      (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-METHODS
       (YIELD-DEFINE-STELLA-METHOD-OBJECT METHOD NULL NULL) NIL))
     (CL:RETURN-FROM WALK-METHOD-UNIT))
    (CL:WHEN
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-FORWARD-DECLARATION? FALSE-WRAPPER))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-FORWARD-DECLARATION? FALSE-WRAPPER
      FALSE-WRAPPER))
    (CL:WHEN
     (CL:AND (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
      (CL:NOT
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-METHOD-NATIVE? FALSE-WRAPPER)))
      (CL:NOT
       (CL:EQ (HOME-MODULE METHOD)
        (HOME-MODULE (%SURROGATE.SURROGATE-VALUE (OWNER METHOD))))))
     (CL:COND
      ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM
          (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
          " Defining method `" (DE-UGLIFY-PARSE-TREE METHOD)
          "' outside the home module of" EOL
          "   its owner class will be illegal in C++ and Java." EOL))))
      (CL:T
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Defining method `" (DE-UGLIFY-PARSE-TREE METHOD)
          "' outside the home module of" EOL
          "   its owner class is illegal in `"
          (TRANSLATOR-OUTPUT-LANGUAGE-NAME) "'." EOL)))
       (CLEAR-TRANSLATION-UNIT UNIT)
       (CL:RETURN-FROM WALK-METHOD-UNIT))))
    (CL:COND
     ((CL:AND (CL:EQ BODY NIL)
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-METHOD-INHERITS-THROUGH NULL)
        NULL))
      (WALK-METHOD-OBJECT UNIT)
      (CL:WHEN
       (CL:NOT
        (CL:OR
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
           SYM-WALK-STELLA-METHOD-NATIVE? FALSE-WRAPPER))
         (%METHOD-SLOT.ABSTRACT? METHOD)))
       (CL:SETQ CREATEMETHODOBJECT? CL:NIL)
       (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-FORWARD-DECLARATION? TRUE-WRAPPER
        FALSE-WRAPPER)
       (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 3)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Forward declaration of `" METHOD "'" EOL)))
      (CLEAR-TRANSLATION-UNIT UNIT))
     ((CL:OR
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))
       (CL:AND (%TRANSLATION-UNIT.AUXILIARY? UNIT)
        (CL:NOT (INLINE-METHOD? METHOD))))
      (CL:SETQ CREATEMETHODOBJECT? CL:NIL)
      (PUSH *TRANSLATIONUNITS* UNIT) (WALK-METHOD-OBJECT UNIT))
     (CL:T (PUSH *TRANSLATIONUNITS* UNIT) (WALK-METHOD-OBJECT UNIT)))
    (CL:WHEN CREATEMETHODOBJECT?
     (CL:WHEN
      (CL:AND
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-METHOD-COMMAND? FALSE-WRAPPER))
       (CL:NOT (COMMAND? METHOD)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL
         " Ignored :command? declaration.  Currently, only functions can be commands.."
         EOL))))
     (CL:WHEN (METHOD-NEEDS-EVALUATOR-WRAPPER? METHOD)
      (CL:SETQ EVALUATORWRAPPERMETHOD
       (CREATE-EVALUATOR-WRAPPER-UNIT METHOD)))
     (CL:WHEN (METHOD-NEEDS-LISP-MACRO? METHOD)
      (CREATE-LISP-MACRO-UNITS NAME METHOD))
     (CL:WHEN (METHOD-NEEDS-C-CALLABLE-WRAPPER? METHOD)
      (CREATE-C-CALLABLE-WRAPPER-UNIT METHOD))
     (CL:SETQ STORECODEPOINTER?
      (METHOD-STORES-NATIVE-CODE-POINTER? METHOD))
     (WALK-AUXILIARY-TREE
      (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-METHODS
       (YIELD-DEFINE-STELLA-METHOD-OBJECT METHOD
        (CL:IF STORECODEPOINTER? METHOD NULL)
        (CL:IF STORECODEPOINTER? EVALUATORWRAPPERMETHOD NULL))
       NIL))
     (CL:WHEN
      (CL:AND (METHOD-NEEDS-C-CALLABLE-WRAPPER? METHOD)
       (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
      (WALK-AUXILIARY-TREE
       (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN
        (LIST* SYM-WALK-STELLA-SETF
         (LIST* SYM-WALK-STELLA-C-CALLABLE-WRAPPER-CODE
          (LIST* SYM-WALK-STELLA-LOOKUP-FUNCTION-BY-NAME
           (WRAP-STRING (%SYMBOL.SYMBOL-NAME NAME)) NIL)
          NIL)
         (LIST* SYM-WALK-STELLA-THE-CODE KWD-WALK-FUNCTION
          (YIELD-C-CALLABLE-WRAPPER-NAME METHOD) NIL)
         NIL)
        NIL))))))
  :VOID)

;;; (DEFUN PRINT-UNDEFINED-METHODS ...)

(CL:DEFUN PRINT-UNDEFINED-METHODS (MODULE LOCAL?)
  "Print all declared but not yet defined functions and methods
in `module'.  If `local?' is true, do not consider any parent modules of
`module'.  If `module' is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions."
  (CL:LET* ((UNDEFINEDMETHODS NIL))
   (CL:LET*
    ((METHOD NULL) (ITER-000 (ALL-METHODS MODULE LOCAL?))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ METHOD (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
         SYM-WALK-STELLA-FORWARD-DECLARATION? FALSE-WRAPPER))
       (CL:NOT (%METHOD-SLOT.ABSTRACT? METHOD))
       (CL:NOT (METHOD-CONTAINS-UNKNOWN-TYPE? METHOD)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS METHOD NIL))
        (CL:IF (CL:EQ UNDEFINEDMETHODS NIL)
         (CL:SETQ UNDEFINEDMETHODS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST UNDEFINEDMETHODS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS METHOD NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((FUNCTION NULL) (ITER-001 (ALL-FUNCTIONS MODULE LOCAL?))
     (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ FUNCTION (%ITERATOR.VALUE ITER-001))
     (CL:WHEN
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
        SYM-WALK-STELLA-FORWARD-DECLARATION? FALSE-WRAPPER))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS FUNCTION NIL))
        (CL:IF (CL:EQ UNDEFINEDMETHODS NIL)
         (CL:SETQ UNDEFINEDMETHODS COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST UNDEFINEDMETHODS COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS FUNCTION NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
   (CL:WHEN (CL:NOT (CL:EQ UNDEFINEDMETHODS NIL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "The following functions and methods are declared but not yet defined:"
     EOL)
    (CL:LET* ((METHOD NULL) (ITER-002 UNDEFINEDMETHODS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ METHOD (%%VALUE ITER-002))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "    " METHOD EOL)
      (CL:SETQ ITER-002 (%%REST ITER-002))))))
  :VOID)

;;; (DEFUN (WALK-SYS-CALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SYS-CALL-TREE (TREE)
  (CL:LET*
   ((SLOT (SLOT-FROM-EXPRESSION-TREE TREE))
    (SLOTTYPE SGT-WALK-STELLA-UNKNOWN))
   (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
    (CL:SETQ SLOTTYPE
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
      SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SLOTTYPE NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:IF (ANCHORED-TYPE-SPECIFIER? SLOTTYPE)
       (CL:SETQ TEST-VALUE-000 CL:T)
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((TS NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST
            (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
             SLOTTYPE))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ TS (%%VALUE ITER-000))
          (CL:WHEN (ANCHORED-TYPE-SPECIFIER? TS)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "walk-sys-call-tree: OOPS, can't handle anchored slot types: `"
        TREE "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:WHEN (CL:EQ SLOTTYPE NULL) (CL:SETQ SLOTTYPE (TYPE SLOT))))
   (CL:RETURN-FROM WALK-SYS-CALL-TREE (CL:VALUES TREE SLOTTYPE))))

;;; (DEFUN WALK-DEFCLASS-TREE ...)

(CL:DEFUN WALK-DEFCLASS-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
    SYM-WALK-STELLA-CLASS)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000)
    (%%VALUE (%%REST TREE)))
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
   (DEFINE-CLASS-FROM-PARSE-TREE TREE))
  (CL:WHEN
   (CL:EQ (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*) NULL)
   (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL))
  :VOID)

;;; (DEFUN (YIELD-INITIALIZE-HARDWIRED-SLOTS CONS) ...)

(CL:DEFUN YIELD-INITIALIZE-HARDWIRED-SLOTS (CLASS)
  (CL:LET* ((HARDWIREDSLOTINITIALIZERS NIL))
   (CL:WHEN (CREATE-NATIVE-CLASS? CLASS)
    (CL:LET* ((SLOT NULL) (ITER-000 (CLASS-SLOTS CLASS)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
      (CL:COND
       ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE SLOT))
        (CL:PROGN
         (CL:WHEN
          (CL:AND (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
           (CL:NOT (CL:EQ (INITIAL-VALUE SLOT) NULL)))
          (CL:SETQ HARDWIREDSLOTINITIALIZERS
           (CONS
            (LIST* SYM-WALK-STELLA-SETQ
             (YIELD-HARDWIRED-SLOT-VARIABLE SLOT)
             (CONS (INITIAL-VALUE SLOT) NIL))
            HARDWIREDSLOTINITIALIZERS)))))
       (CL:T)))))
   (CL:RETURN-FROM YIELD-INITIALIZE-HARDWIRED-SLOTS
    HARDWIREDSLOTINITIALIZERS)))

;;; (DEFUN (YIELD-INITIAL-VALUE-EXPRESSION OBJECT) ...)

(CL:DEFUN YIELD-INITIAL-VALUE-EXPRESSION (SLOT)
  (CL:WHEN
   (CL:OR (%STORAGE-SLOT.ABSTRACT? SLOT) (DYNAMIC-STORAGE? SLOT)
    (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
    (CL:EQ (ALLOCATION SLOT) KWD-WALK-CLASS))
   (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION NULL))
  (CL:LET* ((INITIALVALUEEXPRESSION (INITIALLY SLOT)))
   (CL:WHEN (CL:NOT (CL:EQ INITIALVALUEEXPRESSION NULL))
    (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION
     (COPY-CONS-TREE INITIALVALUEEXPRESSION)))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
     (CL:WHEN (CL:EQ (ALLOCATION SLOT) KWD-WALK-EMBEDDED)
      (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION
       (LIST* SYM-WALK-STELLA-ALLOCATE (TYPE-TO-SYMBOL (TYPE SLOT))
        NIL))))
    ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)
      (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-IDL))
     (CL:WHEN (CL:EQ (ALLOCATION SLOT) KWD-WALK-EMBEDDED)
      (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION
       (LIST* SYM-WALK-STELLA-ALLOCATE (TYPE-TO-SYMBOL (TYPE SLOT))
        NIL))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM YIELD-INITIAL-VALUE-EXPRESSION
    (TYPE-TO-WALKED-NULL-VALUE-TREE (TYPE-SPECIFIER SLOT) (TYPE SLOT)))))

;;; (DEFUN (YIELD-CONSTRUCTOR-ATTACHMENT CONS) ...)

(CL:DEFUN YIELD-CONSTRUCTOR-ATTACHMENT (CLASS CLASSREF)
  (CL:IF
   (CL:AND (CL:NOT (%CLASS.ABSTRACT? CLASS))
    (CREATE-NATIVE-CLASS? CLASS))
   (CL:LET*
    ((CONSTRUCTORFNCODE
      (LIST* SYM-WALK-STELLA-THE-CODE KWD-WALK-FUNCTION
       (YIELD-CONSTRUCTOR-NAME CLASS) NIL)))
    (CL:RETURN-FROM YIELD-CONSTRUCTOR-ATTACHMENT
     (CONS
      (LIST* SYM-WALK-STELLA-SETF
       (LIST* SYM-WALK-STELLA-CLASS-CONSTRUCTOR-CODE CLASSREF NIL)
       CONSTRUCTORFNCODE NIL)
      NIL)))
   (CL:RETURN-FROM YIELD-CONSTRUCTOR-ATTACHMENT NIL)))

(CL:DEFMETHOD CLASS-AUXILIARY-METHODS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SELF)
      SYM-WALK-STELLA-CLASS-AUXILIARY-METHODS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-AUXILIARY-METHODS NIL-LIST)
    (CL:RETURN-FROM CLASS-AUXILIARY-METHODS ANSWER))))

;;; (DEFUN CLEANUP-AUXILIARY-METHODS ...)

(CL:DEFUN CLEANUP-AUXILIARY-METHODS (CLASS)
  (CL:LET*
   ((AUXILIARYMETHODS (CLASS-AUXILIARY-METHODS CLASS)) (REASON NULL))
   (CL:LET*
    ((METHOD NULL) (ITER-000 (%LIST.THE-CONS-LIST AUXILIARYMETHODS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ METHOD (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (DELETED? METHOD))
      (CL:COND
       ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? METHOD))
        (DELETED?-SETTER METHOD CL:T))
       (CL:T
        (CL:SETQ REASON
         (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
          SYM-WALK-STELLA-AUXILIARY-METHOD-REASON NULL))
        (CL:WHEN
         (CL:OR (CL:EQ REASON NULL) (DELETED? REASON)
          (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? REASON))
          (CL:EQ (%SLOT.SLOT-OWNER REASON) NULL)
          (CL:=
           (%GENERALIZED-SYMBOL.SYMBOL-ID (%SLOT.SLOT-OWNER REASON))
           -1)
          (CL:EQ (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER REASON))
           NULL)
          (DELETED?
           (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER REASON)))
          (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
           (BAD?
            (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER REASON))))
          (CL:NOT
           (CL:EQ
            (LOOKUP-SLOT
             (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER REASON))
             (%SLOT.SLOT-NAME REASON))
            REASON)))
         (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
          SYM-WALK-STELLA-AUXILIARY-METHOD-REASON NULL NULL)
         (DELETED?-SETTER METHOD CL:T)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REMOVE-DELETED-MEMBERS AUXILIARYMETHODS))
  :VOID)

;;; (DEFUN REGISTER-AUXILIARY-METHOD ...)

(CL:DEFUN REGISTER-AUXILIARY-METHOD (METHOD REASON)
  (CL:WHEN (CL:NOT (CL:EQ METHOD NULL))
   (CL:LET*
    ((CLASS
      (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER METHOD)))
     (AUXILIARYMETHODS NULL))
    (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
     (CL:SETQ AUXILIARYMETHODS (CLASS-AUXILIARY-METHODS CLASS))
     (CL:WHEN (NULL-LIST? AUXILIARYMETHODS)
      (CL:SETQ AUXILIARYMETHODS
       (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-WALK-STELLA-CLASS-AUXILIARY-METHODS (NEW-LIST) NULL)))
     (FINALIZE-AUXILIARY-METHOD METHOD)
     (CL:LET* ((VALUE-000 NULL))
      (CL:LET*
       ((AUX NULL) (ITER-000 (%LIST.THE-CONS-LIST AUXILIARYMETHODS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ AUX (%%VALUE ITER-000))
        (CL:WHEN
         (CL:AND
          (CL:EQ (%METHOD-SLOT.SLOT-NAME METHOD)
           (%METHOD-SLOT.SLOT-NAME AUX))
          (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD)
           (%METHOD-SLOT.SLOT-OWNER AUX)))
         (CL:SETQ VALUE-000 AUX) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (REMOVE AUXILIARYMETHODS VALUE-000))
     (INSERT AUXILIARYMETHODS METHOD)
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-AUXILIARY-METHOD-REASON REASON NULL))))
  :VOID)

;;; (DEFGLOBAL *MIXIN-IMPLEMENTATION-STYLE* ...)

(CL:DEFVAR *MIXIN-IMPLEMENTATION-STYLE* NULL
  "A keyword describing how mixin classes are handled in
single-inheritance target languages.  The legal values are
:FIRST-CLASS-WITH-METHOD, which means that variables of a mixin type
are legal and that slot access on a mixin type is facilitated by
inherited-down accessor methods and a catch-all method on OBJECT,
:FIRST-CLASS-WITH-TYPECASE which is similar but replaces the catch-all
method with a function using a TYPECASE, and :SECOND-CLASS, which
means that variables of a mixin type are illegal and no additional
accessors and catch-all methods are needed.")

;;; (DEFUN (MIXIN-TYPE-VARIABLES-ALLOWED? BOOLEAN) ...)

(CL:DEFUN MIXIN-TYPE-VARIABLES-ALLOWED? ()
  (CL:RETURN-FROM MIXIN-TYPE-VARIABLES-ALLOWED?
   (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
    (CL:NOT
     (CL:EQ *MIXIN-IMPLEMENTATION-STYLE* KWD-WALK-SECOND-CLASS)))))

;;; (DEFUN (CREATE-NATIVE-MIXIN-SLOT-ACCESSORS? BOOLEAN) ...)

(CL:DEFUN CREATE-NATIVE-MIXIN-SLOT-ACCESSORS? ()
  (CL:RETURN-FROM CREATE-NATIVE-MIXIN-SLOT-ACCESSORS?
   (CL:AND (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)
    (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
     (CL:NOT
      (CL:EQ *MIXIN-IMPLEMENTATION-STYLE* KWD-WALK-SECOND-CLASS))))))

;;; (DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT ...)

(CL:DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT (SLOT CLASS MIXINACCESSORS? SIGNATURESONLY?)
  (CL:LET* ((METHODTREE NULL) (METHOD NULL))
   (CL:WHEN (SYSTEM-DEFINED-SLOT-READER? SLOT)
    (CL:SETQ METHODTREE (YIELD-SLOT-READER-TREE SLOT CLASS))
    (CL:IF SIGNATURESONLY?
     (CL:LET* ((*MODULE* (HOME-MODULE SLOT)) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE)))
     (CL:SETQ METHOD
      (%TRANSLATION-UNIT.THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE CL:T))))
    (REGISTER-AUXILIARY-METHOD METHOD SLOT))
   (CL:WHEN (SYSTEM-DEFINED-SLOT-WRITER? SLOT)
    (CL:SETQ METHODTREE (YIELD-SLOT-WRITER-TREE SLOT CLASS))
    (CL:IF SIGNATURESONLY?
     (CL:LET* ((*MODULE* (HOME-MODULE SLOT)) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE)))
     (CL:SETQ METHOD
      (%TRANSLATION-UNIT.THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE CL:T))))
    (REGISTER-AUXILIARY-METHOD METHOD SLOT))
   (CL:WHEN
    (CL:AND MIXINACCESSORS? (CL:NOT (%STORAGE-SLOT.ABSTRACT? SLOT)))
    (CL:SETQ METHODTREE (YIELD-NATIVE-SLOT-READER-TREE SLOT CLASS))
    (CL:IF SIGNATURESONLY?
     (CL:LET* ((*MODULE* (HOME-MODULE SLOT)) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE)))
     (CL:SETQ METHOD
      (%TRANSLATION-UNIT.THE-OBJECT
       (HELP-WALK-AUXILIARY-TREE METHODTREE CL:T))))
    (REGISTER-AUXILIARY-METHOD METHOD SLOT)
    (CL:WHEN (CL:NOT (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT))
     (CL:SETQ METHODTREE (YIELD-NATIVE-SLOT-WRITER-TREE SLOT CLASS))
     (CL:IF SIGNATURESONLY?
      (CL:LET* ((*MODULE* (HOME-MODULE SLOT)) (*CONTEXT* *MODULE*))
       (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
       (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE METHODTREE)))
      (CL:SETQ METHOD
       (%TRANSLATION-UNIT.THE-OBJECT
        (HELP-WALK-AUXILIARY-TREE METHODTREE CL:T))))
     (REGISTER-AUXILIARY-METHOD METHOD SLOT))))
  :VOID)

;;; (DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT ...)

(CL:DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT (SLOT CLASS)
  (CL:WHEN
   (CL:AND (NATIVE-SLOT? SLOT)
    (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
   (CL:COND
    ((CL:EQ *MIXIN-IMPLEMENTATION-STYLE*
      KWD-WALK-FIRST-CLASS-WITH-TYPECASE)
     (WALK-AUXILIARY-TREE (YIELD-MIXIN-SLOT-READER-TREE SLOT))
     (WALK-AUXILIARY-TREE (YIELD-MIXIN-SLOT-WRITER-TREE SLOT)))
    (CL:T
     (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT
      (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-OBJECT) CL:T
      CL:NIL))))
  (CL:WHEN (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
   (CL:LET* ((READCODE NULL) (AUXILIARYCODE NULL))
    (CL:MULTIPLE-VALUE-SETQ (READCODE AUXILIARYCODE)
     (YIELD-HARDWIRED-SLOT-READER-BODY SLOT))
    (CL:SETQ READCODE READCODE) (WALK-AUXILIARY-TREE AUXILIARYCODE))
   (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT
    (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-OBJECT) CL:NIL CL:NIL))
  :VOID)

;;; (DEFUN CREATE-SLOT-ACCESSOR-UNITS ...)

(CL:DEFUN CREATE-SLOT-ACCESSOR-UNITS (CLASS)
  (CL:LET*
   ((SLOT NULL) (ITER-000 (%LIST.THE-CONS-LIST (LOCAL-SLOTS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SLOT (%%VALUE ITER-000))
    (CL:COND
     ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE SLOT))
      (CL:PROGN
       (CL:IF
        (CL:AND
         (CL:AND (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)
          (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
           (CL:NOT
            (CL:EQ *MIXIN-IMPLEMENTATION-STYLE*
             KWD-WALK-SECOND-CLASS))))
         (%CLASS.MIXIN? CLASS))
        (CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT SLOT CLASS)
        (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT CLASS CL:NIL
         (%STORAGE-SLOT.SLOT-EXTERNAL? SLOT)))))
     (CL:T))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SUPER NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SUPER (%%VALUE ITER-001))
       (CL:WHEN (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((SLOT NULL) (ITER-002 (CLASS-SLOTS CLASS)))
     (CL:LOOP WHILE (NEXT? ITER-002) DO
      (CL:SETQ SLOT (%ITERATOR.VALUE ITER-002))
      (CL:WHEN
       (CL:AND (MIXIN-SLOT? SLOT)
        (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
       (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT CLASS
        (CL:AND (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)
         (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
          (CL:NOT
           (CL:EQ *MIXIN-IMPLEMENTATION-STYLE*
            KWD-WALK-SECOND-CLASS))))
        (%SLOT.SLOT-EXTERNAL? SLOT)))))))
  (CREATE-GENERIC-SLOT-ACCESSOR-UNIT CLASS)
  :VOID)

;;; (DEFUN CREATE-INLINE-METHOD-UNITS ...)

(CL:DEFUN CREATE-INLINE-METHOD-UNITS (CLASS)
  (CL:LET*
   ((SLOT NULL) (ITER-000 (%LIST.THE-CONS-LIST (LOCAL-SLOTS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SLOT (%%VALUE ITER-000))
    (CL:WHEN (INLINE-METHOD? SLOT)
     (CL:LET* ((NAME NULL) (PARAMETERS NULL) (BODY NULL))
      (CL:MULTIPLE-VALUE-SETQ (NAME PARAMETERS BODY)
       (DESTRUCTURE-DEFMETHOD-TREE
        (UNSTRINGIFY-STELLA-SOURCE
         (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE SLOT)
         (HOME-MODULE SLOT))
        NULL))
      (CL:PROGN (CL:SETQ NAME NAME) (CL:SETQ PARAMETERS PARAMETERS))
      (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
       (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) SLOT)
       (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
        SYM-WALK-STELLA-METHOD)
       (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF-000) BODY)
       (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? SELF-000) CL:T)
       (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
       (WALK-METHOD-UNIT SELF-000))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN (YIELD-MIXIN-METHOD-TREE CONS) ...)

(CL:DEFUN YIELD-MIXIN-METHOD-TREE (METHOD CLASS)
  (CL:LET*
   ((TREE
     (UNSTRINGIFY-STELLA-SOURCE
      (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE METHOD)
      (HOME-MODULE METHOD)))
    (PARAMETERS (%%VALUE (%%REST (%%REST TREE))))
    (SELFTREE (%%VALUE PARAMETERS))
    (SELFTYPETREE
     (YIELD-TYPE-SPEC-TREE
      (FIRST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
    (BODY (NTH-REST TREE 3)))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE SELFTYPETREE) SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (FIRST-SETTER SELFTYPETREE
       (YIELD-TYPE-SPEC-TREE (%CLASS.CLASS-TYPE CLASS)))))
    (CL:T
     (CL:SETQ SELFTYPETREE
      (YIELD-TYPE-SPEC-TREE (%CLASS.CLASS-TYPE CLASS)))))
   (FIRST-SETTER (LAST-CONS SELFTREE) SELFTYPETREE)
   (CL:WHEN
    (CL:EQ CLASS (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-OBJECT))
    (CL:SETQ BODY
     (CONCATENATE (EXTRACT-OPTIONS TREE NULL)
      (CONS SYM-WALK-STELLA-NULL NIL))))
   (CL:RETURN-FROM YIELD-MIXIN-METHOD-TREE
    (LIST* SYM-WALK-STELLA-DEFMETHOD (%%VALUE (%%REST TREE))
     (CONS PARAMETERS
      (LIST* KWD-WALK-AUXILIARY? SYM-WALK-STELLA-TRUE KWD-WALK-PUBLIC?
       (CL:IF (%METHOD-SLOT.SLOT-PUBLIC? METHOD) SYM-WALK-STELLA-TRUE
        SYM-WALK-STELLA-FALSE)
       (CONCATENATE BODY NIL)))))))

;;; (DEFUN CREATE-MIXIN-METHOD-UNITS ...)

(CL:DEFUN CREATE-MIXIN-METHOD-UNITS (CLASS)
  (CL:COND
   ((CL:AND (%CLASS.MIXIN? CLASS)
     (CL:OR (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?))
      (CL:NOT
       (CL:EQ *MIXIN-IMPLEMENTATION-STYLE* KWD-WALK-SECOND-CLASS))))
    (CL:LET*
     ((SLOT NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SLOT (%%VALUE ITER-000))
      (CL:WHEN (METHOD-SLOT? SLOT)
       (REGISTER-AUXILIARY-METHOD
        (%TRANSLATION-UNIT.THE-OBJECT
         (HELP-WALK-AUXILIARY-TREE
          (YIELD-MIXIN-METHOD-TREE SLOT
           (%SURROGATE.SURROGATE-VALUE SGT-WALK-STELLA-OBJECT))
          CL:T))
        SLOT))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:T
    (CL:LET* ((MIXINMETHODS (NEW-LIST)) (SUPERMETHODS (NEW-LIST)))
     (CL:LET*
      ((SUPER NULL)
       (ITER-001
        (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SUPER (%%VALUE ITER-001))
       (CL:WHEN (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER))
        (CL:LET*
         ((SLOT NULL)
          (ITER-002 (CLASS-SLOTS (%SURROGATE.SURROGATE-VALUE SUPER))))
         (CL:LOOP WHILE (NEXT? ITER-002) DO
          (CL:SETQ SLOT (%ITERATOR.VALUE ITER-002))
          (CL:WHEN
           (CL:AND (METHOD-SLOT? SLOT)
            (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
           (CL:WHEN
            (CL:NOT (CL:EQ (%SLOT.SLOT-DIRECT-EQUIVALENT SLOT) NULL))
            (INSERT-NEW SUPERMETHODS
             (%SLOT.SLOT-DIRECT-EQUIVALENT SLOT)))
           (CL:WHEN (CL:NOT (MEMBER? SUPERMETHODS SLOT))
            (INSERT-NEW MIXINMETHODS SLOT))))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:LET*
      ((METHOD NULL)
       (ITER-003 (%LIST.THE-CONS-LIST (REVERSE MIXINMETHODS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ METHOD (%%VALUE ITER-003))
       (REGISTER-AUXILIARY-METHOD
        (%TRANSLATION-UNIT.THE-OBJECT
         (HELP-WALK-AUXILIARY-TREE
          (YIELD-MIXIN-METHOD-TREE METHOD CLASS) CL:T))
        METHOD)
       (CL:SETQ ITER-003 (%%REST ITER-003)))))))
  :VOID)

;;; (DEFUN CREATE-DEFPRINT-UNIT ...)

(CL:DEFUN CREATE-DEFPRINT-UNIT (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
      SYM-WALK-STELLA-PRINT-FORM NULL)
     NULL))
   (WALK-AUXILIARY-TREE
    (LIST* SYM-WALK-STELLA-DEFMETHOD SYM-WALK-STELLA-PRINT-OBJECT
     (LIST* (LIST* SYM-WALK-STELLA-SELF (%CLASS.CLASS-TYPE CLASS) NIL)
      (LIST* SYM-WALK-STELLA-STREAM
       SYM-WALK-STELLA-NATIVE-OUTPUT-STREAM NIL)
      NIL)
     KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE
     (COPY-CONS-TREE
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-WALK-STELLA-PRINT-FORM NULL))
     NIL))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((SUPER NULL) (ITER-000 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ SUPER (%%VALUE ITER-000))
        (CL:WHEN
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SUPER)
            SYM-WALK-STELLA-PRINT-FORM NULL)
           NULL))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))
     (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
    (CL:WHEN TEST-VALUE-000
     (PUSH-VARIABLE-BINDING SYM-WALK-STELLA-SELF
      (%CLASS.CLASS-TYPE CLASS))
     (PUSH-VARIABLE-BINDING SYM-WALK-STELLA-STREAM
      SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM)
     (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
      (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) CLASS)
      (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
       SYM-WALK-STELLA-PRINT-METHOD)
      (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
      (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF-000)
       (WALK-A-TREE
        (LIST* SYM-WALK-STELLA-IF
         (LIST* SYM-WALK-STELLA-NULL? SYM-WALK-STELLA-SELF NIL)
         (LIST* SYM-WALK-STELLA-PRINT-NATIVE-STREAM
          SYM-WALK-STELLA-STREAM (WRAP-STRING "!NULL!") NIL)
         (LIST* SYM-WALK-STELLA-PRINT-OBJECT SYM-WALK-STELLA-SELF
          SYM-WALK-STELLA-STREAM NIL)
         NIL)))
      (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? SELF-000) CL:T)
      (PUSH *TRANSLATIONUNITS* SELF-000))
     (POP-VARIABLE-BINDING) (POP-VARIABLE-BINDING)))
   (CL:LET* ((TEST-VALUE-001 CL:NIL))
    (CL:SETQ TEST-VALUE-001
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA))
    (CL:WHEN TEST-VALUE-001
     (CL:LET* ((FOUND?-001 CL:NIL))
      (CL:LET*
       ((SUPER NULL) (ITER-001 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ SUPER (%%VALUE ITER-001))
        (CL:WHEN
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS SUPER)
            SYM-WALK-STELLA-PRINT-FORM NULL)
           NULL))
         (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:SETQ TEST-VALUE-001 FOUND?-001))
     (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001)))
    (CL:WHEN TEST-VALUE-001
     (CL:LET* ((*METHODBEINGWALKED* (NEW-METHOD-SLOT)))
      (CL:DECLARE (CL:SPECIAL *METHODBEINGWALKED*))
      (CL:SETF
       (%METHOD-SLOT.METHOD-RETURN-TYPE-SPECIFIERS *METHODBEINGWALKED*)
       (LIST SGT-WALK-STELLA-STRING))
      (PUSH-VARIABLE-BINDING SYM-WALK-STELLA-SELF
       (%CLASS.CLASS-TYPE CLASS))
      (CL:LET* ((SELF-002 (NEW-TRANSLATION-UNIT)))
       (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-002) CLASS)
       (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-002)
        SYM-WALK-STELLA-PRINT-METHOD)
       (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-002) *MODULE*)
       (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF-002)
        (WALK-A-TREE
         (LIST* SYM-WALK-STELLA-IF
          (LIST* SYM-WALK-STELLA-NULL? SYM-WALK-STELLA-SELF NIL)
          (LIST* SYM-WALK-STELLA-RETURN (WRAP-STRING "!NULL!") NIL)
          (LIST* SYM-WALK-STELLA-RETURN
           (LIST* SYM-WALK-STELLA-VERBATIM KWD-WALK-JAVA
            (WRAP-STRING
             "#$(STELLAROOT).javalib.Native.stringify_via_print(self)")
            NIL)
           NIL)
          NIL)))
       (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? SELF-002) CL:T)
       (PUSH *TRANSLATIONUNITS* SELF-002))
      (POP-VARIABLE-BINDING)))))
  :VOID)

;;; (DEFUN WALK-CLASS-UNIT ...)

(CL:DEFUN WALK-CLASS-UNIT (UNIT)
  (CL:LET*
   ((CLASS (%TRANSLATION-UNIT.THE-OBJECT UNIT)) (STARTUPTIMECODE NULL))
   (CL:WHEN (CL:NOT (%CLASS.CLASS-FINALIZED? CLASS))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Cannot translate class `" (CLASS-SYMBOL CLASS)
       "', since it could not be finalized." EOL)))
    (CLEAR-TRANSLATION-UNIT UNIT) (CL:RETURN-FROM WALK-CLASS-UNIT))
   (CL:WHEN (CREATE-NATIVE-CLASS? CLASS)
    (WARN-ABOUT-MULTIPLE-PARENTS CLASS)
    (WARN-ABOUT-NON-DIRECT-SUPERS CLASS)
    (CLEANUP-AUXILIARY-METHODS CLASS)
    (CL:WHEN
     (CL:NOT
      (CL:AND (%CLASS.MIXIN? CLASS)
       (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)))
     (PUSH *TRANSLATIONUNITS* UNIT)
     (CREATE-CONSTRUCTOR-AND-DESTRUCTOR-UNITS CLASS)
     (CREATE-INLINE-METHOD-UNITS CLASS))
    (CREATE-SLOT-ACCESSOR-UNITS CLASS)
    (CL:WHEN (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)
     (CREATE-MIXIN-METHOD-UNITS CLASS))
    (CL:LET*
     ((SLOT NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SLOT (%%VALUE ITER-000))
      (CL:WHEN
       (CL:AND (STORAGE-SLOT? SLOT) (NATIVE-SLOT? SLOT)
        (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS)
        (CL:NOT (CL:EQ (HOME-MODULE CLASS) (HOME-MODULE SLOT)))
        (SLOT-NAME-CONFLICT? SLOT CLASS))
       (CL:COND
        ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-COMMON-LISP)
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-WARNING)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
            " Defining slot `" (DE-UGLIFY-PARSE-TREE SLOT)
            "' outside the home module of" EOL
            "   its owner class will be illegal in C++ and Java."
            EOL))))
        (CL:T
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL " Slot `"
            (DE-UGLIFY-PARSE-TREE SLOT)
            "' is defined outside the home module of " EOL
            "   its owner class `" (DE-UGLIFY-PARSE-TREE CLASS)
            "', and the name of" EOL
            "   the slot conflicts with another slot.." EOL)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ (POP *TRANSLATIONUNITS*) UNIT)))
         (CLEAR-TRANSLATION-UNIT UNIT)
         (CL:RETURN-FROM WALK-CLASS-UNIT))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CREATE-DEFPRINT-UNIT CLASS)
   (CL:SETQ STARTUPTIMECODE
    (CONCATENATE (YIELD-INITIALIZE-HARDWIRED-SLOTS CLASS)
     (CONCATENATE
      (YIELD-CONSTRUCTOR-ATTACHMENT CLASS SYM-WALK-STELLA-CLASS)
      (CONCATENATE
       (YIELD-GENERIC-SLOT-ACCESSOR-ATTACHMENT CLASS
        SYM-WALK-STELLA-CLASS)
       NIL))))
   (WALK-AUXILIARY-TREE
    (CL:IF (CL:EQ STARTUPTIMECODE NIL)
     (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-CLASSES
      (YIELD-DEFINE-STELLA-CLASS CLASS) NIL)
     (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-CLASSES
      (LIST* SYM-WALK-STELLA-LET
       (CONS
        (LIST* SYM-WALK-STELLA-CLASS (YIELD-DEFINE-STELLA-CLASS CLASS)
         NIL)
        NIL)
       (CONCATENATE STARTUPTIMECODE NIL))
      NIL)))
   (CL:LET*
    ((SYNONYM NULL)
     (ITER-001 (%LIST.THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ SYNONYM (%%VALUE ITER-001))
     (REGISTER-SYMBOL
      (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME SYNONYM)
       (%SURROGATE.HOME-CONTEXT SYNONYM) CL:T))
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  :VOID)

;;; (DEFUN CREATE-FINALIZATION-UNITS ...)

(CL:DEFUN CREATE-FINALIZATION-UNITS ()
  (WALK-AUXILIARY-TREE
   (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-FINALIZE-CLASSES
    (CONS SYM-WALK-STELLA-FINALIZE-CLASSES NIL) NIL))
  (WALK-AUXILIARY-TREE
   (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-FINALIZE-METHODS
    (CONS SYM-WALK-STELLA-FINALIZE-SLOTS NIL)
    (CONS SYM-WALK-STELLA-CLEANUP-UNFINALIZED-CLASSES NIL) NIL))
  :VOID)

;;; (DEFUN WALK-DEFSLOT-TREE ...)

(CL:DEFUN WALK-DEFSLOT-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000) SYM-WALK-STELLA-SLOT)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) TREE)
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  (CL:LET* ((SLOT NULL))
   (CL:SETQ SLOT (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE TREE))
   (CL:WHEN (CL:EQ SLOT NULL)
    (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
    (CL:RETURN-FROM WALK-DEFSLOT-TREE))
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    SLOT)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    TREE))
  :VOID)

;;; (DEFUN WALK-SLOT-UNIT ...)

(CL:DEFUN WALK-SLOT-UNIT (UNIT)
  (CL:LET*
   ((SLOT (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (OWNERCLASS
     (%SURROGATE.SURROGATE-VALUE (%STORAGE-SLOT.SLOT-OWNER SLOT)))
    (STRINGIFIEDDEFINITION
     (STRINGIFY (%TRANSLATION-UNIT.CODE-REGISTER UNIT))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDDEFINITION))
   (CREATE-ACCESSOR-UNITS-FOR-SLOT SLOT OWNERCLASS CL:NIL CL:NIL)
   (CLEAR-TRANSLATION-UNIT UNIT)
   (WALK-AUXILIARY-TREE
    (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-METHODS
     (LIST*
      SYM-WALK-STELLA-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
      (WRAP-STRING STRINGIFIEDDEFINITION) NIL)
     NIL)))
  :VOID)

;;; (DEFUN (LOOKUP-MACRO METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-MACRO (NAME)
  "If `name' has a macro definition, return the method object
holding its expander function."
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
       SYM-WALK-STELLA-METHOD-MACRO? FALSE-WRAPPER)))
    (CL:RETURN-FROM LOOKUP-MACRO FUNCTION))
   (CL:RETURN-FROM LOOKUP-MACRO NULL)))

;;; (DEFUN WALK-DEFMACRO-TREE ...)

(CL:DEFUN WALK-DEFMACRO-TREE (TREE)
  (CL:LET* ((NAME (%%VALUE (%%REST TREE))))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
     (EXTRACT-OPTIONS TREE NULL))
    (CL:LET* ((OPTIONS SELF-000) (METHOD NULL))
     (CL:WHEN (CONS? NAME)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Macro `" (%%VALUE NAME)
         "' contains return type specification." EOL)))
      (CL:RETURN-FROM WALK-DEFMACRO-TREE))
     (CL:WHEN (CL:NOT (SYMBOL? NAME))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal macro name: `" (DE-UGLIFY-PARSE-TREE NAME) "'."
         EOL)))
      (CL:RETURN-FROM WALK-DEFMACRO-TREE))
     (FIRST-SETTER TREE SYM-WALK-STELLA-DEFUN)
     (INSERT-AT OPTIONS KWD-WALK-MACRO? SYM-WALK-STELLA-TRUE)
     (INSERT-AT OPTIONS KWD-WALK-TYPE SYM-WALK-STELLA-OBJECT)
     (CL:SETF (%%REST (%%REST (%%REST TREE)))
      (CONCATENATE (%PROPERTY-LIST.THE-PLIST OPTIONS)
       (%%REST (%%REST (%%REST TREE)))))
     (WALK-DEFMETHOD-TREE TREE)
     (CL:WHEN (CL:NOT (CL:EQ *CURRENTTRANSLATIONUNIT* NULL))
      (CL:SETQ METHOD
       (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*))
      (CL:WHEN (CL:> (METHOD-ARGUMENT-COUNT METHOD) 5)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Too many arguments in macro definition, maximum is 5."
          EOL)))
       (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL))))))
  :VOID)

;;; (DEFUN WALK-DEFGLOBAL-TREE ...)

(CL:DEFUN WALK-DEFGLOBAL-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
    SYM-WALK-STELLA-GLOBAL-VARIABLE)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) TREE)
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  (CL:WHEN (CL:< (LENGTH TREE) 3) (BAD-ARGUMENT-COUNT? TREE 3)
   (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
   (CL:RETURN-FROM WALK-DEFGLOBAL-TREE))
  (CL:LET* ((GLOBAL NULL) (INITIALVALUETREE NULL))
   (CL:MULTIPLE-VALUE-SETQ (GLOBAL INITIALVALUETREE)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE TREE
     (STRINGIFY TREE)))
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    GLOBAL)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    INITIALVALUETREE)
   (CL:SETF (%TRANSLATION-UNIT.AUXILIARY? *CURRENTTRANSLATIONUNIT*)
    (%GLOBAL-VARIABLE.VARIABLE-AUXILIARY? GLOBAL)))
  :VOID)

;;; (DEFUN WALK-GLOBAL-UNIT ...)

(CL:DEFUN WALK-GLOBAL-UNIT (UNIT)
  (CL:LET*
   ((GLOBAL (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (INITIALVALUETREE (%TRANSLATION-UNIT.CODE-REGISTER UNIT))
    (STRINGIFIEDSOURCE
     (%GLOBAL-VARIABLE.VARIABLE-STRINGIFIED-SOURCE GLOBAL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (CL:WHEN
    (CL:NOT (CL:EQ INITIALVALUETREE KWD-WALK-UNBOUND-SPECIAL-VARIABLE))
    (CL:COND
     ((CL:AND (%GLOBAL-VARIABLE.VARIABLE-SPECIAL? GLOBAL)
       (CL:OR (TRANSLATE-TO-JAVA?) (SUPPORT-UNEXEC?)))
      (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-CONSTANT? GLOBAL) CL:NIL)
      (WALK-AUXILIARY-TREE
       (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-GLOBALS
        (LIST* SYM-WALK-STELLA-SYS-SET-DEFAULT
         (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL)
         (CONS INITIALVALUETREE NIL))
        NIL))
      (CL:SETQ INITIALVALUETREE KWD-WALK-UNBOUND-SPECIAL-VARIABLE))
     ((CL:OR (WRAPPER? INITIALVALUETREE)
       (CL:AND (SYMBOL? INITIALVALUETREE)
        (CONSTANT-SYMBOL? INITIALVALUETREE)
        (CL:OR (CL:NOT (CL:EQ INITIALVALUETREE SYM-WALK-STELLA-NULL))
         (CL:EQ
          (TYPE-TO-NULL-VALUE-TREE
           (%GLOBAL-VARIABLE.VARIABLE-TYPE GLOBAL))
          SYM-WALK-STELLA-NULL)))
       (CL:AND (CONS? INITIALVALUETREE)
        (CL:EQ (%%VALUE INITIALVALUETREE) SYM-WALK-STELLA-VERBATIM)))
      (CL:SETQ INITIALVALUETREE
       (WALK-EXPRESSION-TREE INITIALVALUETREE
        (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL)
        (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL) CL:T)))
     (CL:T
      (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-CONSTANT? GLOBAL) CL:NIL)
      (WALK-AUXILIARY-TREE
       (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-GLOBALS
        (LIST* SYM-WALK-STELLA-SETQ
         (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL)
         (CONS INITIALVALUETREE NIL))
        NIL))
      (CL:IF (SUPPORT-UNEXEC?)
       (CL:SETQ INITIALVALUETREE KWD-WALK-UNBOUND-SPECIAL-VARIABLE)
       (CL:SETQ INITIALVALUETREE
        (TYPE-TO-WALKED-NULL-VALUE-TREE
         (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL)
         (TYPE-SPEC-TO-BASE-TYPE
          (%GLOBAL-VARIABLE.VARIABLE-TYPE GLOBAL))))))))
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER UNIT) INITIALVALUETREE)
   (CL:WHEN (CL:NOT (%TRANSLATION-UNIT.AUXILIARY? UNIT))
    (WALK-AUXILIARY-TREE
     (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN
      (LIST* SYM-WALK-STELLA-DEFINE-GLOBAL-VARIABLE-OBJECT
       (WRAP-STRING STRINGIFIEDSOURCE)
       (CONS
        (CL:IF (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
         (LIST* SYM-WALK-STELLA-VERBATIM KWD-WALK-CPP
          (CPP-TRANSLATE-GLOBAL-VARIABLE-ADDRESS GLOBAL) NIL)
         SYM-WALK-STELLA-NULL)
        NIL))
      NIL))))
  :VOID)

;;; (DEFUN WALK-DEFTYPE-TREE ...)

(CL:DEFUN WALK-DEFTYPE-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000) SYM-WALK-STELLA-TYPE)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) TREE)
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  (CL:WHEN (CL:< (LENGTH TREE) 3) (BAD-ARGUMENT-COUNT? TREE 3)
   (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
   (CL:RETURN-FROM WALK-DEFTYPE-TREE))
  (CL:LET* ((TYPE NULL))
   (CL:SETQ TYPE (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TREE))
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    TYPE)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER *CURRENTTRANSLATIONUNIT*)
    TREE))
  :VOID)

;;; (DEFUN WALK-TYPE-UNIT ...)

(CL:DEFUN WALK-TYPE-UNIT (UNIT)
  (CL:LET*
   ((STRINGIFIEDDEFINITION
     (STRINGIFY (%TRANSLATION-UNIT.CODE-REGISTER UNIT))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDDEFINITION))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (WALK-AUXILIARY-TREE
    (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-CLASSES
     (LIST* SYM-WALK-STELLA-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
      (WRAP-STRING STRINGIFIEDDEFINITION) NIL)
     NIL))
   (REGISTER-SYMBOL
    (INTERN-SYMBOL-IN-MODULE
     (%SURROGATE.SYMBOL-NAME (%TRANSLATION-UNIT.THE-OBJECT UNIT))
     (%SURROGATE.HOME-CONTEXT (%TRANSLATION-UNIT.THE-OBJECT UNIT))
     CL:T)))
  :VOID)

;;; (DEFUN WALK-STARTUP-TIME-PROGN-TREE ...)

(CL:DEFUN WALK-STARTUP-TIME-PROGN-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
    SYM-WALK-STELLA-STARTUP-TIME-PROGN)
   (CL:SETF (%TRANSLATION-UNIT.TU-HOME-MODULE SELF-000) *MODULE*)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF-000) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  :VOID)

;;; (DEFUN (EXTRACT-STARTUP-TIME-PHASE KEYWORD) ...)

(CL:DEFUN EXTRACT-STARTUP-TIME-PHASE (TREE)
  (CL:LET*
   ((STARTUPTIMEPHASE KWD-WALK-FINAL) (STARTUPTIMEPHASETREE NULL))
   (CL:WHEN
    (CL:AND (CL:>= (LENGTH TREE) 2) (KEYWORD? (%%VALUE (%%REST TREE)))
     (MEMBER? *STARTUP-TIME-PHASES* (%%VALUE (%%REST TREE))))
    (CL:SETQ STARTUPTIMEPHASE (%%VALUE (%%REST TREE)))
    (CL:SETQ STARTUPTIMEPHASETREE (%%REST TREE))
    (CL:SETF (%%REST TREE) (%%REST (%%REST TREE)))
    (CL:SETF (%%REST STARTUPTIMEPHASETREE) NIL))
   (CL:RETURN-FROM EXTRACT-STARTUP-TIME-PHASE STARTUPTIMEPHASE)))

;;; (DEFUN WALK-STARTUP-TIME-PROGN-UNIT ...)

(CL:DEFUN WALK-STARTUP-TIME-PROGN-UNIT (UNIT)
  (CL:LET*
   ((TREE (%TRANSLATION-UNIT.CODE-REGISTER UNIT))
    (PHASE (EXTRACT-STARTUP-TIME-PHASE TREE)))
   (PUSH *TRANSLATIONUNITS* UNIT)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT UNIT)
    (WALK-LIST-OF-STATEMENTS (%%REST TREE)))
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER UNIT) PHASE))
  :VOID)

;;; (DEFGLOBAL *MAX-NUMBER-OF-STARTUP-UNITS* ...)

(CL:DEFVAR *MAX-NUMBER-OF-STARTUP-UNITS* 60
  "The maximum number of startup units that can be combined
into a single startup function (this avoids the construction of huge startup
functions that would cause too much stress for some wimpy compilers).")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-NUMBER-OF-STARTUP-UNITS*))

;;; (DEFUN (EARLIER-STARTUP-UNIT? BOOLEAN) ...)

(CL:DEFUN EARLIER-STARTUP-UNIT? (UNIT1 UNIT2)
  (CL:RETURN-FROM EARLIER-STARTUP-UNIT?
   (<
    (ENCODE-STARTUP-TIME-PHASE (%TRANSLATION-UNIT.CODE-REGISTER UNIT1))
    (ENCODE-STARTUP-TIME-PHASE
     (%TRANSLATION-UNIT.CODE-REGISTER UNIT2)))))

;;; (DEFUN (COMBINE-STARTUP-FUNCTION-UNITS CONS) ...)

(CL:DEFUN COMBINE-STARTUP-FUNCTION-UNITS (STARTUPFNNAME)
  (CL:LET*
   ((EARLYSTARTUPTREES NIL) (STARTUPTREES NIL) (STARTUPPHASETREES NIL)
    (STARTUPUNITS (NEW-LIST)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR *TRANSLATIONUNITS*)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:WHEN
      (CL:EQ (%TRANSLATION-UNIT.CATEGORY (%LIST-ITERATOR.VALUE IT))
       SYM-WALK-STELLA-STARTUP-TIME-PROGN)
      (PUSH STARTUPUNITS (%LIST-ITERATOR.VALUE IT))
      (VALUE-SETTER IT NULL))))
   (REMOVE *TRANSLATIONUNITS* NULL)
   (SORT STARTUPUNITS (CL:FUNCTION EARLIER-STARTUP-UNIT?))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ STARTUPFNNAME NULL))
     (CL:> (LENGTH STARTUPUNITS) *MAX-NUMBER-OF-STARTUP-UNITS*))
    (EXTRACT-STARTUP-FUNCTION-UNITS STARTUPUNITS STARTUPFNNAME))
   (CL:LET*
    ((PHASE NULL)
     (ITER-000 (%LIST.THE-CONS-LIST *STARTUP-TIME-PHASES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PHASE (%%VALUE ITER-000))
     (CL:LOOP WHILE
      (CL:AND (NON-EMPTY? STARTUPUNITS)
       (CL:EQ (%TRANSLATION-UNIT.CODE-REGISTER (FIRST STARTUPUNITS))
        PHASE))
      DO
      (CL:SETQ STARTUPPHASETREES
       (CONCATENATE STARTUPPHASETREES
        (%TRANSLATION-UNIT.THE-OBJECT (FIRST STARTUPUNITS))))
      (CLEAR-TRANSLATION-UNIT (POP STARTUPUNITS)))
     (CL:WHEN (CL:NOT (CL:EQ STARTUPPHASETREES NIL))
      (CL:SETQ STARTUPPHASETREES
       (LIST* SYM-WALK-STELLA-VOID-SYS
        (LIST* SYM-WALK-STELLA-WHEN
         (LIST* SYM-WALK-STELLA-SYS-CALL-FUNCTION
          SYM-WALK-STELLA-CURRENT-STARTUP-TIME-PHASE?
          (WRAP-INTEGER (ENCODE-STARTUP-TIME-PHASE PHASE)) NIL)
         (CONCATENATE STARTUPPHASETREES NIL))
        NIL))
      (CL:IF
       (CL:<= (ENCODE-STARTUP-TIME-PHASE PHASE)
        (ENCODE-STARTUP-TIME-PHASE KWD-WALK-MODULES))
       (CL:SETQ EARLYSTARTUPTREES
        (CONS STARTUPPHASETREES EARLYSTARTUPTREES))
       (CL:SETQ STARTUPTREES (CONS STARTUPPHASETREES STARTUPTREES)))
      (CL:SETQ STARTUPPHASETREES NIL))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT (CL:EQ STARTUPTREES NIL))
    (CL:SETQ STARTUPTREES
     (CONS
      (LIST* SYM-WALK-STELLA-WITHIN-MODULE
       (CL:IF (CL:EQ *MODULE* *STELLA-MODULE*)
        SYM-WALK-STELLA-*STELLA-MODULE*
        (LIST* SYM-WALK-STELLA-GET-STELLA-MODULE
         (WRAP-STRING (%MODULE.MODULE-FULL-NAME *MODULE*))
         (CONS
          (LIST* SYM-WALK-STELLA-> SYM-WALK-STELLA-*STARTUP-TIME-PHASE*
           (WRAP-INTEGER (ENCODE-STARTUP-TIME-PHASE KWD-WALK-MODULES))
           NIL)
          NIL)))
       (CONCATENATE (REVERSE STARTUPTREES) NIL))
      NIL)))
   (CL:WHEN
    (CL:OR (CL:NOT (CL:EQ EARLYSTARTUPTREES NIL))
     (CL:NOT (CL:EQ STARTUPTREES NIL)))
    (CL:SETQ STARTUPTREES
     (CONCATENATE (REVERSE EARLYSTARTUPTREES) STARTUPTREES)))
   (CL:RETURN-FROM COMBINE-STARTUP-FUNCTION-UNITS STARTUPTREES)))

;;; (DEFMETHOD (METHOD-STARTUP-FUNCTION? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-STARTUP-FUNCTION? ((METHOD METHOD-SLOT))
  (CL:RETURN-FROM METHOD-STARTUP-FUNCTION?
   (CL:NOT
    (CL:EQ
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME NULL-STRING-WRAPPER))
     STELLA::NULL-STRING))))

;;; (DEFUN EXTRACT-STARTUP-FUNCTION-UNITS ...)

(CL:DEFUN EXTRACT-STARTUP-FUNCTION-UNITS (STARTUPUNITS STARTUPFNNAME)
  (CL:LET*
   ((REMAININGUNITS (LENGTH STARTUPUNITS))
    (MINUNITSPERFUNCTION
     (FLOOR
      (CL:1+
       (CL:/ (CL:FLOAT *MAX-NUMBER-OF-STARTUP-UNITS* 0.0d0)
        (LENGTH *STARTUP-TIME-PHASES*)))))
    (CURSOR (%LIST.THE-CONS-LIST STARTUPUNITS)) (PHASESTART CURSOR)
    (PHASEUNITS 0)
    (PHASE (%TRANSLATION-UNIT.CODE-REGISTER (%%VALUE CURSOR)))
    (UNITPHASE PHASE) (HELPFNCOUNTER 0))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM REMAININGUNITS MINUNITSPERFUNCTION PHASEUNITS
     HELPFNCOUNTER))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:TAGBODY
     (CL:SETQ UNITPHASE
      (%TRANSLATION-UNIT.CODE-REGISTER (%%VALUE CURSOR)))
     (CL:WHEN (CL:EQ UNITPHASE PHASE)
      (CL:SETQ PHASEUNITS (CL:1+ PHASEUNITS))
      (CL:WHEN (CL:< PHASEUNITS *MAX-NUMBER-OF-STARTUP-UNITS*)
       (CL:SETQ CURSOR (%%REST CURSOR)) (CL:GO :CONTINUE)))
     (CL:WHEN (CL:< PHASEUNITS MINUNITSPERFUNCTION)
      (CL:SETQ PHASESTART CURSOR) (CL:SETQ PHASEUNITS 0)
      (CL:SETQ PHASE UNITPHASE) (CL:GO :CONTINUE))
     (CL:LET*
      ((FUNCTIONNAME
        (INTERN-DERIVED-SYMBOL STARTUPFNNAME
         (CONCATENATE "HELP-"
          (CONCATENATE (%SYMBOL.SYMBOL-NAME STARTUPFNNAME)
           (INTEGER-TO-STRING
            (CL:TRUNCATE
             (CL:SETQ HELPFNCOUNTER (CL:1+ HELPFNCOUNTER))))))))
       (HELPFNTREE
        (%TRANSLATION-UNIT.THE-OBJECT (%%VALUE PHASESTART))))
      (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT (%%VALUE PHASESTART))
       (CONS (LIST* SYM-WALK-STELLA-SYS-CALL-FUNCTION FUNCTIONNAME NIL)
        NIL))
      (CL:SETQ PHASESTART (%%REST PHASESTART))
      (CL:LET*
       ((IT (ALLOCATE-ITERATOR PHASESTART)) (I NULL-INTEGER)
        (ITER-000 2) (UPPER-BOUND-000 PHASEUNITS)
        (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:AND (NEXT? IT)
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)))
        DO (CL:SETQ I ITER-000) (CL:SETQ I I)
        (CL:SETQ HELPFNTREE
         (CONCATENATE HELPFNTREE
          (%TRANSLATION-UNIT.THE-OBJECT (%CONS-ITERATOR.VALUE IT))))
        (CLEAR-TRANSLATION-UNIT (%CONS-ITERATOR.VALUE IT))
        (VALUE-SETTER IT NULL) (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:SETQ HELPFNTREE
       (LIST* SYM-WALK-STELLA-DEFUN FUNCTIONNAME
        (LIST* NIL KWD-WALK-PUBLIC? SYM-WALK-STELLA-FALSE
         (LIST* SYM-WALK-STELLA-VOID-SYS
          (CONS SYM-WALK-STELLA-PROGN (CONCATENATE HELPFNTREE NIL))
          NIL)
         NIL)))
      (SET-DYNAMIC-SLOT-VALUE
       (%METHOD-SLOT.DYNAMIC-SLOTS
        (%TRANSLATION-UNIT.THE-OBJECT
         (HELP-WALK-AUXILIARY-TREE HELPFNTREE CL:T)))
       SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
       (WRAP-STRING (YIELD-STARTUP-FUNCTION-CLASSNAME STARTUPFNNAME))
       NULL-STRING-WRAPPER)
      (CL:SETQ REMAININGUNITS (CL:- REMAININGUNITS (CL:1- PHASEUNITS)))
      (CL:WHEN (CL:<= REMAININGUNITS *MAX-NUMBER-OF-STARTUP-UNITS*)
       (CL:RETURN))
      (CL:WHEN (CL:EQ UNITPHASE PHASE)
       (CL:SETQ CURSOR (%%REST CURSOR)))
      (CL:SETQ PHASESTART CURSOR) (CL:SETQ PHASEUNITS 0)
      (CL:SETQ PHASE
       (%TRANSLATION-UNIT.CODE-REGISTER (%%VALUE CURSOR))))
     :CONTINUE))
   (REMOVE STARTUPUNITS NULL))
  :VOID)

;;; (DEFUN (YIELD-STARTUP-FUNCTION-NAME SYMBOL) ...)

(CL:DEFUN YIELD-STARTUP-FUNCTION-NAME (FILE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:SETQ FILE
   (CL:IF (CL:EQ FILE STELLA::NULL-STRING) *CURRENTFILENAME* FILE))
  (CL:IF (SYSTEM-STARTUP-FILE? FILE)
   (CL:RETURN-FROM YIELD-STARTUP-FUNCTION-NAME
    (SYSTEM-STARTUP-FUNCTION-SYMBOL *CURRENTSYSTEMDEFINITION*))
   (CL:RETURN-FROM YIELD-STARTUP-FUNCTION-NAME
    (INTERN-SYMBOL-IN-MODULE
     (CONCATENATE "STARTUP-" (STRING-UPCASE (FILE-BASE-NAME FILE)))
     *MODULE* CL:T))))

;;; (DEFUN (YIELD-STARTUP-FUNCTION-CLASSNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  YIELD-STARTUP-FUNCTION-CLASSNAME))
(CL:DEFUN YIELD-STARTUP-FUNCTION-CLASSNAME (FUNCTION-NAME)
  (CL:LET*
   ((BASE-NAME
     (JAVA-TRANSLATE-CLASS-NAMESTRING
      (WRAP-STRING (%SYMBOL.SYMBOL-NAME FUNCTION-NAME)))))
   (CL:IF (SYSTEM-STARTUP-FILE? *CURRENTFILENAME*)
    (CL:RETURN-FROM YIELD-STARTUP-FUNCTION-CLASSNAME
     (%STRING-WRAPPER.WRAPPER-VALUE BASE-NAME))
    (CL:RETURN-FROM YIELD-STARTUP-FUNCTION-CLASSNAME
     (CONCATENATE "_" (%STRING-WRAPPER.WRAPPER-VALUE BASE-NAME))))))

;;; (DEFUN CREATE-STARTUP-FUNCTION-UNITS ...)

(CL:DEFUN CREATE-STARTUP-FUNCTION-UNITS ()
  (CL:LET*
   ((STARTUPFNNAME
     (CL:IF (INCREMENTAL-TRANSLATION?) NULL
      (YIELD-STARTUP-FUNCTION-NAME *CURRENTFILENAME*)))
    (SYSTEMSTARTUP? (SYSTEM-STARTUP-FILE? *CURRENTFILENAME*))
    (OPTIONS
     (CL:IF SYSTEMSTARTUP?
      (LIST* KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE KWD-WALK-C-CALLABLE?
       SYM-WALK-STELLA-TRUE KWD-WALK-C-NAMESPACE-PREFIX
       (WRAP-STRING "stella_") NIL)
      (LIST* KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE NIL)))
    (TREE NULL) (METHOD NULL))
   (CL:COND
    ((DONT-GENERATE-STARTUP-CODE?)
     (REMOVE-ALL-STARTUP-TIME-PROGN-UNITS))
    ((CL:NOT (CL:EQ STARTUPFNNAME NULL))
     (CL:SETQ TREE
      (LIST* SYM-WALK-STELLA-DEFUN STARTUPFNNAME
       (CONS NIL
        (CONCATENATE OPTIONS (CONS SYM-WALK-STELLA-NULL NIL)))))
     (CL:SETQ METHOD (DEFINE-METHOD-FROM-PARSE-TREE TREE))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-FORWARD-DECLARATION? FALSE-WRAPPER FALSE-WRAPPER)
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING (YIELD-STARTUP-FUNCTION-CLASSNAME STARTUPFNNAME))
      NULL-STRING-WRAPPER)
     (CL:SETQ TREE
      (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-METHODS
       (YIELD-DEFINE-STELLA-METHOD-OBJECT METHOD METHOD NULL)
       (CONS
        (LIST* SYM-WALK-STELLA-LET
         (CONS
          (LIST* SYM-WALK-STELLA-FUNCTION
           (LIST* SYM-WALK-STELLA-LOOKUP-FUNCTION
            (LIST* SYM-WALK-STELLA-QUOTE STARTUPFNNAME NIL) NIL)
           NIL)
          NIL)
         (LIST* SYM-WALK-STELLA-SETF
          (LIST* SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
           SYM-WALK-STELLA-FUNCTION NIL)
          (WRAP-STRING
           (%STRING-WRAPPER.WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
             NULL-STRING-WRAPPER)))
          NIL)
         NIL)
        NIL)))
     (WALK-AUXILIARY-TREE TREE)
     (CL:IF SYSTEMSTARTUP?
      (CL:SETQ TREE
       (LIST* SYM-WALK-STELLA-DEFUN STARTUPFNNAME
        (LIST* NIL KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE
         KWD-WALK-AUXILIARY? SYM-WALK-STELLA-TRUE
         (LIST* SYM-WALK-STELLA-WITH-PROCESS-LOCK
          SYM-WALK-STELLA-*BOOTSTRAP-LOCK*
          (CONCATENATE (COMBINE-STARTUP-FUNCTION-UNITS STARTUPFNNAME)
           NIL))
         NIL)))
      (CL:SETQ TREE
       (LIST* SYM-WALK-STELLA-DEFUN STARTUPFNNAME
        (LIST* NIL KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE
         KWD-WALK-AUXILIARY? SYM-WALK-STELLA-TRUE
         (CONCATENATE (COMBINE-STARTUP-FUNCTION-UNITS STARTUPFNNAME)
          NIL)))))
     (SET-DYNAMIC-SLOT-VALUE
      (%METHOD-SLOT.DYNAMIC-SLOTS
       (%TRANSLATION-UNIT.THE-OBJECT
        (HELP-WALK-AUXILIARY-TREE TREE CL:T)))
      SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING (YIELD-STARTUP-FUNCTION-CLASSNAME STARTUPFNNAME))
      NULL-STRING-WRAPPER)
     (CL:WHEN (METHOD-NEEDS-C-CALLABLE-WRAPPER? METHOD)
      (CREATE-C-CALLABLE-WRAPPER-UNIT METHOD)))
    (CL:T
     (CL:SETQ TREE
      (CONS SYM-WALK-STELLA-STARTUP-TIME-PROGN
       (CONCATENATE (COMBINE-STARTUP-FUNCTION-UNITS STARTUPFNNAME)
        NIL)))
     (WALK-AUXILIARY-TREE TREE)
     (CL:SETQ TREE
      (CONS SYM-WALK-STELLA-PROGN
       (%TRANSLATION-UNIT.THE-OBJECT (FIRST *TRANSLATIONUNITS*))))
     (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT (FIRST *TRANSLATIONUNITS*))
      TREE))))
  :VOID)

;;; (DEFUN (DONT-GENERATE-STARTUP-CODE? BOOLEAN) ...)

(CL:DEFUN DONT-GENERATE-STARTUP-CODE? ()
  (CL:RETURN-FROM DONT-GENERATE-STARTUP-CODE?
   (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE)))

;;; (DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ...)

(CL:DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ()
  (CL:LET* ((PLACEHOLDERUNIT NULL))
   (CL:LET* ((IT (ALLOCATE-ITERATOR *TRANSLATIONUNITS*)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:WHEN
      (CL:EQ (%TRANSLATION-UNIT.CATEGORY (%LIST-ITERATOR.VALUE IT))
       SYM-WALK-STELLA-STARTUP-TIME-PROGN)
      (CL:LET* ((UNIT (%LIST-ITERATOR.VALUE IT)))
       (CL:IF (CL:EQ PLACEHOLDERUNIT NULL)
        (CL:SETQ PLACEHOLDERUNIT UNIT) (CLEAR-TRANSLATION-UNIT UNIT))
       (VALUE-SETTER IT PLACEHOLDERUNIT)))))
   (REMOVE *TRANSLATIONUNITS* PLACEHOLDERUNIT)
   (CLEAR-TRANSLATION-UNIT PLACEHOLDERUNIT))
  :VOID)

;;; (DEFUN (WALK-SIGNAL-EXCEPTION-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SIGNAL-EXCEPTION-TREE (TREE)
  (CL:SETQ *FOUNDRETURN?* CL:T)
  (CL:LET* ((EXPRESSION NULL) (ITS-TYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (EXPRESSION ITS-TYPE)
    (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE))
     SGT-WALK-STELLA-STELLA-ROOT-EXCEPTION
     SYM-WALK-STELLA-SIGNAL-EXCEPTION CL:NIL))
   (CL:RETURN-FROM WALK-SIGNAL-EXCEPTION-TREE
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-SYS-SIGNAL EXPRESSION (CONS ITS-TYPE NIL))
     SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-EXCEPTION-CASE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-EXCEPTION-CASE-TREE (TREE)
  (CL:WHEN (CL:<= (LENGTH TREE) 2)
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Missing handler(s) in 'exception-case': `"
      (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
   (CL:RETURN-FROM WALK-EXCEPTION-CASE-TREE
    (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
  (CL:LET*
   ((PROTECTEDTREE (WALK-A-TREE (%%VALUE (%%REST TREE))))
    (HANDLERTREES
     (WALK-EXCEPTION-HANDLER-TREES (%%REST (%%REST TREE)))))
   (CL:WHEN
    (CL:OR (CL:EQ PROTECTEDTREE NULL) (CL:EQ HANDLERTREES NULL))
    (CL:RETURN-FROM WALK-EXCEPTION-CASE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-VOID)))
   (CL:RETURN-FROM WALK-EXCEPTION-CASE-TREE
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-SYS-HANDLER-CASE
      (WALK-A-TREE PROTECTEDTREE) (CONCATENATE HANDLERTREES NIL))
     SGT-WALK-STELLA-VOID))))

;;; (DEFUN (WALK-EXCEPTION-HANDLER-TREES CONS) ...)

(CL:DEFUN WALK-EXCEPTION-HANDLER-TREES (TREE)
  (CL:LET*
   ((CLAUSES NIL) (EXCEPTIONTYPE NULL) (EXCEPTIONVARIABLESPEC NULL)
    (EXCEPTIONVARIABLE NULL))
   (CL:LET* ((CLAUSE NULL) (ITER-000 TREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE CLAUSE) SGT-WALK-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN (CL:< (LENGTH CLAUSE) 2)
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal exception handler clause: `"
            (DE-UGLIFY-PARSE-TREE CLAUSE) "'." EOL)))
         (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL))
        (CL:SETQ EXCEPTIONTYPE (%%VALUE CLAUSE))
        (CL:WHEN (CL:NOT (SYMBOL? EXCEPTIONTYPE))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal exception type: `"
            (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE) "'." EOL)))
         (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL))
        (CL:SETQ EXCEPTIONTYPE (TYPIFY EXCEPTIONTYPE))
        (CL:WHEN (CL:EQ (TYPE-TO-CLASS EXCEPTIONTYPE) NULL)
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Undefined exception type: `"
            (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE) "'." EOL)))
         (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL))
        (CL:WHEN
         (CL:NOT
          (SUBTYPE-OF? EXCEPTIONTYPE SGT-WALK-STELLA-NATIVE-EXCEPTION))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Exception type `" (DE-UGLIFY-PARSE-TREE EXCEPTIONTYPE)
            "' is not a subtype of NATIVE-EXCEPTION." EOL)))
         (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL))
        (CL:SETQ EXCEPTIONVARIABLESPEC (%%VALUE (%%REST CLAUSE)))
        (CL:WHEN
         (CL:OR (CL:NOT (CONS? EXCEPTIONVARIABLESPEC))
          (CL:> (LENGTH EXCEPTIONVARIABLESPEC) 1)
          (CL:AND (CL:= (LENGTH EXCEPTIONVARIABLESPEC) 1)
           (CL:NOT (SYMBOL? (%%VALUE EXCEPTIONVARIABLESPEC)))))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal exception variable specification: `"
            (DE-UGLIFY-PARSE-TREE CLAUSE) "'." EOL)))
         (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL))
        (CL:SETQ EXCEPTIONVARIABLE (%%VALUE EXCEPTIONVARIABLESPEC))
        (CL:WHEN
         (CL:AND (TRANSLATE-TO-JAVA?) (CL:EQ EXCEPTIONVARIABLE NULL))
         (CL:SETQ EXCEPTIONVARIABLE (LOCAL-GENSYM "E")))
        (CL:SETQ EXCEPTIONVARIABLESPEC
         (WALK-A-DECLARATION EXCEPTIONVARIABLE EXCEPTIONTYPE NULL
          CL:T))
        (CL:SETQ CLAUSE
         (LIST* SYM-WALK-STELLA-SYS-HANDLE-EXCEPTION
          EXCEPTIONVARIABLESPEC
          (CONCATENATE (WALK-LIST-OF-TREES (%%REST (%%REST CLAUSE)))
           NIL)))
        (CL:WHEN (CL:NOT (CL:EQ EXCEPTIONVARIABLE NULL))
         (POP-VARIABLE-BINDING))
        (CL:SETQ CLAUSES (CONS CLAUSE CLAUSES))))
      (CL:T
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Illegal exception handler clause: `"
          (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
       (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES NULL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM WALK-EXCEPTION-HANDLER-TREES (REVERSE CLAUSES))))

;;; (DEFUN (WALK-UNWIND-PROTECT-TREE CONS TYPE) ...)

(CL:DEFUN WALK-UNWIND-PROTECT-TREE (TREE)
  (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-SYS-UNWIND-PROTECT)
   (CL:RETURN-FROM WALK-UNWIND-PROTECT-TREE
    (CL:VALUES TREE SGT-WALK-STELLA-VOID)))
  (CL:RETURN-FROM WALK-UNWIND-PROTECT-TREE
   (CL:VALUES
    (CONS SYM-WALK-STELLA-SYS-UNWIND-PROTECT
     (CONCATENATE (WALK-LIST-OF-STATEMENTS (%%REST TREE)) NIL))
    SGT-WALK-STELLA-VOID)))

;;; (DEFUN WALK-VERBATIM-DEFINITION-TREE ...)

(CL:DEFUN WALK-VERBATIM-DEFINITION-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
    SYM-WALK-STELLA-VERBATIM)
   (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER SELF-000) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  :VOID)

;;; (DEFUN WALK-VERBATIM-UNIT ...)

(CL:DEFUN WALK-VERBATIM-UNIT (UNIT)
  (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT UNIT)
   (WALK-A-TREE (%TRANSLATION-UNIT.CODE-REGISTER UNIT)))
  (CL:COND
   ((CL:NOT (CL:EQ (%TRANSLATION-UNIT.THE-OBJECT UNIT) NULL))
    (PUSH *TRANSLATIONUNITS* UNIT)
    (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER UNIT) NULL))
   (CL:T (CL:SETF (%TRANSLATION-UNIT.CODE-REGISTER UNIT) NULL)
    (CLEAR-TRANSLATION-UNIT UNIT)))
  :VOID)

;;; (DEFUN (WALK-VERBATIM-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-VERBATIM-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) (%%REST TREE))
   (CL:LET*
    ((OPTIONS SELF-000)
     (VERBATIMTREE (LOOKUP OPTIONS *TRANSLATOROUTPUTLANGUAGE*)))
    (CL:WHEN (CL:EQ VERBATIMTREE NULL)
     (CL:SETQ VERBATIMTREE (LOOKUP OPTIONS KWD-WALK-OTHERWISE))
     (CL:WHEN (CL:EQ VERBATIMTREE NULL)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Verbatim statement has no `" *TRANSLATOROUTPUTLANGUAGE*
         "' option.." EOL)))
      (CL:RETURN-FROM WALK-VERBATIM-TREE
       (CL:VALUES NULL SGT-WALK-STELLA-UNKNOWN)))
     (CL:WHEN (CL:NOT (CL:EQ VERBATIMTREE SYM-WALK-STELLA-NULL))
      (CL:RETURN-FROM WALK-VERBATIM-TREE (WALK-A-TREE VERBATIMTREE))))
    (CL:WHEN (CL:EQ VERBATIMTREE SYM-WALK-STELLA-NULL)
     (CL:RETURN-FROM WALK-VERBATIM-TREE
      (CL:VALUES NULL SGT-WALK-STELLA-UNKNOWN)))
    (CL:COND
     ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE VERBATIMTREE))
      (CL:PROGN
       (INSERT-AT OPTIONS *TRANSLATOROUTPUTLANGUAGE*
        (NEW-VERBATIM-STRING-WRAPPER
         (%STRING-WRAPPER.WRAPPER-VALUE VERBATIMTREE)))))
     (CL:T))
    (CL:RETURN-FROM WALK-VERBATIM-TREE
     (CL:VALUES TREE SGT-WALK-STELLA-UNKNOWN)))))

;;; (DEFUN (LOOKUP-VERBATIM-TREE OBJECT) ...)

(CL:DEFUN LOOKUP-VERBATIM-TREE (TREE LANGUAGE)
  (CL:WHEN (CL:EQ LANGUAGE NULL)
   (CL:SETQ LANGUAGE *TRANSLATOROUTPUTLANGUAGE*))
  (CL:RETURN-FROM LOOKUP-VERBATIM-TREE
   (SEARCH-PLIST (%%REST TREE) LANGUAGE)))

;;; (DEFUN (VERBATIM-TREE? BOOLEAN) ...)

(CL:DEFUN VERBATIM-TREE? (TREE)
  (CL:RETURN-FROM VERBATIM-TREE?
   (CL:AND (CONS? TREE)
    (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-VERBATIM))))

;;; (DEFUN WALK-DEFMODULE-TREE ...)

(CL:DEFUN WALK-DEFMODULE-TREE (TREE)
  (CL:LET* ((SELF-000 (NEW-TRANSLATION-UNIT)))
   (CL:SETF (%TRANSLATION-UNIT.CATEGORY SELF-000)
    SYM-WALK-STELLA-MODULE)
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT SELF-000) TREE)
   (CL:SETQ *CURRENTTRANSLATIONUNIT* SELF-000))
  (CL:LET*
   ((MODULE NULL)
    (MODULENAME
     (COERCE-TO-MODULE-NAME (%%VALUE (%%REST TREE)) CL:NIL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME))
   (CL:WHEN (CL:EQ MODULENAME STELLA::NULL-STRING)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal module name: `" (%%VALUE (%%REST TREE)) "'." EOL)))
    (CLEAR-TRANSLATION-UNIT *CURRENTTRANSLATIONUNIT*)
    (CL:SETQ *CURRENTTRANSLATIONUNIT* NULL)
    (CL:RETURN-FROM WALK-DEFMODULE-TREE))
   (CL:SETQ MODULE (DEFINE-MODULE MODULENAME (%%REST (%%REST TREE))))
   (CL:SETF (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*)
    MODULE))
  :VOID)

;;; (DEFUN WALK-MODULE-UNIT ...)

(CL:DEFUN WALK-MODULE-UNIT (UNIT)
  (CL:LET* ((MODULE (%TRANSLATION-UNIT.THE-OBJECT UNIT)))
   (WALK-AUXILIARY-TREE
    (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN KWD-WALK-MODULES
     (YIELD-DEFINE-MODULE MODULE) NIL)))
  :VOID)

;;; (DEFUN (EXTRACT-REQUIRED-ARGUMENT-VALUES CONS) ...)

(CL:DEFUN EXTRACT-REQUIRED-ARGUMENT-VALUES (CLASSTYPE SLOTSANDVALUES)
  (CL:LET*
   ((ARRAYTYPE? (ARRAY-TYPE-SPECIFIER? CLASSTYPE))
    (REQUIREDVALUES (NEW-LIST)) (FOUND? CL:NIL))
   (CL:WHEN ARRAYTYPE?
    (PREPROCESS-ARRAY-ARGUMENTS CLASSTYPE SLOTSANDVALUES))
   (CL:LET*
    ((REQUIREDSLOTNAME NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (CLASS-REQUIRED-SLOT-NAMES (TYPE-SPEC-TO-CLASS CLASSTYPE)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ REQUIREDSLOTNAME (%%VALUE ITER-000))
     (CL:SETQ FOUND? CL:NIL)
     (CL:LET*
      ((SLOT NULL) (VALUEREF NULL)
       (ITER-001 (%PROPERTY-LIST.THE-PLIST SLOTSANDVALUES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SLOT (%%VALUE ITER-001))
       (CL:SETQ VALUEREF (%%VALUE (%%REST ITER-001)))
       (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME SLOT) REQUIREDSLOTNAME)
        (CL:SETQ FOUND? CL:T)
        (CL:IF ARRAYTYPE?
         (EVALUATE-ARRAY-ARGUMENT-VALUE CLASSTYPE REQUIREDVALUES SLOT
          VALUEREF)
         (INSERT-LAST REQUIREDVALUES
          (WALK-EXPRESSION-TREE VALUEREF
           (COMPUTE-RETURN-TYPE-SPEC SLOT CLASSTYPE)
           SYM-WALK-STELLA-NEW CL:NIL)))
        (REMOVE-AT SLOTSANDVALUES SLOT) (CL:RETURN))
       (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
     (CL:WHEN (CL:NOT FOUND?)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Missing required NEW argument: `"
         (DE-UGLIFY-PARSE-TREE REQUIREDSLOTNAME) "'." EOL))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM EXTRACT-REQUIRED-ARGUMENT-VALUES
    (%LIST.THE-CONS-LIST REQUIREDVALUES))))

;;; (DEFUN PREPROCESS-ARRAY-ARGUMENTS ...)

(CL:DEFUN PREPROCESS-ARRAY-ARGUMENTS (ARRAYTYPE SLOTSANDVALUES)
  (CL:LET*
   ((ARRAYCLASS
     (%SURROGATE.SURROGATE-VALUE
      (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE ARRAYTYPE)))
    (ARRAYDIMENSIONS (ARRAY-TYPE-DIMENSIONS ARRAYTYPE))
    (ARRAYRANK (LENGTH ARRAYDIMENSIONS))
    (INITIALELEMENTSLOT
     (LOOKUP-SLOT ARRAYCLASS SYM-WALK-STELLA-INITIAL-ELEMENT))
    (INITIALELEMENTREF (LOOKUP SLOTSANDVALUES INITIALELEMENTSLOT))
    (ARRAYSIZESLOT (LOOKUP-SLOT ARRAYCLASS SYM-WALK-STELLA-SIZE))
    (SIZEREF (LOOKUP SLOTSANDVALUES ARRAYSIZESLOT))
    (NONLISTSIZE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAYRANK))
   (CL:WHEN (CL:EQ SIZEREF NULL)
    (CL:WHEN (CL:NOT (INDEFINITE-ARRAY-TYPE? ARRAYTYPE))
     (CL:SETQ SIZEREF
      (%LIST.THE-CONS-LIST (ARRAY-TYPE-DIMENSIONS ARRAYTYPE)))))
   (CL:COND
    ((CL:EQ SIZEREF NULL)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Missing array :size argument in NEW expression." EOL))))
    (CL:T
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE SIZEREF) SGT-WALK-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN
         (CL:AND (CL:= ARRAYRANK 1)
          (CL:OR (CL:NOT (CL:= (LENGTH SIZEREF) 1))
           (CL:AND (SYMBOL? (%%VALUE SIZEREF))
            (CL:OR
             (CL:NOT (CL:EQ (LOOKUP-FUNCTION (%%VALUE SIZEREF)) NULL))
             (CL:NOT (CL:EQ (LOOKUP-MACRO (%%VALUE SIZEREF)) NULL))))))
         (CL:SETQ NONLISTSIZE? CL:T))))
      (CL:T (CL:SETQ NONLISTSIZE? CL:T)))
     (CL:WHEN NONLISTSIZE? (CL:SETQ SIZEREF (CONS SIZEREF NIL)))
     (CL:COND
      ((CL:NOT (CL:= (LENGTH SIZEREF) ARRAYRANK))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Array :size initializer `"
          (DE-UGLIFY-PARSE-TREE SIZEREF) "'" EOL
          "   doesn't match the rank of" EOL "   `"
          (DE-UGLIFY-PARSE-TREE ARRAYTYPE) "'." EOL)))
       (CL:SETQ SIZEREF NULL))
      (CL:T
       (CL:LET*
        ((SIZEIT (ALLOCATE-ITERATOR SIZEREF))
         (DIMIT (ALLOCATE-ITERATOR ARRAYDIMENSIONS)) (DIM NULL-INTEGER)
         (ITER-000 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM DIM ITER-000))
        (CL:LOOP WHILE (CL:AND (NEXT? SIZEIT) (NEXT? DIMIT)) DO
         (CL:SETQ DIM ITER-000)
         (CL:COND
          ((CL:EQ (%LIST-ITERATOR.VALUE DIMIT) NULL)
           (CL:WHEN (INTEGER? (%CONS-ITERATOR.VALUE SIZEIT))
            (VALUE-SETTER DIMIT (%CONS-ITERATOR.VALUE SIZEIT))))
          ((CL:NOT
            (EQL? (%LIST-ITERATOR.VALUE DIMIT)
             (%CONS-ITERATOR.VALUE SIZEIT)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
              " Array :size initializer `"
              (%CONS-ITERATOR.VALUE SIZEIT)
              "' doesn't match array dimension `"
              (DE-UGLIFY-PARSE-TREE (WRAP-INTEGER DIM)) "' of" EOL
              "   `" (DE-UGLIFY-PARSE-TREE ARRAYTYPE) "'." EOL)))
           (VALUE-SETTER SIZEIT (%LIST-ITERATOR.VALUE DIMIT))))
         (CL:SETQ ITER-000 (CL:1+ ITER-000))))))))
   (INSERT-AT SLOTSANDVALUES INITIALELEMENTSLOT INITIALELEMENTREF)
   (CL:IF (CL:NOT (CL:EQ SIZEREF NULL))
    (INSERT-AT SLOTSANDVALUES ARRAYSIZESLOT SIZEREF)
    (REMOVE-AT SLOTSANDVALUES ARRAYSIZESLOT)))
  :VOID)

;;; (DEFUN EVALUATE-ARRAY-ARGUMENT-VALUE ...)

(CL:DEFUN EVALUATE-ARRAY-ARGUMENT-VALUE (ARRAYTYPE REQUIREDVALUES SLOT VALUEREF)
  (CL:COND
   ((CL:EQ (%SLOT.SLOT-NAME SLOT) SYM-WALK-STELLA-SIZE)
    (CL:LET* ((DIM NULL) (ITER-000 VALUEREF) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ DIM (%%VALUE ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS
          (WALK-EXPRESSION-TREE DIM SGT-WALK-STELLA-INTEGER
           SYM-WALK-STELLA-NEW CL:NIL)
          NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST REQUIREDVALUES) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST REQUIREDVALUES) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (%LIST.THE-CONS-LIST REQUIREDVALUES) COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS
          (WALK-EXPRESSION-TREE DIM SGT-WALK-STELLA-INTEGER
           SYM-WALK-STELLA-NEW CL:NIL)
          NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:T
    (INSERT-LAST REQUIREDVALUES
     (WALK-EXPRESSION-TREE VALUEREF
      (COMPUTE-RETURN-TYPE-SPEC SLOT ARRAYTYPE) SYM-WALK-STELLA-NEW
      CL:NIL))))
  :VOID)

;;; (DEFUN (YIELD-NEW-ARGUMENTS-TREE CONS CONS) ...)

(CL:DEFUN YIELD-NEW-ARGUMENTS-TREE (KEYWORDSANDVALUES CLASSTYPE SELFVARIABLE)
  (CL:WHEN (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH KEYWORDSANDVALUES)))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Odd number of arguments in 'new' expression: `"
      (DE-UGLIFY-PARSE-TREE KEYWORDSANDVALUES) "'." EOL)))
   (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE (CL:VALUES NIL NIL)))
  (CL:LET* ((CLASS (TYPE-SPEC-TO-CLASS CLASSTYPE)))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) KEYWORDSANDVALUES)
    (CL:LET*
     ((PLIST SELF-000) (OTHERASSIGNMENTS NIL) (REQUIREDVALUES NULL)
      (SLOTNAME NULL) (SLOT NULL))
     (CL:LET* ((IT (ALLOCATE-ITERATOR PLIST)))
      (CL:LOOP WHILE (NEXT? IT) DO
       (CL:LET*
        ((TEST-VALUE-000
          (SAFE-PRIMARY-TYPE (%PROPERTY-LIST-ITERATOR.KEY IT))))
        (CL:COND
         ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
          (CL:SETQ SLOTNAME
           (INTERN-SYMBOL-IN-MODULE
            (%KEYWORD.SYMBOL-NAME (%PROPERTY-LIST-ITERATOR.KEY IT))
            (HOME-MODULE CLASS) CL:NIL)))
         ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
          (CL:SETQ SLOTNAME (%PROPERTY-LIST-ITERATOR.KEY IT)))
         (CL:T
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal slot keyword `" (%PROPERTY-LIST-ITERATOR.KEY IT)
             "' in NEW expression." EOL)))
          (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE
           (CL:VALUES NIL NIL)))))
       (CL:SETQ SLOT (LOOKUP-SLOT CLASS SLOTNAME))
       (CL:WHEN (CL:EQ SLOT NULL)
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " No such slot `" (DE-UGLIFY-PARSE-TREE SLOTNAME)
           "' on the class `" (CLASS-NAME CLASS) "'." EOL)))
        (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE (CL:VALUES NIL NIL)))
       (KEY-SETTER IT SLOT)))
     (CL:SETQ REQUIREDVALUES
      (EXTRACT-REQUIRED-ARGUMENT-VALUES CLASSTYPE PLIST))
     (CL:LET*
      ((SLOT NULL) (VALUEREF NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST PLIST)) (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SLOT (%%VALUE ITER-000))
       (CL:SETQ VALUEREF (%%VALUE (%%REST ITER-000)))
       (CL:WHEN (CL:NOT (STORAGE-SLOT? SLOT))
        (CL:LET* ((METHOD SLOT))
         (CL:WHEN
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-WALK-STELLA-STORAGE-SLOT NULL)
            NULL))
          (CL:SETQ SLOT
           (LOOKUP-SLOT CLASS
            (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-WALK-STELLA-STORAGE-SLOT NULL))))))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS
           (LIST* SYM-WALK-STELLA-SETF
            (CONS (%SLOT.SLOT-NAME SLOT) (CONS SELFVARIABLE NIL))
            VALUEREF NIL)
           NIL))
         (CL:IF (CL:EQ OTHERASSIGNMENTS NIL)
          (CL:SETQ OTHERASSIGNMENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST OTHERASSIGNMENTS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS
           (LIST* SYM-WALK-STELLA-SETF
            (CONS (%SLOT.SLOT-NAME SLOT) (CONS SELFVARIABLE NIL))
            VALUEREF NIL)
           NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
     (CL:RETURN-FROM YIELD-NEW-ARGUMENTS-TREE
      (CL:VALUES REQUIREDVALUES OTHERASSIGNMENTS))))))

;;; (DEFUN (GET-CURRENT-SELF-TYPE TYPE) ...)

(CL:DEFUN GET-CURRENT-SELF-TYPE ()
  (CL:LET*
   ((METHOD *METHODBEINGWALKED*) (OWNER SGT-WALK-STELLA-UNKNOWN))
   (CL:WHEN (CL:NOT (CL:EQ METHOD NULL)) (CL:SETQ OWNER (OWNER METHOD))
    (CL:WHEN (CL:EQ OWNER NULL)
     (CL:IF
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-METHOD-CONSTRUCTOR? FALSE-WRAPPER))
      (CL:SETQ OWNER (%METHOD-SLOT.SLOT-BASE-TYPE METHOD))
      (CL:SETQ OWNER SGT-WALK-STELLA-UNKNOWN))))
   (CL:RETURN-FROM GET-CURRENT-SELF-TYPE OWNER)))

;;; (DEFUN (WALK-NEW-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-NEW-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (CLASSTREE (%%VALUE (%%REST TREE)))
    (BASECLASSNAME
     (CL:IF (CONS? CLASSTREE) (%%VALUE CLASSTREE) CLASSTREE))
    (KEYWORDARGUMENTS (%%REST (%%REST TREE)))
    (SELFVARIABLE (LOCAL-GENSYM "SELF")) (CLASSTYPE NULL)
    (NEWTREE NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (SYMBOL? BASECLASSNAME))
     (CL:NOT (KEYWORD? BASECLASSNAME)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal argument to `" (DE-UGLIFY-PARSE-TREE OPERATOR)
       "' where symbol expected:  `"
       (DE-UGLIFY-PARSE-TREE BASECLASSNAME) "'." EOL)))
    (CL:RETURN-FROM WALK-NEW-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:SETQ CLASSTYPE (SAFE-YIELD-TYPE-SPECIFIER CLASSTREE))
   (CL:WHEN (CL:EQ (TYPE-SPEC-TO-CLASS CLASSTYPE) NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Undefined class supplied to `" (DE-UGLIFY-PARSE-TREE OPERATOR)
       "' operator: `" (DE-UGLIFY-PARSE-TREE BASECLASSNAME) "'." EOL)))
    (CL:RETURN-FROM WALK-NEW-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:WHEN (CL:NOT (TYPE? CLASSTYPE))
    (CL:SETQ CLASSTYPE
     (COMPUTE-RELATIVE-TYPE-SPEC CLASSTYPE (GET-CURRENT-SELF-TYPE))))
   (CL:WHEN (%CLASS.ABSTRACT? (TYPE-SPEC-TO-CLASS CLASSTYPE))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Trying to create an instance of the ABSTRACT class `"
       (DE-UGLIFY-PARSE-TREE BASECLASSNAME) "'." EOL)))
    (CL:RETURN-FROM WALK-NEW-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:LET* ((REQUIREDARGS NULL) (OTHERASSIGNMENTS NULL))
    (CL:MULTIPLE-VALUE-SETQ (REQUIREDARGS OTHERASSIGNMENTS)
     (YIELD-NEW-ARGUMENTS-TREE KEYWORDARGUMENTS CLASSTYPE
      SELFVARIABLE))
    (CL:SETQ NEWTREE
     (LIST* SYM-WALK-STELLA-SYS-NEW CLASSTYPE
      (CONCATENATE REQUIREDARGS NIL)))
    (CL:IF (CL:EQ OTHERASSIGNMENTS NIL)
     (CL:RETURN-FROM WALK-NEW-TREE (CL:VALUES NEWTREE CLASSTYPE))
     (CL:RETURN-FROM WALK-NEW-TREE
      (CL:VALUES
       (LIST* SYM-WALK-STELLA-VRLET
        (CONS (CONS SELFVARIABLE (CONS NEWTREE NIL)) NIL)
        (CONCATENATE OTHERASSIGNMENTS (CONS SELFVARIABLE NIL)))
       CLASSTYPE))))))

;;; (DEFUN (WALK-MAKE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-MAKE-TREE (TREE)
  (CL:LET*
   ((CLASSNAME (%%VALUE (%%REST TREE)))
    (ARGUMENTS (%%REST (%%REST TREE))) (TYPE NULL) (CLASS NULL))
   (CL:COND ((SYMBOL? CLASSNAME))
    ((TYPE? CLASSNAME)
     (SECOND-SETTER TREE
      (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME CLASSNAME)
       (%SURROGATE.HOME-CONTEXT CLASSNAME) CL:T)))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Bad argument to 'make':" EOL "   `"
        (DE-UGLIFY-PARSE-TREE CLASSNAME)
        "' found where symbol expected." EOL)))
     (CL:RETURN-FROM WALK-MAKE-TREE
      (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN))))
   (CL:SETQ TYPE (TYPIFY CLASSNAME))
   (CL:SETQ CLASS (%SURROGATE.SURROGATE-VALUE TYPE))
   (CL:WHEN (CL:EQ CLASS NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Reference to undefined class `"
       (DE-UGLIFY-PARSE-TREE CLASSNAME) "'." EOL)))
    (CL:RETURN-FROM WALK-MAKE-TREE
     (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-UNKNOWN)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ARGUMENTS NIL))
     (CL:NOT (EXCEPTION-CLASS? CLASS)))
    (CL:COND
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
      (CL:WHEN
       (CL:EQ
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
          SYM-WALK-STELLA-CLASS-CPP-NATIVE-TYPE NULL-STRING-WRAPPER))
        STELLA::NULL-STRING)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " MAKE arguments not supported for non-native class `"
          (DE-UGLIFY-PARSE-TREE CLASSNAME) "'." EOL)))
       (CL:RETURN-FROM WALK-MAKE-TREE
        (WALK-DONT-CALL-ME-TREE TREE TYPE))))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-JAVA)
      (CL:WHEN
       (CL:EQ
        (%STRING-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
          SYM-WALK-STELLA-CLASS-JAVA-NATIVE-TYPE NULL-STRING-WRAPPER))
        STELLA::NULL-STRING)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " MAKE arguments not supported for non-native class `"
          (DE-UGLIFY-PARSE-TREE CLASSNAME) "'." EOL)))
       (CL:RETURN-FROM WALK-MAKE-TREE
        (WALK-DONT-CALL-ME-TREE TREE TYPE))))
     (CL:T
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL " MAKE arguments not supported for `"
         (TRANSLATOR-OUTPUT-LANGUAGE-NAME) "'; skipping them." EOL)))
      (CL:SETQ ARGUMENTS NIL))))
   (CL:SETF (%%REST (%%REST TREE)) (WALK-LIST-OF-TREES ARGUMENTS))
   (CL:RETURN-FROM WALK-MAKE-TREE (CL:VALUES TREE TYPE))))

;;; (DEFUN (WALK-FUNCALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FUNCALL-TREE (TREE)
  (CL:WHEN
   (CL:OR (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-SYS-CALL-FUNCTION-CODE)
    (CL:EQ (%%VALUE TREE) SYM-WALK-STELLA-SYS-CALL-METHOD-CODE))
   (CL:RETURN-FROM WALK-FUNCALL-TREE
    (CL:VALUES TREE (%%VALUE (%%VALUE (%%VALUE (%%REST TREE)))))))
  (CL:LET*
   ((RETURNTYPE
     (CL:IF (CL:EQ *TARGETTYPE* SGT-WALK-STELLA-UNKNOWN)
      SGT-WALK-STELLA-VOID *TARGETTYPE*))
    (SIGNATURE (CONS (CONS RETURNTYPE NIL) NIL)))
   (CL:LET* ((OTREE NULL) (OTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
     (WALK-EXPRESSION-TREE (%%VALUE (%%REST TREE)) SGT-WALK-STELLA-CODE
      SYM-WALK-STELLA-FUNCALL CL:T))
    (FIRST-SETTER TREE
     (CL:IF (CL:EQ OTYPE SGT-WALK-STELLA-METHOD-CODE)
      SYM-WALK-STELLA-SYS-CALL-METHOD-CODE
      SYM-WALK-STELLA-SYS-CALL-FUNCTION-CODE))
    (SECOND-SETTER TREE OTREE))
   (CL:LET* ((IT (ALLOCATE-ITERATOR (%%REST (%%REST TREE)))))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:LET* ((ARGTREE NULL) (ARGTYPE NULL))
      (CL:MULTIPLE-VALUE-SETQ (ARGTREE ARGTYPE)
       (WALK-A-TREE (%CONS-ITERATOR.VALUE IT)))
      (VALUE-SETTER IT ARGTREE)
      (CL:SETQ SIGNATURE (CONS ARGTYPE SIGNATURE)))))
   (CL:SETF (%%REST TREE) (CONS (REVERSE SIGNATURE) (%%REST TREE)))
   (CL:RETURN-FROM WALK-FUNCALL-TREE (CL:VALUES TREE RETURNTYPE))))

;;; (DEFUN (WALK-THE-CODE-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-THE-CODE-TREE (TREE)
  (CL:LET* ((TEST-VALUE-000 (%%VALUE (%%REST TREE))))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-WALK-FUNCTION)
     (CL:WHEN (BAD-ARGUMENT-RANGE? TREE 2 3)
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-FUNCTION-CODE)))
     (CL:WHEN (CL:NOT (SYMBOL? (%%VALUE (%%REST (%%REST TREE)))))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal function name: `"
         (%%VALUE (%%REST (%%REST TREE))) "'." EOL)))
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-FUNCTION-CODE)))
     (CL:WHEN
      (CL:EQ (%%VALUE (%%REST (%%REST TREE))) SYM-WALK-STELLA-MAIN)
      (CL:COND
       ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
         (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Cannot generate a function pointer to `main' in C++."
           EOL)))
        (CL:RETURN-FROM WALK-THE-CODE-TREE
         (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-FUNCTION-CODE)))
       (CL:T
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
           " Won't be able to generate a function pointer to `main' in C++."
           EOL))))))
     (CL:RETURN-FROM WALK-THE-CODE-TREE
      (CL:VALUES TREE SGT-WALK-STELLA-FUNCTION-CODE)))
    ((CL:EQ TEST-VALUE-000 KWD-WALK-METHOD)
     (CL:WHEN (BAD-ARGUMENT-COUNT? TREE 3)
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-METHOD-CODE)))
     (CL:WHEN
      (CL:NOT
       (ISA? (%%VALUE (%%REST (%%REST TREE)))
        SGT-WALK-STELLA-GENERALIZED-SYMBOL))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal method class: `"
         (%%VALUE (%%REST (%%REST TREE))) "'." EOL)))
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-METHOD-CODE)))
     (CL:WHEN (CL:NOT (SYMBOL? (FOURTH TREE)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL " Illegal method name: `" (FOURTH TREE) "'." EOL)))
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (WALK-DONT-CALL-ME-TREE TREE SGT-WALK-STELLA-METHOD-CODE)))
     (CL:LET* ((TYPE (TYPIFY (%%VALUE (%%REST (%%REST TREE))))))
      (THIRD-SETTER TREE TYPE)
      (CL:IF (CL:EQ (%SURROGATE.SURROGATE-VALUE TYPE) NULL)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " No class defined for the type: `"
          (DE-UGLIFY-PARSE-TREE TYPE) "'." EOL)))
       (CL:COND
        ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP)
          (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-WALK-CPP-STANDALONE))
         (CL:LET*
          ((METHOD
            (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE TYPE)
             (FOURTH TREE))))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ METHOD NULL))
            (CPP-METHOD-OBJECT-IS-OVERLOADED-FUNCTION? METHOD))
           (CL:RETURN-FROM WALK-THE-CODE-TREE
            (SYS-TREE
             (LIST* SYM-WALK-STELLA-THE-CODE KWD-WALK-FUNCTION METHOD
              NIL)
             SGT-WALK-STELLA-FUNCTION-CODE))))
         (CL:WHEN (CL:NOT (SUBTYPE-OF? TYPE SGT-WALK-STELLA-OBJECT))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-NOTE)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) EOL
             " Cannot store a method-code pointer for " EOL " `"
             (%%VALUE (%%REST (%%REST TREE))) "'.`" (FOURTH TREE) "'"
             EOL " since it is not defined on a subtype of @OBJECT."
             EOL)))
          (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
           (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
            (WALK-A-TREE
             (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-NULL
              SYM-WALK-STELLA-METHOD-CODE NIL)))
           (CL:RETURN-FROM WALK-THE-CODE-TREE
            (CL:VALUES VALUE-000 VALUE-001)))))
        (CL:T)))
      (CL:RETURN-FROM WALK-THE-CODE-TREE
       (CL:VALUES TREE SGT-WALK-STELLA-METHOD-CODE))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (WALK-CALL-SUPER-METHOD-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-CALL-SUPER-METHOD-TREE (TREE)
  (CL:LET*
   ((ENCLOSINGMETHOD *METHODBEINGWALKED*) (CALLTREE NULL)
    (CALLTYPE NULL) (BARETREE NULL))
   (CL:COND
    ((CL:OR (CL:EQ ENCLOSINGMETHOD NULL)
      (%METHOD-SLOT.METHOD-FUNCTION? ENCLOSINGMETHOD))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " call-super-method not called within a method: `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))
    ((CL:NOT
      (CL:EQ (FIRST (METHOD-PARAMETER-NAMES ENCLOSINGMETHOD))
       (%%VALUE (%%REST TREE))))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL
        " call-super-method needs to be called with enclosing method's self arg: `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL))))
    ((CL:EQ (%METHOD-SLOT.SLOT-DIRECT-EQUIVALENT ENCLOSINGMETHOD) NULL)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " call-super-method: no super method available for: `"
        (DE-UGLIFY-PARSE-TREE *METHODBEINGWALKED*) "'." EOL))))
    (CL:T (FIRST-SETTER TREE (%METHOD-SLOT.SLOT-NAME ENCLOSINGMETHOD))
     (CL:LET* ((VALUE-000 NULL) (VALUE-001 NULL))
      (CL:MULTIPLE-VALUE-SETQ (VALUE-000 VALUE-001)
       (WALK-CALL-SLOT-TREE TREE))
      (CL:PROGN (CL:SETQ CALLTREE VALUE-000)
       (CL:SETQ CALLTYPE VALUE-001)))
     (CL:SETQ BARETREE (WALKED-EXPRESSION-EXPRESSION CALLTREE))
     (CL:WHEN
      (CL:EQ (%%VALUE BARETREE) SYM-WALK-STELLA-SYS-CALL-METHOD)
      (FIRST-SETTER BARETREE SYM-WALK-STELLA-SYS-CALL-SUPER-METHOD)
      (CL:RETURN-FROM WALK-CALL-SUPER-METHOD-TREE
       (SYS-TREE CALLTREE CALLTYPE)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal call-super-method call or context: `"
        (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))))
   (CL:RETURN-FROM WALK-CALL-SUPER-METHOD-TREE
    (WALK-DONT-CALL-ME-TREE TREE *TARGETTYPE*))))

;;; (DEFUN (DE-UGLIFY-ARGUMENTS CONS) ...)

(CL:DEFUN DE-UGLIFY-ARGUMENTS (UGLYARGUMENTS)
  (CL:LET* ((PRETTYARGUMENTS NIL))
   (CL:LET* ((ARG NULL) (ITER-000 UGLYARGUMENTS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
       (CL:IF (CL:EQ PRETTYARGUMENTS NIL)
        (CL:SETQ PRETTYARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST PRETTYARGUMENTS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM DE-UGLIFY-ARGUMENTS PRETTYARGUMENTS)))

;;; (DEFUN (DE-UGLIFY-PARSE-TREE OBJECT) ...)

(CL:DEFUN DE-UGLIFY-PARSE-TREE (TREE)
  (CL:WHEN (CL:EQ TREE NULL) (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE NULL))
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-001 SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((OPERATOR (%%VALUE TREE)))
       (CL:WHEN (CL:NOT (SYMBOL? OPERATOR))
        (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
         (DE-UGLIFY-ARGUMENTS TREE)))
       (CL:LET* ((TEST-VALUE-000 OPERATOR))
        (CL:COND
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-METHOD))
          (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
           (DE-UGLIFY-PARSE-TREE (%%REST (%%REST TREE)))))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-SYS-CALL-FUNCTION)
          (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
           (DE-UGLIFY-PARSE-TREE (%%REST TREE))))
         ((CL:OR (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-TYPED-SYS)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-VOID-SYS)
           (CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-BAD-SYS))
          (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
           (DE-UGLIFY-PARSE-TREE (%%VALUE (%%REST TREE)))))
         ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-SYM)
          (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
           (GET-SYM-FROM-OFFSET
            (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST TREE))))))
         (CL:T
          (CL:LET* ((PRETTYARGUMENTS NIL))
           (CL:LET*
            ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
             (CL:SETQ ARG (%%VALUE ITER-000))
             (CL:IF (CL:EQ COLLECT-000 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-000
                (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
               (CL:IF (CL:EQ PRETTYARGUMENTS NIL)
                (CL:SETQ PRETTYARGUMENTS COLLECT-000)
                (ADD-CONS-TO-END-OF-CONS-LIST PRETTYARGUMENTS
                 COLLECT-000)))
              (CL:PROGN
               (CL:SETF (%%REST COLLECT-000)
                (CONS (DE-UGLIFY-PARSE-TREE ARG) NIL))
               (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
             (CL:SETQ ITER-000 (%%REST ITER-000))))
           (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
            (CONS OPERATOR (CONCATENATE PRETTYARGUMENTS NIL))))))))))
    ((SUBTYPE-OF? TEST-VALUE-001
      SGT-WALK-STELLA-COMPOUND-TYPE-SPECIFIER)
     (CL:PROGN
      (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE
       (YIELD-TYPE-SPEC-TREE TREE))))
    (CL:T (CL:RETURN-FROM DE-UGLIFY-PARSE-TREE TREE)))))

;;; (DEFGLOBAL *NATIVE-NAME-TABLE* ...)

(CL:DEFVAR *NATIVE-NAME-TABLE* NULL)

;;; (DEFUN REGISTER-NATIVE-NAME ...)

(CL:DEFUN REGISTER-NATIVE-NAME (NAME LANGUAGE CATEGORY)
  (CL:LET*
   ((TABLEENTRY (LOOKUP *NATIVE-NAME-TABLE* NAME)) (CATEGORIES NULL))
   (CL:WHEN (CL:EQ TABLEENTRY NULL)
    (CL:SETQ TABLEENTRY (NEW-KEY-VALUE-LIST)))
   (CL:SETQ CATEGORIES (LOOKUP TABLEENTRY LANGUAGE))
   (CL:WHEN (CL:EQ CATEGORIES NULL) (CL:SETQ CATEGORIES (NEW-LIST)))
   (INSERT-NEW CATEGORIES CATEGORY)
   (INSERT-AT TABLEENTRY LANGUAGE CATEGORIES)
   (INSERT-AT *NATIVE-NAME-TABLE* NAME TABLEENTRY))
  :VOID)

;;; (DEFUN (NATIVE-NAME? BOOLEAN) ...)

(CL:DEFUN NATIVE-NAME? (NAME LANGUAGE CATEGORY)
  (CL:LET*
   ((TABLEENTRY (LOOKUP *NATIVE-NAME-TABLE* NAME)) (CATEGORIES NULL))
   (CL:WHEN (CL:EQ TABLEENTRY NULL)
    (CL:RETURN-FROM NATIVE-NAME? CL:NIL))
   (CL:SETQ CATEGORIES (LOOKUP TABLEENTRY LANGUAGE))
   (CL:IF (CL:EQ CATEGORIES NULL) (CL:RETURN-FROM NATIVE-NAME? CL:NIL)
    (CL:RETURN-FROM NATIVE-NAME?
     (CL:OR (CL:EQ CATEGORY NULL) (MEMBER? CATEGORIES CATEGORY))))))

;;; (DEFUN (YIELD-RENAMED-NAME-IF-NATIVE SYMBOL) ...)

(CL:DEFUN YIELD-RENAMED-NAME-IF-NATIVE (NAME LANGUAGE CATEGORY)
  (CL:IF (NATIVE-NAME? NAME LANGUAGE CATEGORY)
   (CL:LET* ((NEWNAME NULL))
    (CL:COND
     ((CL:EQ LANGUAGE KWD-WALK-COMMON-LISP)
      (CL:SETQ NEWNAME
       (INTERN-DERIVED-SYMBOL NAME
        (CONCATENATE "%" (%SYMBOL.SYMBOL-NAME NAME)))))
     ((CL:EQ LANGUAGE KWD-WALK-CPP)
      (CL:RETURN-FROM YIELD-RENAMED-NAME-IF-NATIVE NAME))
     (CL:T
      (CL:SETQ NEWNAME
       (INTERN-DERIVED-SYMBOL NAME
        (CONCATENATE (%SYMBOL.SYMBOL-NAME NAME) "_")))))
    (CL:RETURN-FROM YIELD-RENAMED-NAME-IF-NATIVE
     (YIELD-RENAMED-NAME-IF-NATIVE NEWNAME LANGUAGE CATEGORY)))
   (CL:RETURN-FROM YIELD-RENAMED-NAME-IF-NATIVE NAME)))

;;; (DEFUN (METHOD-NEEDS-LISP-MACRO? BOOLEAN) ...)

(CL:DEFUN METHOD-NEEDS-LISP-MACRO? (METHOD)
  (CL:IF
   (CL:AND (TRANSLATE-TO-COMMON-LISP?)
    (NON-EMPTY? (METHOD-PARAMETER-NAMES METHOD)))
   (CL:LET*
    ((LISPMACRO?
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-LISP-MACRO? NULL)))
    (CL:RETURN-FROM METHOD-NEEDS-LISP-MACRO?
     (CL:OR
      (CL:AND (CL:NOT (CL:EQ LISPMACRO? NULL))
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN LISPMACRO?))
      (CL:AND (COMMAND? METHOD)
       (CL:NOT
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
          SYM-WALK-STELLA-METHOD-NATIVE? FALSE-WRAPPER)))
       (CL:OR (CL:EQ LISPMACRO? NULL)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN LISPMACRO?))))))
   (CL:RETURN-FROM METHOD-NEEDS-LISP-MACRO? CL:NIL)))

;;; (DEFUN (YIELD-LISP-MACRO-TREES CONS CONS) ...)

(CL:DEFUN YIELD-LISP-MACRO-TREES (NAME METHOD)
  (CL:LET*
   ((MODULE
     (CL:IF (CL:NOT (CL:EQ (%SYMBOL.HOME-CONTEXT NAME) NULL))
      (%SYMBOL.HOME-CONTEXT NAME) *MODULE*))
    (TRANSLATEDNAME
     (YIELD-GLOBAL-LISP-SYMBOL MODULE (%SYMBOL.SYMBOL-NAME NAME)))
    (TRANSLATEDFULLNAME
     (YIELD-GLOBAL-LISP-SYMBOL MODULE
      (COMPUTE-FULL-NAME (%SYMBOL.SYMBOL-NAME NAME) MODULE)))
    (DOCUMENTATION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (CL:RETURN-FROM YIELD-LISP-MACRO-TREES
    (CL:VALUES
     (LIST* SYM-WALK-STELLA-VERBATIM KWD-WALK-COMMON-LISP
      (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFMACRO") TRANSLATEDNAME
       (CONS
        (LIST* (INTERN-COMMON-LISP-SYMBOL "&WHOLE")
         SYM-WALK-STELLA-EXPRESSION (INTERN-COMMON-LISP-SYMBOL "&REST")
         SYM-WALK-STELLA-IGNORE NIL)
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
          (CONS (WRAP-STRING DOCUMENTATION) NIL) NIL)
         (LIST*
          (LIST* (INTERN-COMMON-LISP-SYMBOL "DECLARE")
           (LIST* (INTERN-COMMON-LISP-SYMBOL "IGNORE")
            SYM-WALK-STELLA-IGNORE NIL)
           NIL)
          (LIST* (INTERN-COMMON-LISP-SYMBOL "LET")
           (CONS
            (CONS
             (CL-TRANSLATE-GLOBAL-SYMBOL
              SYM-WALK-STELLA-*IGNORETRANSLATIONERRORS?*)
             (CONS
              (CL:IF (COMMAND? METHOD)
               (CL-TRANSLATE-GLOBAL-SYMBOL SYM-WALK-STELLA-FALSE)
               (CL-TRANSLATE-GLOBAL-SYMBOL SYM-WALK-STELLA-TRUE))
              NIL))
            NIL)
           (CONS
            (CL-TRANSLATE-GLOBAL-SYMBOL
             SYM-WALK-STELLA-CL-INCREMENTALLY-TRANSLATE)
            (CONS SYM-WALK-STELLA-EXPRESSION NIL))
           NIL)
          NIL))))
      KWD-WALK-OTHERWISE SYM-WALK-STELLA-NULL NIL)
     (LIST* SYM-WALK-STELLA-VERBATIM KWD-WALK-COMMON-LISP
      (LIST* (INTERN-COMMON-LISP-SYMBOL "SETF")
       (LIST* (INTERN-COMMON-LISP-SYMBOL "MACRO-FUNCTION")
        (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") TRANSLATEDFULLNAME
         NIL)
        NIL)
       (LIST* (INTERN-COMMON-LISP-SYMBOL "MACRO-FUNCTION")
        (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") TRANSLATEDNAME NIL)
        NIL)
       NIL)
      KWD-WALK-OTHERWISE SYM-WALK-STELLA-NULL NIL)))))

;;; (DEFUN CREATE-LISP-MACRO-UNITS ...)

(CL:DEFUN CREATE-LISP-MACRO-UNITS (NAME METHOD)
  (CL:WHEN (CL:EQ NAME (%METHOD-SLOT.SLOT-NAME METHOD))
   (REGISTER-NATIVE-NAME NAME KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION))
  (CL:LET* ((MACROTREE NULL) (ALIASDEFINITIONTREE NULL))
   (CL:MULTIPLE-VALUE-SETQ (MACROTREE ALIASDEFINITIONTREE)
    (YIELD-LISP-MACRO-TREES NAME METHOD))
   (WALK-AUXILIARY-TREE MACROTREE)
   (WALK-AUXILIARY-TREE ALIASDEFINITIONTREE))
  (CL:WHEN (CL:EQ NAME (%METHOD-SLOT.SLOT-NAME METHOD))
   (WALK-AUXILIARY-TREE
    (LIST* SYM-WALK-STELLA-STARTUP-TIME-PROGN
     (LIST* SYM-WALK-STELLA-REGISTER-NATIVE-NAME
      (LIST* SYM-WALK-STELLA-QUOTE NAME NIL) KWD-WALK-COMMON-LISP
      KWD-WALK-FUNCTION NIL)
     NIL)))
  :VOID)

;;; (DEFUN (METHOD-NEEDS-C-CALLABLE-WRAPPER? BOOLEAN) ...)

(CL:DEFUN METHOD-NEEDS-C-CALLABLE-WRAPPER? (METHOD)
  (CL:COND
   ((CL:AND (TRANSLATE-TO-CPP?)
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-C-CALLABLE? FALSE-WRAPPER))
     (CL:NOT
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))))
    (CL:COND
     ((%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
        SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL
         " Cannot create a C-callable wrapper for a variable arguments function: `"
         (DE-UGLIFY-PARSE-TREE METHOD) "'." EOL)))
      (CL:RETURN-FROM METHOD-NEEDS-C-CALLABLE-WRAPPER? CL:NIL))
     ((CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL
         " Cannot create a C-callable wrapper for a multi-valued function: `"
         (DE-UGLIFY-PARSE-TREE METHOD) "'." EOL)))
      (CL:RETURN-FROM METHOD-NEEDS-C-CALLABLE-WRAPPER? CL:NIL))
     (CL:T (CL:RETURN-FROM METHOD-NEEDS-C-CALLABLE-WRAPPER? CL:T))))
   (CL:T (CL:RETURN-FROM METHOD-NEEDS-C-CALLABLE-WRAPPER? CL:NIL))))

;;; (DEFUN (YIELD-C-CALLABLE-WRAPPER-NAME SYMBOL) ...)

(CL:DEFUN YIELD-C-CALLABLE-WRAPPER-NAME (METHOD)
  (CL:LET*
   ((METHODNAME (%METHOD-SLOT.SLOT-NAME METHOD))
    (BASENAME (%SYMBOL.SYMBOL-NAME METHODNAME))
    (PREFIX
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-C-NAMESPACE-PREFIX
       NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BASENAME PREFIX))
   (CL:WHEN (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
    (CL:SETQ BASENAME
     (CONCATENATE
      (%SURROGATE.SYMBOL-NAME (%METHOD-SLOT.SLOT-OWNER METHOD)) "-"
      BASENAME)))
   (CL:WHEN (CL:EQ PREFIX STELLA::NULL-STRING)
    (CL:SETQ PREFIX
     (CONCATENATE
      (CPP-YIELD-NAMESPACE-PREFIX-FROM-MODULE (HOME-MODULE METHOD))
      "_")))
   (CL:WHEN (ALL-UPPER-CASE-STRING? BASENAME)
    (CL:SETQ PREFIX (STRING-UPCASE PREFIX)))
   (CL:RETURN-FROM YIELD-C-CALLABLE-WRAPPER-NAME
    (INTERN-DERIVED-SYMBOL METHODNAME (CONCATENATE PREFIX BASENAME)))))

;;; (DEFUN (YIELD-C-CALLABLE-WRAPPER-TREE CONS) ...)

(CL:DEFUN YIELD-C-CALLABLE-WRAPPER-TREE (METHOD)
  (CL:LET*
   ((DEFINITION
     (UNSTRINGIFY-STELLA-SOURCE
      (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE METHOD) NULL))
    (WRAPPERNAME (YIELD-C-CALLABLE-WRAPPER-NAME METHOD))
    (NAMETREE (%%VALUE (%%REST DEFINITION)))
    (CALLTREE (CONS (%METHOD-SLOT.SLOT-NAME METHOD) NIL))
    (RETURNTYPE (TYPE METHOD))
    (RETURNSVALUES? (CL:NOT (CL:EQ RETURNTYPE SGT-WALK-STELLA-VOID))))
   (CL:LET*
    ((NAME NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ NAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS NAME NIL))
       (CL:IF (CL:EQ CALLTREE NIL) (CL:SETQ CALLTREE COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CALLTREE COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS NAME NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN RETURNSVALUES?
    (CL:COND
     ((CL:OR (SUBTYPE-OF? RETURNTYPE SGT-WALK-STELLA-STRING)
       (SUBTYPE-OF? RETURNTYPE SGT-WALK-STELLA-MUTABLE-STRING)
       (CL:NOT (SUBTYPE-OF? RETURNTYPE SGT-WALK-STELLA-LITERAL)))
      (CL:SETQ CALLTREE
       (LIST* SYM-WALK-STELLA-PROGN
        (LIST* SYM-WALK-STELLA-SETQ
         SYM-WALK-STELLA-*C-API-RESULT-BUFFER*
         (LIST* SYM-WALK-STELLA-CAST CALLTREE
          (CONS SYM-WALK-STELLA-NATIVE-OBJECT-POINTER NIL))
         NIL)
        (LIST* SYM-WALK-STELLA-RETURN
         (LIST* SYM-WALK-STELLA-CAST
          SYM-WALK-STELLA-*C-API-RESULT-BUFFER* RETURNTYPE NIL)
         NIL)
        NIL)))
     (CL:T
      (CL:SETQ CALLTREE (LIST* SYM-WALK-STELLA-RETURN CALLTREE NIL)))))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-THROWS-EXCEPTIONS? FALSE-WRAPPER))
    (CL:LET* ((RETURNTREE NIL))
     (CL:WHEN RETURNSVALUES?
      (CL:LET*
       ((TYPE NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD)))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ TYPE (%%VALUE ITER-001)) (CL:SETQ TYPE TYPE)
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (CONS SYM-WALK-STELLA-NULL NIL))
          (CL:IF (CL:EQ RETURNTREE NIL)
           (CL:SETQ RETURNTREE COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST RETURNTREE COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS SYM-WALK-STELLA-NULL NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:SETQ RETURNTREE
       (CONS (CONS SYM-WALK-STELLA-RETURN (CONCATENATE RETURNTREE NIL))
        NIL)))
     (CL:SETQ CALLTREE
      (LIST* SYM-WALK-STELLA-EXCEPTION-CASE CALLTREE
       (CONS
        (LIST* SYM-WALK-STELLA-NATIVE-EXCEPTION
         (CONS SYM-WALK-STELLA-E NIL)
         (LIST* SYM-WALK-STELLA-CALL-GLOBAL-EXCEPTION-HANDLER
          SYM-WALK-STELLA-E NIL)
         (CONCATENATE RETURNTREE NIL))
        NIL)))))
   (CL:IF (CONS? NAMETREE) (FIRST-SETTER NAMETREE WRAPPERNAME)
    (CL:SETQ NAMETREE WRAPPERNAME))
   (CL:RETURN-FROM YIELD-C-CALLABLE-WRAPPER-TREE
    (LIST* SYM-WALK-STELLA-DEFUN NAMETREE
     (CONS (%%VALUE (%%REST (%%REST DEFINITION)))
      (LIST* KWD-WALK-DOCUMENTATION
       (WRAP-STRING
        (CONCATENATE "C-callable wrapper for `"
         (%STRING-WRAPPER.WRAPPER-VALUE
          (CPP-TRANSLATE-METHOD-NAME METHOD CL:T))
         "'."))
       (LIST* KWD-WALK-PUBLIC? SYM-WALK-STELLA-TRUE KWD-WALK-AUXILIARY?
        SYM-WALK-STELLA-TRUE KWD-WALK-C-CALLABLE? SYM-WALK-STELLA-TRUE
        CALLTREE NIL)))))))

;;; (DEFUN (CREATE-C-CALLABLE-WRAPPER-UNIT METHOD-SLOT) ...)

(CL:DEFUN CREATE-C-CALLABLE-WRAPPER-UNIT (METHOD)
  (CL:LET*
   ((WRAPPERTREE (YIELD-C-CALLABLE-WRAPPER-TREE METHOD))
    (WRAPPERMETHOD NULL))
   (CL:SETQ WRAPPERMETHOD
    (%TRANSLATION-UNIT.THE-OBJECT
     (HELP-WALK-AUXILIARY-TREE WRAPPERTREE CL:T)))
   (CL:RETURN-FROM CREATE-C-CALLABLE-WRAPPER-UNIT WRAPPERMETHOD)))

;;; (DEFUN (C-CALLABLE-WRAPPER-METHOD? BOOLEAN) ...)

(CL:DEFUN C-CALLABLE-WRAPPER-METHOD? (METHOD)
  (CL:RETURN-FROM C-CALLABLE-WRAPPER-METHOD?
   (CL:AND
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-C-CALLABLE? FALSE-WRAPPER)))))

;;; (DEFUN (YIELD-FUNCTION-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-FUNCTION-CPP-SIGNATURE (FUNCTION FIRSTARGTYPE QUALIFY?)
  (CL:LET*
   ((*MODULE* (CL:IF QUALIFY? *ROOT-MODULE* (HOME-MODULE FUNCTION)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CL:EQ FIRSTARGTYPE NULL)
    (CL:SETQ FIRSTARGTYPE (%METHOD-SLOT.SLOT-OWNER FUNCTION)))
   (CL:LET*
    ((RETURNTYPE
      (COMPUTE-MOST-GENERAL-RETURN-TYPE FUNCTION
       (COMPUTE-RETURN-TYPE-SPEC FUNCTION FIRSTARGTYPE)))
     (CPPSIG
      (CONS
       (CONS (CPP-TRANSLATE-METHOD-NAME FUNCTION CL:T)
        (CONS
         (CL:IF (VOID? RETURNTYPE) (WRAP-STRING "void")
          (CPP-TRANSLATE-AND-POINTERIZE-TYPE-SPEC RETURNTYPE))
         (CONS
          (WRAP-STRING (STRINGIFY (TYPE-SPEC-TO-BASE-TYPE RETURNTYPE)))
          NIL)))
       NIL))
     (RETURNTYPES (METHOD-RETURN-TYPE-SPECIFIERS FUNCTION))
     (PARAMETERTYPES (METHOD-PARAMETER-TYPE-SPECIFIERS FUNCTION))
     (RETIDX 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM RETIDX))
    (CL:LET*
     ((PARAM NULL)
      (ITER-000 (CPP-TRANSLATE-FUNCTION-PARAMETERS FUNCTION))
      (I NULL-INTEGER) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PARAM (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:LET*
       ((TYPE (%%VALUE PARAM)) (NAME (%%VALUE (%%REST PARAM)))
        (STELLATYPE NULL))
       (CL:COND
        ((CL:EQ TYPE SYM-WALK-STELLA-CPP_VAR_ARGS)
         (CL:SETQ CPPSIG
          (CONS
           (CONS-LIST NAME (WRAP-STRING "int")
            (WRAP-STRING (STRINGIFY SGT-WALK-STELLA-INTEGER)))
           CPPSIG))
         (CL:SETQ NAME (WRAP-STRING "..."))
         (CL:SETQ STELLATYPE (VARIABLE-ARGUMENTS-TYPE FUNCTION))
         (CL:SETQ TYPE
          (CPP-TRANSLATE-AND-POINTERIZE-TYPE-SPEC STELLATYPE)))
        ((STARTS-WITH? (%STRING-WRAPPER.WRAPPER-VALUE NAME) "_Return"
          0)
         (CL:SETQ RETIDX (CL:1+ RETIDX))
         (CL:SETQ STELLATYPE (NTH RETURNTYPES RETIDX)))
        (CL:T (CL:SETQ STELLATYPE (NTH PARAMETERTYPES I))))
       (CL:SETQ STELLATYPE
        (COMPUTE-RELATIVE-TYPE-SPEC STELLATYPE FIRSTARGTYPE))
       (CL:SETQ CPPSIG
        (CONS
         (CONS-LIST NAME TYPE
          (WRAP-STRING
           (STRINGIFY (TYPE-SPEC-TO-BASE-TYPE STELLATYPE))))
         CPPSIG)))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:RETURN-FROM YIELD-FUNCTION-CPP-SIGNATURE (REVERSE CPPSIG)))))

;;; (DEFUN (CPP-TYPE-TO-C-TYPE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  CPP-TYPE-TO-C-TYPE))
(CL:DEFUN CPP-TYPE-TO-C-TYPE (TYPE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TYPE))
  #+MCL
  (CL:CHECK-TYPE TYPE CL:SIMPLE-STRING)
  (CL:LET* ((RETURNPARAMETER? (ENDS-WITH? TYPE "&" NULL-INTEGER)))
   (CL:WHEN RETURNPARAMETER?
    (CL:SETQ TYPE
     (SUBSEQUENCE TYPE 0 (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH TYPE))))))
   (CL:COND ((STRING-EQL? TYPE "boolean") (CL:SETQ TYPE "int"))
    ((STRING-EQL? TYPE "char*")) ((STRING-EQL? TYPE "const char*"))
    ((STRING-EQL? TYPE "cpp_function_code") (CL:SETQ TYPE "void*"))
    ((STRING-EQL? TYPE "cpp_method_code") (CL:SETQ TYPE "void*"))
    (CL:T
     (CL:LET* ((STARPOS (POSITION TYPE #\* 0)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM STARPOS))
      (CL:WHEN (CL:NOT (CL:= STARPOS NULL-INTEGER))
       (CL:SETQ TYPE
        (CONCATENATE "void*"
         (SUBSEQUENCE TYPE (CL:1+ STARPOS) NULL-INTEGER)))))))
   (CL:WHEN RETURNPARAMETER? (CL:SETQ TYPE (CONCATENATE TYPE "&")))
   (CL:RETURN-FROM CPP-TYPE-TO-C-TYPE TYPE)))

;;; (DEFUN (YIELD-FUNCTION-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-FUNCTION-C-SIGNATURE (FUNCTION FIRSTARGTYPE)
  (CL:LET*
   ((CPPSIGNATURE
     (YIELD-FUNCTION-CPP-SIGNATURE FUNCTION FIRSTARGTYPE CL:T))
    (CSIGNATURE NIL) (NAME STELLA::NULL-STRING)
    (TYPE STELLA::NULL-STRING) (STELLATYPE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME TYPE STELLATYPE))
   (FIRST-SETTER (%%VALUE CPPSIGNATURE)
    (CPP-TRANSLATE-NAME (YIELD-C-CALLABLE-WRAPPER-NAME FUNCTION)))
   (CL:LET* ((TUPLE NULL) (ITER-000 CPPSIGNATURE) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-000))
     (CL:SETQ NAME (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE TUPLE)))
     (CL:SETQ TYPE
      (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST TUPLE))))
     (CL:SETQ STELLATYPE
      (%STRING-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%%REST (%%REST TUPLE)))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CONS-LIST (WRAP-STRING NAME)
          (WRAP-STRING (CPP-TYPE-TO-C-TYPE TYPE))
          (WRAP-STRING STELLATYPE))
         NIL))
       (CL:IF (CL:EQ CSIGNATURE NIL) (CL:SETQ CSIGNATURE COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CSIGNATURE COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CONS-LIST (WRAP-STRING NAME)
          (WRAP-STRING (CPP-TYPE-TO-C-TYPE TYPE))
          (WRAP-STRING STELLATYPE))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-FUNCTION-C-SIGNATURE CSIGNATURE)))

;;; (DEFUN (YIELD-METHOD-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-METHOD-CPP-SIGNATURE (METHOD FIRSTARGTYPE QUALIFY?)
  (CL:LET*
   ((*MODULE* (CL:IF QUALIFY? *ROOT-MODULE* (HOME-MODULE METHOD)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET* ((SIG NULL) (TRANSNAME STELLA::NULL-STRING))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TRANSNAME))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) CL:T)
      (CL:SETQ SIG
       (YIELD-FUNCTION-CPP-SIGNATURE METHOD FIRSTARGTYPE QUALIFY?)))
     (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) CL:NIL))
    (CL:SETQ TRANSNAME
     (%STRING-WRAPPER.WRAPPER-VALUE
      (CPP-TRANSLATE-METHOD-NAME METHOD QUALIFY?)))
    (FIRST-SETTER (%%VALUE SIG) (WRAP-STRING TRANSNAME))
    (CL:RETURN-FROM YIELD-METHOD-CPP-SIGNATURE SIG))))

;;; (DEFUN (YIELD-METHOD-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-METHOD-C-SIGNATURE (METHOD FIRSTARGTYPE)
  (CL:LET*
   ((CPPNAME
     (%%VALUE
      (%%VALUE (YIELD-METHOD-CPP-SIGNATURE METHOD FIRSTARGTYPE CL:T))))
    (SIG NULL))
   (CL:UNWIND-PROTECT
    (CL:PROGN (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) CL:T)
     (CL:SETQ SIG (YIELD-FUNCTION-C-SIGNATURE METHOD FIRSTARGTYPE)))
    (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) CL:NIL))
   (FIRST-SETTER (%%VALUE SIG)
    (WRAP-STRING
     (REPLACE-SUBSTRINGS (%STRING-WRAPPER.WRAPPER-VALUE CPPNAME) "_"
      "::")))
   (CL:RETURN-FROM YIELD-METHOD-C-SIGNATURE SIG)))

;;; (DEFUN (YIELD-STORAGE-SLOT-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-STORAGE-SLOT-CPP-SIGNATURE (SLOT FIRSTARGTYPE QUALIFY?)
  (CL:LET*
   ((*MODULE* (CL:IF QUALIFY? *ROOT-MODULE* (HOME-MODULE SLOT)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CL:EQ FIRSTARGTYPE NULL)
    (CL:SETQ FIRSTARGTYPE (%STORAGE-SLOT.SLOT-OWNER SLOT)))
   (CL:LET*
    ((SLOTNAME
      (TRUE-SLOT-NAME (%STORAGE-SLOT.SLOT-NAME SLOT)
       (%STORAGE-SLOT.SLOT-OWNER SLOT)))
     (SLOTTYPE (COMPUTE-RETURN-TYPE-SPEC SLOT FIRSTARGTYPE))
     (CPPSIG
      (CONS
       (CONS (CPP-TRANSLATE-NAME SLOTNAME)
        (CONS (CPP-TRANSLATE-AND-POINTERIZE-TYPE-SPEC SLOTTYPE)
         (CONS
          (WRAP-STRING (STRINGIFY (TYPE-SPEC-TO-BASE-TYPE SLOTTYPE)))
          NIL)))
       NIL)))
    (CL:RETURN-FROM YIELD-STORAGE-SLOT-CPP-SIGNATURE CPPSIG))))

;;; (DEFUN (YIELD-STORAGE-SLOT-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-STORAGE-SLOT-C-SIGNATURE (SLOT FIRSTARGTYPE)
  (CL:LET*
   ((SIG (YIELD-STORAGE-SLOT-CPP-SIGNATURE SLOT FIRSTARGTYPE CL:T))
    (CPPNAME (%%VALUE (%%VALUE SIG)))
    (CPPTYPE (%%VALUE (%%REST (%%VALUE SIG)))))
   (FIRST-SETTER (%%VALUE SIG)
    (WRAP-STRING
     (REPLACE-SUBSTRINGS (%STRING-WRAPPER.WRAPPER-VALUE CPPNAME) "_"
      "::")))
   (SECOND-SETTER (%%VALUE SIG)
    (WRAP-STRING
     (CPP-TYPE-TO-C-TYPE (%STRING-WRAPPER.WRAPPER-VALUE CPPTYPE))))
   (CL:RETURN-FROM YIELD-STORAGE-SLOT-C-SIGNATURE SIG)))

;;; (DEFUN (YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE (GLOBAL QUALIFY?)
  (CL:LET*
   ((*MODULE* (CL:IF QUALIFY? *ROOT-MODULE* (HOME-MODULE GLOBAL)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((CPPSIG
      (CONS
       (CONS (CPP-TRANSLATE-GLOBAL-VARIABLE-NAME GLOBAL)
        (CONS
         (CPP-TRANSLATE-AND-POINTERIZE-TYPE-SPEC
          (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL))
         (CONS
          (WRAP-STRING
           (STRINGIFY
            (TYPE-SPEC-TO-BASE-TYPE
             (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL))))
          NIL)))
       NIL)))
    (CL:RETURN-FROM YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE CPPSIG))))

;;; (DEFUN (YIELD-GLOBAL-VARIABLE-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ...)

(CL:DEFUN YIELD-GLOBAL-VARIABLE-C-SIGNATURE (GLOBAL)
  (CL:LET*
   ((SIG (YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE GLOBAL CL:T))
    (CPPNAME (%%VALUE (%%VALUE SIG)))
    (CPPTYPE (%%VALUE (%%REST (%%VALUE SIG)))))
   (FIRST-SETTER (%%VALUE SIG)
    (WRAP-STRING
     (REPLACE-SUBSTRINGS (%STRING-WRAPPER.WRAPPER-VALUE CPPNAME) "_"
      "::")))
   (SECOND-SETTER (%%VALUE SIG)
    (WRAP-STRING
     (CPP-TYPE-TO-C-TYPE (%STRING-WRAPPER.WRAPPER-VALUE CPPTYPE))))
   (CL:RETURN-FROM YIELD-GLOBAL-VARIABLE-C-SIGNATURE SIG)))

;;; (DEFUN (LIST-SIGNATURE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  LIST-SIGNATURE-TO-STRING))
(CL:DEFUN LIST-SIGNATURE-TO-STRING (SIGNATURE)
  (CL:LET* ((SEP #\Tab) (SSIG (NEW-OUTPUT-STRING-STREAM)))
   (CL:LET*
    ((TUPLE NULL) (ITER-000 SIGNATURE) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:> I 0)
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM SSIG) SEP))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM SSIG)
      (UNWRAP-STRING (%%VALUE TUPLE)) SEP
      (UNWRAP-STRING (%%VALUE (%%REST TUPLE))) SEP
      (UNWRAP-STRING (%%VALUE (%%REST (%%REST TUPLE)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:RETURN-FROM LIST-SIGNATURE-TO-STRING (THE-STRING-READER SSIG))))

;;; (DEFUN (LOOKUP-FUNCTION-CODE-BY-NAME FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-FUNCTION-CODE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FUNCTION (LOOKUP-FUNCTION-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (CL:RETURN-FROM LOOKUP-FUNCTION-CODE-BY-NAME
     (%METHOD-SLOT.FUNCTION-CODE FUNCTION))
    (CL:RETURN-FROM LOOKUP-FUNCTION-CODE-BY-NAME NULL))))

;;; (DEFUN (LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FUNCTION (LOOKUP-FUNCTION-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (CL:RETURN-FROM LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME
     (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
       SYM-WALK-STELLA-C-CALLABLE-WRAPPER-CODE
       NULL-FUNCTION-CODE-WRAPPER)))
    (CL:RETURN-FROM LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME NULL))))

;;; (DEFUN (LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FUNCTION (LOOKUP-FUNCTION-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (CL:RETURN-FROM LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-FUNCTION-CPP-SIGNATURE FUNCTION NULL CL:T)))
    (CL:RETURN-FROM LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FUNCTION (LOOKUP-FUNCTION-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ FUNCTION NULL))
    (CL:RETURN-FROM LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-FUNCTION-C-SIGNATURE FUNCTION NULL)))
    (CL:RETURN-FROM LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-METHOD-CODE-BY-NAME CODE-WRAPPER) ...)

(CL:DEFUN LOOKUP-METHOD-CODE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((SLOT (LOOKUP-SLOT-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (METHOD-SLOT? SLOT)
    (CL:RETURN-FROM LOOKUP-METHOD-CODE-BY-NAME
     (%METHOD-SLOT.METHOD-CODE SLOT))
    (CL:RETURN-FROM LOOKUP-METHOD-CODE-BY-NAME NULL))))

;;; (DEFUN (LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((SLOT NULL) (CLASS NULL))
   (CL:MULTIPLE-VALUE-SETQ (SLOT CLASS)
    (LOOKUP-SLOT-AND-CLASS-BY-QUALIFIED-NAME QUALIFIEDNAME))
   (CL:IF (METHOD-SLOT? SLOT)
    (CL:RETURN-FROM LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-METHOD-CPP-SIGNATURE SLOT (%CLASS.CLASS-TYPE CLASS)
       CL:T)))
    (CL:RETURN-FROM LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-METHOD-C-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-METHOD-C-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-METHOD-C-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((SLOT NULL) (CLASS NULL))
   (CL:MULTIPLE-VALUE-SETQ (SLOT CLASS)
    (LOOKUP-SLOT-AND-CLASS-BY-QUALIFIED-NAME QUALIFIEDNAME))
   (CL:IF (METHOD-SLOT? SLOT)
    (CL:RETURN-FROM LOOKUP-METHOD-C-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-METHOD-C-SIGNATURE SLOT (%CLASS.CLASS-TYPE CLASS))))
    (CL:RETURN-FROM LOOKUP-METHOD-C-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((SLOT NULL) (CLASS NULL))
   (CL:MULTIPLE-VALUE-SETQ (SLOT CLASS)
    (LOOKUP-SLOT-AND-CLASS-BY-QUALIFIED-NAME QUALIFIEDNAME))
   (CL:IF (STORAGE-SLOT? SLOT)
    (CL:RETURN-FROM LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-STORAGE-SLOT-CPP-SIGNATURE SLOT (%CLASS.CLASS-TYPE CLASS)
       CL:T)))
    (CL:RETURN-FROM LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((SLOT NULL) (CLASS NULL))
   (CL:MULTIPLE-VALUE-SETQ (SLOT CLASS)
    (LOOKUP-SLOT-AND-CLASS-BY-QUALIFIED-NAME QUALIFIEDNAME))
   (CL:IF (STORAGE-SLOT? SLOT)
    (CL:RETURN-FROM LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-STORAGE-SLOT-C-SIGNATURE SLOT (%CLASS.CLASS-TYPE CLASS))))
    (CL:RETURN-FROM LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-CLASS-CPP-TYPE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-CLASS-CPP-TYPE-BY-NAME))
(CL:DEFUN LOOKUP-CLASS-CPP-TYPE-BY-NAME (QUALIFIEDNAME)
  "Return a namespace-qualified C++ translation of the class type
named by `qualifiedName' or NULL if no such STELLA class exists."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET* ((CLASS (LOOKUP-CLASS-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ CLASS NULL))
    (CL:LET* ((*MODULE* *ROOT-MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:RETURN-FROM LOOKUP-CLASS-CPP-TYPE-BY-NAME
      (%STRING-WRAPPER.WRAPPER-VALUE
       (CPP-TRANSLATE-AND-POINTERIZE-TYPE-SPEC
        (%CLASS.CLASS-TYPE CLASS)))))
    (CL:RETURN-FROM LOOKUP-CLASS-CPP-TYPE-BY-NAME STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((GLOBAL (LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ GLOBAL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE GLOBAL CL:T)))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME))
(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME (QUALIFIEDNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((GLOBAL (LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME QUALIFIEDNAME)))
   (CL:IF (CL:NOT (CL:EQ GLOBAL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME
     (LIST-SIGNATURE-TO-STRING
      (YIELD-GLOBAL-VARIABLE-C-SIGNATURE GLOBAL)))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME
     STELLA::NULL-STRING))))

;;; (DEFGLOBAL *GLOBAL-EXCEPTION-HANDLER* ...)

(CL:DEFVAR *GLOBAL-EXCEPTION-HANDLER* NULL
  "Handler to handle exceptions caught within a c-callable function that throws exceptions.
If non-NULL the handler will be called with two string arguments: message and context.
This is intended primarily for language environments that can't directly catch native
exceptions (e.g., if we are in C or Python).")

;;; (DEFUN (GET-GLOBAL-EXCEPTION-HANDLER FUNCTION-CODE) ...)

(CL:DEFUN GET-GLOBAL-EXCEPTION-HANDLER ()
  (CL:RETURN-FROM GET-GLOBAL-EXCEPTION-HANDLER
   *GLOBAL-EXCEPTION-HANDLER*))

;;; (DEFUN SET-GLOBAL-EXCEPTION-HANDLER ...)

(CL:DEFUN SET-GLOBAL-EXCEPTION-HANDLER (HANDLER)
  (CL:SETQ *GLOBAL-EXCEPTION-HANDLER* HANDLER)
  :VOID)

;;; (DEFUN CALL-GLOBAL-EXCEPTION-HANDLER ...)

(CL:DEFUN CALL-GLOBAL-EXCEPTION-HANDLER (E)
  (CL:LET* ((HANDLER (GET-GLOBAL-EXCEPTION-HANDLER)))
   (CL:IF (CL:NOT (CL:EQ HANDLER NULL))
    (CL:FUNCALL HANDLER (EXCEPTION-MESSAGE E) (EXCEPTION-CONTEXT E))
    (CL:ERROR E)))
  :VOID)

;;; (DEFGLOBAL *C-API-RESULT-BUFFER* ...)

(CL:DEFVAR *C-API-RESULT-BUFFER* NULL
  "Result buffer used to support temporary protection of garbage-collectable
objects when a C API function is called from a non-C environment (such as Python).")

;;; (DEFUN (GC-PROTECT-OBJECT NATIVE-OBJECT-POINTER) ...)

(CL:DEFUN GC-PROTECT-OBJECT (OBJECT)
  "Protect `object' from garbage collection.  Returns a handle that can later
be passed to `gc-release-object' to release `object' from garbage collection protection."
  (CL:RETURN-FROM GC-PROTECT-OBJECT OBJECT))

;;; (DEFUN (GC-RELEASE-OBJECT NATIVE-OBJECT-POINTER) ...)

(CL:DEFUN GC-RELEASE-OBJECT (HANDLE)
  "Release the object pointed to by `handle' from garbage collection protection
and return the protected object.  This frees `handle' but does not necessarily mean that the
object will be garbage collected, it just can be again, once all references to it disappear."
  (CL:RETURN-FROM GC-RELEASE-OBJECT HANDLE))

;;; (DEFUN (COMMAND? BOOLEAN) ...)

(CL:DEFUN COMMAND? (METHOD)
  "Return `true' if `method' is an evaluable command."
  (CL:RETURN-FROM COMMAND?
   (CL:AND
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-COMMAND? FALSE-WRAPPER))
    (%METHOD-SLOT.METHOD-FUNCTION? METHOD))))

;;; (DEFUN (LOOKUP-COMMAND METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-COMMAND (NAME)
  "If `name' names an evaluable command return its associated
command object;  otherwise, return `null'.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions."
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:IF (CL:AND (CL:NOT (CL:EQ FUNCTION NULL)) (COMMAND? FUNCTION))
    (CL:RETURN-FROM LOOKUP-COMMAND FUNCTION)
    (CL:RETURN-FROM LOOKUP-COMMAND NULL))))

;;; (DEFUN (LOOKUP-COMMAND-LIKE-FUNCTION METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-COMMAND-LIKE-FUNCTION (NAME)
  "Look up a function with `name' that can be evaluated via `apply'
just like a command, regardless of whether it was marked as such."
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
     (METHOD-CALLABLE-VIA-APPLY? FUNCTION))
    (CL:RETURN-FROM LOOKUP-COMMAND-LIKE-FUNCTION FUNCTION)
    (CL:RETURN-FROM LOOKUP-COMMAND-LIKE-FUNCTION NULL))))

;;; (DEFUN (METHOD-MUST-BE-EVALUABLE? BOOLEAN) ...)

(CL:DEFUN METHOD-MUST-BE-EVALUABLE? (METHOD)
  (CL:RETURN-FROM METHOD-MUST-BE-EVALUABLE?
   (CL:AND (COMMAND? METHOD)
    (CL:NOT
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-NATIVE? FALSE-WRAPPER))))))

;;; (DEFUN (METHOD-CALLABLE-VIA-APPLY? BOOLEAN) ...)

(CL:DEFUN METHOD-CALLABLE-VIA-APPLY? (METHOD)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:IF (CL:> (LENGTH (METHOD-PARAMETER-NAMES METHOD)) 10)
     (CL:SETQ TEST-VALUE-000 CL:T)
     (CL:IF (CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
      (CL:SETQ TEST-VALUE-000 CL:T)
      (CL:IF (SUBTYPE-OF? (TYPE METHOD) SGT-WALK-STELLA-LITERAL)
       (CL:SETQ TEST-VALUE-000 CL:T)
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((TSPEC NULL)
          (ITER-000
           (%LIST.THE-CONS-LIST
            (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ TSPEC (%%VALUE ITER-000))
          (CL:WHEN
           (SUBTYPE-OF? (TYPE-SPEC-TO-BASE-TYPE TSPEC)
            SGT-WALK-STELLA-LITERAL)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))))))
   (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM METHOD-CALLABLE-VIA-APPLY? VALUE-000))))

;;; (DEFUN (METHOD-NEEDS-EVALUATOR-WRAPPER? BOOLEAN) ...)

(CL:DEFUN METHOD-NEEDS-EVALUATOR-WRAPPER? (METHOD)
  (CL:RETURN-FROM METHOD-NEEDS-EVALUATOR-WRAPPER?
   (CL:AND (METHOD-MUST-BE-EVALUABLE? METHOD)
    (CL:NOT (METHOD-CALLABLE-VIA-APPLY? METHOD)))))

;;; (DEFUN (YIELD-EVALUATOR-WRAPPER-NAME SYMBOL) ...)

(CL:DEFUN YIELD-EVALUATOR-WRAPPER-NAME (METHODNAME)
  (CL:LET*
   ((BASE-NAME (%SYMBOL.SYMBOL-NAME METHODNAME))
    (SUFFIX
     (CL:IF (ALL-UPPER-CASE-STRING? BASE-NAME) "-EVALUATOR-WRAPPER"
      "-Evaluator-Wrapper")))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BASE-NAME SUFFIX))
   (CL:RETURN-FROM YIELD-EVALUATOR-WRAPPER-NAME
    (INTERN-DERIVED-SYMBOL METHODNAME (CONCATENATE BASE-NAME SUFFIX)))))

;;; (DEFUN (YIELD-ARGUMENT-ACCESS-TREE OBJECT) ...)

(CL:DEFUN YIELD-ARGUMENT-ACCESS-TREE (ARGUMENTSVARIABLE INDEX RESTARGUMENT?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
  #+MCL
  (CL:CHECK-TYPE INDEX CL:FIXNUM)
  (CL:LET* ((LIMIT 5) (ACCESSTREE ARGUMENTSVARIABLE))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LIMIT))
   (CL:IF (CL:<= INDEX LIMIT)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 2) (UPPER-BOUND-000 INDEX)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-000) (CL:SETQ I I)
      (CL:SETQ ACCESSTREE (LIST* SYM-WALK-STELLA-REST ACCESSTREE NIL))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:SETQ ACCESSTREE
     (LIST* SYM-WALK-STELLA-NTH-REST ACCESSTREE
      (CONS (WRAP-INTEGER (CL:1- INDEX)) NIL))))
   (CL:WHEN (CL:NOT RESTARGUMENT?)
    (CL:IF (CL:<= INDEX LIMIT)
     (CL:SETQ ACCESSTREE (LIST* SYM-WALK-STELLA-VALUE ACCESSTREE NIL))
     (CL:SETF (%%VALUE ACCESSTREE) SYM-WALK-STELLA-NTH)))
   (CL:RETURN-FROM YIELD-ARGUMENT-ACCESS-TREE ACCESSTREE)))

;;; (DEFUN (YIELD-EVALUATOR-WRAPPER-TREE CONS) ...)

(CL:DEFUN YIELD-EVALUATOR-WRAPPER-TREE (METHOD)
  (CL:LET*
   ((NAMETREE
     (YIELD-EVALUATOR-WRAPPER-NAME (%METHOD-SLOT.SLOT-NAME METHOD)))
    (CALLTREE (CONS (%METHOD-SLOT.SLOT-NAME METHOD) NIL))
    (PARAMETERTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (RESULTTYPE (TYPE METHOD))
    (NOFPARAMETERS (LENGTH PARAMETERTYPESPECS))
    (VARIABLEARGUMENTS?
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFPARAMETERS))
   (CL:LET*
    ((INDEX NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NOFPARAMETERS)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ INDEX ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (YIELD-ARGUMENT-ACCESS-TREE SYM-WALK-STELLA-ARGUMENTS INDEX
          (CL:AND (CL:= INDEX NOFPARAMETERS) VARIABLEARGUMENTS?))
         NIL))
       (CL:IF (CL:EQ CALLTREE NIL) (CL:SETQ CALLTREE COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST CALLTREE COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (YIELD-ARGUMENT-ACCESS-TREE SYM-WALK-STELLA-ARGUMENTS INDEX
          (CL:AND (CL:= INDEX NOFPARAMETERS) VARIABLEARGUMENTS?))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((PTYPE NULL) (ITER-001 (%LIST.THE-CONS-LIST PARAMETERTYPESPECS))
     (IT (ALLOCATE-ITERATOR (%%REST CALLTREE))))
    (CL:LOOP WHILE (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (NEXT? IT)) DO
     (CL:SETQ PTYPE (%%VALUE ITER-001))
     (CL:COND
      ((SUB-TYPE-SPEC-OF? PTYPE SGT-WALK-STELLA-LITERAL)
       (VALUE-SETTER IT
        (LIST* SYM-WALK-STELLA-WRAPPER-VALUE
         (LIST* SYM-WALK-STELLA-SAFE-CAST (%CONS-ITERATOR.VALUE IT)
          (CONS (TYPE-TO-WRAPPED-TYPE (TYPE-SPEC-TO-BASE-TYPE PTYPE))
           NIL))
         NIL)))
      ((SUB-TYPE-SPEC-OF? PTYPE SGT-WALK-STELLA-ARGUMENT-LIST)
       (PUSH-VARIABLE-BINDING SYM-WALK-STELLA-ARGUMENTS
        (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE METHOD))
       (VALUE-SETTER IT
        (SYS-TREE (WALK-WITHOUT-TYPE-TREE (%CONS-ITERATOR.VALUE IT))
         PTYPE))
       (POP-VARIABLE-BINDING))
      ((CL:NOT (CL:EQ PTYPE SGT-WALK-STELLA-OBJECT))
       (VALUE-SETTER IT
        (LIST* SYM-WALK-STELLA-SAFE-CAST (%CONS-ITERATOR.VALUE IT)
         (CONS (YIELD-TYPE-SPEC-TREE PTYPE) NIL)))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:COND ((VOID? RESULTTYPE))
    ((SUBTYPE-OF? RESULTTYPE SGT-WALK-STELLA-LITERAL)
     (CL:SETQ NAMETREE
      (CONS NAMETREE (CONS (TYPE-TO-WRAPPED-TYPE RESULTTYPE) NIL)))
     (CL:IF (CL:EQ (TYPE METHOD) SGT-WALK-STELLA-BOOLEAN)
      (CL:SETQ CALLTREE
       (LIST* SYM-WALK-STELLA-RETURN
        (LIST* SYM-WALK-STELLA-WRAP-BOOLEAN CALLTREE NIL) NIL))
      (CL:SETQ CALLTREE
       (LIST* SYM-WALK-STELLA-LET
        (CONS (LIST* SYM-WALK-STELLA-RESULT CALLTREE NIL) NIL)
        (LIST* SYM-WALK-STELLA-IF
         (LIST* SYM-WALK-STELLA-DEFINED? SYM-WALK-STELLA-RESULT NIL)
         (LIST* SYM-WALK-STELLA-RETURN
          (LIST* SYM-WALK-STELLA-WRAP-LITERAL SYM-WALK-STELLA-RESULT
           NIL)
          NIL)
         (LIST* SYM-WALK-STELLA-RETURN SYM-WALK-STELLA-NULL NIL) NIL)
        NIL))))
    (CL:T (CL:SETQ NAMETREE (CONS NAMETREE (CONS RESULTTYPE NIL)))
     (CL:SETQ CALLTREE (LIST* SYM-WALK-STELLA-RETURN CALLTREE NIL))))
   (CL:RETURN-FROM YIELD-EVALUATOR-WRAPPER-TREE
    (LIST* SYM-WALK-STELLA-DEFUN NAMETREE
     (LIST*
      (CONS (LIST* SYM-WALK-STELLA-ARGUMENTS SYM-WALK-STELLA-CONS NIL)
       NIL)
      KWD-WALK-AUXILIARY? SYM-WALK-STELLA-TRUE
      (CONCATENATE
       (CL:IF (CL:= NOFPARAMETERS 0)
        (CONS
         (LIST* SYM-WALK-STELLA-IGNORE SYM-WALK-STELLA-ARGUMENTS NIL)
         NIL)
        NIL)
       (CONS CALLTREE NIL)))))))

;;; (DEFUN (CREATE-EVALUATOR-WRAPPER-UNIT METHOD-SLOT) ...)

(CL:DEFUN CREATE-EVALUATOR-WRAPPER-UNIT (METHOD)
  (CL:LET*
   ((VARIABLEARGUMENTS?
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER)))
    (EVALUATEARGUMENTS? (METHOD-EVALUATE-ARGUMENTS? METHOD))
    (WRAPPERTREE (YIELD-EVALUATOR-WRAPPER-TREE METHOD))
    (WRAPPERMETHOD NULL))
   (CL:WHEN (CL:> (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS METHOD)) 1)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-WARNING)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
       EOL " During interpreted command evaluation only the" EOL
       " first return value will be usable." EOL))))
   (CL:WHEN (CL:NOT EVALUATEARGUMENTS?)
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
     SYM-WALK-STELLA-METHOD-EVALUATE-ARGUMENTS? TRUE-WRAPPER
     FALSE-WRAPPER))
   (CL:WHEN VARIABLEARGUMENTS?
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
     SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER
     FALSE-WRAPPER))
   (CL:SETQ WRAPPERMETHOD
    (%TRANSLATION-UNIT.THE-OBJECT
     (HELP-WALK-AUXILIARY-TREE WRAPPERTREE CL:T)))
   (CL:WHEN (CL:NOT EVALUATEARGUMENTS?)
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
     SYM-WALK-STELLA-METHOD-EVALUATE-ARGUMENTS? FALSE-WRAPPER
     FALSE-WRAPPER))
   (CL:WHEN VARIABLEARGUMENTS?
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
     SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? TRUE-WRAPPER
     FALSE-WRAPPER))
   (CL:RETURN-FROM CREATE-EVALUATOR-WRAPPER-UNIT WRAPPERMETHOD)))

;;; (DEFSPECIAL *EVALUATIONTREE* ...)

(CL:DEFVAR *EVALUATIONTREE* NULL)

;;; (DEFSPECIAL *EVALUATIONPARENTTREE* ...)

(CL:DEFVAR *EVALUATIONPARENTTREE* NULL)

;;; (DEFUN (EVALUATE OBJECT) ...)

(CL:DEFUN %EVALUATE (EXPRESSION)
  "Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call `evaluate-string'."
  (CL:LET* ((OTREE NULL))
   (CL:WHEN (CL:NOT (CL:EQ EXPRESSION NULL))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE EXPRESSION) SGT-WALK-STELLA-CONS)
      (CL:PROGN (CL:SETQ OTREE (EVALUATE-CONS-TREE EXPRESSION))))
     (CL:T (CL:SETQ OTREE (EVALUATE-ATOMIC-TREE EXPRESSION)))))
   (CL:RETURN-FROM %EVALUATE OTREE)))

(CL:DEFMACRO EVALUATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call `evaluate-string'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/EVALUATE|)) (CL:MACRO-FUNCTION (CL:QUOTE EVALUATE)))

;;; (DEFUN (EVALUATE-STRING OBJECT) ...)

(CL:DEFUN EVALUATE-STRING (EXPRESSION)
  "Evaluate the expression represented by `expression' and return the result.
This is equivalent to '(evaluate (unstringify expression))'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPRESSION))
  #+MCL
  (CL:CHECK-TYPE EXPRESSION CL:SIMPLE-STRING)
  (CL:RETURN-FROM EVALUATE-STRING
   (%EVALUATE (READ-S-EXPRESSION-FROM-STRING EXPRESSION))))

;;; (DEFUN (TRY-TO-EVALUATE OBJECT) ...)

(CL:DEFUN TRY-TO-EVALUATE (TREE)
  "Variant of `evaluate' that only evaluates `tree' if it
represents an evaluable expression.  If it does not, `tree' is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies."
  (CL:LET* ((OTREE TREE))
   (CL:WHEN (CL:NOT (CL:EQ TREE NULL))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN
        (CL:AND (SYMBOL? (%%VALUE TREE))
         (CL:NOT (CL:EQ (LOOKUP-COMMAND (%%VALUE TREE)) NULL)))
        (CL:HANDLER-CASE (CL:SETQ OTREE (EVALUATE-CONS-TREE TREE))
         (STELLA-EXCEPTION (E)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL " `"
             (EXCEPTION-MESSAGE E) "'." EOL))))))))
     (CL:T)))
   (CL:RETURN-FROM TRY-TO-EVALUATE OTREE)))

;;; (DEFUN (EVALUATE-CONS-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-CONS-TREE (TREE)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*) (*EVALUATIONTREE* TREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET*
    ((OPERATORNAME (%%VALUE TREE)) (ARGUMENTS (%%REST TREE))
     (OPERATOR NULL))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATORNAME))
      (CL:PROGN
       (CL:COND
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-QUOTE)
         (CL:WHEN (CL:= (LENGTH ARGUMENTS) 1)
          (CL:RETURN-FROM EVALUATE-CONS-TREE
           (CL:VALUES (%%VALUE ARGUMENTS)
            (PRIMARY-TYPE (%%VALUE ARGUMENTS)))))
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "While evaluating '" *EVALUATIONTREE*)
          (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) EOL
            "' inside '" *EVALUATIONPARENTTREE*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "':" EOL)
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "Illegal QUOTE expression")
          (CL:ERROR
           (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-000)))))
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-BQUOTE)
         (CL:RETURN-FROM EVALUATE-CONS-TREE
          (EVALUATE-BQUOTE-TREE TREE)))
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-CONS)
         (CL:LET*
          ((ARG1 (EVALUATE-ARGUMENT-TREE (%%VALUE ARGUMENTS) CL:T))
           (ARG2
            (EVALUATE-ARGUMENT-TREE (%%VALUE (%%REST ARGUMENTS))
             CL:T)))
          (CL:WHEN
           (CL:AND (CONS? ARG2)
            (CL:EQ (%%REST (%%REST ARGUMENTS)) NIL))
           (CL:RETURN-FROM EVALUATE-CONS-TREE
            (CL:VALUES (CONS ARG1 ARG2) SGT-WALK-STELLA-CONS)))
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
            "While evaluating '" *EVALUATIONTREE*)
           (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) EOL
             "' inside '" *EVALUATIONPARENTTREE*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "':" EOL)
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
            "Illegal CONS expression")
           (CL:ERROR
            (NEW-EVALUATION-EXCEPTION
             (THE-STRING-READER STREAM-001))))))
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-APPEND)
         (CL:LET*
          ((ARG1 (EVALUATE-ARGUMENT-TREE (%%VALUE ARGUMENTS) CL:T))
           (ARG2
            (EVALUATE-ARGUMENT-TREE (%%VALUE (%%REST ARGUMENTS))
             CL:T)))
          (CL:WHEN
           (CL:AND (CONS? ARG1) (CONS? ARG2)
            (CL:EQ (%%REST (%%REST ARGUMENTS)) NIL))
           (CL:RETURN-FROM EVALUATE-CONS-TREE
            (CL:VALUES (APPEND ARG1 ARG2) SGT-WALK-STELLA-CONS)))
          (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
            "While evaluating '" *EVALUATIONTREE*)
           (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) EOL
             "' inside '" *EVALUATIONPARENTTREE*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002) "':" EOL)
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
            "Illegal APPEND expression")
           (CL:ERROR
            (NEW-EVALUATION-EXCEPTION
             (THE-STRING-READER STREAM-002))))))
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-SETQ)
         (CL:WHEN (CL:= (LENGTH ARGUMENTS) 2)
          (CL:LET*
           ((VARNAME (%%VALUE ARGUMENTS))
            (VALUE (%%VALUE (%%REST ARGUMENTS))) (VALUETYPE NULL)
            (GLOBAL NULL))
           (CL:WHEN (SYMBOL? VARNAME)
            (CL:SETQ GLOBAL (LOOKUP-GLOBAL-VARIABLE VARNAME))
            (CL:WHEN (CL:EQ GLOBAL NULL)
             (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
               "While evaluating '" *EVALUATIONTREE*)
              (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
               (%%PRINT-STREAM
                (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003) EOL
                "' inside '" *EVALUATIONPARENTTREE*))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003) "':"
               EOL)
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
               "Undefined global variable: `" VARNAME "'")
              (CL:ERROR
               (NEW-EVALUATION-EXCEPTION
                (THE-STRING-READER STREAM-003)))))
            (CL:MULTIPLE-VALUE-SETQ (VALUE VALUETYPE)
             (EVALUATE-ARGUMENT-TREE VALUE CL:T))
            (WRITE-GLOBAL-VARIABLE-VALUE GLOBAL VALUE)
            (CL:RETURN-FROM EVALUATE-CONS-TREE
             (CL:VALUES VALUE VALUETYPE)))))
         (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
           "While evaluating '" *EVALUATIONTREE*)
          (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004) EOL
            "' inside '" *EVALUATIONPARENTTREE*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004) "':" EOL)
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
           "Illegal SETQ expression")
          (CL:ERROR
           (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-004)))))
        ((CL:EQ OPERATORNAME SYM-WALK-STELLA-PROGN)
         (CL:LET* ((ARG NULL) (ITER-000 ARGUMENTS))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000)) (%EVALUATE ARG)
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:RETURN-FROM EVALUATE-CONS-TREE
          (CL:VALUES NULL SGT-WALK-STELLA-VOID)))
        (CL:T (CL:SETQ OPERATOR (LOOKUP-COMMAND OPERATORNAME))
         (CL:WHEN (CL:EQ OPERATOR NULL)
          (CL:SETQ OPERATOR
           (LOOKUP-COMMAND-LIKE-FUNCTION OPERATORNAME)))
         (CL:WHEN (CL:EQ OPERATOR NULL)
          (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
            "While evaluating '" *EVALUATIONTREE*)
           (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005) EOL
             "' inside '" *EVALUATIONPARENTTREE*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005) "':" EOL)
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
            "Undefined operator: `" OPERATORNAME "'")
           (CL:ERROR
            (NEW-EVALUATION-EXCEPTION
             (THE-STRING-READER STREAM-005)))))))))
     (CL:T
      (CL:LET* ((STREAM-006 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006)
        "While evaluating '" *EVALUATIONTREE*)
       (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006) EOL
         "' inside '" *EVALUATIONPARENTTREE*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006)
        "':" EOL)
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-006)
        "Illegal operator: `" OPERATORNAME "'")
       (CL:ERROR
        (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-006))))))
    (CL:LET*
     ((EVALUATORWRAPPERCODE
       (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS OPERATOR)
         SYM-WALK-STELLA-EVALUATOR-WRAPPER-CODE
         NULL-FUNCTION-CODE-WRAPPER)))
      (EVALUATEARGS? (METHOD-EVALUATE-ARGUMENTS? OPERATOR))
      (VARIABLEARGS?
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS OPERATOR)
         SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER)))
      (PARAMETERTYPES (METHOD-PARAMETER-TYPE-SPECIFIERS OPERATOR))
      (NOFPARAMETERS (LENGTH PARAMETERTYPES))
      (NOFARGS (LENGTH ARGUMENTS))
      (MINARGS
       (CL:IF VARIABLEARGS? (CL:1- NOFPARAMETERS) NOFPARAMETERS))
      (MAXARGS (CL:IF VARIABLEARGS? NULL-INTEGER NOFPARAMETERS))
      (UNEVALUATEDARGS ARGUMENTS) (EVALUATEDARG NULL)
      (EVALUATEDARGTYPE NULL) (ARGINDEX 0) (RETURNTYPE (TYPE OPERATOR))
      (RESULT NULL))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM NOFPARAMETERS NOFARGS MINARGS MAXARGS
       ARGINDEX))
     (CL:WHEN
      (CL:OR (CL:< NOFARGS MINARGS)
       (CL:AND (CL:NOT (CL:= MAXARGS NULL-INTEGER))
        (CL:> NOFARGS MAXARGS)))
      (CL:LET*
       ((MINSTRING (INTEGER-TO-STRING (CL:TRUNCATE MINARGS)))
        (MAXSTRING ""))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MINSTRING MAXSTRING))
       (CL:COND ((CL:= MAXARGS NULL-INTEGER) (CL:SETQ MAXSTRING "+"))
        ((CL:> MAXARGS MINARGS)
         (CL:SETQ MAXSTRING
          (STRING-CONCATENATE "-"
           (INTEGER-TO-STRING (CL:TRUNCATE MAXARGS))))))
       (CL:LET* ((STREAM-007 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007)
         "While evaluating '" *EVALUATIONTREE*)
        (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007) EOL
          "' inside '" *EVALUATIONPARENTTREE*))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007) "':" EOL)
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-007)
         "Wrong number of arguments.  Expected `" MINSTRING "'`"
         MAXSTRING "' but got `" NOFARGS "'")
        (CL:ERROR
         (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-007))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ UNEVALUATEDARGS NIL)) DO
      (CL:MULTIPLE-VALUE-SETQ (EVALUATEDARG EVALUATEDARGTYPE)
       (EVALUATE-ARGUMENT-TREE (%%VALUE UNEVALUATEDARGS)
        EVALUATEARGS?))
      (CL:MULTIPLE-VALUE-SETQ (EVALUATEDARG EVALUATEDARGTYPE)
       (COERCE-EVALUATED-TREE EVALUATEDARG (%%VALUE UNEVALUATEDARGS)
        EVALUATEDARGTYPE
        (CL:IF (CL:>= ARGINDEX MINARGS)
         (VARIABLE-ARGUMENTS-TYPE OPERATOR)
         (NTH PARAMETERTYPES ARGINDEX))
        EVALUATEARGS?))
      (CL:SETF (%%VALUE UNEVALUATEDARGS) EVALUATEDARG)
      (CL:SETQ UNEVALUATEDARGS (%%REST UNEVALUATEDARGS))
      (CL:SETQ ARGINDEX (CL:1+ ARGINDEX)))
     (CL:IF (CL:NOT (CL:EQ EVALUATORWRAPPERCODE NULL))
      (CL:IF (VOID? RETURNTYPE)
       (CL:FUNCALL EVALUATORWRAPPERCODE ARGUMENTS)
       (CL:SETQ RESULT (CL:FUNCALL EVALUATORWRAPPERCODE ARGUMENTS)))
      (CL:IF (VOID? RETURNTYPE)
       (APPLY (%METHOD-SLOT.FUNCTION-CODE OPERATOR) ARGUMENTS)
       (CL:SETQ RESULT
        (APPLY (%METHOD-SLOT.FUNCTION-CODE OPERATOR) ARGUMENTS))))
     (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
      (CL:SETQ RETURNTYPE (PRIMARY-TYPE RESULT)))
     (CL:RETURN-FROM EVALUATE-CONS-TREE
      (CL:VALUES RESULT RETURNTYPE))))))

;;; (DEFUN (EVALUATE-ARGUMENT-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-ARGUMENT-TREE (TREE EVALUATE?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-CONS)
     (CL:PROGN
      (CL:IF EVALUATE?
       (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE
        (EVALUATE-CONS-TREE TREE))
       (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE
        (CL:VALUES TREE SGT-WALK-STELLA-CONS)))))
    ((SUBTYPE-OF-WRAPPER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE
       (CL:VALUES TREE (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE))))))
    (CL:T
     (CL:IF EVALUATE?
      (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE
       (EVALUATE-ATOMIC-TREE TREE))
      (CL:RETURN-FROM EVALUATE-ARGUMENT-TREE
       (CL:VALUES TREE (PRIMARY-TYPE TREE))))))))

;;; (DEFUN (EVALUATE-ATOMIC-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-ATOMIC-TREE (TREE)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*) (*EVALUATIONTREE* TREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:COND
        ((CL:EQ TREE SYM-WALK-STELLA-NULL)
         (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
          (CL:VALUES TREE SGT-WALK-STELLA-UNKNOWN)))
        ((CL:EQ TREE SYM-WALK-STELLA-NIL)
         (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
          (CL:VALUES NIL SGT-WALK-STELLA-CONS)))
        ((CL:EQ TREE SYM-WALK-STELLA-TRUE)
         (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
          (CL:VALUES TRUE-WRAPPER SGT-WALK-STELLA-BOOLEAN)))
        ((CL:EQ TREE SYM-WALK-STELLA-FALSE)
         (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
          (CL:VALUES FALSE-WRAPPER SGT-WALK-STELLA-BOOLEAN)))
        (CL:T
         (CL:LET* ((GLOBAL (LOOKUP-GLOBAL-VARIABLE TREE)))
          (CL:IF (CL:NOT (CL:EQ GLOBAL NULL))
           (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
            (CL:VALUES (READ-GLOBAL-VARIABLE-VALUE GLOBAL)
             (DYNAMIC-SLOT-VALUE
              (%GLOBAL-VARIABLE.DYNAMIC-SLOTS GLOBAL)
              SYM-WALK-STELLA-VARIABLE-TYPE-SPECIFIER NULL)))
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
             "While evaluating '" *EVALUATIONTREE*)
            (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) EOL
              "' inside '" *EVALUATIONPARENTTREE*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "':" EOL)
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
             "Undefined variable: `" TREE "'")
            (CL:ERROR
             (NEW-EVALUATION-EXCEPTION
              (THE-STRING-READER STREAM-000))))))))))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE SGT-WALK-STELLA-SURROGATE))))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE SGT-WALK-STELLA-KEYWORD))))
     ((SUBTYPE-OF-WRAPPER? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM EVALUATE-ATOMIC-TREE
        (CL:VALUES TREE (WRAPPED-TYPE-TO-TYPE (PRIMARY-TYPE TREE))))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "While evaluating '" *EVALUATIONTREE*)
       (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) EOL
         "' inside '" *EVALUATIONPARENTTREE*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "':" EOL)
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "Unknown atomic expression type: `" TREE "'")
       (CL:ERROR
        (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-001)))))))))

;;; (DEFUN (MAKE-EVALUATABLE-BQUOTE-TREE OBJECT) ...)

(CL:DEFUN MAKE-EVALUATABLE-BQUOTE-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-WALK-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-SYM)
        (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
         (LIST* SYM-WALK-STELLA-QUOTE
          (GET-SYM
           (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST TREE))))
          NIL)))
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-SGT)
        (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
         (GET-SGT
          (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST TREE))))))
       ((CL:EQ TEST-VALUE-000 SYM-WALK-STELLA-GET-KWD)
        (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
         (GET-KWD
          (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST TREE))))))
       (CL:T
        (CL:LET* ((ARGS NIL))
         (CL:LET*
          ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-000
              (CONS (MAKE-EVALUATABLE-BQUOTE-TREE ARG) NIL))
             (CL:IF (CL:EQ ARGS NIL) (CL:SETQ ARGS COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST ARGS COLLECT-000)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-000)
              (CONS (MAKE-EVALUATABLE-BQUOTE-TREE ARG) NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:LET* ((TEST-VALUE-001 (%%VALUE TREE)))
          (CL:COND
           ((CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-LIST*)
            (CL:WHEN (CL:EQ (%%REST ARGS) NIL)
             (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
              (%%VALUE ARGS)))
            (CL:SETQ ARGS (REVERSE ARGS))
            (CL:LET*
             ((CONSTREE
               (LIST* SYM-WALK-STELLA-CONS (%%VALUE (%%REST ARGS))
                (CONS (%%VALUE ARGS) NIL))))
             (CL:LET* ((ARG NULL) (ITER-001 (%%REST (%%REST ARGS))))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
               (CL:SETQ ARG (%%VALUE ITER-001))
               (CL:SETQ CONSTREE
                (LIST* SYM-WALK-STELLA-CONS ARG (CONS CONSTREE NIL)))
               (CL:SETQ ITER-001 (%%REST ITER-001))))
             (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE CONSTREE)))
           ((CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-CONCATENATE)
            (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
             (LIST* SYM-WALK-STELLA-APPEND (%%VALUE ARGS)
              (CONS (%%VALUE (%%REST ARGS)) NIL))))
           ((CL:EQ TEST-VALUE-001 SYM-WALK-STELLA-WRAP-LITERAL)
            (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
             (%%VALUE ARGS)))
           (CL:T
            (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE
             (CONS (%%VALUE TREE) ARGS)))))))))))
   (CL:T (CL:RETURN-FROM MAKE-EVALUATABLE-BQUOTE-TREE TREE))))

;;; (DEFUN (EVALUATE-BQUOTE-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN EVALUATE-BQUOTE-TREE (TREE)
  (CL:LET* ((ARGTREE NULL))
   (CL:LET* ((*USEHARDCODEDSYMBOLS?* CL:T))
    (CL:DECLARE (CL:SPECIAL *USEHARDCODEDSYMBOLS?*))
    (CL:SETQ ARGTREE
     (MAKE-EVALUATABLE-BQUOTE-TREE
      (EXPAND-BQUOTE-TREE (%%VALUE (%%REST TREE))))))
   (CL:RETURN-FROM EVALUATE-BQUOTE-TREE
    (EVALUATE-ARGUMENT-TREE ARGTREE CL:T))))

;;; (DEFUN (COERCE-EVALUATED-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN COERCE-EVALUATED-TREE (TREE SOURCETREE SOURCETYPE TARGETTYPE EVALUATE?)
  (CL:LET*
   ((*EVALUATIONPARENTTREE* *EVALUATIONTREE*)
    (*EVALUATIONTREE* SOURCETREE))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONPARENTTREE* *EVALUATIONTREE*))
   (CL:LET*
    ((SOURCEBASETYPE (TYPE-SPEC-TO-BASE-TYPE SOURCETYPE))
     (TARGETBASETYPE (TYPE-SPEC-TO-BASE-TYPE TARGETTYPE)))
    (CL:WHEN
     (CL:OR (CL:EQ TREE NULL) (CL:EQ TREE SYM-WALK-STELLA-NULL))
     (CL:LET* ((TEST-VALUE-000 TARGETTYPE))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-INTEGER)
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES NULL-INTEGER-WRAPPER TARGETTYPE)))
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-LONG-INTEGER)
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES NULL-LONG-INTEGER-WRAPPER TARGETTYPE)))
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-FLOAT)
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES NULL-FLOAT-WRAPPER TARGETTYPE)))
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-STRING)
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES NULL-STRING-WRAPPER TARGETTYPE)))
       ((CL:EQ TEST-VALUE-000 SGT-WALK-STELLA-BOOLEAN)
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES FALSE-WRAPPER TARGETTYPE)))
       (CL:T
        (CL:RETURN-FROM COERCE-EVALUATED-TREE
         (CL:VALUES NULL TARGETTYPE))))))
    (CL:WHEN
     (CL:AND (CL:EQ TARGETTYPE SGT-WALK-STELLA-BOOLEAN)
      (CL:NOT EVALUATE?))
     (CL:WHEN (CL:EQ TREE SYM-WALK-STELLA-TRUE)
      (CL:RETURN-FROM COERCE-EVALUATED-TREE
       (CL:VALUES TRUE-WRAPPER TARGETTYPE)))
     (CL:WHEN (CL:EQ TREE SYM-WALK-STELLA-FALSE)
      (CL:RETURN-FROM COERCE-EVALUATED-TREE
       (CL:VALUES FALSE-WRAPPER TARGETTYPE))))
    (CL:WHEN (SUBTYPE-OF? SOURCEBASETYPE TARGETBASETYPE)
     (CL:RETURN-FROM COERCE-EVALUATED-TREE
      (CL:VALUES TREE SOURCETYPE)))
    (CL:WHEN
     (CL:AND
      (CL:OR (CL:NOT EVALUATE?) (ISA? TREE SGT-WALK-STELLA-WRAPPER))
      (SUBTYPE-OF? SOURCEBASETYPE SGT-WALK-STELLA-LITERAL)
      (SUBTYPE-OF? (TYPE-TO-WRAPPED-TYPE SOURCEBASETYPE)
       TARGETBASETYPE))
     (CL:RETURN-FROM COERCE-EVALUATED-TREE
      (CL:VALUES TREE (TYPE-TO-WRAPPED-TYPE SOURCEBASETYPE))))
    (CL:WHEN
     (CL:AND (SUBTYPE-OF? TARGETBASETYPE SGT-WALK-STELLA-LITERAL)
      (SUBTYPE-OF? SOURCEBASETYPE
       (TYPE-TO-WRAPPED-TYPE TARGETBASETYPE)))
     (CL:RETURN-FROM COERCE-EVALUATED-TREE
      (CL:VALUES TREE TARGETTYPE)))
    (CL:IF (VOID? SOURCETYPE)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "While evaluating '" *EVALUATIONTREE*)
      (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        EOL "' inside '" *EVALUATIONPARENTTREE*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "':" EOL)
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" SOURCETREE "' does not return a value")
      (CL:ERROR
       (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-000))))
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "While evaluating '" *EVALUATIONTREE*)
      (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        EOL "' inside '" *EVALUATIONPARENTTREE*))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "':" EOL)
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "Type conflict: `" (YIELD-TYPE-SPEC-TREE SOURCETYPE)
       "' found where `" (YIELD-TYPE-SPEC-TREE TARGETTYPE)
       "' expected")
      (CL:ERROR
       (NEW-EVALUATION-EXCEPTION (THE-STRING-READER STREAM-001))))))))

(CL:DEFUN HELP-STARTUP-WALK1 ()
  (CL:PROGN
   (CL:SETQ KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL
     2))
   (CL:SETQ KWD-WALK-WARN-ABOUT-MISSING-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-MISSING-METHODS" NULL
     2))
   (CL:SETQ KWD-WALK-SUPPRESS-WARNINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPRESS-WARNINGS" NULL 2))
   (CL:SETQ KWD-WALK-USE-HARDCODED-SYMBOLS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-HARDCODED-SYMBOLS" NULL 2))
   (CL:SETQ KWD-WALK-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-WALK-USE-COMMON-LISP-CONSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-CONSES" NULL 2))
   (CL:SETQ KWD-WALK-USE-CPP-GARBAGE-COLLECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-CPP-GARBAGE-COLLECTOR" NULL
     2))
   (CL:SETQ KWD-WALK-MINIMIZE-JAVA-PREFIXES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MINIMIZE-JAVA-PREFIXES" NULL 2))
   (CL:SETQ KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-WITH-COPYRIGHT-HEADER"
     NULL 2))
   (CL:SETQ KWD-WALK-SUPPORT-UNEXEC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT-UNEXEC" NULL 2))
   (CL:SETQ KWD-WALK-USE-COMMON-LISP-VECTOR-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS"
     NULL 2))
   (CL:SETQ SYM-WALK-STELLA-SET-STELLA-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-STELLA-FEATURE" NULL 0))
   (CL:SETQ KWD-WALK-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-WALK-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-UNSET-STELLA-FEATURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSET-STELLA-FEATURE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MEMB?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMB?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*TRACED-KEYWORDS*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*TRACED-KEYWORDS*" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PRINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EOL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FLUSH-OUTPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLUSH-OUTPUT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STANDARD-OUTPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OUTPUT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ADD-TRACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-TRACE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DROP-TRACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DROP-TRACE" NULL 0))
   (CL:SETQ KWD-WALK-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ SGT-WALK-STELLA-F-GET-QUOTED-TREE-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-GET-QUOTED-TREE-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SGT-WALK-STELLA-TRANSLATION-UNIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATION-UNIT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOME-MODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TU-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TU-HOME-MODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-THE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-OBJECT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CATEGORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CATEGORY" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ANNOTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANNOTATION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CODE-REGISTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-REGISTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TRANSLATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-REFERENCED-GLOBALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCED-GLOBALS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GLOBAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 0))
   (CL:SETQ KWD-WALK-CPP (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-WALK-CPP-STANDALONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-STANDALONE" NULL 2))
   (CL:SETQ KWD-WALK-IDL (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-SET-TRANSLATOR-OUTPUT-LANGUAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-TRANSLATOR-OUTPUT-LANGUAGE"
     NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFCLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCLASS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFSLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFOPERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFOPERATOR" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFGLOBAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFGLOBAL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFSPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSPECIAL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFCONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONSTANT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFTYPE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFMACRO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMACRO" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK2 ()
  (CL:PROGN
   (CL:SETQ SYM-WALK-STELLA-STARTUP-TIME-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-VERBATIM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PRINT-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-METHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 0))
   (CL:SETQ KWD-WALK-JAVA-STANDALONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-STANDALONE" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-METHOD-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CONSTRUCTOR?" NULL 0))
   (CL:SETQ KWD-WALK-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ KWD-WALK-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ KWD-WALK-WALK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WALK" NULL 2))
   (CL:SETQ KWD-WALK-TRANSLATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-METHOD-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-MACRO?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-GLOBAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-TYPE-SPEC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-SPEC" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-GLOBALLY-INLINE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LOG-FUNCTION-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOG-FUNCTION-CALL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-START-FUNCTION-CALL-LOGGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-FUNCTION-CALL-LOGGING" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-STOP-FUNCTION-CALL-LOGGING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STOP-FUNCTION-CALL-LOGGING" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-SET-CALL-LOG-BREAK-POINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-CALL-LOG-BREAK-POINT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-BREAK-PROGRAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK-PROGRAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TERMINATE-PROGRAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINATE-PROGRAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PO" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQ?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQ?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
   (CL:SETQ SYM-WALK-STELLA->
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">" NULL 0))
   (CL:SETQ SYM-WALK-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-LISP-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-CODE" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OUTPUT-STREAM" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-INLINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-UNINITIALIZED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNINITIALIZED" NULL 1))
   (CL:SETQ KWD-WALK-SECOND-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SECOND-CLASS" NULL 2))
   (CL:SETQ SGT-WALK-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ KWD-WALK-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-WALK-ALIAS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALIAS" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 0))
   (CL:SETQ
    SYM-WALK-STELLA-ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-BAD-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD-SYS" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-LONG-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-CHARACTER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-WRAPPER" NULL 1)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK3 ()
  (CL:PROGN
   (CL:SETQ SGT-WALK-STELLA-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-INLINE-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WRAP-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LITERAL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INTEGER-TO-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-TO-BOOLEAN-WRAPPER" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-INTEGER-TO-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-TO-BOOLEAN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MUTABLE-STRING-TO-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING-TO-STRING" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STRING-TO-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-TO-MUTABLE-STRING" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-INTERN-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SYMBOL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CHARACTER-TO-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-TO-STRING" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYMBOL-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-NAME" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INLINE-UNWRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-UNWRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WRAPPER-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER-VALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NUMBER-WRAPPER-TO-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER-TO-FLOAT" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-SURROGATE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-NATIVE-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-INPUT-STREAM" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-NATIVE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-STREAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-<X>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<X>" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-SINGLE-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-FLOAT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-IDENTITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDENTITY" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-DOUBLE-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOUBLE-FLOAT" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-SHORT-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHORT-INTEGER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-UNSIGNED-SHORT-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSIGNED-SHORT-INTEGER" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-UNSIGNED-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNSIGNED-LONG-INTEGER" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-VRLET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TYPED-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-INLINE-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-INLINE-CALL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SAFE-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFE-CAST" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-NON-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-OBJECT" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "X" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-VOID-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID-SYS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-SET-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SET-DEFAULT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SETF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SLOT-VALUE-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE-SETTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-AREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AREF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-AREF-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AREF-SETTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WITH-PROCESS-LOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-PROCESS-LOCK" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LOOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUES" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SPECIAL" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK4 ()
  (CL:PROGN
   (CL:SETQ SYM-WALK-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MV-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-SETQ" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MV-BIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-BIND" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-BREAK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CONTINUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WHILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHILE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SOME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-OF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SELECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELECT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-TYPECASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPECASE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
   (CL:SETQ SYM-WALK-STELLA--
    (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
   (CL:SETQ |SYM-WALK-STELLA-/|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "/" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-BQUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BQUOTE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PRINT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PRINT-NATIVE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-NATIVE-STREAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ALLOCATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LOCAL-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOCAL-NEW" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MAKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FUNCALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCALL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-THE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CALL-SUPER-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CALL-SUPER-METHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SIGNAL-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-EXCEPTION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EXCEPTION-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXCEPTION-CASE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-UNWIND-PROTECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNWIND-PROTECT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-UNWIND-PROTECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-UNWIND-PROTECT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-SLOT-VALUE-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE-SETTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-SUPER-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-SUPER-METHOD" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-CALL-METHOD-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-SETTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-NEW" NULL 0))
   (CL:SETQ KWD-WALK-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ KWD-WALK-SYMBOLS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOLS" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-INTERN-RIGID-SYMBOL-WRT-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-RIGID-SYMBOL-WRT-MODULE"
     NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GET-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-STELLA-MODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INTERN-SYMBOL-AT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SYMBOL-AT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INTERN-SURROGATE-AT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-SURROGATE-AT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INTERN-KEYWORD-AT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-KEYWORD-AT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ KWD-WALK-INLINE-ARGUMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-ARGUMENT" NULL 2))
   (CL:SETQ SGT-WALK-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
   (CL:SETQ KWD-WALK-PLACE-WHERE-VRLET-WAS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PLACE-WHERE-VRLET-WAS" NULL 2))
   (CL:SETQ KWD-WALK-PLACE-WHERE-LAST-EXPRESSION-WAS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PLACE-WHERE-LAST-EXPRESSION-WAS"
     NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK5 ()
  (CL:PROGN
   (CL:SETQ KWD-WALK-DYNAMIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-IT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ON" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DYNAMIC-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-SLOTS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WHERE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WRAPPEDVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPEDVALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ KWD-WALK-BIT (INTERN-RIGID-SYMBOL-WRT-MODULE "BIT" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-DYNAMICSLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMICSLOTS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NEWVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEWVALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FOUNDMATCHINGENTRY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOUNDMATCHINGENTRY?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-THE-KV-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-KV-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-OLDVALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OLDVALUE" NULL 0))
   (CL:SETQ KWD-WALK-CONTEXT-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE?" NULL 2))
   (CL:SETQ KWD-WALK-DONT-INHERIT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-INHERIT?" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-ACCESS-IN-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCESS-IN-CONTEXT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-HOME-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOME-CONTEXT" NULL 0))
   (CL:SETQ KWD-WALK-COPY-TO-CHILDREN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPY-TO-CHILDREN?" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-UPDATE-IN-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPDATE-IN-CONTEXT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CS-VALUE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-ANY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-VARIABLE-DECLARATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-DECLARATION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ILLEGAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ILLEGAL-VARIABLE" NULL 0))
   (CL:SETQ KWD-WALK-UNBIND-WITH-DESTRUCTORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBIND-WITH-DESTRUCTORS" NULL 2))
   (CL:SETQ KWD-WALK-UNWIND-PROTECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNWIND-PROTECT" NULL 2))
   (CL:SETQ SGT-WALK-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYMBOL-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-ID" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-BOOLEAN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-BOOLEAN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-BOOLEAN?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LONG-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-LONG-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-LONG-INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-FLOAT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-FLOAT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-FLOAT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STRING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-STRING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-STRING?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CHARACTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-CHARACTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-CHARACTER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WRAPPER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-WRAPPER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-WRAPPER?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-VERBATIM-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-VERBATIM-STRING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-VERBATIM-STRING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-VERBATIM-STRING?" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-SURROGATE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-SURROGATE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-SURROGATE?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-TYPE?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYMBOL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-SYMBOL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-SYMBOL?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-TRANSIENT-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-TRANSIENT-SYMBOL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-TRANSIENT-SYMBOL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-TRANSIENT-SYMBOL?" NULL
     0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK6 ()
  (CL:PROGN
   (CL:SETQ SYM-WALK-STELLA-KEYWORD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-KEYWORD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-KEYWORD?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-CONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-CONS?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STELLA-CLASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-CLASS?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-CLASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-CLASS?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-STORAGE-SLOT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-STORAGE-SLOT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-STORAGE-SLOT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-SLOT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-METHOD-SLOT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF-METHOD-SLOT?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-ANCHORED-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-ANCHORED-TYPE-SPECIFIER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL
     1))
   (CL:SETQ SYM-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER?" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ISA?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SUBTYPE-OF?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTYPE-OF?" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-STRING-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-EQL?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SAFE-PRIMARY-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFE-PRIMARY-TYPE" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-PROCESS-LOCK-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCESS-LOCK-OBJECT" NULL 1))
   (CL:SETQ SGT-WALK-STELLA-STANDARD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-EQL-TO-BOOLEAN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-BOOLEAN?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQL-TO-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQL-TO-LONG-INTEGER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-LONG-INTEGER?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQL-TO-FLOAT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-FLOAT?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EQL-TO-STRING?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL-TO-STRING?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GET-QUOTED-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-QUOTED-TREE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-BODY-ARGUMENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-BODY-ARGUMENT?" NULL 0))
   (CL:SETQ KWD-WALK-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
   (CL:SETQ KWD-WALK-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-WALK-CONTINUABLE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUABLE-ERROR" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-CLASS-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CLASS-CPP-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CPP-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CLASS-JAVA-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-JAVA-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-LIST" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ALLOCATE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ITERATOR" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-ARGUMENT-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST-ITERATOR" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LENGTH" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-VARIABLE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-COPY-CONS-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPY-CONS-TREE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GET-SYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SYM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GET-SGT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-GET-KWD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-ARGUMENT-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-CACHED-INLINABLE-METHOD-BODY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHED-INLINABLE-METHOD-BODY" NULL
     0))
   (CL:SETQ KWD-WALK-INLINE-REFERENCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-REFERENCES" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-INLINE-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE-CALL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INHERITS-THROUGH" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-MAIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAIN" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-NATIVE?" NULL 0))
   (CL:SETQ KWD-WALK-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-FORWARD-DECLARATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-DECLARATION?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK7 ()
  (CL:PROGN
   (CL:SETQ SYM-WALK-STELLA-C-CALLABLE-WRAPPER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-CALLABLE-WRAPPER-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LOOKUP-FUNCTION-BY-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-FUNCTION-BY-NAME" NULL 0))
   (CL:SETQ KWD-WALK-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 2))
   (CL:SETQ KWD-WALK-EMBEDDED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMBEDDED" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-CLASS-CONSTRUCTOR-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CLASS-AUXILIARY-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-AUXILIARY-METHODS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-AUXILIARY-METHOD-REASON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY-METHOD-REASON" NULL 0))
   (CL:SETQ KWD-WALK-FIRST-CLASS-WITH-TYPECASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-CLASS-WITH-TYPECASE" NULL
     2))
   (CL:SETQ KWD-WALK-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-PRINT-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-OBJECT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NATIVE-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OUTPUT-STREAM" NULL 0))
   (CL:SETQ KWD-WALK-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSES" NULL 2))
   (CL:SETQ KWD-WALK-FINALIZE-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-CLASSES" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-FINALIZE-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-CLASSES" NULL 0))
   (CL:SETQ KWD-WALK-FINALIZE-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-METHODS" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-FINALIZE-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-SLOTS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CLEANUP-UNFINALIZED-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEANUP-UNFINALIZED-CLASSES" NULL
     0))
   (CL:SETQ
    SYM-WALK-STELLA-DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ KWD-WALK-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MACRO?" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 0))
   (CL:SETQ KWD-WALK-UNBOUND-SPECIAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
   (CL:SETQ KWD-WALK-GLOBALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALS" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-DEFINE-GLOBAL-VARIABLE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-GLOBAL-VARIABLE-OBJECT"
     NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ KWD-WALK-FINAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-CURRENT-STARTUP-TIME-PHASE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-STARTUP-TIME-PHASE?" NULL
     0))
   (CL:SETQ KWD-WALK-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULES" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-WITHIN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITHIN-MODULE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*STELLA-MODULE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STELLA-MODULE*" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*STARTUP-TIME-PHASE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STARTUP-TIME-PHASE*" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0))
   (CL:SETQ KWD-WALK-C-CALLABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-CALLABLE?" NULL 2))
   (CL:SETQ KWD-WALK-C-NAMESPACE-PREFIX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-NAMESPACE-PREFIX" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LOOKUP-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-FUNCTION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*BOOTSTRAP-LOCK*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*BOOTSTRAP-LOCK*" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-STELLA-ROOT-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-ROOT-EXCEPTION" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-SYS-SIGNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SIGNAL" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SYS-HANDLER-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-HANDLER-CASE" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-NATIVE-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-EXCEPTION" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-SYS-HANDLE-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-HANDLE-EXCEPTION" NULL 0))
   (CL:SETQ KWD-WALK-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-INITIAL-ELEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-ELEMENT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE" NULL 1))
   (CL:SETQ KWD-WALK-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 0))
   (CL:SETQ SGT-WALK-STELLA-COMPOUND-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPOUND-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SYM-WALK-STELLA-METHOD-LISP-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EXPRESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPRESSION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-*IGNORETRANSLATIONERRORS?*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*IGNORETRANSLATIONERRORS?*" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-CL-INCREMENTALLY-TRANSLATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-INCREMENTALLY-TRANSLATE" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-REGISTER-NATIVE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTER-NATIVE-NAME" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-C-CALLABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-C-CALLABLE?" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK8 ()
  (CL:PROGN
   (CL:SETQ SYM-WALK-STELLA-METHOD-C-NAMESPACE-PREFIX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-C-NAMESPACE-PREFIX" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-*C-API-RESULT-BUFFER*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*C-API-RESULT-BUFFER*" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NATIVE-OBJECT-POINTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OBJECT-POINTER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-THROWS-EXCEPTIONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-THROWS-EXCEPTIONS?" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-NATIVE-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-EXCEPTION" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-E
    (INTERN-RIGID-SYMBOL-WRT-MODULE "E" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-CALL-GLOBAL-EXCEPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CALL-GLOBAL-EXCEPTION-HANDLER"
     NULL 0))
   (CL:SETQ KWD-WALK-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ SYM-WALK-STELLA-CPP_VAR_ARGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP_VAR_ARGS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NTH-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH-REST" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-NTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-RESULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESULT" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-METHOD-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL
     0))
   (CL:SETQ SYM-WALK-STELLA-EVALUATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-APPEND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "APPEND" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-EVALUATOR-WRAPPER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-VARIABLE-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-LIST*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST*" NULL 0))
   (CL:SETQ SYM-WALK-STELLA-STARTUP-WALK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-WALK" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK9 ()
  (CL:PROGN
   (CL:SETQ *AVAILABLE-STELLA-FEATURES*
    (LIST KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
     KWD-WALK-WARN-ABOUT-MISSING-METHODS KWD-WALK-SUPPRESS-WARNINGS
     KWD-WALK-USE-HARDCODED-SYMBOLS KWD-WALK-USE-COMMON-LISP-STRUCTS
     KWD-WALK-USE-COMMON-LISP-CONSES KWD-WALK-USE-CPP-GARBAGE-COLLECTOR
     KWD-WALK-MINIMIZE-JAVA-PREFIXES
     KWD-WALK-TRANSLATE-WITH-COPYRIGHT-HEADER KWD-WALK-SUPPORT-UNEXEC))
   (CL:SETQ *CURRENT-STELLA-FEATURES* (LIST))
   (CL:SETQ *DEFAULT-STELLA-FEATURES*
    (LIST KWD-WALK-WARN-ABOUT-UNDEFINED-METHODS
     KWD-WALK-WARN-ABOUT-MISSING-METHODS
     KWD-WALK-USE-CPP-GARBAGE-COLLECTOR KWD-WALK-USE-COMMON-LISP-CONSES
     KWD-WALK-MINIMIZE-JAVA-PREFIXES))
   (RESET-STELLA-FEATURES)
   (CL:SETQ *TRANSLATOROUTPUTLANGUAGE* (RUNNING-IN-LANGUAGE))
   (CL:SETQ *TARGETTYPE* SGT-WALK-STELLA-VOID)
   (CL:SETQ *LOG-BREAK-POINT-COUNTER* NULL-INTEGER)
   (CL:SETQ *WRAPPED-TYPE-TABLE*
    (LIST*
     (LIST* SGT-WALK-STELLA-INTEGER-WRAPPER SGT-WALK-STELLA-INTEGER
      NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER-WRAPPER
      SGT-WALK-STELLA-LONG-INTEGER NIL)
     (LIST* SGT-WALK-STELLA-FLOAT-WRAPPER SGT-WALK-STELLA-FLOAT NIL)
     (LIST* SGT-WALK-STELLA-NUMBER-WRAPPER SGT-WALK-STELLA-NUMBER NIL)
     (LIST* SGT-WALK-STELLA-STRING-WRAPPER SGT-WALK-STELLA-STRING NIL)
     (LIST* SGT-WALK-STELLA-MUTABLE-STRING-WRAPPER
      SGT-WALK-STELLA-MUTABLE-STRING NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER-WRAPPER SGT-WALK-STELLA-CHARACTER
      NIL)
     (LIST* SGT-WALK-STELLA-BOOLEAN-WRAPPER SGT-WALK-STELLA-BOOLEAN
      NIL)
     (LIST* SGT-WALK-STELLA-FUNCTION-CODE-WRAPPER
      SGT-WALK-STELLA-FUNCTION-CODE NIL)
     (LIST* SGT-WALK-STELLA-METHOD-CODE-WRAPPER
      SGT-WALK-STELLA-METHOD-CODE NIL)
     NIL))
   (CL:SETQ *COERSION-TABLE*
    (LIST*
     (LIST* SGT-WALK-STELLA-BOOLEAN SGT-WALK-STELLA-BOOLEAN-WRAPPER
      SYM-WALK-STELLA-INLINE-WRAP-BOOLEAN NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-INTEGER-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER
      SGT-WALK-STELLA-LONG-INTEGER-WRAPPER SYM-WALK-STELLA-WRAP-LITERAL
      NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-BOOLEAN-WRAPPER
      SYM-WALK-STELLA-INTEGER-TO-BOOLEAN-WRAPPER NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-BOOLEAN
      SYM-WALK-STELLA-INTEGER-TO-BOOLEAN NIL)
     (LIST* SGT-WALK-STELLA-FLOAT SGT-WALK-STELLA-FLOAT-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-MUTABLE-STRING SGT-WALK-STELLA-STRING
      SYM-WALK-STELLA-MUTABLE-STRING-TO-STRING NIL)
     (LIST* SGT-WALK-STELLA-MUTABLE-STRING
      SGT-WALK-STELLA-MUTABLE-STRING-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-STRING SGT-WALK-STELLA-STRING-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-STRING SGT-WALK-STELLA-MUTABLE-STRING
      SYM-WALK-STELLA-STRING-TO-MUTABLE-STRING NIL)
     (LIST* SGT-WALK-STELLA-STRING SGT-WALK-STELLA-SYMBOL
      SYM-WALK-STELLA-INTERN-SYMBOL NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER SGT-WALK-STELLA-CHARACTER-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER SGT-WALK-STELLA-STRING
      SYM-WALK-STELLA-CHARACTER-TO-STRING NIL)
     (LIST* SGT-WALK-STELLA-FUNCTION-CODE
      SGT-WALK-STELLA-FUNCTION-CODE-WRAPPER
      SYM-WALK-STELLA-WRAP-LITERAL NIL)
     (LIST* SGT-WALK-STELLA-METHOD-CODE
      SGT-WALK-STELLA-METHOD-CODE-WRAPPER SYM-WALK-STELLA-WRAP-LITERAL
      NIL)
     (LIST* SGT-WALK-STELLA-SYMBOL SGT-WALK-STELLA-STRING
      SYM-WALK-STELLA-SYMBOL-NAME NIL)
     (LIST* SGT-WALK-STELLA-BOOLEAN-WRAPPER SGT-WALK-STELLA-BOOLEAN
      SYM-WALK-STELLA-INLINE-UNWRAP-BOOLEAN NIL)
     (LIST* SGT-WALK-STELLA-INTEGER-WRAPPER SGT-WALK-STELLA-INTEGER
      SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-INTEGER-WRAPPER
      SGT-WALK-STELLA-LONG-INTEGER SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER-WRAPPER
      SGT-WALK-STELLA-LONG-INTEGER SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-FLOAT-WRAPPER SGT-WALK-STELLA-FLOAT
      SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-NUMBER-WRAPPER SGT-WALK-STELLA-FLOAT
      SYM-WALK-STELLA-NUMBER-WRAPPER-TO-FLOAT NIL)
     (LIST* SGT-WALK-STELLA-STRING-WRAPPER SGT-WALK-STELLA-STRING
      SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-MUTABLE-STRING-WRAPPER
      SGT-WALK-STELLA-MUTABLE-STRING SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER-WRAPPER SGT-WALK-STELLA-CHARACTER
      SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-FUNCTION-CODE-WRAPPER
      SGT-WALK-STELLA-FUNCTION-CODE SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-METHOD-CODE-WRAPPER
      SGT-WALK-STELLA-METHOD-CODE SYM-WALK-STELLA-WRAPPER-VALUE NIL)
     (LIST* SGT-WALK-STELLA-SURROGATE SGT-WALK-STELLA-CLASS
      SYM-WALK-STELLA-SURROGATE-VALUE NIL)
     (LIST* SGT-WALK-STELLA-SURROGATE SGT-WALK-STELLA-MODULE
      SYM-WALK-STELLA-SURROGATE-VALUE NIL)
     (LIST* SGT-WALK-STELLA-INPUT-STREAM
      SGT-WALK-STELLA-NATIVE-INPUT-STREAM SYM-WALK-STELLA-NATIVE-STREAM
      NIL)
     (LIST* SGT-WALK-STELLA-OUTPUT-STREAM
      SGT-WALK-STELLA-NATIVE-OUTPUT-STREAM
      SYM-WALK-STELLA-NATIVE-STREAM NIL)
     (LIST* SGT-WALK-STELLA-NUMBER SGT-WALK-STELLA-INTEGER
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-INTEGER NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-NUMBER SGT-WALK-STELLA-LONG-INTEGER
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-LONG-INTEGER NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-NUMBER SGT-WALK-STELLA-FLOAT
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-FLOAT NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-FLOAT
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-FLOAT NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-SINGLE-FLOAT
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-SINGLE-FLOAT NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER SGT-WALK-STELLA-FLOAT
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-FLOAT NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER SGT-WALK-STELLA-SINGLE-FLOAT
      (LIST* SYM-WALK-STELLA-CAST SYM-WALK-STELLA-<X>
       SGT-WALK-STELLA-SINGLE-FLOAT NIL)
      NIL)
     (LIST* SGT-WALK-STELLA-FLOAT SGT-WALK-STELLA-SINGLE-FLOAT
      SYM-WALK-STELLA-IDENTITY NIL)
     (LIST* SGT-WALK-STELLA-FLOAT SGT-WALK-STELLA-DOUBLE-FLOAT
      SYM-WALK-STELLA-IDENTITY NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-SHORT-INTEGER
      SYM-WALK-STELLA-IDENTITY NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-LONG-INTEGER
      SYM-WALK-STELLA-IDENTITY NIL)
     (LIST* SGT-WALK-STELLA-INTEGER
      SGT-WALK-STELLA-UNSIGNED-SHORT-INTEGER SYM-WALK-STELLA-IDENTITY
      NIL)
     (LIST* SGT-WALK-STELLA-INTEGER
      SGT-WALK-STELLA-UNSIGNED-LONG-INTEGER SYM-WALK-STELLA-IDENTITY
      NIL)
     NIL))
   (CL:SETQ *SYMBOL-REGISTRY* (NEW-HASH-TABLE))
   (CL:SETQ *SYMBOL-SET* (NEW-LIST))
   (CL:SETQ *CURRENTFILENAME* STELLA::NULL-STRING)
   (CL:SETQ *SPECIALVARIABLESTACK* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *TYPE-PREDICATE-TABLE*
    (LIST*
     (LIST* SGT-WALK-STELLA-BOOLEAN SYM-WALK-STELLA-BOOLEAN?
      SYM-WALK-STELLA-SUBTYPE-OF-BOOLEAN? NIL)
     (LIST* SGT-WALK-STELLA-INTEGER SYM-WALK-STELLA-INTEGER?
      SYM-WALK-STELLA-SUBTYPE-OF-INTEGER? NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER SYM-WALK-STELLA-LONG-INTEGER?
      SYM-WALK-STELLA-SUBTYPE-OF-LONG-INTEGER? NIL)
     (LIST* SGT-WALK-STELLA-FLOAT SYM-WALK-STELLA-FLOAT?
      SYM-WALK-STELLA-SUBTYPE-OF-FLOAT? NIL)
     (LIST* SGT-WALK-STELLA-STRING SYM-WALK-STELLA-STRING?
      SYM-WALK-STELLA-SUBTYPE-OF-STRING? NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER SYM-WALK-STELLA-CHARACTER?
      SYM-WALK-STELLA-SUBTYPE-OF-CHARACTER? NIL)
     (LIST* SGT-WALK-STELLA-WRAPPER SYM-WALK-STELLA-WRAPPER?
      SYM-WALK-STELLA-SUBTYPE-OF-WRAPPER? NIL)
     (LIST* SGT-WALK-STELLA-BOOLEAN-WRAPPER SYM-WALK-STELLA-BOOLEAN?
      SYM-WALK-STELLA-SUBTYPE-OF-BOOLEAN? NIL)
     (LIST* SGT-WALK-STELLA-INTEGER-WRAPPER SYM-WALK-STELLA-INTEGER?
      SYM-WALK-STELLA-SUBTYPE-OF-INTEGER? NIL)
     (LIST* SGT-WALK-STELLA-LONG-INTEGER-WRAPPER
      SYM-WALK-STELLA-LONG-INTEGER?
      SYM-WALK-STELLA-SUBTYPE-OF-LONG-INTEGER? NIL)
     (LIST* SGT-WALK-STELLA-FLOAT-WRAPPER SYM-WALK-STELLA-FLOAT?
      SYM-WALK-STELLA-SUBTYPE-OF-FLOAT? NIL)
     (LIST* SGT-WALK-STELLA-STRING-WRAPPER SYM-WALK-STELLA-STRING?
      SYM-WALK-STELLA-SUBTYPE-OF-STRING? NIL)
     (LIST* SGT-WALK-STELLA-CHARACTER-WRAPPER
      SYM-WALK-STELLA-CHARACTER? SYM-WALK-STELLA-SUBTYPE-OF-CHARACTER?
      NIL)
     (LIST* SGT-WALK-STELLA-VERBATIM-STRING-WRAPPER
      SYM-WALK-STELLA-VERBATIM-STRING?
      SYM-WALK-STELLA-SUBTYPE-OF-VERBATIM-STRING? NIL)
     (LIST* SGT-WALK-STELLA-SURROGATE SYM-WALK-STELLA-SURROGATE?
      SYM-WALK-STELLA-SUBTYPE-OF-SURROGATE? NIL)
     (LIST* SGT-WALK-STELLA-TYPE SYM-WALK-STELLA-TYPE?
      SYM-WALK-STELLA-SUBTYPE-OF-TYPE? NIL)
     (LIST* SGT-WALK-STELLA-SYMBOL SYM-WALK-STELLA-SYMBOL?
      SYM-WALK-STELLA-SUBTYPE-OF-SYMBOL? NIL)
     (LIST* SGT-WALK-STELLA-TRANSIENT-SYMBOL
      SYM-WALK-STELLA-TRANSIENT-SYMBOL?
      SYM-WALK-STELLA-SUBTYPE-OF-TRANSIENT-SYMBOL? NIL)
     (LIST* SGT-WALK-STELLA-KEYWORD SYM-WALK-STELLA-KEYWORD?
      SYM-WALK-STELLA-SUBTYPE-OF-KEYWORD? NIL)
     (LIST* SGT-WALK-STELLA-CONS SYM-WALK-STELLA-CONS?
      SYM-WALK-STELLA-SUBTYPE-OF-CONS? NIL)
     (LIST* SGT-WALK-STELLA-CLASS SYM-WALK-STELLA-STELLA-CLASS?
      SYM-WALK-STELLA-SUBTYPE-OF-CLASS? NIL)
     (LIST* SGT-WALK-STELLA-STORAGE-SLOT SYM-WALK-STELLA-STORAGE-SLOT?
      SYM-WALK-STELLA-SUBTYPE-OF-STORAGE-SLOT? NIL)
     (LIST* SGT-WALK-STELLA-METHOD-SLOT SYM-WALK-STELLA-METHOD-SLOT?
      SYM-WALK-STELLA-SUBTYPE-OF-METHOD-SLOT? NIL)
     (LIST* SGT-WALK-STELLA-ANCHORED-TYPE-SPECIFIER
      SYM-WALK-STELLA-ANCHORED-TYPE-SPECIFIER?
      SYM-WALK-STELLA-SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? NIL)
     (LIST* SGT-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER
      SYM-WALK-STELLA-PARAMETRIC-TYPE-SPECIFIER?
      SYM-WALK-STELLA-SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? NIL)
     NIL))
   (CL:SETQ *NUMERIC-TYPE-HIERARCHY*
    (LIST SGT-WALK-STELLA-INTEGER SGT-WALK-STELLA-LONG-INTEGER
     SGT-WALK-STELLA-FLOAT SGT-WALK-STELLA-NUMBER))
   (CL:SETQ *MIXIN-IMPLEMENTATION-STYLE* KWD-WALK-SECOND-CLASS)
   (CL:SETQ *NATIVE-NAME-TABLE* (NEW-HASH-TABLE)))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK10 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PRINT-STELLA-FEATURES"
    "(DEFUN PRINT-STELLA-FEATURES () :DOCUMENTATION \"Print the list of enabled and disabled STELLA features.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION PRINT-STELLA-FEATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-STELLA-FEATURE"
    "(DEFUN SET-STELLA-FEATURE (|&REST| (FEATURES KEYWORD)) :DOCUMENTATION \"Enable all listed STELLA `features'.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %SET-STELLA-FEATURE)
    (CL:FUNCTION SET-STELLA-FEATURE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "UNSET-STELLA-FEATURE"
    "(DEFUN UNSET-STELLA-FEATURE (|&REST| (FEATURES KEYWORD)) :DOCUMENTATION \"Disable all listed STELLA `features'.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %UNSET-STELLA-FEATURE)
    (CL:FUNCTION UNSET-STELLA-FEATURE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RESET-STELLA-FEATURES"
    "(DEFUN RESET-STELLA-FEATURES () :DOCUMENTATION \"Reset STELLA features to their default settings.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION RESET-STELLA-FEATURES) NULL)
   (DEFINE-FUNCTION-OBJECT "ENABLED-STELLA-FEATURE?"
    "(DEFUN (ENABLED-STELLA-FEATURE? BOOLEAN) ((FEATURE KEYWORD)) :DOCUMENTATION \"Return true if the STELLA `feature' is currently enabled.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MEMB? *CURRENT-STELLA-FEATURES* FEATURE)))"
    (CL:FUNCTION ENABLED-STELLA-FEATURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "DISABLED-STELLA-FEATURE?"
    "(DEFUN (DISABLED-STELLA-FEATURE? BOOLEAN) ((FEATURE KEYWORD)) :DOCUMENTATION \"Return true if the STELLA `feature' is currently disabled.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NOT (MEMB? *CURRENT-STELLA-FEATURES* FEATURE))))"
    (CL:FUNCTION DISABLED-STELLA-FEATURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-IF"
    "(DEFUN TRACE-IF ((KEYWORD OBJECT) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"If `keyword' is a trace keyword that has been enabled with `add-trace'
print all the elements in `body' to standard output.  Otherwise, do nothing.
`keyword' can also be a list of keywords in which case printing is done if
one or more of them are trace enabled.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TRACE-IF) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-KEYWORD?"
    "(DEFUN (TRACE-KEYWORD? BOOLEAN) ((KEYWORD OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION TRACE-KEYWORD?) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TRACE"
    "(DEFUN (ADD-TRACE LIST) (|&REST| (KEYWORDS GENERALIZED-SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Enable trace messages identified by any of the listed `keywords'.  After
calling (`add-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will be executed when it is encountered.\")" (CL:FUNCTION %ADD-TRACE)
    (CL:FUNCTION ADD-TRACE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DROP-TRACE"
    "(DEFUN (DROP-TRACE LIST) (|&REST| (KEYWORDS GENERALIZED-SYMBOL)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Disable trace messages identified by any of the listed `keywords'.  After
calling (`drop-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will not be executed when it is encountered.\")"
    (CL:FUNCTION %DROP-TRACE)
    (CL:FUNCTION DROP-TRACE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "CLEAR-TRACE"
    "(DEFUN CLEAR-TRACE () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Disable all tracing previously enabled with `add-trace'.\")"
    (CL:FUNCTION CLEAR-TRACE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-OPTIMIZATION-LEVELS"
    "(DEFUN SET-OPTIMIZATION-LEVELS ((SAFETY INTEGER) (DEBUG INTEGER) (SPEED INTEGER) (SPACE INTEGER)) :DOCUMENTATION \"Set optimization levels for the qualities `safety', `debug',
`speed', and `space'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SET-OPTIMIZATION-LEVELS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRESERVE-TAIL-MERGE-OPTIMIZABILITY?"
    "(DEFUN (PRESERVE-TAIL-MERGE-OPTIMIZABILITY? BOOLEAN) ())"
    (CL:FUNCTION PRESERVE-TAIL-MERGE-OPTIMIZABILITY?) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-CALL-INLINING-ENABLED?"
    "(DEFUN (METHOD-CALL-INLINING-ENABLED? BOOLEAN) ())"
    (CL:FUNCTION METHOD-CALL-INLINING-ENABLED?) NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMIZE-BOOLEAN-TESTS?"
    "(DEFUN (OPTIMIZE-BOOLEAN-TESTS? BOOLEAN) ())"
    (CL:FUNCTION OPTIMIZE-BOOLEAN-TESTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-FOR-ILLEGAL-RETURN?"
    "(DEFUN (CHECK-FOR-ILLEGAL-RETURN? BOOLEAN) ())"
    (CL:FUNCTION CHECK-FOR-ILLEGAL-RETURN?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUPPORT-UNEXEC?"
    "(DEFUN (SUPPORT-UNEXEC? BOOLEAN) ())"
    (CL:FUNCTION SUPPORT-UNEXEC?) NULL)
   (DEFINE-FUNCTION-OBJECT "NAME-QUOTED-TREE"
    "(DEFUN (NAME-QUOTED-TREE STRING) ((TREE CONS)))"
    (CL:FUNCTION NAME-QUOTED-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-QUOTED-TREE"
    "(DEFUN (GET-QUOTED-TREE CONS) ((TREE-NAME STRING) (MODULENAME STRING)) :DOCUMENTATION \"Return the quoted tree with name `tree-name'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-QUOTED-TREE) NULL)
   (DEFINE-INLINE-METHOD-CODE SGT-WALK-STELLA-TRANSLATION-UNIT
    SYM-WALK-STELLA-HOME-MODULE
    (WRAP-METHOD-CODE (CL:FUNCTION HOME-MODULE)) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-TRANSLATION-UNIT"
    "(DEFUN CLEAR-TRANSLATION-UNIT ((SELF TRANSLATION-UNIT)))"
    (CL:FUNCTION CLEAR-TRANSLATION-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-TRANSLATION-UNIT"
    "(DEFUN PRINT-TRANSLATION-UNIT ((SELF TRANSLATION-UNIT) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-TRANSLATION-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-HARDCODED-SYMBOLS?"
    "(DEFUN (USE-HARDCODED-SYMBOLS? BOOLEAN) ())"
    (CL:FUNCTION USE-HARDCODED-SYMBOLS?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATOR-OUTPUT-LANGUAGE"
    "(DEFUN (TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) () :GLOBALLY-INLINE? TRUE (RETURN *TRANSLATOROUTPUTLANGUAGE*))"
    (CL:FUNCTION TRANSLATOR-OUTPUT-LANGUAGE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATOR-OUTPUT-LANGUAGE-NAME"
    "(DEFUN (TRANSLATOR-OUTPUT-LANGUAGE-NAME STRING) ())"
    (CL:FUNCTION TRANSLATOR-OUTPUT-LANGUAGE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-TRANSLATOR-OUTPUT-LANGUAGE"
    "(DEFUN (SET-TRANSLATOR-OUTPUT-LANGUAGE KEYWORD) ((NEW-LANGUAGE KEYWORD)) :DOCUMENTATION \"Set output language to `new-language'.  Return previous language.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-TRANSLATOR-OUTPUT-LANGUAGE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-TO-COMMON-LISP?"
    "(DEFUN (TRANSLATE-TO-COMMON-LISP? BOOLEAN) () :DOCUMENTATION \"Return `true' if current output language is Common-Lisp.\")"
    (CL:FUNCTION TRANSLATE-TO-COMMON-LISP?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-TO-CPP?"
    "(DEFUN (TRANSLATE-TO-CPP? BOOLEAN) () :DOCUMENTATION \"Return `true' if current output language is C++\")"
    (CL:FUNCTION TRANSLATE-TO-CPP?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-TO-JAVA?"
    "(DEFUN (TRANSLATE-TO-JAVA? BOOLEAN) () :DOCUMENTATION \"Return `true' if current output language is Java\")"
    (CL:FUNCTION TRANSLATE-TO-JAVA?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?"
    "(DEFUN (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE? BOOLEAN) ())"
    (CL:FUNCTION TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-OUTPUT-LANGUAGE"
    "(DEFUN (TOGGLE-OUTPUT-LANGUAGE KEYWORD) () :DOCUMENTATION \"Switch between Common Lisp and C++ as output languages.\")"
    (CL:FUNCTION TOGGLE-OUTPUT-LANGUAGE) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-BOOTSTRAP-TRANSLATOR?"
    "(DEFUN (USE-BOOTSTRAP-TRANSLATOR? BOOLEAN) ())"
    (CL:FUNCTION USE-BOOTSTRAP-TRANSLATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-TRANSLATORS"
    "(DEFUN (TOGGLE-TRANSLATORS KEYWORD) ())"
    (CL:FUNCTION TOGGLE-TRANSLATORS) NULL)
   (DEFINE-FUNCTION-OBJECT "DECLARATION-OPERATOR?"
    "(DEFUN (DECLARATION-OPERATOR? BOOLEAN) ((OPERATOR SYMBOL)))"
    (CL:FUNCTION DECLARATION-OPERATOR?) NULL)
   (DEFINE-FUNCTION-OBJECT "DECLARATION-TREE?"
    "(DEFUN (DECLARATION-TREE? BOOLEAN) ((TREE CONS)) :PUBLIC? TRUE)"
    (CL:FUNCTION DECLARATION-TREE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-ANNOTATION"
    "(DEFUN (CREATE-ANNOTATION STRING) ((TOP-LEVEL-TREE CONS)))"
    (CL:FUNCTION CREATE-ANNOTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-TOP-LEVEL-TREE"
    "(DEFUN WALK-TOP-LEVEL-TREE ((TREE CONS) (CREATEANNOTATION? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION WALK-TOP-LEVEL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-TOP-LEVEL-EXPRESSION"
    "(DEFUN (WALK-TOP-LEVEL-EXPRESSION OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION WALK-TOP-LEVEL-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-PHASE-ONE-UNIT"
    "(DEFUN WALK-PHASE-ONE-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-PHASE-ONE-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-AUXILIARY-TREE"
    "(DEFUN WALK-AUXILIARY-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-AUXILIARY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-WALK-AUXILIARY-TREE"
    "(DEFUN (HELP-WALK-AUXILIARY-TREE TRANSLATION-UNIT) ((TREE CONS) (FINALIZE? BOOLEAN)))"
    (CL:FUNCTION HELP-WALK-AUXILIARY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-ALL-PHASE-ONE-UNITS"
    "(DEFUN WALK-ALL-PHASE-ONE-UNITS ())"
    (CL:FUNCTION WALK-ALL-PHASE-ONE-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-ALL-UNITS"
    "(DEFUN TRANSLATE-ALL-UNITS ())" (CL:FUNCTION TRANSLATE-ALL-UNITS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "UNIT-INCLUDED-IN-OTHER-UNITS?"
    "(DEFUN (UNIT-INCLUDED-IN-OTHER-UNITS? BOOLEAN) ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION UNIT-INCLUDED-IN-OTHER-UNITS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMBINE-TRANSLATED-TREES"
    "(DEFUN (COMBINE-TRANSLATED-TREES CONS) ())"
    (CL:FUNCTION COMBINE-TRANSLATED-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-WALKED-TREE"
    "(DEFUN (TRANSLATE-WALKED-TREE OBJECT) ((CODETREE OBJECT)))"
    (CL:FUNCTION TRANSLATE-WALKED-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREMENTALLY-TRANSLATE"
    "(DEFUN (INCREMENTALLY-TRANSLATE OBJECT) ((TREE OBJECT)) :DOCUMENTATION \"Translate a single Stella expression `tree' and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION INCREMENTALLY-TRANSLATE) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-TRANSLATION-ERRORS"
    "(DEFUN RESET-TRANSLATION-ERRORS ())"
    (CL:FUNCTION RESET-TRANSLATION-ERRORS) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-TRANSLATION-ERROR"
    "(DEFUN SIGNAL-TRANSLATION-ERROR () :PUBLIC? TRUE)"
    (CL:FUNCTION SIGNAL-TRANSLATION-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-TRANSLATION-WARNING"
    "(DEFUN SIGNAL-TRANSLATION-WARNING () :PUBLIC? TRUE)"
    (CL:FUNCTION SIGNAL-TRANSLATION-WARNING) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-TRANSLATION-NOTE"
    "(DEFUN SIGNAL-TRANSLATION-NOTE () :PUBLIC? TRUE)"
    (CL:FUNCTION SIGNAL-TRANSLATION-NOTE) NULL)
   (DEFINE-FUNCTION-OBJECT "IGNORE-TRANSLATION-ERRORS?"
    "(DEFUN (IGNORE-TRANSLATION-ERRORS? BOOLEAN) ())"
    (CL:FUNCTION IGNORE-TRANSLATION-ERRORS?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATION-ERRORS?"
    "(DEFUN (TRANSLATION-ERRORS? BOOLEAN) () :PUBLIC? TRUE)"
    (CL:FUNCTION TRANSLATION-ERRORS?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUMMARIZE-TRANSLATION-ERRORS"
    "(DEFUN SUMMARIZE-TRANSLATION-ERRORS ())"
    (CL:FUNCTION SUMMARIZE-TRANSLATION-ERRORS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ERROR-CONTEXT"
    "(DEFUN PRINT-ERROR-CONTEXT ((PREFIX STRING) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-ERROR-CONTEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-FUNCTION-CALL?"
    "(DEFUN (LOG-FUNCTION-CALL? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION LOG-FUNCTION-CALL?) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE"
    "(DEFUN (WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE CONS) ((METHOD METHOD-SLOT) (BODY CONS)))"
    (CL:FUNCTION WRAP-BODY-WITH-LOG-FUNCTION-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-FUNCTION-CALL"
    "(DEFUN LOG-FUNCTION-CALL ((NAME STRING)))"
    (CL:FUNCTION LOG-FUNCTION-CALL) NULL)
   (DEFINE-FUNCTION-OBJECT "START-FUNCTION-CALL-LOGGING"
    "(DEFUN START-FUNCTION-CALL-LOGGING ((FILENAME STRING)) :DOCUMENTATION \"Start function call logging to `fileName'.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %START-FUNCTION-CALL-LOGGING)
    (CL:FUNCTION START-FUNCTION-CALL-LOGGING-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STOP-FUNCTION-CALL-LOGGING"
    "(DEFUN STOP-FUNCTION-CALL-LOGGING () :DOCUMENTATION \"Stop function call logging and close the current log file.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION STOP-FUNCTION-CALL-LOGGING) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK11 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-CALL-LOG-BREAK-POINT"
    "(DEFUN SET-CALL-LOG-BREAK-POINT ((COUNT INTEGER)) :DOCUMENTATION \"Set a call log break point to `count'.  Execution will be
interrupted right at the entry of the `count'th logged function call.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-CALL-LOG-BREAK-POINT)
    (CL:FUNCTION SET-CALL-LOG-BREAK-POINT-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "BREAK-PROGRAM"
    "(DEFUN BREAK-PROGRAM ((MESSAGE STRING)) :DOCUMENTATION \"Interrupt the program and print `message'.  Continue after
confirmation with the user.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %BREAK-PROGRAM)
    (CL:FUNCTION BREAK-PROGRAM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TERMINATE-PROGRAM"
    "(DEFUN TERMINATE-PROGRAM () :DOCUMENTATION \"Terminate and exit the program with normal exit code.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION TERMINATE-PROGRAM) NULL)
   (DEFINE-FUNCTION-OBJECT "PO" "(DEFUN PO ((THING OBJECT)))"
    (CL:FUNCTION PO) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-EQL?"
    "(DEFUN (VARIABLE-EQL? BOOLEAN) ((VAR1 SYMBOL) (VAR2 SYMBOL)))"
    (CL:FUNCTION VARIABLE-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VARIABLE-TABLE"
    "(DEFUN (LOOKUP-VARIABLE-TABLE (LIKE (ANY-VALUE SELF))) ((SELF (KEY-VALUE-LIST OF SYMBOL OBJECT)) (VARIABLE SYMBOL)))"
    (CL:FUNCTION LOOKUP-VARIABLE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "INSERT-AT-VARIABLE-TABLE"
    "(DEFUN INSERT-AT-VARIABLE-TABLE ((SELF (KEY-VALUE-LIST OF SYMBOL OBJECT)) (VARIABLE SYMBOL) (VALUE OBJECT)))"
    (CL:FUNCTION INSERT-AT-VARIABLE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-VARIABLE-BINDING"
    "(DEFUN PUSH-VARIABLE-BINDING ((VARIABLE SYMBOL) (TYPE TYPE-SPEC)))"
    (CL:FUNCTION PUSH-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-VARIABLE-BINDING"
    "(DEFUN POP-VARIABLE-BINDING ())"
    (CL:FUNCTION POP-VARIABLE-BINDING) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VARIABLE-TYPE"
    "(DEFUN (LOOKUP-VARIABLE-TYPE TYPE-SPEC) ((VARIABLENAME SYMBOL)))"
    (CL:FUNCTION LOOKUP-VARIABLE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-LOCAL-VARIABLE-INFO"
    "(DEFUN SET-LOCAL-VARIABLE-INFO ((VARIABLE SYMBOL) (KEY KEYWORD) (INFO OBJECT)))"
    (CL:FUNCTION SET-LOCAL-VARIABLE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-LOCAL-VARIABLE-INFO"
    "(DEFUN (GET-LOCAL-VARIABLE-INFO OBJECT) ((VARIABLE SYMBOL) (KEY KEYWORD)))"
    (CL:FUNCTION GET-LOCAL-VARIABLE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-REFERENCE-TO-GLOBAL-VARIABLE"
    "(DEFUN REGISTER-REFERENCE-TO-GLOBAL-VARIABLE ((VARIABLENAME SYMBOL)))"
    (CL:FUNCTION REGISTER-REFERENCE-TO-GLOBAL-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOCAL-GENSYM"
    "(DEFUN (LOCAL-GENSYM SYMBOL) ((PREFIX STRING)))"
    (CL:FUNCTION LOCAL-GENSYM) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-GENSYM"
    "(DEFUN (METHOD-GENSYM SYMBOL) ((PREFIX STRING)))"
    (CL:FUNCTION METHOD-GENSYM) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-LOCAL-VARIABLE-ALIAS"
    "(DEFUN (YIELD-LOCAL-VARIABLE-ALIAS SYMBOL) ((VARIABLE SYMBOL) (LEVEL INTEGER)))"
    (CL:FUNCTION YIELD-LOCAL-VARIABLE-ALIAS) NULL)
   (DEFINE-FUNCTION-OBJECT "RENAME-SHADOWING-LOCAL-VARIABLES?"
    "(DEFUN (RENAME-SHADOWING-LOCAL-VARIABLES? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (EQL? (TRANSLATOR-OUTPUT-LANGUAGE) :JAVA)))"
    (CL:FUNCTION RENAME-SHADOWING-LOCAL-VARIABLES?) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-RENAME-LOCAL-VARIABLE"
    "(DEFUN MAYBE-RENAME-LOCAL-VARIABLE ((VARIABLE SYMBOL)))"
    (CL:FUNCTION MAYBE-RENAME-LOCAL-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-VARIABLE-NAME"
    "(DEFUN (TRUE-VARIABLE-NAME SYMBOL) ((VARIABLE SYMBOL)))"
    (CL:FUNCTION TRUE-VARIABLE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SUPPRESS-WARNINGS?"
    "(DEFUN (SUPPRESS-WARNINGS? BOOLEAN) () :PUBLIC? TRUE)"
    (CL:FUNCTION SUPPRESS-WARNINGS?) NULL)
   (DEFINE-FUNCTION-OBJECT "BAD-ARGUMENT-RANGE?"
    "(DEFUN (BAD-ARGUMENT-RANGE? BOOLEAN) ((TREE CONS) (MINARITY INTEGER) (MAXARITY INTEGER)))"
    (CL:FUNCTION BAD-ARGUMENT-RANGE?) NULL)
   (DEFINE-FUNCTION-OBJECT "BAD-ARGUMENT-COUNT?"
    "(DEFUN (BAD-ARGUMENT-COUNT? BOOLEAN) ((TREE CONS) (ARITY INTEGER)))"
    (CL:FUNCTION BAD-ARGUMENT-COUNT?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ILLEGAL-STATEMENT-TREE"
    "(DEFUN (YIELD-ILLEGAL-STATEMENT-TREE CONS) ())"
    (CL:FUNCTION YIELD-ILLEGAL-STATEMENT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ILLEGAL-EXPRESSION-TREE"
    "(DEFUN (YIELD-ILLEGAL-EXPRESSION-TREE OBJECT) ())"
    (CL:FUNCTION YIELD-ILLEGAL-EXPRESSION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DONT-CALL-ME-TREE"
    "(DEFUN (WALK-DONT-CALL-ME-TREE CONS TYPE-SPEC) ((TREE OBJECT) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION WALK-DONT-CALL-ME-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ILLEGAL-TREE?"
    "(DEFUN (ILLEGAL-TREE? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION ILLEGAL-TREE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-CLASS-METHOD-INLINING?"
    "(DEFUN (NATIVE-CLASS-METHOD-INLINING? BOOLEAN) ())"
    (CL:FUNCTION NATIVE-CLASS-METHOD-INLINING?) NULL)
   (DEFINE-FUNCTION-OBJECT "PROGNIFY"
    "(DEFUN (PROGNIFY OBJECT) ((TREES CONS)))" (CL:FUNCTION PROGNIFY)
    NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMIZE-PROGN"
    "(DEFUN (OPTIMIZE-PROGN OBJECT) ((PROGN-TREE CONS)))"
    (CL:FUNCTION OPTIMIZE-PROGN) NULL)
   (DEFINE-FUNCTION-OBJECT "TREE-TO-TREES"
    "(DEFUN (TREE-TO-TREES CONS) ((TREE OBJECT)))"
    (CL:FUNCTION TREE-TO-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAPPED-TYPE-TO-TYPE"
    "(DEFUN (WRAPPED-TYPE-TO-TYPE TYPE) ((SELF TYPE)) :DOCUMENTATION \"Return the unwrapped type for the wrapped type `self',
or `self' if it is not a wrapped type.\" :PUBLIC? TRUE)"
    (CL:FUNCTION WRAPPED-TYPE-TO-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAPPER-VALUE-TYPE"
    "(DEFUN (WRAPPER-VALUE-TYPE TYPE) ((SELF WRAPPER)) :DOCUMENTATION \"Return the type of the value stored in the wrapper `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION WRAPPER-VALUE-TYPE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TYPE-TO-WRAPPED-TYPE TYPE) ((SELF TYPE)) :DOCUMENTATION \"Return the wrapped type for the type `self',
or 'self' if it is not a bare literal type.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION TYPE-TO-WRAPPED-TYPE)) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COERSION-METHOD"
    "(DEFUN (LOOKUP-COERSION-METHOD OBJECT) ((SOURCETYPE TYPE) (TARGETTYPE TYPE) (EXPRESSION OBJECT)))"
    (CL:FUNCTION LOOKUP-COERSION-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-COERCION-METHOD"
    "(DEFUN (APPLY-COERCION-METHOD OBJECT TYPE-SPEC) ((EXPRESSION OBJECT) (SOURCETYPE TYPE) (TARGETTYPE TYPE) (COERCIONMETHOD OBJECT)))"
    (CL:FUNCTION APPLY-COERCION-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATING-CODE?"
    "(DEFUN (TRANSLATING-CODE? BOOLEAN) ())"
    (CL:FUNCTION TRANSLATING-CODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-TYPE"
    "(DEFUN (VERIFY-TYPE TYPE) ((SELF TYPE)))"
    (CL:FUNCTION VERIFY-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-SUBTYPE-OF?"
    "(DEFUN (SAFE-SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)))"
    (CL:FUNCTION SAFE-SUBTYPE-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-ABOUT-UNKNOWN-SOURCE-TYPE"
    "(DEFUN WARN-ABOUT-UNKNOWN-SOURCE-TYPE ((TREE OBJECT)))"
    (CL:FUNCTION WARN-ABOUT-UNKNOWN-SOURCE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-A-TREE"
    "(DEFUN (COERCE-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC)))"
    (CL:FUNCTION COERCE-A-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COERCE-A-TREE"
    "(DEFUN (HELP-COERCE-A-TREE OBJECT TYPE-SPEC BOOLEAN) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC) (TESTONLY? BOOLEAN)))"
    (CL:FUNCTION HELP-COERCE-A-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCIBLE?"
    "(DEFUN (COERCIBLE? BOOLEAN) ((TREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC)))"
    (CL:FUNCTION COERCIBLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALKING-EXPRESSION?"
    "(DEFUN (WALKING-EXPRESSION? BOOLEAN) ())"
    (CL:FUNCTION WALKING-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-EXPRESSION-TREE"
    "(DEFUN (WALK-EXPRESSION-TREE OBJECT TYPE-SPEC) ((EXPTREE OBJECT) (TARGETTYPE TYPE-SPEC) (OPERATORNAME SYMBOL) (VRLETISOK? BOOLEAN)))"
    (CL:FUNCTION WALK-EXPRESSION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-EXPRESSION-TYPE"
    "(DEFUN (COMPUTE-EXPRESSION-TYPE TYPE-SPEC) ((EXPRESSION OBJECT) (WRAP? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-EXPRESSION-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-WITHOUT-TYPE-TREE"
    "(DEFUN (WALK-WITHOUT-TYPE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION WALK-WITHOUT-TYPE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-LIST-OF-TREES"
    "(DEFUN (WALK-LIST-OF-TREES CONS) ((TREES CONS)))"
    (CL:FUNCTION WALK-LIST-OF-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-LIST-OF-STATEMENTS"
    "(DEFUN (WALK-LIST-OF-STATEMENTS CONS) ((TREES CONS)))"
    (CL:FUNCTION WALK-LIST-OF-STATEMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-STATEMENT"
    "(DEFUN (WALK-STATEMENT OBJECT) ((TREE OBJECT) (WARNONATOM? BOOLEAN)))"
    (CL:FUNCTION WALK-STATEMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "ELIMINATE-VRLET-STATEMENT"
    "(DEFUN (ELIMINATE-VRLET-STATEMENT CONS) ((TREE CONS)))"
    (CL:FUNCTION ELIMINATE-VRLET-STATEMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "SYS-TREE"
    "(DEFUN (SYS-TREE CONS TYPE-SPEC) ((TREE OBJECT) (TYPESPEC TYPE-SPEC)))"
    (CL:FUNCTION SYS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALKED-EXPRESSION-TYPE"
    "(DEFUN (WALKED-EXPRESSION-TYPE TYPE-SPEC) ((TREE OBJECT)))"
    (CL:FUNCTION WALKED-EXPRESSION-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALKED-EXPRESSION-EXPRESSION"
    "(DEFUN (WALKED-EXPRESSION-EXPRESSION OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION WALKED-EXPRESSION-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "NEED-IDENTICAL-METHOD-SIGNATURES?"
    "(DEFUN (NEED-IDENTICAL-METHOD-SIGNATURES? BOOLEAN) ())"
    (CL:FUNCTION NEED-IDENTICAL-METHOD-SIGNATURES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MOST-GENERAL-RETURN-TYPE"
    "(DEFUN (COMPUTE-MOST-GENERAL-RETURN-TYPE TYPE-SPEC) ((METHOD METHOD-SLOT) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-MOST-GENERAL-RETURN-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-REAL-SLOT-TYPE"
    "(DEFUN (COMPUTE-REAL-SLOT-TYPE TYPE-SPEC) ((SLOT STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-REAL-SLOT-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SYS-TREE-IF-NEEDED"
    "(DEFUN (SYS-TREE-IF-NEEDED OBJECT TYPE-SPEC) ((SLOT SLOT) (TREE OBJECT) (FIRSTARGTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION SYS-TREE-IF-NEEDED) NULL)
   (DEFINE-FUNCTION-OBJECT "TARGET-LANGUAGE-TYPE"
    "(DEFUN (TARGET-LANGUAGE-TYPE TYPE) ((TREE OBJECT)))"
    (CL:FUNCTION TARGET-LANGUAGE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-TARGET-LANGUAGE-TYPE"
    "(DEFUN (SET-TARGET-LANGUAGE-TYPE CONS TYPE-SPEC) ((SYSTREE CONS) (TYPE TYPE)))"
    (CL:FUNCTION SET-TARGET-LANGUAGE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-A-TREE"
    "(DEFUN (WALK-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))"
    (CL:FUNCTION WALK-A-TREE) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK12 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "HELP-WALK-A-TREE"
    "(DEFUN (HELP-WALK-A-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))"
    (CL:FUNCTION HELP-WALK-A-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-A-CONS-TREE"
    "(DEFUN (WALK-A-CONS-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-A-CONS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INCREMENTAL-TRANSLATION?"
    "(DEFUN (INCREMENTAL-TRANSLATION? BOOLEAN) ())"
    (CL:FUNCTION INCREMENTAL-TRANSLATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSTRUCT-SYMBOL-CONSTANT-NAME"
    "(DEFUN (CONSTRUCT-SYMBOL-CONSTANT-NAME STRING) ((SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION CONSTRUCT-SYMBOL-CONSTANT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SYMBOL-CONSTANT-NAME"
    "(DEFUN (YIELD-SYMBOL-CONSTANT-NAME SYMBOL) ((SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION YIELD-SYMBOL-CONSTANT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-STARTUP-SYMBOL"
    "(DEFUN (CREATE-STARTUP-SYMBOL SYMBOL) ((SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION CREATE-STARTUP-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SYMBOL"
    "(DEFUN (REGISTER-SYMBOL GENERALIZED-SYMBOL) ((SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION REGISTER-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SYMBOL-REGISTRY"
    "(DEFUN CLEAR-SYMBOL-REGISTRY ())"
    (CL:FUNCTION CLEAR-SYMBOL-REGISTRY) NULL)
   (DEFINE-FUNCTION-OBJECT
    "YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE"
    "(DEFUN (YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE CONS) ())"
    (CL:FUNCTION YIELD-HARDCODED-INTERN-REGISTERED-SYMBOLS-TREE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION WALK-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF WRAPPER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION WALK-ATOMIC-TREE)) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTANT-SYMBOL"
    "(DEFUN (LOOKUP-CONSTANT-SYMBOL TYPE) ((SELF SYMBOL)))"
    (CL:FUNCTION LOOKUP-CONSTANT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "CONSTANT-SYMBOL?"
    "(DEFUN (CONSTANT-SYMBOL? BOOLEAN) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION CONSTANT-SYMBOL?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CONSTANT-SYMBOL"
    "(DEFUN (WALK-CONSTANT-SYMBOL SYMBOL TYPE) ((SELF SYMBOL)))"
    (CL:FUNCTION WALK-CONSTANT-SYMBOL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF SYMBOL)))"
    (WRAP-METHOD-CODE (CL:FUNCTION WALK-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF KEYWORD)))"
    (WRAP-METHOD-CODE (CL:FUNCTION WALK-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WALK-ATOMIC-TREE OBJECT TYPE-SPEC) ((SELF SURROGATE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION WALK-ATOMIC-TREE)) NULL)
   (DEFINE-FUNCTION-OBJECT "ATOMIC-EXPRESSION?"
    "(DEFUN (ATOMIC-EXPRESSION? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION ATOMIC-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-EXPRESSION?"
    "(DEFUN (VARIABLE-EXPRESSION? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION VARIABLE-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "VRLET-EXPRESSION?"
    "(DEFUN (VRLET-EXPRESSION? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION VRLET-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCEDURAL-EXPRESSION?"
    "(DEFUN (PROCEDURAL-EXPRESSION? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION PROCEDURAL-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBSTITUTE-ONCE"
    "(DEFUN (SUBSTITUTE-ONCE BOOLEAN) ((EXPRESSION OBJECT) (NEWTREE OBJECT) (OLDTREE OBJECT)))"
    (CL:FUNCTION SUBSTITUTE-ONCE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFORM-VRLET-EXPRESSION"
    "(DEFUN (TRANSFORM-VRLET-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS)))"
    (CL:FUNCTION TRANSFORM-VRLET-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT
    "HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION"
    "(DEFUN (HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS) ((EXPRESSION OBJECT) (TESTVARIABLE SYMBOL)))"
    (CL:FUNCTION HELP-TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION"
    "(DEFUN (TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS)))"
    (CL:FUNCTION TRANSFORM-BOOLEAN-PROCEDURAL-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS"
    "(DEFUN (PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS CONS) ((BOOLEANEXPRESSION CONS)))"
    (CL:FUNCTION PERCOLATE-OUT-BOOLEAN-VRLET-EXPRESSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFORM-PROCEDURAL-EXPRESSION"
    "(DEFUN (TRANSFORM-PROCEDURAL-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS) (TYPE TYPE-SPEC)))"
    (CL:FUNCTION TRANSFORM-PROCEDURAL-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PERCOLATE-OUT-VRLET-EXPRESSION"
    "(DEFUN (PERCOLATE-OUT-VRLET-EXPRESSION CONS TYPE-SPEC) ((STATEMENT CONS) (VREXPRESSION CONS) (TYPE TYPE-SPEC)))"
    (CL:FUNCTION PERCOLATE-OUT-VRLET-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SETQ-TREE"
    "(DEFUN (WALK-SETQ-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SETQ-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-FIXED-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (YIELD-FIXED-SLOT-VALUE-SETTER-TREE CONS) ((SLOT SLOT) (OBJECTREF OBJECT) (VALUETREE OBJECT)))"
    (CL:FUNCTION YIELD-FIXED-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SETF-TREE"
    "(DEFUN (WALK-SETF-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SETF-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-DYNAMIC-SLOT-VALUE-TREE"
    "(DEFUN (YIELD-DYNAMIC-SLOT-VALUE-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-DYNAMIC-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-DYNAMIC-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-NATIVE-SLOT-VALUE-TREE"
    "(DEFUN (YIELD-NATIVE-SLOT-VALUE-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-NATIVE-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE"
    "(DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))"
    (CL:FUNCTION YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SLOT-VALUE-TREE"
    "(DEFUN (YIELD-SLOT-VALUE-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))"
    (CL:FUNCTION YIELD-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SLOT-VALUE-TREE"
    "(DEFUN (WALK-SLOT-VALUE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-NATIVE-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (YIELD-NATIVE-SLOT-VALUE-SETTER-TREE CONS) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (VALUEREF OBJECT)))"
    (CL:FUNCTION YIELD-NATIVE-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))"
    (CL:FUNCTION YIELD-CONTEXT-SENSITIVE-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (YIELD-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((SLOT STORAGE-SLOT) (OBJECTREF OBJECT) (OBJECTTYPE TYPE-SPEC) (VALUEREF OBJECT) (RETURNTYPE TYPE-SPEC) (CSOPTIONS CONS)))"
    (CL:FUNCTION YIELD-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (WALK-SLOT-VALUE-SETTER-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-AREF-TREE"
    "(DEFUN (WALK-AREF-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-AREF-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-YIELD-TYPE-SPECIFIER"
    "(DEFUN (SAFE-YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPETREE OBJECT)))"
    (CL:FUNCTION SAFE-YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-A-DECLARATION"
    "(DEFUN (WALK-A-DECLARATION CONS) ((VARIABLE SYMBOL) (TYPETREE OBJECT) (VALUE OBJECT) (INPUTPARAMETER? BOOLEAN)))"
    (CL:FUNCTION WALK-A-DECLARATION) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VARIABLE-DECLARATIONS"
    "(DEFUN (WALK-VARIABLE-DECLARATIONS CONS) ((DECLARATIONS CONS)))"
    (CL:FUNCTION WALK-VARIABLE-DECLARATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION"
    "(DEFUN (TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION CONS) ((TREE CONS)))"
    (CL:FUNCTION TRANSFORM-LET-WITH-PROCEDURAL-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-LOCAL-VARIABLE-BINDINGS"
    "(DEFUN POP-LOCAL-VARIABLE-BINDINGS ((DECLARATIONS CONS)))"
    (CL:FUNCTION POP-LOCAL-VARIABLE-BINDINGS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-LET-TREE"
    "(DEFUN (WALK-LET-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-LET-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIAL-IMPLEMENTATION-STYLE"
    "(DEFUN (SPECIAL-IMPLEMENTATION-STYLE KEYWORD) ())"
    (CL:FUNCTION SPECIAL-IMPLEMENTATION-STYLE) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-SPECIAL"
    "(DEFUN PUSH-SPECIAL ((VARIABLE SYMBOL) (OLDVALUEVARIABLE SYMBOL)))"
    (CL:FUNCTION PUSH-SPECIAL) NULL)
   (DEFINE-FUNCTION-OBJECT "POP-SPECIAL" "(DEFUN POP-SPECIAL ())"
    (CL:FUNCTION POP-SPECIAL) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-OLD-VALUE-VARIABLE"
    "(DEFUN (LOOKUP-OLD-VALUE-VARIABLE SYMBOL) ((VARIABLE SYMBOL)))"
    (CL:FUNCTION LOOKUP-OLD-VALUE-VARIABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "NEED-TO-UNBIND-SPECIALS?"
    "(DEFUN (NEED-TO-UNBIND-SPECIALS? BOOLEAN) ())"
    (CL:FUNCTION NEED-TO-UNBIND-SPECIALS?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SPECIAL-UNBIND-TREE"
    "(DEFUN (YIELD-SPECIAL-UNBIND-TREE CONS) ((NOFBINDINGS INTEGER)))"
    (CL:FUNCTION YIELD-SPECIAL-UNBIND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-RETURN-SPECIAL-UNBIND-TREE"
    "(DEFUN (YIELD-RETURN-SPECIAL-UNBIND-TREE CONS) ())"
    (CL:FUNCTION YIELD-RETURN-SPECIAL-UNBIND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE"
    "(DEFUN (YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE CONS) ())"
    (CL:FUNCTION YIELD-LOOP-EXIT-SPECIAL-UNBIND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SPECIAL-TREE"
    "(DEFUN (WALK-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SPECIAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CL-SPECIAL-TREE"
    "(DEFUN (WALK-CL-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CL-SPECIAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-UNWIND-PROTECT-SPECIAL-TREE"
    "(DEFUN (WALK-UNWIND-PROTECT-SPECIAL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-UNWIND-PROTECT-SPECIAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CAST-TREE"
    "(DEFUN (WALK-CAST-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CAST-TREE) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK13 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "VALUES-TREE?"
    "(DEFUN (VALUES-TREE? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION VALUES-TREE?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VALUES-TREE"
    "(DEFUN (WALK-VALUES-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-VALUES-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MV-EXPRESSION-TREE"
    "(DEFUN (WALK-MV-EXPRESSION-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT) (TARGETTYPES (LIST OF TYPE-SPEC)) (OPERATOR SYMBOL)))"
    (CL:FUNCTION WALK-MV-EXPRESSION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "LISTIFY-TYPE-SPEC"
    "(DEFUN (LISTIFY-TYPE-SPEC (LIST OF TYPE-SPEC)) ((TYPESPEC TYPE-SPEC)))"
    (CL:FUNCTION LISTIFY-TYPE-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOT-FROM-EXPRESSION-TREE"
    "(DEFUN (SLOT-FROM-EXPRESSION-TREE SLOT) ((TREE CONS)))"
    (CL:FUNCTION SLOT-FROM-EXPRESSION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MV-TREE"
    "(DEFUN (WALK-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT)))"
    (CL:FUNCTION WALK-MV-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MV-VALUES-TREE"
    "(DEFUN (WALK-MV-VALUES-TREE CONS CONS (LIST OF TYPE-SPEC)) ((TREE CONS)))"
    (CL:FUNCTION WALK-MV-VALUES-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-MV-TREE"
    "(DEFUN (COERCE-MV-TREE OBJECT CONS (LIST OF TYPE-SPEC)) ((TREE OBJECT) (OPERATOR SYMBOL) (SOURCETYPES (LIST OF TYPE-SPEC)) (TARGETTYPES (LIST OF TYPE-SPEC))))"
    (CL:FUNCTION COERCE-MV-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-RETURN-AND-UNBIND-SPECIALS"
    "(DEFUN (WALK-RETURN-AND-UNBIND-SPECIALS CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-RETURN-AND-UNBIND-SPECIALS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-RETURN-TREE"
    "(DEFUN (WALK-RETURN-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-RETURN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MV-SETQ-TREE"
    "(DEFUN (WALK-MV-SETQ-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-MV-SETQ-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MV-BIND-TREE"
    "(DEFUN (WALK-MV-BIND-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-MV-BIND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-LOOP-TREE"
    "(DEFUN (WALK-LOOP-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-LOOP-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-LOOP-EXIT-TREE"
    "(DEFUN (WALK-LOOP-EXIT-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-LOOP-EXIT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-WHILE-TREE"
    "(DEFUN (WALK-WHILE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-WHILE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CONDITIONAL-TREE"
    "(DEFUN (WALK-CONDITIONAL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CONDITIONAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CHOOSE-TREE"
    "(DEFUN (WALK-CHOOSE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CHOOSE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-BOOLEAN-TREE"
    "(DEFUN (WALK-BOOLEAN-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-BOOLEAN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "AND-OR-NOT-TREE?"
    "(DEFUN (AND-OR-NOT-TREE? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION AND-OR-NOT-TREE?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-WALK-BOOLEAN-TREE"
    "(DEFUN (HELP-WALK-BOOLEAN-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION HELP-WALK-BOOLEAN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-COND-TREE"
    "(DEFUN (WALK-COND-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-COND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COND-TREE-TO-IF-TREE"
    "(DEFUN (COND-TREE-TO-IF-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION COND-TREE-TO-IF-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS"
    "(DEFUN (YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS OBJECT) ((CASETEST OBJECT)))"
    (CL:FUNCTION YIELD-HARDCODED-CASE-SYMBOL-ID-OR-IDS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-HARDCODED-SYMBOL-CASE-TREE"
    "(DEFUN (WALK-HARDCODED-SYMBOL-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-HARDCODED-SYMBOL-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ISA?-CASE-TEST"
    "(DEFUN (YIELD-ISA?-CASE-TEST CONS) ((CASEKEY TYPE) (TESTEXPRESSION OBJECT)))"
    (CL:FUNCTION YIELD-ISA?-CASE-TEST) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SUBTYPE-OF?-CASE-TEST"
    "(DEFUN (YIELD-SUBTYPE-OF?-CASE-TEST CONS) ((CASEKEY TYPE) (TESTEXPRESSION OBJECT)))"
    (CL:FUNCTION YIELD-SUBTYPE-OF?-CASE-TEST) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-COND-TEST"
    "(DEFUN (YIELD-COND-TEST CONS) ((CASETEST OBJECT) (TESTVARIABLE OBJECT) (EQUALITYTEST SYMBOL)))"
    (CL:FUNCTION YIELD-COND-TEST) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-COND-TEST-OR-TESTS"
    "(DEFUN (YIELD-COND-TEST-OR-TESTS OBJECT) ((CASETEST OBJECT) (TESTVARIABLE OBJECT) (EQUALITYTEST SYMBOL)))"
    (CL:FUNCTION YIELD-COND-TEST-OR-TESTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COUNT-CASE-TEST-CLAUSES"
    "(DEFUN (COUNT-CASE-TEST-CLAUSES INTEGER BOOLEAN) ((TREE CONS)))"
    (CL:FUNCTION COUNT-CASE-TEST-CLAUSES) NULL)
   (DEFINE-FUNCTION-OBJECT "ATTACH-UNHANDLED-CASE-ERROR-CLAUSE"
    "(DEFUN (ATTACH-UNHANDLED-CASE-ERROR-CLAUSE CONS) ((CASETREE CONS) (TESTTREE OBJECT)))"
    (CL:FUNCTION ATTACH-UNHANDLED-CASE-ERROR-CLAUSE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-NON-BUILT-IN-CASE-TREE"
    "(DEFUN (WALK-NON-BUILT-IN-CASE-TREE CONS TYPE-SPEC) ((TREE CONS) (EQUALITYTEST SYMBOL)))"
    (CL:FUNCTION WALK-NON-BUILT-IN-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CASE-TREE"
    "(DEFUN (WALK-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-TYPECASE-TREE"
    "(DEFUN (WALK-TYPECASE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-TYPECASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CASTED-TYPECASE-CLAUSE-TREES"
    "(DEFUN (YIELD-CASTED-TYPECASE-CLAUSE-TREES CONS) ((TESTVARIABLE SYMBOL) (CLAUSETYPE TYPE-SPEC) (CLAUSETREES CONS)))"
    (CL:FUNCTION YIELD-CASTED-TYPECASE-CLAUSE-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "VERIFY-TYPECASE-CLAUSE-TYPE"
    "(DEFUN VERIFY-TYPECASE-CLAUSE-TYPE ((TESTTYPE TYPE) (CLAUSETYPE TYPE) (PRECEDINGCLAUSETYPES (LIST OF TYPE)) (CLAUSE CONS)))"
    (CL:FUNCTION VERIFY-TYPECASE-CLAUSE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-WITH-PROCESS-LOCK-TREE"
    "(DEFUN (WALK-WITH-PROCESS-LOCK-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-WITH-PROCESS-LOCK-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-WALKING-EQL-TREE"
    "(DEFUN (FINISH-WALKING-EQL-TREE CONS TYPE-SPEC) ((TREE CONS) (TYPE1 TYPE) (TYPE2 TYPE)))"
    (CL:FUNCTION FINISH-WALKING-EQL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-WALKING-EQUAL-TREE"
    "(DEFUN (FINISH-WALKING-EQUAL-TREE CONS TYPE-SPEC) ((TREE CONS) (TYPE1 TYPE) (TYPE2 TYPE)))"
    (CL:FUNCTION FINISH-WALKING-EQUAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-EQUALITY-TREE"
    "(DEFUN (WALK-EQUALITY-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-EQUALITY-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "MORE-GENERAL-NUMERIC-TYPE"
    "(DEFUN (MORE-GENERAL-NUMERIC-TYPE TYPE) ((TYPE1 TYPE) (TYPE2 TYPE)))"
    (CL:FUNCTION MORE-GENERAL-NUMERIC-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ARITHMETIC-OPERATOR-CALL-TREE"
    "(DEFUN (YIELD-ARITHMETIC-OPERATOR-CALL-TREE CONS) ((OPERATOR SYMBOL) (OPERANDS CONS)))"
    (CL:FUNCTION YIELD-ARITHMETIC-OPERATOR-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE"
    "(DEFUN (YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE CONS) ((OPERATOR SYMBOL) (OPERANDS CONS)))"
    (CL:FUNCTION YIELD-NESTED-ARITHMETIC-OPERATOR-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-ARITHMETIC-TREE"
    "(DEFUN (WALK-ARITHMETIC-TREE OBJECT TYPE) ((TREE CONS)))"
    (CL:FUNCTION WALK-ARITHMETIC-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-QUOTED-TREE"
    "(DEFUN (WALK-QUOTED-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-QUOTED-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-BQUOTE-TREE"
    "(DEFUN (WALK-BQUOTE-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-BQUOTE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-MACRO"
    "(DEFUN (EXPAND-MACRO OBJECT) ((TREE CONS)))"
    (CL:FUNCTION EXPAND-MACRO) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MACRO-TREE"
    "(DEFUN (WALK-MACRO-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-MACRO-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-PRINT-STREAM-TREE"
    "(DEFUN (WALK-PRINT-STREAM-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-PRINT-STREAM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-ABOUT-UNDEFINED-METHODS?"
    "(DEFUN (WARN-ABOUT-UNDEFINED-METHODS? BOOLEAN) ())"
    (CL:FUNCTION WARN-ABOUT-UNDEFINED-METHODS?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-ABOUT-MISSING-METHODS?"
    "(DEFUN (WARN-ABOUT-MISSING-METHODS? BOOLEAN) ())"
    (CL:FUNCTION WARN-ABOUT-MISSING-METHODS?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-TYPE-SPEC-IS-NATIVE-TYPE?"
    "(DEFUN (WALK-TYPE-SPEC-IS-NATIVE-TYPE? BOOLEAN) ((THETYPE TYPE-SPEC)))"
    (CL:FUNCTION WALK-TYPE-SPEC-IS-NATIVE-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-UNDEFINED-SLOT-TREE"
    "(DEFUN (WALK-UNDEFINED-SLOT-TREE CONS TYPE) ((TREE CONS) (FIRSTARGTYPE TYPE-SPEC) (WARN? BOOLEAN)))"
    (CL:FUNCTION WALK-UNDEFINED-SLOT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SLOT-ON-ABSTRACT-TYPE-TREE"
    "(DEFUN (WALK-SLOT-ON-ABSTRACT-TYPE-TREE CONS TYPE-SPEC) ((TREE CONS) (ABSTRACTTYPE TYPE)))"
    (CL:FUNCTION WALK-SLOT-ON-ABSTRACT-TYPE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-PROTOTYPE-METHOD"
    "(DEFUN (FIND-PROTOTYPE-METHOD METHOD-SLOT) ((METHODNAME SYMBOL) (ABSTRACTTYPE TYPE)))"
    (CL:FUNCTION FIND-PROTOTYPE-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPATIBLE-REAL-METHODS"
    "(DEFUN (COMPATIBLE-REAL-METHODS INTEGER INTEGER BOOLEAN) ((PROTOTYPEMETHOD METHOD-SLOT) (ABSTRACTTYPE TYPE)))"
    (CL:FUNCTION COMPATIBLE-REAL-METHODS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ((SELF SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ((SELF STORAGE-SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE))
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CONCATENATE-METHOD?"
    "(DEFUN (STRING-CONCATENATE-METHOD? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION STRING-CONCATENATE-METHOD?) NULL)
   (DEFINE-FUNCTION-OBJECT "PASS-VARIABLE-ARGUMENTS-AS-LIST?"
    "(DEFUN (PASS-VARIABLE-ARGUMENTS-AS-LIST? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION PASS-VARIABLE-ARGUMENTS-AS-LIST?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARGUMENTS-TYPE"
    "(DEFUN (VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION VARIABLE-ARGUMENTS-TYPE) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK14 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARGUMENTS-NAME"
    "(DEFUN (VARIABLE-ARGUMENTS-NAME SYMBOL) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION VARIABLE-ARGUMENTS-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE"
    "(DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE TYPE-SPEC) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-LISTIFIED-VARIABLE-ARGUMENTS"
    "(DEFUN (YIELD-LISTIFIED-VARIABLE-ARGUMENTS CONS) ((WALKEDARGS CONS) (TARGETTYPE TYPE-SPEC) (WRAPARGS? BOOLEAN)))"
    (CL:FUNCTION YIELD-LISTIFIED-VARIABLE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "FINISH-WALKING-ARGUMENT-LIST-TREE"
    "(DEFUN (FINISH-WALKING-ARGUMENT-LIST-TREE OBJECT TYPE-SPEC) ((SELF SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION FINISH-WALKING-ARGUMENT-LIST-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VARIABLE-ARGUMENTS"
    "(DEFUN (WALK-VARIABLE-ARGUMENTS CONS) ((ARGUMENTS CONS) (METHOD METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION WALK-VARIABLE-ARGUMENTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FINISH-WALKING-CALL-SLOT-TREE OBJECT TYPE-SPEC) ((SELF METHOD-SLOT) (TREE CONS) (FIRSTARGTYPE TYPE-SPEC)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FINISH-WALKING-CALL-SLOT-TREE))
    NULL)
   (DEFINE-FUNCTION-OBJECT "QUOTE-ARGUMENTS"
    "(DEFUN (QUOTE-ARGUMENTS CONS) ((METHOD METHOD-SLOT) (ARGUMENTS CONS)))"
    (CL:FUNCTION QUOTE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-FIRST-ARGUMENT-TO-FUNCTION"
    "(DEFUN (WALK-FIRST-ARGUMENT-TO-FUNCTION TYPE-SPEC) ((FNSLOT METHOD-SLOT) (TREE CONS)))"
    (CL:FUNCTION WALK-FIRST-ARGUMENT-TO-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CALL-SLOT-TREE"
    "(DEFUN (WALK-CALL-SLOT-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CALL-SLOT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-METHOD-CALL?"
    "(DEFUN (INLINE-METHOD-CALL? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION INLINE-METHOD-CALL?) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-INLINABLE?"
    "(DEFUN (METHOD-INLINABLE? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-INLINABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-METHOD?"
    "(DEFUN (MOST-SPECIFIC-METHOD? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION MOST-SPECIFIC-METHOD?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MOST-SPECIFIC-METHOD?"
    "(DEFUN (HELP-MOST-SPECIFIC-METHOD? BOOLEAN) ((CLASS CLASS) (METHOD METHOD-SLOT)))"
    (CL:FUNCTION HELP-MOST-SPECIFIC-METHOD?) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT CACHED-INLINABLE-METHOD-BODY :TYPE OBJECT :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "INLINABLE-METHOD-BODY"
    "(DEFUN (INLINABLE-METHOD-BODY OBJECT) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION INLINABLE-METHOD-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-INLINE-METHOD-CALL"
    "(DEFUN (WALK-INLINE-METHOD-CALL OBJECT) ((METHOD METHOD-SLOT) (WALKEDARGS CONS) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION WALK-INLINE-METHOD-CALL) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-VERBATIM-INLINE-CALL-TREE"
    "(DEFUN (YIELD-VERBATIM-INLINE-CALL-TREE CONS) ((METHOD METHOD-SLOT) (WALKEDARGS CONS)))"
    (CL:FUNCTION YIELD-VERBATIM-INLINE-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-VARIABLE-REFERENCE?"
    "(DEFUN (INLINE-VARIABLE-REFERENCE? BOOLEAN) ((SELF SYMBOL)) :GLOBALLY-INLINE? TRUE (RETURN (AND *INLININGMETHODCALL?* (DEFINED? (GET-LOCAL-VARIABLE-INFO SELF :INLINE-ARGUMENT)))))"
    (CL:FUNCTION INLINE-VARIABLE-REFERENCE?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-INLINE-VARIABLE-REFERENCE"
    "(DEFUN (WALK-INLINE-VARIABLE-REFERENCE CONS TYPE-SPEC) ((SELF SYMBOL)))"
    (CL:FUNCTION WALK-INLINE-VARIABLE-REFERENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIDE-EFFECT-FREE-EXPRESSION?"
    "(DEFUN (SIDE-EFFECT-FREE-EXPRESSION? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION SIDE-EFFECT-FREE-EXPRESSION?) NULL)
   (DEFINE-FUNCTION-OBJECT "ESTIMATED-EVALUATION-COST"
    "(DEFUN (ESTIMATED-EVALUATION-COST INTEGER) ((TREE OBJECT)))"
    (CL:FUNCTION ESTIMATED-EVALUATION-COST) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SYNTHESIZED-METHOD-BODY"
    "(DEFUN (YIELD-SYNTHESIZED-METHOD-BODY CONS) ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION YIELD-SYNTHESIZED-METHOD-BODY) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-METHOD-OBJECT"
    "(DEFUN (WALK-METHOD-OBJECT CONS) ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-METHOD-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFMETHOD-TREE"
    "(DEFUN WALK-DEFMETHOD-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFMETHOD-TREE) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT FORWARD-DECLARATION? :TYPE BOOLEAN :DEFAULT FALSE :DOCUMENTATION \"Set to `true' for walked methods without a body.
Used to flag functions and methods that were declared but not defined.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "METHOD-STORES-NATIVE-CODE-POINTER?"
    "(DEFUN (METHOD-STORES-NATIVE-CODE-POINTER? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-STORES-NATIVE-CODE-POINTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-METHOD-UNIT"
    "(DEFUN WALK-METHOD-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-METHOD-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-UNDEFINED-METHODS"
    "(DEFUN PRINT-UNDEFINED-METHODS ((MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Print all declared but not yet defined functions and methods
in `module'.  If `local?' is true, do not consider any parent modules of
`module'.  If `module' is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions.\")" (CL:FUNCTION PRINT-UNDEFINED-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SYS-CALL-TREE"
    "(DEFUN (WALK-SYS-CALL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SYS-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFCLASS-TREE"
    "(DEFUN WALK-DEFCLASS-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFCLASS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-INITIALIZE-HARDWIRED-SLOTS"
    "(DEFUN (YIELD-INITIALIZE-HARDWIRED-SLOTS CONS) ((CLASS CLASS)))"
    (CL:FUNCTION YIELD-INITIALIZE-HARDWIRED-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-INITIAL-VALUE-EXPRESSION"
    "(DEFUN (YIELD-INITIAL-VALUE-EXPRESSION OBJECT) ((SLOT STORAGE-SLOT)))"
    (CL:FUNCTION YIELD-INITIAL-VALUE-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CONSTRUCTOR-ATTACHMENT"
    "(DEFUN (YIELD-CONSTRUCTOR-ATTACHMENT CONS) ((CLASS CLASS) (CLASSREF SYMBOL)))"
    (CL:FUNCTION YIELD-CONSTRUCTOR-ATTACHMENT) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CLASS CLASS-AUXILIARY-METHODS :TYPE (LIST OF METHOD-SLOT) :DEFAULT NIL-LIST :DOCUMENTATION \"Stores auxiliary method objects such as slot accessors and
inherited mixin methods that are not attached to the class as regular methods
but need to be accessible by the C++ translator in order to generate the
necessary signatures.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT AUXILIARY-METHOD-REASON :TYPE SLOT :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "CLEANUP-AUXILIARY-METHODS"
    "(DEFUN CLEANUP-AUXILIARY-METHODS ((CLASS CLASS)))"
    (CL:FUNCTION CLEANUP-AUXILIARY-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-AUXILIARY-METHOD"
    "(DEFUN REGISTER-AUXILIARY-METHOD ((METHOD METHOD-SLOT) (REASON SLOT)))"
    (CL:FUNCTION REGISTER-AUXILIARY-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "MIXIN-TYPE-VARIABLES-ALLOWED?"
    "(DEFUN (MIXIN-TYPE-VARIABLES-ALLOWED? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (OR (NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)) (NOT (EQL? *MIXIN-IMPLEMENTATION-STYLE* :SECOND-CLASS)))))"
    (CL:FUNCTION MIXIN-TYPE-VARIABLES-ALLOWED?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-NATIVE-MIXIN-SLOT-ACCESSORS?"
    "(DEFUN (CREATE-NATIVE-MIXIN-SLOT-ACCESSORS? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (AND (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?) (MIXIN-TYPE-VARIABLES-ALLOWED?))))"
    (CL:FUNCTION CREATE-NATIVE-MIXIN-SLOT-ACCESSORS?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-ACCESSOR-UNITS-FOR-SLOT"
    "(DEFUN CREATE-ACCESSOR-UNITS-FOR-SLOT ((SLOT STORAGE-SLOT) (CLASS CLASS) (MIXINACCESSORS? BOOLEAN) (SIGNATURESONLY? BOOLEAN)))"
    (CL:FUNCTION CREATE-ACCESSOR-UNITS-FOR-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT"
    "(DEFUN CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT ((SLOT STORAGE-SLOT) (CLASS CLASS)))"
    (CL:FUNCTION CREATE-ACCESSOR-UNITS-FOR-MIXIN-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SLOT-ACCESSOR-UNITS"
    "(DEFUN CREATE-SLOT-ACCESSOR-UNITS ((CLASS CLASS)))"
    (CL:FUNCTION CREATE-SLOT-ACCESSOR-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-INLINE-METHOD-UNITS"
    "(DEFUN CREATE-INLINE-METHOD-UNITS ((CLASS CLASS)))"
    (CL:FUNCTION CREATE-INLINE-METHOD-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-MIXIN-METHOD-TREE"
    "(DEFUN (YIELD-MIXIN-METHOD-TREE CONS) ((METHOD METHOD-SLOT) (CLASS CLASS)))"
    (CL:FUNCTION YIELD-MIXIN-METHOD-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-MIXIN-METHOD-UNITS"
    "(DEFUN CREATE-MIXIN-METHOD-UNITS ((CLASS CLASS)))"
    (CL:FUNCTION CREATE-MIXIN-METHOD-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DEFPRINT-UNIT"
    "(DEFUN CREATE-DEFPRINT-UNIT ((CLASS CLASS)))"
    (CL:FUNCTION CREATE-DEFPRINT-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CLASS-UNIT"
    "(DEFUN WALK-CLASS-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-CLASS-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-FINALIZATION-UNITS"
    "(DEFUN CREATE-FINALIZATION-UNITS ())"
    (CL:FUNCTION CREATE-FINALIZATION-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFSLOT-TREE"
    "(DEFUN WALK-DEFSLOT-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFSLOT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SLOT-UNIT"
    "(DEFUN WALK-SLOT-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-SLOT-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-MACRO"
    "(DEFUN (LOOKUP-MACRO METHOD-SLOT) ((NAME SYMBOL)) :DOCUMENTATION \"If `name' has a macro definition, return the method object
holding its expander function.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-MACRO) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT METHOD-MACRO? :TYPE BOOLEAN :OPTION-KEYWORD :MACRO? :DOCUMENTATION \"If true, the object is a macro expander function.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "WALK-DEFMACRO-TREE"
    "(DEFUN WALK-DEFMACRO-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFMACRO-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFGLOBAL-TREE"
    "(DEFUN WALK-DEFGLOBAL-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFGLOBAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-GLOBAL-UNIT"
    "(DEFUN WALK-GLOBAL-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-GLOBAL-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFTYPE-TREE"
    "(DEFUN WALK-DEFTYPE-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFTYPE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-TYPE-UNIT"
    "(DEFUN WALK-TYPE-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-TYPE-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-STARTUP-TIME-PROGN-TREE"
    "(DEFUN WALK-STARTUP-TIME-PROGN-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-STARTUP-TIME-PROGN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-STARTUP-TIME-PHASE"
    "(DEFUN (EXTRACT-STARTUP-TIME-PHASE KEYWORD) ((TREE CONS)))"
    (CL:FUNCTION EXTRACT-STARTUP-TIME-PHASE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-STARTUP-TIME-PROGN-UNIT"
    "(DEFUN WALK-STARTUP-TIME-PROGN-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-STARTUP-TIME-PROGN-UNIT) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK15 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "EARLIER-STARTUP-UNIT?"
    "(DEFUN (EARLIER-STARTUP-UNIT? BOOLEAN) ((UNIT1 TRANSLATION-UNIT) (UNIT2 TRANSLATION-UNIT)))"
    (CL:FUNCTION EARLIER-STARTUP-UNIT?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMBINE-STARTUP-FUNCTION-UNITS"
    "(DEFUN (COMBINE-STARTUP-FUNCTION-UNITS CONS) ((STARTUPFNNAME SYMBOL)))"
    (CL:FUNCTION COMBINE-STARTUP-FUNCTION-UNITS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT METHOD-STARTUP-CLASSNAME :TYPE STRING :ALLOCATION :DYNAMIC)")
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-STARTUP-FUNCTION? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-STARTUP-FUNCTION?)) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-STARTUP-FUNCTION-UNITS"
    "(DEFUN EXTRACT-STARTUP-FUNCTION-UNITS ((STARTUPUNITS (LIST OF TRANSLATION-UNIT)) (STARTUPFNNAME SYMBOL)))"
    (CL:FUNCTION EXTRACT-STARTUP-FUNCTION-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STARTUP-FUNCTION-NAME"
    "(DEFUN (YIELD-STARTUP-FUNCTION-NAME SYMBOL) ((FILE STRING)))"
    (CL:FUNCTION YIELD-STARTUP-FUNCTION-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STARTUP-FUNCTION-CLASSNAME"
    "(DEFUN (YIELD-STARTUP-FUNCTION-CLASSNAME STRING) ((FUNCTION-NAME SYMBOL)))"
    (CL:FUNCTION YIELD-STARTUP-FUNCTION-CLASSNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-STARTUP-FUNCTION-UNITS"
    "(DEFUN CREATE-STARTUP-FUNCTION-UNITS ())"
    (CL:FUNCTION CREATE-STARTUP-FUNCTION-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "DONT-GENERATE-STARTUP-CODE?"
    "(DEFUN (DONT-GENERATE-STARTUP-CODE? BOOLEAN) ())"
    (CL:FUNCTION DONT-GENERATE-STARTUP-CODE?) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-ALL-STARTUP-TIME-PROGN-UNITS"
    "(DEFUN REMOVE-ALL-STARTUP-TIME-PROGN-UNITS ())"
    (CL:FUNCTION REMOVE-ALL-STARTUP-TIME-PROGN-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-SIGNAL-EXCEPTION-TREE"
    "(DEFUN (WALK-SIGNAL-EXCEPTION-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-SIGNAL-EXCEPTION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-EXCEPTION-CASE-TREE"
    "(DEFUN (WALK-EXCEPTION-CASE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-EXCEPTION-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-EXCEPTION-HANDLER-TREES"
    "(DEFUN (WALK-EXCEPTION-HANDLER-TREES CONS) ((TREE CONS)))"
    (CL:FUNCTION WALK-EXCEPTION-HANDLER-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-UNWIND-PROTECT-TREE"
    "(DEFUN (WALK-UNWIND-PROTECT-TREE CONS TYPE) ((TREE CONS)))"
    (CL:FUNCTION WALK-UNWIND-PROTECT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VERBATIM-DEFINITION-TREE"
    "(DEFUN WALK-VERBATIM-DEFINITION-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-VERBATIM-DEFINITION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VERBATIM-UNIT"
    "(DEFUN WALK-VERBATIM-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-VERBATIM-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-VERBATIM-TREE"
    "(DEFUN (WALK-VERBATIM-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-VERBATIM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VERBATIM-TREE"
    "(DEFUN (LOOKUP-VERBATIM-TREE OBJECT) ((TREE CONS) (LANGUAGE KEYWORD)))"
    (CL:FUNCTION LOOKUP-VERBATIM-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "VERBATIM-TREE?"
    "(DEFUN (VERBATIM-TREE? BOOLEAN) ((TREE OBJECT)))"
    (CL:FUNCTION VERBATIM-TREE?) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-DEFMODULE-TREE"
    "(DEFUN WALK-DEFMODULE-TREE ((TREE CONS)))"
    (CL:FUNCTION WALK-DEFMODULE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MODULE-UNIT"
    "(DEFUN WALK-MODULE-UNIT ((UNIT TRANSLATION-UNIT)))"
    (CL:FUNCTION WALK-MODULE-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-REQUIRED-ARGUMENT-VALUES"
    "(DEFUN (EXTRACT-REQUIRED-ARGUMENT-VALUES CONS) ((CLASSTYPE TYPE-SPEC) (SLOTSANDVALUES (PROPERTY-LIST OF SLOT OBJECT))))"
    (CL:FUNCTION EXTRACT-REQUIRED-ARGUMENT-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "PREPROCESS-ARRAY-ARGUMENTS"
    "(DEFUN PREPROCESS-ARRAY-ARGUMENTS ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER) (SLOTSANDVALUES (PROPERTY-LIST OF SLOT OBJECT))))"
    (CL:FUNCTION PREPROCESS-ARRAY-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-ARRAY-ARGUMENT-VALUE"
    "(DEFUN EVALUATE-ARRAY-ARGUMENT-VALUE ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER) (REQUIREDVALUES LIST) (SLOT SLOT) (VALUEREF OBJECT)))"
    (CL:FUNCTION EVALUATE-ARRAY-ARGUMENT-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-NEW-ARGUMENTS-TREE"
    "(DEFUN (YIELD-NEW-ARGUMENTS-TREE CONS CONS) ((KEYWORDSANDVALUES CONS) (CLASSTYPE TYPE-SPEC) (SELFVARIABLE SYMBOL)))"
    (CL:FUNCTION YIELD-NEW-ARGUMENTS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CURRENT-SELF-TYPE"
    "(DEFUN (GET-CURRENT-SELF-TYPE TYPE) ())"
    (CL:FUNCTION GET-CURRENT-SELF-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-NEW-TREE"
    "(DEFUN (WALK-NEW-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-NEW-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-MAKE-TREE"
    "(DEFUN (WALK-MAKE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-MAKE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-FUNCALL-TREE"
    "(DEFUN (WALK-FUNCALL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-FUNCALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-THE-CODE-TREE"
    "(DEFUN (WALK-THE-CODE-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-THE-CODE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-CALL-SUPER-METHOD-TREE"
    "(DEFUN (WALK-CALL-SUPER-METHOD-TREE CONS TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION WALK-CALL-SUPER-METHOD-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "DE-UGLIFY-ARGUMENTS"
    "(DEFUN (DE-UGLIFY-ARGUMENTS CONS) ((UGLYARGUMENTS CONS)))"
    (CL:FUNCTION DE-UGLIFY-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DE-UGLIFY-PARSE-TREE"
    "(DEFUN (DE-UGLIFY-PARSE-TREE OBJECT) ((TREE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION DE-UGLIFY-PARSE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-NATIVE-NAME"
    "(DEFUN REGISTER-NATIVE-NAME ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))"
    (CL:FUNCTION REGISTER-NATIVE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-NAME?"
    "(DEFUN (NATIVE-NAME? BOOLEAN) ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))"
    (CL:FUNCTION NATIVE-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-RENAMED-NAME-IF-NATIVE"
    "(DEFUN (YIELD-RENAMED-NAME-IF-NATIVE SYMBOL) ((NAME SYMBOL) (LANGUAGE KEYWORD) (CATEGORY KEYWORD)))"
    (CL:FUNCTION YIELD-RENAMED-NAME-IF-NATIVE) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-NEEDS-LISP-MACRO?"
    "(DEFUN (METHOD-NEEDS-LISP-MACRO? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-NEEDS-LISP-MACRO?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-LISP-MACRO-TREES"
    "(DEFUN (YIELD-LISP-MACRO-TREES CONS CONS) ((NAME SYMBOL) (METHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-LISP-MACRO-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-LISP-MACRO-UNITS"
    "(DEFUN CREATE-LISP-MACRO-UNITS ((NAME SYMBOL) (METHOD METHOD-SLOT)))"
    (CL:FUNCTION CREATE-LISP-MACRO-UNITS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT METHOD-C-NAMESPACE-PREFIX :TYPE STRING :OPTION-KEYWORD :C-NAMESPACE-PREFIX :DOCUMENTATION \"The package prefix to use for the C-callable function (defaults to C++ namespace).\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "METHOD-NEEDS-C-CALLABLE-WRAPPER?"
    "(DEFUN (METHOD-NEEDS-C-CALLABLE-WRAPPER? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-NEEDS-C-CALLABLE-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-C-CALLABLE-WRAPPER-NAME"
    "(DEFUN (YIELD-C-CALLABLE-WRAPPER-NAME SYMBOL) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-C-CALLABLE-WRAPPER-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-C-CALLABLE-WRAPPER-TREE"
    "(DEFUN (YIELD-C-CALLABLE-WRAPPER-TREE CONS) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-C-CALLABLE-WRAPPER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-C-CALLABLE-WRAPPER-UNIT"
    "(DEFUN (CREATE-C-CALLABLE-WRAPPER-UNIT METHOD-SLOT) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION CREATE-C-CALLABLE-WRAPPER-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "C-CALLABLE-WRAPPER-METHOD?"
    "(DEFUN (C-CALLABLE-WRAPPER-METHOD? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION C-CALLABLE-WRAPPER-METHOD?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-FUNCTION-CPP-SIGNATURE"
    "(DEFUN (YIELD-FUNCTION-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((FUNCTION METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC) (QUALIFY? BOOLEAN)))"
    (CL:FUNCTION YIELD-FUNCTION-CPP-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "CPP-TYPE-TO-C-TYPE"
    "(DEFUN (CPP-TYPE-TO-C-TYPE STRING) ((TYPE STRING)))"
    (CL:FUNCTION CPP-TYPE-TO-C-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-FUNCTION-C-SIGNATURE"
    "(DEFUN (YIELD-FUNCTION-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((FUNCTION METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-FUNCTION-C-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-METHOD-CPP-SIGNATURE"
    "(DEFUN (YIELD-METHOD-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((METHOD METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC) (QUALIFY? BOOLEAN)))"
    (CL:FUNCTION YIELD-METHOD-CPP-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-METHOD-C-SIGNATURE"
    "(DEFUN (YIELD-METHOD-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((METHOD METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-METHOD-C-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STORAGE-SLOT-CPP-SIGNATURE"
    "(DEFUN (YIELD-STORAGE-SLOT-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((SLOT STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC) (QUALIFY? BOOLEAN)))"
    (CL:FUNCTION YIELD-STORAGE-SLOT-CPP-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STORAGE-SLOT-C-SIGNATURE"
    "(DEFUN (YIELD-STORAGE-SLOT-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((SLOT STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION YIELD-STORAGE-SLOT-C-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE"
    "(DEFUN (YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((GLOBAL GLOBAL-VARIABLE) (QUALIFY? BOOLEAN)))"
    (CL:FUNCTION YIELD-GLOBAL-VARIABLE-CPP-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-GLOBAL-VARIABLE-C-SIGNATURE"
    "(DEFUN (YIELD-GLOBAL-VARIABLE-C-SIGNATURE (CONS OF (CONS OF STRING-WRAPPER))) ((GLOBAL GLOBAL-VARIABLE)))"
    (CL:FUNCTION YIELD-GLOBAL-VARIABLE-C-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "LIST-SIGNATURE-TO-STRING"
    "(DEFUN (LIST-SIGNATURE-TO-STRING STRING) ((SIGNATURE (CONS OF (CONS OF STRING-WRAPPER)))))"
    (CL:FUNCTION LIST-SIGNATURE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-CODE-BY-NAME"
    "(DEFUN (LOOKUP-FUNCTION-CODE-BY-NAME FUNCTION-CODE) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-FUNCTION-CODE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME"
    "(DEFUN (LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME FUNCTION-CODE) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-C-CALLABLE-WRAPPER-CODE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-FUNCTION-CPP-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-FUNCTION-C-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-METHOD-CODE-BY-NAME"
    "(DEFUN (LOOKUP-METHOD-CODE-BY-NAME CODE-WRAPPER) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-METHOD-CODE-BY-NAME) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-WALK16 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-METHOD-CPP-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-METHOD-C-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-METHOD-C-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-METHOD-C-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-STORAGE-SLOT-CPP-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-STORAGE-SLOT-C-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CLASS-CPP-TYPE-BY-NAME"
    "(DEFUN (LOOKUP-CLASS-CPP-TYPE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :DOCUMENTATION \"Return a namespace-qualified C++ translation of the class type
named by `qualifiedName' or NULL if no such STELLA class exists.\" :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-CLASS-CPP-TYPE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT
    "LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-CPP-SIGNATURE-BY-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME"
    "(DEFUN (LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME STRING) ((QUALIFIEDNAME STRING)) :PUBLIC? TRUE :C-CALLABLE? TRUE :THROWS-EXCEPTIONS? TRUE)"
    (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-C-SIGNATURE-BY-NAME) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT METHOD-SLOT METHOD-THROWS-EXCEPTIONS? :TYPE BOOLEAN :OPTION-KEYWORD :THROWS-EXCEPTIONS? :DOCUMENTATION \"If TRUE, this function might throw exceptions which means we need to explicitly catch and handle them in C.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-GLOBAL-EXCEPTION-HANDLER"
    "(DEFUN (GET-GLOBAL-EXCEPTION-HANDLER FUNCTION-CODE) () :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GET-GLOBAL-EXCEPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-GLOBAL-EXCEPTION-HANDLER"
    "(DEFUN SET-GLOBAL-EXCEPTION-HANDLER ((HANDLER FUNCTION-CODE)) :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION SET-GLOBAL-EXCEPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-GLOBAL-EXCEPTION-HANDLER"
    "(DEFUN CALL-GLOBAL-EXCEPTION-HANDLER ((E NATIVE-EXCEPTION)))"
    (CL:FUNCTION CALL-GLOBAL-EXCEPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "GC-PROTECT-OBJECT"
    "(DEFUN (GC-PROTECT-OBJECT NATIVE-OBJECT-POINTER) ((OBJECT NATIVE-OBJECT-POINTER)) :DOCUMENTATION \"Protect `object' from garbage collection.  Returns a handle that can later
be passed to `gc-release-object' to release `object' from garbage collection protection.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GC-PROTECT-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "GC-RELEASE-OBJECT"
    "(DEFUN (GC-RELEASE-OBJECT NATIVE-OBJECT-POINTER) ((HANDLE NATIVE-OBJECT-POINTER)) :DOCUMENTATION \"Release the object pointed to by `handle' from garbage collection protection
and return the protected object.  This frees `handle' but does not necessarily mean that the
object will be garbage collected, it just can be again, once all references to it disappear.\" :PUBLIC? TRUE :C-CALLABLE? TRUE)"
    (CL:FUNCTION GC-RELEASE-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "COMMAND?"
    "(DEFUN (COMMAND? BOOLEAN) ((METHOD METHOD-SLOT)) :DOCUMENTATION \"Return `true' if `method' is an evaluable command.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COMMAND?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COMMAND"
    "(DEFUN (LOOKUP-COMMAND METHOD-SLOT) ((NAME SYMBOL)) :DOCUMENTATION \"If `name' names an evaluable command return its associated
command object;  otherwise, return `null'.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COMMAND-LIKE-FUNCTION"
    "(DEFUN (LOOKUP-COMMAND-LIKE-FUNCTION METHOD-SLOT) ((NAME SYMBOL)) :DOCUMENTATION \"Look up a function with `name' that can be evaluated via `apply'
just like a command, regardless of whether it was marked as such.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-COMMAND-LIKE-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-MUST-BE-EVALUABLE?"
    "(DEFUN (METHOD-MUST-BE-EVALUABLE? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-MUST-BE-EVALUABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-CALLABLE-VIA-APPLY?"
    "(DEFUN (METHOD-CALLABLE-VIA-APPLY? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-CALLABLE-VIA-APPLY?) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-NEEDS-EVALUATOR-WRAPPER?"
    "(DEFUN (METHOD-NEEDS-EVALUATOR-WRAPPER? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION METHOD-NEEDS-EVALUATOR-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-EVALUATOR-WRAPPER-NAME"
    "(DEFUN (YIELD-EVALUATOR-WRAPPER-NAME SYMBOL) ((METHODNAME SYMBOL)))"
    (CL:FUNCTION YIELD-EVALUATOR-WRAPPER-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ARGUMENT-ACCESS-TREE"
    "(DEFUN (YIELD-ARGUMENT-ACCESS-TREE OBJECT) ((ARGUMENTSVARIABLE SYMBOL) (INDEX INTEGER) (RESTARGUMENT? BOOLEAN)))"
    (CL:FUNCTION YIELD-ARGUMENT-ACCESS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-EVALUATOR-WRAPPER-TREE"
    "(DEFUN (YIELD-EVALUATOR-WRAPPER-TREE CONS) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-EVALUATOR-WRAPPER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-EVALUATOR-WRAPPER-UNIT"
    "(DEFUN (CREATE-EVALUATOR-WRAPPER-UNIT METHOD-SLOT) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION CREATE-EVALUATOR-WRAPPER-UNIT) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE"
    "(DEFUN (EVALUATE OBJECT) ((EXPRESSION OBJECT)) :DOCUMENTATION \"Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call `evaluate-string'.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %EVALUATE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-STRING"
    "(DEFUN (EVALUATE-STRING OBJECT) ((EXPRESSION STRING)) :DOCUMENTATION \"Evaluate the expression represented by `expression' and return the result.
This is equivalent to '(evaluate (unstringify expression))'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "TRY-TO-EVALUATE"
    "(DEFUN (TRY-TO-EVALUATE OBJECT) ((TREE OBJECT)) :DOCUMENTATION \"Variant of `evaluate' that only evaluates `tree' if it
represents an evaluable expression.  If it does not, `tree' is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies.\" :PUBLIC? TRUE)" (CL:FUNCTION TRY-TO-EVALUATE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-CONS-TREE"
    "(DEFUN (EVALUATE-CONS-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION EVALUATE-CONS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-ARGUMENT-TREE"
    "(DEFUN (EVALUATE-ARGUMENT-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (EVALUATE? BOOLEAN)))"
    (CL:FUNCTION EVALUATE-ARGUMENT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-ATOMIC-TREE"
    "(DEFUN (EVALUATE-ATOMIC-TREE OBJECT TYPE-SPEC) ((TREE OBJECT)))"
    (CL:FUNCTION EVALUATE-ATOMIC-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-EVALUATABLE-BQUOTE-TREE"
    "(DEFUN (MAKE-EVALUATABLE-BQUOTE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION MAKE-EVALUATABLE-BQUOTE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-BQUOTE-TREE"
    "(DEFUN (EVALUATE-BQUOTE-TREE OBJECT TYPE-SPEC) ((TREE CONS)))"
    (CL:FUNCTION EVALUATE-BQUOTE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-EVALUATED-TREE"
    "(DEFUN (COERCE-EVALUATED-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (SOURCETREE OBJECT) (SOURCETYPE TYPE-SPEC) (TARGETTYPE TYPE-SPEC) (EVALUATE? BOOLEAN)))"
    (CL:FUNCTION COERCE-EVALUATED-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-WALK"
    "(DEFUN STARTUP-WALK () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-WALK)
    NULL)
   (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-WALK-STELLA-STARTUP-WALK)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-WALK-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupWalk") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-WALK ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-WALK1)
    (HELP-STARTUP-WALK2) (HELP-STARTUP-WALK3) (HELP-STARTUP-WALK4)
    (HELP-STARTUP-WALK5) (HELP-STARTUP-WALK6) (HELP-STARTUP-WALK7)
    (HELP-STARTUP-WALK8))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-WALK9))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRANSLATION-UNIT"
        "(DEFCLASS TRANSLATION-UNIT (STANDARD-OBJECT) :PUBLIC? TRUE :PUBLIC-SLOTS ((TU-HOME-MODULE :TYPE MODULE :OPTION-KEYWORD :TU-HOME-MODULE) (THE-OBJECT :TYPE OBJECT) (CATEGORY :TYPE SYMBOL) (ANNOTATION :TYPE STRING) (AUXILIARY? :TYPE BOOLEAN) (CODE-REGISTER :TYPE OBJECT) (TRANSLATION :TYPE OBJECT) (REFERENCED-GLOBALS :TYPE (LIST OF GLOBAL-VARIABLE) :ALLOCATION :EMBEDDED :COMPONENT? TRUE)) :PUBLIC-METHODS ((HOME-MODULE ((SELF TRANSLATION-UNIT)) :TYPE MODULE (RETURN (TU-HOME-MODULE SELF)))) :PRINT-FORM (PRINT-TRANSLATION-UNIT SELF STREAM))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-TRANSLATION-UNIT))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-TRANSLATION-UNIT-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-WALK10)
    (HELP-STARTUP-WALK11) (HELP-STARTUP-WALK12) (HELP-STARTUP-WALK13)
    (HELP-STARTUP-WALK14) (HELP-STARTUP-WALK15) (HELP-STARTUP-WALK16))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *AVAILABLE-STELLA-FEATURES* (LIST OF KEYWORD) (LIST :WARN-ABOUT-UNDEFINED-METHODS :WARN-ABOUT-MISSING-METHODS :SUPPRESS-WARNINGS :USE-HARDCODED-SYMBOLS :USE-COMMON-LISP-STRUCTS :USE-COMMON-LISP-CONSES :USE-CPP-GARBAGE-COLLECTOR :MINIMIZE-JAVA-PREFIXES :TRANSLATE-WITH-COPYRIGHT-HEADER :SUPPORT-UNEXEC) :DOCUMENTATION \"List of available STELLA features.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENT-STELLA-FEATURES* (LIST OF KEYWORD) (LIST) :DOCUMENTATION \"List of currently enabled STELLA features.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *DEFAULT-STELLA-FEATURES* (LIST OF KEYWORD) (LIST :WARN-ABOUT-UNDEFINED-METHODS :WARN-ABOUT-MISSING-METHODS :USE-CPP-GARBAGE-COLLECTOR :USE-COMMON-LISP-CONSES :MINIMIZE-JAVA-PREFIXES) :DOCUMENTATION \"List of STELLA features enabled by default and after resetting them
with `reset-stella-features'.\" :PUBLIC? TRUE)" NULL)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-SET-STELLA-FEATURE
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-UNSET-STELLA-FEATURE
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *TRACED-KEYWORDS* (LIST OF KEYWORD) NULL :PUBLIC? TRUE)"
     NULL)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-ADD-TRACE
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-DROP-TRACE
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *SAFETY* INTEGER 3 :DOCUMENTATION \"Integer between 0 and 3.  Higher levels call more
safety checks.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DEBUGLEVEL* INTEGER 3 :DOCUMENTATION \"Integer between 0 and 3.  Higher levels generate more
code to aid debugging.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *OPTIMIZESPEEDLEVEL* INTEGER 3 :DOCUMENTATION \"Integer between 0 and 3.  Higher levels optimize for
greater execution speed.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *OPTIMIZESPACELEVEL* INTEGER 3 :DOCUMENTATION \"Integer between 0 and 3.  Higher levels optimize for
less code size and memory consumption.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONUNITS* (LIST OF TRANSLATION-UNIT) NULL :PUBLIC? TRUE :DOCUMENTATION \"List of objects representing partially walked
top-level definitions and auxiliary code.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENTTRANSLATIONUNIT* TRANSLATION-UNIT NULL :PUBLIC? TRUE :DOCUMENTATION \"The translation unit currently operated on.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONPHASE* KEYWORD NULL :PUBLIC? TRUE :DOCUMENTATION \"Indicates the current translation phase which is one of
:DEFINE, :FINALIZE, :WALK, or :TRANSLATE.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONVERBOSITYLEVEL* INTEGER 1 :PUBLIC? TRUE :DOCUMENTATION \"The higher the level, the more progress annotations are
generated during the translation of Stella declarations.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *USEHARDCODEDSYMBOLS?* BOOLEAN FALSE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATOROUTPUTLANGUAGE* KEYWORD (RUNNING-IN-LANGUAGE) :DOCUMENTATION \"Specifies the current translator output language; either
:common-lisp, :idl, :java, :cpp, or :cpp-standalone.  The initial value
points to the native implementation language of this STELLA instance.\")"
     NULL)
    (REGISTER-NATIVE-NAME
     SYM-WALK-STELLA-SET-TRANSLATOR-OUTPUT-LANGUAGE
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *LOCALVARIABLETYPETABLE* (KEY-VALUE-LIST OF SYMBOL STANDARD-OBJECT) NULL :DOCUMENTATION \"Table mapping local variable names their declared types
(declared explicitly or implicitly).\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *METHODBEINGWALKED* METHOD-SLOT NULL :DOCUMENTATION \"Contains the method or function being walked, or else `null'.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *FOUNDRETURN?* BOOLEAN FALSE :DOCUMENTATION \"Indicates that one or more return statements have been found
during the walk of the current method.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TARGETTYPE* TYPE-SPEC @VOID :DOCUMENTATION \"Bound to the target type for an expression currently walked.
Used instead of an extra argument to `walk-a-tree', since only a few types
of expressions need to know about their expected type (e.g., FUNCALL).\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *LOCALGENSYMTABLE* KEY-VALUE-LIST NULL :DOCUMENTATION \"Table that maps each prefix of a function-local gensym
to its own gensym counter and/or to related gensyms.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONERRORS* INTEGER 0 :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONWARNINGS* INTEGER 0 :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TRANSLATIONNOTES* INTEGER 0 :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *FUNCTION-CALL-LOG-STREAM* OUTPUT-STREAM NULL :DOCUMENTATION \"The current log file to which function calls should be logged.
A non-NULL value indicates that function call logging is enabled.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOG-FUNCTION-CALLS?* BOOLEAN FALSE :DOCUMENTATION \"Translation switch which indicates that methods should
be instrumented to log their calls to a file.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOG-BREAK-POINT-COUNTER* INTEGER NULL)" NULL)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-START-FUNCTION-CALL-LOGGING
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-SET-CALL-LOG-BREAK-POINT
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-BREAK-PROGRAM
     KWD-WALK-COMMON-LISP KWD-WALK-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *WRAPPED-TYPE-TABLE* (CONS OF CONS) (BQUOTE ((@INTEGER-WRAPPER @INTEGER) (@LONG-INTEGER-WRAPPER @LONG-INTEGER) (@FLOAT-WRAPPER @FLOAT) (@NUMBER-WRAPPER @NUMBER) (@STRING-WRAPPER @STRING) (@MUTABLE-STRING-WRAPPER @MUTABLE-STRING) (@CHARACTER-WRAPPER @CHARACTER) (@BOOLEAN-WRAPPER @BOOLEAN) (@FUNCTION-CODE-WRAPPER @FUNCTION-CODE) (@METHOD-CODE-WRAPPER @METHOD-CODE))) :DOCUMENTATION \"Table of pairs used by `wrapper-value-type' and
`type-to-wrapped-type'.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *COERSION-TABLE* (CONS OF CONS) (BQUOTE ((@BOOLEAN @BOOLEAN-WRAPPER INLINE-WRAP-BOOLEAN) (@INTEGER @INTEGER-WRAPPER WRAP-LITERAL) (@LONG-INTEGER @LONG-INTEGER-WRAPPER WRAP-LITERAL) (@INTEGER @BOOLEAN-WRAPPER INTEGER-TO-BOOLEAN-WRAPPER) (@INTEGER @BOOLEAN INTEGER-TO-BOOLEAN) (@FLOAT @FLOAT-WRAPPER WRAP-LITERAL) (@MUTABLE-STRING @STRING MUTABLE-STRING-TO-STRING) (@MUTABLE-STRING @MUTABLE-STRING-WRAPPER WRAP-LITERAL) (@STRING @STRING-WRAPPER WRAP-LITERAL) (@STRING @MUTABLE-STRING STRING-TO-MUTABLE-STRING) (@STRING @SYMBOL INTERN-SYMBOL) (@CHARACTER @CHARACTER-WRAPPER WRAP-LITERAL) (@CHARACTER @STRING CHARACTER-TO-STRING) (@FUNCTION-CODE @FUNCTION-CODE-WRAPPER WRAP-LITERAL) (@METHOD-CODE @METHOD-CODE-WRAPPER WRAP-LITERAL) (@SYMBOL @STRING SYMBOL-NAME) (@BOOLEAN-WRAPPER @BOOLEAN INLINE-UNWRAP-BOOLEAN) (@INTEGER-WRAPPER @INTEGER WRAPPER-VALUE) (@INTEGER-WRAPPER @LONG-INTEGER WRAPPER-VALUE) (@LONG-INTEGER-WRAPPER @LONG-INTEGER WRAPPER-VALUE) (@FLOAT-WRAPPER @FLOAT WRAPPER-VALUE) (@NUMBER-WRAPPER @FLOAT NUMBER-WRAPPER-TO-FLOAT) (@STRING-WRAPPER @STRING WRAPPER-VALUE) (@MUTABLE-STRING-WRAPPER @MUTABLE-STRING WRAPPER-VALUE) (@CHARACTER-WRAPPER @CHARACTER WRAPPER-VALUE) (@FUNCTION-CODE-WRAPPER @FUNCTION-CODE WRAPPER-VALUE) (@METHOD-CODE-WRAPPER @METHOD-CODE WRAPPER-VALUE) (@SURROGATE @CLASS SURROGATE-VALUE) (@SURROGATE @MODULE SURROGATE-VALUE) (@INPUT-STREAM @NATIVE-INPUT-STREAM NATIVE-STREAM) (@OUTPUT-STREAM @NATIVE-OUTPUT-STREAM NATIVE-STREAM) (@NUMBER @INTEGER (CAST <X> @INTEGER)) (@NUMBER @LONG-INTEGER (CAST <X> @LONG-INTEGER)) (@NUMBER @FLOAT (CAST <X> @FLOAT)) (@INTEGER @FLOAT (CAST <X> @FLOAT)) (@INTEGER @SINGLE-FLOAT (CAST <X> @SINGLE-FLOAT)) (@LONG-INTEGER @FLOAT (CAST <X> @FLOAT)) (@LONG-INTEGER @SINGLE-FLOAT (CAST <X> @SINGLE-FLOAT)) (@FLOAT @SINGLE-FLOAT IDENTITY) (@FLOAT @DOUBLE-FLOAT IDENTITY) (@INTEGER @SHORT-INTEGER IDENTITY) (@INTEGER @LONG-INTEGER IDENTITY) (@INTEGER @UNSIGNED-SHORT-INTEGER IDENTITY) (@INTEGER @UNSIGNED-LONG-INTEGER IDENTITY))) :DOCUMENTATION \"Table of triples used by `lookup-coersion-method' to
locate a coersion method.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *SYMBOL-REGISTRY* (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL) (NEW (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL)) :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *SYMBOL-SET* (LIST OF GENERALIZED-SYMBOL) (NEW (LIST OF GENERALIZED-SYMBOL)))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENTFILENAME* STRING NULL :PUBLIC? TRUE :DOCUMENTATION \"Basename of file that is currently being translated.
A NULL value indicates an incremental translation.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *SPECIALVARIABLESTACK* (KEY-VALUE-LIST OF SYMBOL SYMBOL) (NEW (KEY-VALUE-LIST OF SYMBOL SYMBOL)) :DOCUMENTATION \"Stack mirroring the current state of bound specials
with their associated old-value variables.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *SPECIALSENABLED?* BOOLEAN TRUE :DOCUMENTATION \"`true' if using specials is enabled and legal.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *NOFSPECIALSATLOOPENTRY* INTEGER 0 :DOCUMENTATION \"Number of specials bound at the most recent entry
to a LOOP/WHILE/FOREACH construct.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *TYPE-PREDICATE-TABLE* (CONS OF CONS) (BQUOTE ((@BOOLEAN BOOLEAN? SUBTYPE-OF-BOOLEAN?) (@INTEGER INTEGER? SUBTYPE-OF-INTEGER?) (@LONG-INTEGER LONG-INTEGER? SUBTYPE-OF-LONG-INTEGER?) (@FLOAT FLOAT? SUBTYPE-OF-FLOAT?) (@STRING STRING? SUBTYPE-OF-STRING?) (@CHARACTER CHARACTER? SUBTYPE-OF-CHARACTER?) (@WRAPPER WRAPPER? SUBTYPE-OF-WRAPPER?) (@BOOLEAN-WRAPPER BOOLEAN? SUBTYPE-OF-BOOLEAN?) (@INTEGER-WRAPPER INTEGER? SUBTYPE-OF-INTEGER?) (@LONG-INTEGER-WRAPPER LONG-INTEGER? SUBTYPE-OF-LONG-INTEGER?) (@FLOAT-WRAPPER FLOAT? SUBTYPE-OF-FLOAT?) (@STRING-WRAPPER STRING? SUBTYPE-OF-STRING?) (@CHARACTER-WRAPPER CHARACTER? SUBTYPE-OF-CHARACTER?) (@VERBATIM-STRING-WRAPPER VERBATIM-STRING? SUBTYPE-OF-VERBATIM-STRING?) (@SURROGATE SURROGATE? SUBTYPE-OF-SURROGATE?) (@TYPE TYPE? SUBTYPE-OF-TYPE?) (@SYMBOL SYMBOL? SUBTYPE-OF-SYMBOL?) (@TRANSIENT-SYMBOL TRANSIENT-SYMBOL? SUBTYPE-OF-TRANSIENT-SYMBOL?) (@KEYWORD KEYWORD? SUBTYPE-OF-KEYWORD?) (@CONS CONS? SUBTYPE-OF-CONS?) (@CLASS STELLA-CLASS? SUBTYPE-OF-CLASS?) (@STORAGE-SLOT STORAGE-SLOT? SUBTYPE-OF-STORAGE-SLOT?) (@METHOD-SLOT METHOD-SLOT? SUBTYPE-OF-METHOD-SLOT?) (@ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER? SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER?) (@PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER? SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?))) :DOCUMENTATION \"Table of specialized type predicates for various types.
These predicates have to be used instead of `isa?', since they also work
during bootstrap when only some class objects are defined.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *NUMERIC-TYPE-HIERARCHY* (LIST OF TYPE) (LIST @INTEGER @LONG-INTEGER @FLOAT @NUMBER))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *INLININGMETHODCALL?* BOOLEAN FALSE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *MIXIN-IMPLEMENTATION-STYLE* KEYWORD :SECOND-CLASS :DOCUMENTATION \"A keyword describing how mixin classes are handled in
single-inheritance target languages.  The legal values are
:FIRST-CLASS-WITH-METHOD, which means that variables of a mixin type
are legal and that slot access on a mixin type is facilitated by
inherited-down accessor methods and a catch-all method on OBJECT,
:FIRST-CLASS-WITH-TYPECASE which is similar but replaces the catch-all
method with a function using a TYPECASE, and :SECOND-CLASS, which
means that variables of a mixin type are illegal and no additional
accessors and catch-all methods are needed.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *MAX-NUMBER-OF-STARTUP-UNITS* INTEGER 60 :DOCUMENTATION \"The maximum number of startup units that can be combined
into a single startup function (this avoids the construction of huge startup
functions that would cause too much stress for some wimpy compilers).\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *NATIVE-NAME-TABLE* (HASH-TABLE OF SYMBOL (KEY-VALUE-LIST OF KEYWORD LIST)) (NEW HASH-TABLE))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *GLOBAL-EXCEPTION-HANDLER* FUNCTION-CODE NULL :DOCUMENTATION \"Handler to handle exceptions caught within a c-callable function that throws exceptions.
If non-NULL the handler will be called with two string arguments: message and context.
This is intended primarily for language environments that can't directly catch native
exceptions (e.g., if we are in C or Python).\" :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *C-API-RESULT-BUFFER* NATIVE-OBJECT-POINTER NULL :DOCUMENTATION \"Result buffer used to support temporary protection of garbage-collectable
objects when a C API function is called from a non-C environment (such as Python).\" :PUBLIC? FALSE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *EVALUATIONTREE* OBJECT NULL :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *EVALUATIONPARENTTREE* OBJECT NULL :PUBLIC? TRUE)"
     NULL)
    (REGISTER-NATIVE-NAME SYM-WALK-STELLA-EVALUATE KWD-WALK-COMMON-LISP
     KWD-WALK-FUNCTION)))
  :VOID)
