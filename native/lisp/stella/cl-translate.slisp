;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; cl-translate.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-+ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-- NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-* NULL)
(CL:DEFVAR |SYM-CL-TRANSLATE-STELLA-/| NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-EQ? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-< NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-<= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA->= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-> NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-= NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-!= NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-CONS NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-STANDARD-OBJECT NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-OBJECT NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-VOID NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-VOID-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-TYPED-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-BAD-SYS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SETQ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE-SETTER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-CALL-SUPER-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PROGN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-WITH-PROCESS-LOCK NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-LOOP NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-FOREACH NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-LET NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SPECIAL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-UNWIND-PROTECT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-HANDLER-CASE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-HANDLE-EXCEPTION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-SIGNAL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CAST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SAFE-CAST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-RETURN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-BREAK NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CONTINUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-WHILE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-IF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-WHEN NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-AND NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-OR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NOT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-COND NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CASE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-MAKE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-NEW NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-MV-SETQ NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-QUOTE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SYS-INLINE-CALL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-THE-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PRINT-STREAM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PRINT-NATIVE-STREAM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-VERBATIM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-INLINE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-IGNORE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONTINUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-TRUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-FALSE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-GET-KWD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-GET-SGT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-MODULE-LISP-PACKAGE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-UNESCAPED NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ESCAPED NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-COMPLEX-ESCAPED NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-VALUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-REST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-%%VALUE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-%%REST NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-SVAL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NTH NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NTH-SETTER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-AREF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-AREF-SETTER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NULL? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-DEFINED? NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NORMAL-CALL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-OBJECT-METHOD NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-COMMON-LISP NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-FUNCTION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-CALL NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NULL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-STRING NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-ARRAY NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-INTEGER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-ALLOCATE-ITERATOR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-LENGTH NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NEXT? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-ARGUMENT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-DO NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-LONG-INTEGER NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PRIMARY-TYPE NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-SECOND-CLASS-OBJECT NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-CODE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-NULL-ARRAY? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-*CONDITION-MESSAGE-KEYWORD* NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-REPLACE-SUBSTRINGS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-MAKE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INITIAL-ELEMENT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-%%PRINT-STREAM NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-WARN NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ERROR NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONTINUABLE-ERROR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-METHOD-CODE-CALL NULL)
(CL:DEFVAR SGT-CL-TRANSLATE-STELLA-SHORT-INTEGER NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLASS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-MACRO NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-PRINT-METHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-TYPE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-SELF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-DUMMY NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-%%DEFCONSMETHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-%%DEFINTEGERMETHOD NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SELF NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-*CLSYS-SELF* NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-VOID NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INITFORM NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-TYPE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-EMBEDDED NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INSTANCE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ALLOCATION NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-DOCUMENTATION NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-ACCESSOR NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-OBJECT NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLASS-CL-STRUCT-SLOTS NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-STRUCT NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONC-NAME NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-CONSTRUCTOR NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-COPIER NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-PREDICATE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA- NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-INCLUDE NULL)
(CL:DEFVAR KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-STREAM NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-STARTUP-CL-TRANSLATE NULL)
(CL:DEFVAR SYM-CL-TRANSLATE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* FALSE-WRAPPER NIL-LIST ONE-WRAPPER
  NULL-INTEGER *CURRENTTRANSLATIONUNIT* *SAFETY* *STARTUP-TIME-PHASE*
  *UNFINALIZED-CLASSES* STANDARD-ERROR EOL NULL-STRING-WRAPPER
  *COMMON-LISP-MODULE* *MODULE* NIL *CURRENT-STELLA-FEATURES*))

;;; (DEFUN (DESTRUCTURE-CALL-TREE SYMBOL TYPE CONS) ...)

(CL:DEFUN DESTRUCTURE-CALL-TREE (TREE)
  (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION)
     (CL:RETURN-FROM DESTRUCTURE-CALL-TREE
      (CL:VALUES (%%VALUE (%%REST TREE)) NULL (%%REST (%%REST TREE)))))
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD)
     (CL:RETURN-FROM DESTRUCTURE-CALL-TREE
      (CL:VALUES (%%VALUE (%%REST (%%REST TREE)))
       (%%VALUE (%%REST TREE)) (%%REST (%%REST (%%REST TREE))))))
    (CL:T
     (CL:RETURN-FROM DESTRUCTURE-CALL-TREE
      (CL:VALUES (%%VALUE TREE) NULL (%%REST TREE)))))))

;;; (DEFGLOBAL *CL-TRUE-STRING-WRAPPER* ...)

(CL:DEFVAR *CL-TRUE-STRING-WRAPPER* NULL)

;;; (DEFGLOBAL *CL-FALSE-STRING-WRAPPER* ...)

(CL:DEFVAR *CL-FALSE-STRING-WRAPPER* NULL)

;;; (DEFGLOBAL *CL-OPERATOR-TABLE* ...)

(CL:DEFVAR *CL-OPERATOR-TABLE* NULL
  "Mapping from STELLA operators to Common-Lisp operators.")

;;; (DEFUN (USE-CL-CONSES? BOOLEAN) ...)

(CL:DEFUN USE-CL-CONSES? ()
  (CL:RETURN-FROM USE-CL-CONSES?
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES)))

;;; (DEFUN (USE-DEFCONSMETHOD? BOOLEAN) ...)

(CL:DEFUN USE-DEFCONSMETHOD? (METHOD)
  (CL:WHEN
   (CL:AND (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
    (MEMB? *CURRENT-STELLA-FEATURES*
     KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES))
   (CL:LET* ((TEST-VALUE-000 (%METHOD-SLOT.SLOT-OWNER METHOD)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-CL-TRANSLATE-STELLA-CONS)
      (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:T))
     ((CL:EQ TEST-VALUE-000 SGT-CL-TRANSLATE-STELLA-STANDARD-OBJECT)
      (CL:COND
       ((CL:EQ
         (%SLOT.SLOT-OWNER
          (LOOKUP-SLOT
           (%SURROGATE.SURROGATE-VALUE SGT-CL-TRANSLATE-STELLA-CONS)
           (%METHOD-SLOT.SLOT-NAME METHOD)))
         SGT-CL-TRANSLATE-STELLA-CONS)
        (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:NIL))
       (CL:T (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:T))))
     ((CL:EQ TEST-VALUE-000 SGT-CL-TRANSLATE-STELLA-OBJECT)
      (CL:LET*
       ((TEST-VALUE-001
         (%SLOT.SLOT-OWNER
          (LOOKUP-SLOT
           (%SURROGATE.SURROGATE-VALUE SGT-CL-TRANSLATE-STELLA-CONS)
           (%METHOD-SLOT.SLOT-NAME METHOD)))))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-001 SGT-CL-TRANSLATE-STELLA-CONS)
          (CL:EQ TEST-VALUE-001
           SGT-CL-TRANSLATE-STELLA-STANDARD-OBJECT))
         (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:NIL))
        (CL:T (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:T)))))
     (CL:T))))
  (CL:RETURN-FROM USE-DEFCONSMETHOD? CL:NIL))

;;; (DEFUN (USE-CL-STRUCTS? BOOLEAN) ...)

(CL:DEFUN USE-CL-STRUCTS? ()
  (CL:RETURN-FROM USE-CL-STRUCTS?
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS)))

;;; (DEFUN (USE-VECTOR-STRUCTS? BOOLEAN) ...)

(CL:DEFUN USE-VECTOR-STRUCTS? ()
  (CL:RETURN-FROM USE-VECTOR-STRUCTS?
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)))

;;; (DEFSPECIAL *NEEDEXPLICITRETURN?* ...)

(CL:DEFVAR *NEEDEXPLICITRETURN?* CL:NIL)

;;; (DEFUN (CL-TRANSLATE-LIST-OF-TREES CONS) ...)

(CL:DEFUN CL-TRANSLATE-LIST-OF-TREES (TREES)
  (CL:LET* ((CURSOR TREES))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:LET*
     ((*NEEDEXPLICITRETURN?*
       (CL:OR *NEEDEXPLICITRETURN?*
        (CL:NOT (CL:EQ (%%REST CURSOR) NIL)))))
     (CL:DECLARE (CL:SPECIAL *NEEDEXPLICITRETURN?*))
     (CL:SETF (%%VALUE CURSOR) (CL-TRANSLATE-A-TREE (%%VALUE CURSOR))))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:RETURN-FROM CL-TRANSLATE-LIST-OF-TREES TREES)))

;;; (DEFUN (CL-TRANSLATE-VOID-SYS CONS) ...)

(CL:DEFUN CL-TRANSLATE-VOID-SYS (TREE)
  (CL:LET* ((OTREE (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE)))))
   (CL:RETURN-FROM CL-TRANSLATE-VOID-SYS OTREE)))

;;; (DEFUN (CL-TRANSLATE-TYPED-SYS OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-TYPED-SYS (TREE)
  (CL:LET* ((OTREE (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE)))))
   (CL:RETURN-FROM CL-TRANSLATE-TYPED-SYS OTREE)))

;;; (DEFUN (CL-TRANSLATE-BAD-SYS OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-BAD-SYS (TREE)
  (CL:LET* ((RETURNTYPE (%%VALUE (%%REST (%%REST TREE)))))
   (CL:IF (CL:EQ RETURNTYPE SGT-CL-TRANSLATE-STELLA-VOID)
    (CL:RETURN-FROM CL-TRANSLATE-BAD-SYS
     (CL-TRANSLATE-A-TREE (YIELD-ILLEGAL-STATEMENT-TREE)))
    (CL:RETURN-FROM CL-TRANSLATE-BAD-SYS
     (CL-TRANSLATE-A-TREE (YIELD-ILLEGAL-EXPRESSION-TREE))))))

;;; (DEFUN (CL-TRANSLATE-A-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-A-TREE (TREE)
  (CL:RETURN-FROM CL-TRANSLATE-A-TREE (HELP-CL-TRANSLATE-A-TREE TREE)))

;;; (DEFUN (HELP-CL-TRANSLATE-A-TREE OBJECT) ...)

(CL:DEFUN HELP-CL-TRANSLATE-A-TREE (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-CL-TRANSLATE-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (CL:EQ TREE NIL)
      (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-VOID-SYS)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-VOID-SYS TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-TYPED-SYS)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-TYPED-SYS TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-BAD-SYS)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-BAD-SYS TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SETQ)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-SETQ-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE TREE)))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE-SETTER)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE TREE)))
       ((CL:OR
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD)
         (CL:EQ TEST-VALUE-000
          SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CALL-METHOD-TREE TREE)))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-SYS-CALL-SUPER-METHOD)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CALL-SUPER-METHOD-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-PROGN)
        (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "PROGN"))
        (CL:SETF (%%REST TREE)
         (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE)))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-WITH-PROCESS-LOCK)
        (CL:SETF (%%VALUE TREE)
         (CL-TRANSLATE-GLOBAL-SYMBOL
          SYM-CL-TRANSLATE-STELLA-WITH-PROCESS-LOCK))
        (SECOND-SETTER TREE
         (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE))))
        (CL:SETF (%%REST (%%REST TREE))
         (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST TREE))))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-LOOP)
        (CL:LET* ((*NEEDEXPLICITRETURN?* CL:T))
         (CL:DECLARE (CL:SPECIAL *NEEDEXPLICITRETURN?*))
         (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "LOOP"))
         (CL:SETF (%%REST TREE)
          (MAYBE-WRAP-WITH-CONTINUE-LABEL
           (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE))))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-FOREACH)
        (CL:LET* ((*NEEDEXPLICITRETURN?* CL:T))
         (CL:DECLARE (CL:SPECIAL *NEEDEXPLICITRETURN?*))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-FOREACH-TREE TREE))))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-LET)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-LET-TREE TREE CL:NIL)))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-STARTUP-TIME-PROGN)
        (CL:LET* ((*NEEDEXPLICITRETURN?* CL:T))
         (CL:DECLARE (CL:SPECIAL *NEEDEXPLICITRETURN?*))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE TREE))))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SPECIAL)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-SPECIAL-TREE TREE)))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-SYS-UNWIND-PROTECT)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-UNWIND-PROTECT-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-HANDLER-CASE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-HANDLER-CASE-TREE TREE)))
       ((CL:EQ TEST-VALUE-000
         SYM-CL-TRANSLATE-STELLA-SYS-HANDLE-EXCEPTION)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-HANDLE-EXCEPTION-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-SIGNAL)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-SIGNAL-TREE TREE)))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CAST)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SAFE-CAST))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CAST-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-RETURN)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-RETURN-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-BREAK)
        (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "RETURN"))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CONTINUE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (LIST* (INTERN-COMMON-LISP-SYMBOL "GO")
          KWD-CL-TRANSLATE-CONTINUE NIL)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-WHILE)
        (CL:LET* ((*NEEDEXPLICITRETURN?* CL:T))
         (CL:DECLARE (CL:SPECIAL *NEEDEXPLICITRETURN?*))
         (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
          (CL-TRANSLATE-WHILE-TREE TREE))))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-IF)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CHOOSE)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-WHEN)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-UNLESS))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CONDITIONAL-TREE TREE)))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-AND)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-OR)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-NOT))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-BOOLEAN-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-COND)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-COND-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CASE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CASE-TREE TREE)))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-EQ?)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA->)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA->=)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-<)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-<=))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-OPERATOR-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-MAKE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-MAKE-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-NEW)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-NEW-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-MV-SETQ)
        (FIRST-SETTER TREE
         (INTERN-COMMON-LISP-SYMBOL "MULTIPLE-VALUE-SETQ"))
        (SECOND-SETTER TREE
         (CL-TRANSLATE-LIST-OF-TREES (%%VALUE (%%REST TREE))))
        (THIRD-SETTER TREE
         (CL-TRANSLATE-A-TREE (%%VALUE (%%REST (%%REST TREE)))))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-QUOTE)
        (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "QUOTE"))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE TREE))
       ((CL:OR
         (CL:EQ TEST-VALUE-000
          SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION-CODE)
         (CL:EQ TEST-VALUE-000
          SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD-CODE))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-SYS-INLINE-CALL)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-INLINE-CALL-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-THE-CODE)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-THE-CODE-TREE TREE)))
       ((CL:OR
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-PRINT-STREAM)
         (CL:EQ TEST-VALUE-000
          SYM-CL-TRANSLATE-STELLA-PRINT-NATIVE-STREAM))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-PRINT-STREAM-TREE TREE)))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-VERBATIM)
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-VERBATIM-TREE TREE)))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-INLINE)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-IGNORE))
        (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
         (CL-TRANSLATE-INLINE-TREE TREE)))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          TEST-VALUE-000 "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))
   (CL:T
    (CL:RETURN-FROM HELP-CL-TRANSLATE-A-TREE
     (CL-TRANSLATE-ATOMIC-TREE TREE)))))

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(%%DEFCONSMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE OBJECT))
  (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE TREE))

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE FLOAT-WRAPPER))
  (CL:LET* ((FLOAT-STRING (STRINGIFY TREE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FLOAT-STRING))
   (CL:COND
    ((MEMBER? FLOAT-STRING #\e)
     (CL:SETQ FLOAT-STRING (SUBSTITUTE FLOAT-STRING #\d #\e)))
    ((MEMBER? FLOAT-STRING #\E)
     (CL:SETQ FLOAT-STRING (SUBSTITUTE FLOAT-STRING #\d #\E)))
    (CL:T (CL:SETQ FLOAT-STRING (CONCATENATE FLOAT-STRING "d0"))))
   (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
    (NEW-VERBATIM-STRING-WRAPPER FLOAT-STRING))))

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE SYMBOL))
  (CL:COND
   ((CL:EQ TREE SYM-CL-TRANSLATE-STELLA-TRUE)
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE *CL-TRUE-STRING-WRAPPER*))
   ((CL:EQ TREE SYM-CL-TRANSLATE-STELLA-FALSE)
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
     *CL-FALSE-STRING-WRAPPER*))
   ((CL:NOT (CL:EQ (LOOKUP-GLOBAL-VARIABLE TREE) NULL))
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
     (CL-TRANSLATE-GLOBAL-SYMBOL TREE)))
   (CL:T
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
     (CL-TRANSLATE-LOCAL-SYMBOL TREE)))))

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE KEYWORD))
  (CL:IF (USE-HARDCODED-SYMBOLS?)
   (CL:LET*
    ((OFFSET (WRAP-INTEGER (%KEYWORD.SYMBOL-ID (KEYWORDIFY TREE)))))
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
     (LIST* SYM-CL-TRANSLATE-STELLA-GET-KWD OFFSET NIL)))
   (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
    (CL-TRANSLATE-GLOBAL-SYMBOL (YIELD-SYMBOL-CONSTANT-NAME TREE)))))

;;; (DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ...)

(CL:DEFMETHOD CL-TRANSLATE-ATOMIC-TREE ((TREE SURROGATE))
  (CL:IF (USE-HARDCODED-SYMBOLS?)
   (CL:LET* ((OFFSET (WRAP-INTEGER (%SURROGATE.SYMBOL-ID TREE))))
    (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
     (LIST* SYM-CL-TRANSLATE-STELLA-GET-SGT OFFSET NIL)))
   (CL:RETURN-FROM CL-TRANSLATE-ATOMIC-TREE
    (CL-TRANSLATE-GLOBAL-SYMBOL (YIELD-SYMBOL-CONSTANT-NAME TREE)))))

;;; (DEFUN (CL-TRANSLATE-GLOBAL-SYMBOL OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-GLOBAL-SYMBOL (SYMBOL)
  (CL:LET* ((SYMBOLMODULE (%SYMBOL.HOME-CONTEXT SYMBOL)))
   (CL:WHEN (CL:EQ SYMBOLMODULE *COMMON-LISP-MODULE*)
    (CL:RETURN-FROM CL-TRANSLATE-GLOBAL-SYMBOL SYMBOL))
   (CL:WHEN (CL:EQ SYMBOLMODULE NULL) (CL:SETQ SYMBOLMODULE *MODULE*))
   (CL:RETURN-FROM CL-TRANSLATE-GLOBAL-SYMBOL
    (YIELD-GLOBAL-LISP-SYMBOL SYMBOLMODULE
     (%SYMBOL.SYMBOL-NAME SYMBOL)))))

;;; (DEFUN (YIELD-READABLE-SYMBOL-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  YIELD-READABLE-SYMBOL-NAME))
(CL:DEFUN YIELD-READABLE-SYMBOL-NAME (SYMBOLMODULE SYMBOLNAME LOCAL?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOLNAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOLNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((LISPSYMBOLNAME
     (CL:IF
      (CL:OR LOCAL?
       (CL:NOT
        (CL:EQ
         (%STRING-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%MODULE.DYNAMIC-SLOTS SYMBOLMODULE)
           SYM-CL-TRANSLATE-STELLA-MODULE-LISP-PACKAGE
           NULL-STRING-WRAPPER))
         STELLA::NULL-STRING)))
      SYMBOLNAME (COMPUTE-FULL-NAME SYMBOLNAME SYMBOLMODULE))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LISPSYMBOLNAME))
   (CL:LET*
    ((TEST-VALUE-000
      (COMPUTE-SYMBOL-ESCAPE-CODE LISPSYMBOLNAME CL:NIL)))
    (CL:COND ((CL:EQ TEST-VALUE-000 KWD-CL-TRANSLATE-UNESCAPED))
     ((CL:EQ TEST-VALUE-000 KWD-CL-TRANSLATE-ESCAPED)
      (CL:SETQ LISPSYMBOLNAME
       (CONCATENATE "|" (CONCATENATE LISPSYMBOLNAME "|"))))
     ((CL:EQ TEST-VALUE-000 KWD-CL-TRANSLATE-COMPLEX-ESCAPED)
      (CL:LET* ((S (NEW-OUTPUT-STRING-STREAM)))
       (PRINT-SYMBOL-NAME-READABLY LISPSYMBOLNAME
        (%OUTPUT-STRING-STREAM.NATIVE-STREAM S) CL:NIL)
       (CL:SETQ LISPSYMBOLNAME (THE-STRING-READER S))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM YIELD-READABLE-SYMBOL-NAME LISPSYMBOLNAME)))

;;; (DEFUN (YIELD-GLOBAL-LISP-SYMBOL OBJECT) ...)

(CL:DEFUN YIELD-GLOBAL-LISP-SYMBOL (SYMBOLMODULE SYMBOLNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOLNAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOLNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((LISPSYMBOLPACKAGE
     (CL:IF
      (CL:OR (CL:EQ SYMBOLMODULE NULL) (CL:EQ SYMBOLMODULE *MODULE*)
       (STRING-EQL? (LISP-PACKAGE SYMBOLMODULE)
        (LISP-PACKAGE *MODULE*)))
      STELLA::NULL-STRING (LISP-PACKAGE SYMBOLMODULE)))
    (LISPSYMBOLNAME
     (YIELD-READABLE-SYMBOL-NAME SYMBOLMODULE SYMBOLNAME CL:NIL)))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING LISPSYMBOLPACKAGE LISPSYMBOLNAME))
   (CL:IF (CL:EQ LISPSYMBOLPACKAGE STELLA::NULL-STRING)
    (CL:RETURN-FROM YIELD-GLOBAL-LISP-SYMBOL
     (NEW-VERBATIM-STRING-WRAPPER LISPSYMBOLNAME))
    (CL:RETURN-FROM YIELD-GLOBAL-LISP-SYMBOL
     (NEW-VERBATIM-STRING-WRAPPER
      (CONCATENATE LISPSYMBOLPACKAGE
       (CONCATENATE "::" LISPSYMBOLNAME)))))))

;;; (DEFUN (CL-TRANSLATE-LOCAL-SYMBOL OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-LOCAL-SYMBOL (SYMBOL)
  (CL:RETURN-FROM CL-TRANSLATE-LOCAL-SYMBOL
   (NEW-VERBATIM-STRING-WRAPPER
    (YIELD-READABLE-SYMBOL-NAME (%SYMBOL.HOME-CONTEXT SYMBOL)
     (%SYMBOL.SYMBOL-NAME SYMBOL) CL:T))))

;;; (DEFUN (CL-TRANSLATE-SETQ-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-SETQ-TREE (TREE)
  (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "SETQ"))
  (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE))))
  (THIRD-SETTER TREE
   (CL-TRANSLATE-A-TREE (%%VALUE (%%REST (%%REST TREE)))))
  (CL:RETURN-FROM CL-TRANSLATE-SETQ-TREE TREE))

;;; (DEFUN (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-STRUCT-SLOT-ACCESSOR-NAME (CLASSTYPE SLOTNAME)
  (CL:RETURN-FROM YIELD-STRUCT-SLOT-ACCESSOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL (%SURROGATE.HOME-CONTEXT CLASSTYPE)
    (CONCATENATE "%"
     (CONCATENATE (%SURROGATE.SYMBOL-NAME CLASSTYPE)
      (CONCATENATE "." (%SYMBOL.SYMBOL-NAME SLOTNAME)))))))

;;; (DEFUN (YIELD-CLOS-SLOT-ACCESSOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-CLOS-SLOT-ACCESSOR-NAME (SLOTNAME)
  (CL:RETURN-FROM YIELD-CLOS-SLOT-ACCESSOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL (%SYMBOL.HOME-CONTEXT SLOTNAME)
    (CONCATENATE "%" (%SYMBOL.SYMBOL-NAME SLOTNAME)))))

;;; (DEFUN (YIELD-SLOT-VALUE-READER-TREE CONS) ...)

(CL:DEFUN YIELD-SLOT-VALUE-READER-TREE (SLOTNAME OBJECTREF OBJECTTYPE)
  (CL:WHEN
   (CL:AND (CL:EQ OBJECTTYPE SGT-CL-TRANSLATE-STELLA-CONS)
    (MEMB? *CURRENT-STELLA-FEATURES*
     KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES))
   (CL:COND
    ((CL:EQ SLOTNAME SYM-CL-TRANSLATE-STELLA-VALUE)
     (CL:RETURN-FROM YIELD-SLOT-VALUE-READER-TREE
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-%%VALUE)
       (CONS OBJECTREF NIL))))
    ((CL:EQ SLOTNAME SYM-CL-TRANSLATE-STELLA-REST)
     (CL:RETURN-FROM YIELD-SLOT-VALUE-READER-TREE
      (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-%%REST)
       (CONS OBJECTREF NIL))))
    (CL:T)))
  (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE OBJECTTYPE)))
   (CL:COND
    ((CL:OR
      (CL:NOT
       (MEMB? *CURRENT-STELLA-FEATURES*
        KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS))
      (EXCEPTION-CLASS? CLASS)
      (CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? CLASS))
     (CL:RETURN-FROM YIELD-SLOT-VALUE-READER-TREE
      (CONS (YIELD-CLOS-SLOT-ACCESSOR-NAME SLOTNAME)
       (CONS OBJECTREF NIL))))
    ((MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)
     (CL:RETURN-FROM YIELD-SLOT-VALUE-READER-TREE
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-CLSYS-SVAL)
       (CONS (WRAP-INTEGER (CL-STRUCT-SLOT-OFFSET SLOTNAME OBJECTTYPE))
        (CONS
         (CL-TRANSLATE-GLOBAL-SYMBOL
          (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME OBJECTTYPE)
           (%SURROGATE.HOME-CONTEXT OBJECTTYPE) CL:T))
         (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SLOTNAME)
          (CONS OBJECTREF NIL)))))))
    (CL:T
     (CL:RETURN-FROM YIELD-SLOT-VALUE-READER-TREE
      (CONS (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECTTYPE SLOTNAME)
       (CONS OBJECTREF NIL)))))))

;;; (DEFUN (YIELD-SLOT-VALUE-WRITER-TREE CONS) ...)

(CL:DEFUN YIELD-SLOT-VALUE-WRITER-TREE (SLOTNAME OBJECTREF OBJECTTYPE VALUEREF)
  (CL:RETURN-FROM YIELD-SLOT-VALUE-WRITER-TREE
   (LIST* (INTERN-COMMON-LISP-SYMBOL "SETF")
    (YIELD-SLOT-VALUE-READER-TREE SLOTNAME OBJECTREF OBJECTTYPE)
    (CONS VALUEREF NIL))))

;;; (DEFUN (TRUE-SLOT-NAME SYMBOL) ...)

(CL:DEFUN TRUE-SLOT-NAME (SLOTNAME TYPE)
  (CL:RETURN-FROM TRUE-SLOT-NAME
   (CANONICAL-SLOT-NAME
    (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME))))

;;; (DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FIXED-SLOT-VALUE-TREE (TREE)
  (CL:LET*
   ((OBJTYPE (%%VALUE (%%REST TREE)))
    (SLOTNAME
     (TRUE-SLOT-NAME (%%VALUE (%%REST (%%REST TREE))) OBJTYPE))
    (OBJREF (CL-TRANSLATE-A-TREE (FOURTH TREE)))
    (OTREE (YIELD-SLOT-VALUE-READER-TREE SLOTNAME OBJREF OBJTYPE)))
   (CL:RETURN-FROM CL-TRANSLATE-FIXED-SLOT-VALUE-TREE OTREE)))

;;; (DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE (TREE)
  (CL:LET*
   ((OBJTYPE (%%VALUE (%%REST TREE)))
    (SLOTNAME
     (TRUE-SLOT-NAME (%%VALUE (%%REST (%%REST TREE))) OBJTYPE))
    (OBJREF (CL-TRANSLATE-A-TREE (FOURTH TREE)))
    (VALUEREF (CL-TRANSLATE-A-TREE (FIFTH TREE)))
    (OTREE
     (YIELD-SLOT-VALUE-WRITER-TREE SLOTNAME OBJREF OBJTYPE VALUEREF)))
   (CL:RETURN-FROM CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE OTREE)))

;;; (DEFUN (CL-TRANSLATE-CALL-METHOD-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-CALL-METHOD-TREE (TREE)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:COND
    ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NTH)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NTH-SETTER))
     (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
      (CL-TRANSLATE-NTH-TREE TREE)))
    ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-AREF)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-AREF-SETTER))
     (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
      (CL-TRANSLATE-AREF-TREE TREE)))
    ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NULL?)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-DEFINED?))
     (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
      (CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE CL:NIL)))
    (CL:T))
   (CL:WHEN
    (CL:OR (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST)
     (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST-ITERATOR))
    (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
     (CL-TRANSLATE-ARGUMENT-LIST-TREE TREE)))
   (CL:WHEN (CL:NOT (CL:EQ (LOOKUP *CL-OPERATOR-TABLE* OPERATOR) NULL))
    (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
     (CL-TRANSLATE-OPERATOR-TREE TREE)))
   (CL:RETURN-FROM CL-TRANSLATE-CALL-METHOD-TREE
    (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER ARGUMENTS))))

;;; (DEFUN (CL-TRANSLATE-CALL-SUPER-METHOD-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-CALL-SUPER-METHOD-TREE (TREE)
  (FIRST-SETTER TREE SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "CALL-NEXT-METHOD"))
   (CL:RETURN-FROM CL-TRANSLATE-CALL-SUPER-METHOD-TREE
    (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER ARGUMENTS))))

;;; (DEFUN (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS SYMBOL) ...)

(CL:DEFUN METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS (SLOTNAME OWNER FUNCTION?)
  (CL:WHEN
   (CL:OR FUNCTION? (CL:EQ OWNER NULL)
    (CL:EQ SLOTNAME SYM-CL-TRANSLATE-STELLA-NULL?)
    (CL:EQ SLOTNAME SYM-CL-TRANSLATE-STELLA-DEFINED?)
    (SYMBOL-COMMON-LISP? SLOTNAME)
    (CL:NOT
     (MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS))
    (CL:NOT
     (MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)))
   (CL:RETURN-FROM METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
    SYM-CL-TRANSLATE-STELLA-NORMAL-CALL))
  (CL:IF
   (CL:OR
    (CL:AND (CL:NOT (SUBTYPE-OF? OWNER SGT-CL-TRANSLATE-STELLA-OBJECT))
     (CL:NOT (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE OWNER))))
    (CL:AND (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-CONS)
     (MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES)))
   (CL:RETURN-FROM METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
    SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD)
   (CL:IF (CL:EQ SLOTNAME SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
    (CL:RETURN-FROM METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
     SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
    (CL:RETURN-FROM METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
     SYM-CL-TRANSLATE-STELLA-OBJECT-METHOD))))

;;; (DEFUN (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NORMAL-CALL-METHOD-TREE (OPERATOR OWNER ARGUMENTS)
  (CL:LET*
   ((TRANSLATEDOPERATOR
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-RENAMED-NAME-IF-NATIVE OPERATOR
       KWD-CL-TRANSLATE-COMMON-LISP KWD-CL-TRANSLATE-FUNCTION))))
   (CL:LET*
    ((TEST-VALUE-000
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS OPERATOR OWNER
       (CL:EQ OWNER NULL))))
    (CL:COND
     ((CL:OR
       (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-OBJECT-METHOD)
       (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT))
      (CL:RETURN-FROM CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS
        (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-CLSYS-CALL)
        (CONS TRANSLATEDOPERATOR
         (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL)))))
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD)
      (CL:RETURN-FROM CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS TRANSLATEDOPERATOR
        (CONS (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS))
         (CONS SYM-CL-TRANSLATE-STELLA-NULL
          (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES (%%REST ARGUMENTS))
           NIL))))))
     (CL:T
      (CL:RETURN-FROM CL-TRANSLATE-NORMAL-CALL-METHOD-TREE
       (CONS TRANSLATEDOPERATOR
        (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL))))))))

;;; (DEFUN (CL-TRANSLATE-NTH-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NTH-TREE (TREE)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:LET*
    ((SETTER? (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NTH-SETTER))
     (COLLECTION (%%VALUE ARGUMENTS)) (POSITION (LAST ARGUMENTS))
     (VALUE (CL:IF SETTER? (%%VALUE (%%REST ARGUMENTS)) NULL)))
    (CL:COND
     ((CL:OR (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-STRING)
       (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-MUTABLE-STRING)
       (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR))
      (CL:WHEN
       (CL:OR (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR)
        (METHOD-CALL-INLINING-ENABLED?))
       (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "AREF"))
       (CL:SETQ TREE
        (CONS OPERATOR
         (CONS (CL-TRANSLATE-A-TREE COLLECTION)
          (CONS (CL-TRANSLATE-A-TREE POSITION) NIL))))
       (CL:WHEN SETTER?
        (CL:SETQ TREE
         (LIST* (INTERN-COMMON-LISP-SYMBOL "SETF") TREE
          (CONS (CL-TRANSLATE-A-TREE VALUE) NIL))))
       (CL:RETURN-FROM CL-TRANSLATE-NTH-TREE TREE)))
     (CL:T))
    (CL:RETURN-FROM CL-TRANSLATE-NTH-TREE
     (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER ARGUMENTS)))))

;;; (DEFUN (CL-TRANSLATE-AREF-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-AREF-TREE (TREE)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:COND
    ((CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-ARRAY)
     (CL:LET*
      ((SETTER? (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-AREF-SETTER))
       (ARRAY (%%VALUE ARGUMENTS))
       (ARRAYTYPE (WALKED-EXPRESSION-TYPE ARRAY))
       (INDICES
        (CL:IF SETTER? (%%REST (%%REST ARGUMENTS)) (%%REST ARGUMENTS)))
       (VALUE (CL:IF SETTER? (%%VALUE (%%REST ARGUMENTS)) NULL)))
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "AREF"))
      (CL:SETQ ARRAY (CL-TRANSLATE-A-TREE ARRAY))
      (CL:SETQ INDICES (CL-TRANSLATE-LIST-OF-TREES INDICES))
      (CL:WHEN (GENERATE-CL-TYPE-DECLARATIONS?)
       (CL:WHEN (CONS? ARRAY)
        (CL:SETQ ARRAY
         (CL-YIELD-TYPED-EXPRESSION-TREE ARRAY ARRAYTYPE)))
       (CL:LET* ((IT (ALLOCATE-ITERATOR INDICES)))
        (CL:LOOP WHILE (NEXT? IT) DO
         (CL:WHEN (CONS? (%CONS-ITERATOR.VALUE IT))
          (VALUE-SETTER IT
           (CL-YIELD-TYPED-EXPRESSION-TREE (%CONS-ITERATOR.VALUE IT)
            SGT-CL-TRANSLATE-STELLA-INTEGER))))))
      (CL:SETQ TREE
       (CONS OPERATOR (CONS ARRAY (CONCATENATE INDICES NIL))))
      (CL:WHEN SETTER?
       (CL:SETQ TREE
        (LIST* (INTERN-COMMON-LISP-SYMBOL "SETF") TREE
         (CONS (CL-TRANSLATE-A-TREE VALUE) NIL))))
      (CL:RETURN-FROM CL-TRANSLATE-AREF-TREE TREE)))
    (CL:T
     (CL:RETURN-FROM CL-TRANSLATE-AREF-TREE
      (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE OPERATOR OWNER
       ARGUMENTS))))))

;;; (DEFUN (CL-TRANSLATE-ARGUMENT-LIST-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-ARGUMENT-LIST-TREE (TREE)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:SETQ OWNER OWNER)
   (CL:COND
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-ALLOCATE-ITERATOR)
     (CL:RETURN-FROM CL-TRANSLATE-ARGUMENT-LIST-TREE
      (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-LENGTH)
     (CL:RETURN-FROM CL-TRANSLATE-ARGUMENT-LIST-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "LENGTH")
       (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS)) NIL)))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NEXT?)
     (CL:RETURN-FROM CL-TRANSLATE-ARGUMENT-LIST-TREE
      (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-ARGUMENT)
     (CL:RETURN-FROM CL-TRANSLATE-ARGUMENT-LIST-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "POP")
       (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS)) NIL)))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Cannot translate call to `"
        (DE-UGLIFY-PARSE-TREE OPERATOR) "' on an `ARGUMENT-LIST'."
        EOL)))
     (CL:RETURN-FROM CL-TRANSLATE-ARGUMENT-LIST-TREE
      (CONS OPERATOR
       (CONS (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS)) NIL)))))))

;;; (DEFUN (DUPLICATE-CURSOR-VARIABLE? BOOLEAN) ...)

(CL:DEFUN DUPLICATE-CURSOR-VARIABLE? (VARIABLE ITERATORBINDINGS)
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET* ((IB NULL) (ITER-000 ITERATORBINDINGS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ IB (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%%VALUE IB) VARIABLE) (CL:SETQ FOUND?-000 CL:T)
      (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((VALUE-000 FOUND?-000))
    (CL:RETURN-FROM DUPLICATE-CURSOR-VARIABLE? VALUE-000))))

;;; (DEFUN (CL-TRANSLATE-FOREACH-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-FOREACH-TREE (TREE)
  (CL:LET*
   ((ITERATORBINDINGS (%%VALUE (%%REST TREE)))
    (VALUETREES (%%VALUE (%%REST (%%REST TREE))))
    (NEXTTREES (FOURTH TREE))
    (CONTINUATIONTEST (CL-TRANSLATE-BOOLEAN-TEST (FIFTH TREE) CL:NIL))
    (BODY (CL-TRANSLATE-LIST-OF-TREES (NTH-REST TREE 5)))
    (DECLARATIONS NIL) (VALUEASSIGNMENTS NIL) (NEXTASSIGNMENTS NIL)
    (TYPEDECLARATIONS NIL) (ITERATORCONSTRUCTOR NULL))
   (CL:WHEN (GENERATE-CL-TYPE-DECLARATIONS?)
    (CL:SETQ TYPEDECLARATIONS
     (CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES ITERATORBINDINGS)))
   (CL:LET*
    ((BINDING NULL) (ITER-000 ITERATORBINDINGS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-000))
     (CL:SETQ ITERATORCONSTRUCTOR
      (CL-TRANSLATE-A-TREE (%%VALUE (%%REST (%%REST BINDING)))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CONS (CL-TRANSLATE-LOCAL-SYMBOL (%%VALUE BINDING))
          (CONS ITERATORCONSTRUCTOR NIL))
         NIL))
       (CL:IF (CL:EQ DECLARATIONS NIL)
        (CL:SETQ DECLARATIONS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST DECLARATIONS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CONS (CL-TRANSLATE-LOCAL-SYMBOL (%%VALUE BINDING))
          (CONS ITERATORCONSTRUCTOR NIL))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((TREE NULL) (ITER-001 VALUETREES) (COLLECT-001 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TREE (%%VALUE ITER-001))
     (CL:IF (CL:EQ COLLECT-001 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-001 (CONS (CL-TRANSLATE-A-TREE TREE) NIL))
       (CL:IF (CL:EQ VALUEASSIGNMENTS NIL)
        (CL:SETQ VALUEASSIGNMENTS COLLECT-001)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUEASSIGNMENTS COLLECT-001)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-001)
        (CONS (CL-TRANSLATE-A-TREE TREE) NIL))
       (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((TREE NULL) (ITER-002 NEXTTREES) (COLLECT-002 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ TREE (%%VALUE ITER-002))
     (CL:IF (CL:EQ COLLECT-002 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-002 (CONS (CL-TRANSLATE-A-TREE TREE) NIL))
       (CL:IF (CL:EQ NEXTASSIGNMENTS NIL)
        (CL:SETQ NEXTASSIGNMENTS COLLECT-002)
        (ADD-CONS-TO-END-OF-CONS-LIST NEXTASSIGNMENTS COLLECT-002)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-002)
        (CONS (CL-TRANSLATE-A-TREE TREE) NIL))
       (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:RETURN-FROM CL-TRANSLATE-FOREACH-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "LET*") DECLARATIONS
     (CONCATENATE (CL-YIELD-DECLARE-TREE TYPEDECLARATIONS CL:NIL)
      (CONS
       (LIST* (INTERN-COMMON-LISP-SYMBOL "LOOP")
        SYM-CL-TRANSLATE-STELLA-WHILE CONTINUATIONTEST
        (CONS SYM-CL-TRANSLATE-STELLA-DO
         (CONCATENATE VALUEASSIGNMENTS
          (CONCATENATE (MAYBE-WRAP-WITH-CONTINUE-LABEL BODY)
           (CONCATENATE NEXTASSIGNMENTS NIL)))))
       NIL))))))

;;; (DEFUN (MAYBE-WRAP-WITH-CONTINUE-LABEL CONS) ...)

(CL:DEFUN MAYBE-WRAP-WITH-CONTINUE-LABEL (TRANSLATEDLOOPBODY)
  (CL:IF
   (SEARCH-CONS-TREE-WITH-FILTER? TRANSLATEDLOOPBODY
    KWD-CL-TRANSLATE-CONTINUE
    (GET-QUOTED-TREE "((CL:LOOP QUOTE) \"/STELLA\")" "/STELLA"))
   (CL:RETURN-FROM MAYBE-WRAP-WITH-CONTINUE-LABEL
    (CONS
     (CONS (INTERN-COMMON-LISP-SYMBOL "TAGBODY")
      (CONCATENATE TRANSLATEDLOOPBODY
       (CONS KWD-CL-TRANSLATE-CONTINUE NIL)))
     NIL))
   (CL:RETURN-FROM MAYBE-WRAP-WITH-CONTINUE-LABEL TRANSLATEDLOOPBODY)))

;;; (DEFUN (CL-TRANSLATE-LET-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-LET-TREE (TREE SPECIAL?)
  (CL:LET*
   ((ODECLARATIONS NIL)
    (TYPEDECLARATIONS
     (CL:IF (GENERATE-CL-TYPE-DECLARATIONS?)
      (CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES
       (%%VALUE (%%REST TREE)))
      NIL)))
   (CL:LET* ((D NULL) (ITER-000 (%%VALUE (%%REST TREE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ D (%%VALUE ITER-000))
     (CL:SETQ ODECLARATIONS
      (CONS
       (CONS
        (CL:IF SPECIAL? (CL-TRANSLATE-GLOBAL-SYMBOL (%%VALUE D))
         (CL-TRANSLATE-LOCAL-SYMBOL (%%VALUE D)))
        (CONS (CL-TRANSLATE-A-TREE (%%VALUE (%%REST (%%REST D)))) NIL))
       ODECLARATIONS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "LET*"))
   (SECOND-SETTER TREE (REVERSE ODECLARATIONS))
   (CL:SETF (%%REST (%%REST TREE))
    (CONCATENATE (CL-YIELD-DECLARE-TREE TYPEDECLARATIONS CL:NIL)
     (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST TREE)))))
   (CL:RETURN-FROM CL-TRANSLATE-LET-TREE TREE)))

;;; (DEFUN (CL-TRANSLATE-SPECIAL-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-SPECIAL-TREE (TREE)
  (CL:LET*
   ((TRANSLATEDTREE (CL-TRANSLATE-LET-TREE TREE CL:T))
    (SPECIALVARS NIL))
   (CL:LET*
    ((DECL NULL) (ITER-000 (%%VALUE (%%REST TREE))) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DECL (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (%%VALUE DECL) NIL))
       (CL:IF (CL:EQ SPECIALVARS NIL) (CL:SETQ SPECIALVARS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST SPECIALVARS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (%%VALUE DECL) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%%REST (%%REST TRANSLATEDTREE))
    (CONS
     (LIST* (INTERN-COMMON-LISP-SYMBOL "DECLARE")
      (CONS (INTERN-COMMON-LISP-SYMBOL "SPECIAL")
       (CONCATENATE SPECIALVARS NIL))
      NIL)
     (%%REST (%%REST TRANSLATEDTREE))))
   (CL:RETURN-FROM CL-TRANSLATE-SPECIAL-TREE TRANSLATEDTREE)))

;;; (DEFUN (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-STARTUP-TIME-PROGN-TREE (TREE)
  (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "PROGN"))
  (CL:SETF (%%REST TREE) (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE)))
  (CL:RETURN-FROM CL-TRANSLATE-STARTUP-TIME-PROGN-TREE
   (LIST* (INTERN-COMMON-LISP-SYMBOL "EVAL-WHEN")
    (CONS (NEW-VERBATIM-STRING-WRAPPER ":LOAD-TOPLEVEL")
     (CONS (NEW-VERBATIM-STRING-WRAPPER ":EXECUTE") NIL))
    TREE NIL)))

;;; (DEFUN (CL-TRANSLATE-UNWIND-PROTECT-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-UNWIND-PROTECT-TREE (TREE)
  (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "UNWIND-PROTECT"))
  (CL:SETF (%%REST TREE) (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE)))
  (CL:RETURN-FROM CL-TRANSLATE-UNWIND-PROTECT-TREE TREE))

;;; (DEFUN (CL-TRANSLATE-SIGNAL-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-SIGNAL-TREE (TREE)
  (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "ERROR"))
  (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE))))
  (CL:SETF (%%REST (%%REST TREE)) NIL)
  (CL:RETURN-FROM CL-TRANSLATE-SIGNAL-TREE TREE))

;;; (DEFUN (CL-TRANSLATE-HANDLER-CASE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-HANDLER-CASE-TREE (TREE)
  (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "HANDLER-CASE"))
  (CL:SETF (%%REST TREE) (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE)))
  (CL:RETURN-FROM CL-TRANSLATE-HANDLER-CASE-TREE TREE))

;;; (DEFUN (CL-TRANSLATE-HANDLE-EXCEPTION-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-HANDLE-EXCEPTION-TREE (TREE)
  (CL:LET*
   ((VAR (%%VALUE (%%VALUE (%%REST TREE))))
    (TYPE (%%VALUE (%%REST (%%VALUE (%%REST TREE))))))
   (CL:SETF (%%VALUE TREE)
    (CL-TRANSLATE-CLASS-NAME
     (TYPE-TO-CLASS (TYPE-SPEC-TO-BASE-TYPE TYPE))))
   (CL:IF (CL:NOT (CL:EQ VAR NULL))
    (SECOND-SETTER TREE (CONS (CL-TRANSLATE-LOCAL-SYMBOL VAR) NIL))
    (SECOND-SETTER TREE NIL))
   (CL:SETF (%%REST (%%REST TREE))
    (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST TREE))))
   (CL:RETURN-FROM CL-TRANSLATE-HANDLE-EXCEPTION-TREE TREE)))

;;; (DEFUN (CAST OBJECT) ...)

(CL:DEFUN CAST (VALUE TYPE)
  "Perform a run-time type check, and then return `value'."
  (CL:WHEN
   (CL:AND (CL:>= *SAFETY* 2) (CL:= *STARTUP-TIME-PHASE* 999)
    (EMPTY? *UNFINALIZED-CLASSES*))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (CL:NOT (ISA? VALUE TYPE)))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Run-time casting violation.  The value: " EOL "`" VALUE "'" EOL
      " is not of type `" TYPE "'.")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM CAST VALUE))

;;; (DEFUN (COERCE-NUMERIC-CONSTANT NUMBER-WRAPPER) ...)

(CL:DEFUN COERCE-NUMERIC-CONSTANT (CONSTANT TYPE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONSTANT)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-FLOAT)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-FLOAT (COERCE-TO-FLOAT CONSTANT))))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT CONSTANT))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-LONG-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-LONG-INTEGER
          (CL:TRUNCATE (%INTEGER-WRAPPER.WRAPPER-VALUE CONSTANT))))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-FLOAT)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-FLOAT (COERCE-TO-FLOAT CONSTANT))))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-INTEGER
          (CL:TRUNCATE
           (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE CONSTANT)))))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-LONG-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT CONSTANT)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-FLOAT)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT CONSTANT))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-INTEGER
          (CL:TRUNCATE (%FLOAT-WRAPPER.WRAPPER-VALUE CONSTANT)))))
       ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-LONG-INTEGER)
        (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT
         (WRAP-LONG-INTEGER
          (CL:TRUNCATE (%FLOAT-WRAPPER.WRAPPER-VALUE CONSTANT))))))))
    (CL:T)))
  (CL:RETURN-FROM COERCE-NUMERIC-CONSTANT CONSTANT))

;;; (DEFUN (CL-TRANSLATE-CAST-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-CAST-TREE (TREE)
  (CL:LET*
   ((EXPRESSION (%%VALUE (%%REST TREE)))
    (TYPE (TYPE-SPEC-TO-BASE-TYPE (%%VALUE (%%REST (%%REST TREE))))))
   (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE EXPRESSION))
   (THIRD-SETTER TREE (CL-TRANSLATE-A-TREE TYPE))
   (CL:COND
    ((CL:AND (SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-NUMBER)
      (ISA? EXPRESSION SGT-CL-TRANSLATE-STELLA-NUMBER-WRAPPER))
     (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE
      (CL-TRANSLATE-ATOMIC-TREE
       (COERCE-NUMERIC-CONSTANT EXPRESSION TYPE))))
    ((SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-FLOAT)
     (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "FLOAT")
       (%%VALUE (%%REST TREE))
       (CONS (NEW-VERBATIM-STRING-WRAPPER "0.0d0") NIL))))
    ((CL:OR (SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-INTEGER)
      (SUBTYPE-OF? TYPE SGT-CL-TRANSLATE-STELLA-LONG-INTEGER))
     (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "TRUNCATE")
       (%%VALUE (%%REST TREE)) NIL))))
   (CL:WHEN
    (CL:OR (CL:< *SAFETY* 2)
     (CL:EQ (%%VALUE TREE) SYM-CL-TRANSLATE-STELLA-SAFE-CAST)
     (CL:EQ
      (LOOKUP-SLOT (TYPE-TO-CLASS TYPE)
       SYM-CL-TRANSLATE-STELLA-PRIMARY-TYPE)
      NULL))
    (CL:SETQ EXPRESSION (%%VALUE (%%REST TREE)))
    (SECOND-SETTER TREE NIL)
    (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE EXPRESSION))
   (FIRST-SETTER TREE
    (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-CAST))
   (CL:RETURN-FROM CL-TRANSLATE-CAST-TREE TREE)))

;;; (DEFUN (CL-TRANSLATE-RETURN-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-RETURN-TREE (TREE)
  (CL:LET* ((RETURNVALUES (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE))))
   (CL:WHEN (CL:NOT (CL:EQ (%%REST RETURNVALUES) NIL))
    (CL:SETQ RETURNVALUES
     (CONS
      (CONS (INTERN-COMMON-LISP-SYMBOL "VALUES")
       (CONCATENATE RETURNVALUES NIL))
      NIL)))
   (CL:RETURN-FROM CL-TRANSLATE-RETURN-TREE
    (CL:IF
     (CL:AND (CL:NOT *NEEDEXPLICITRETURN?*)
      (PRESERVE-TAIL-MERGE-OPTIMIZABILITY?))
     (%%VALUE RETURNVALUES)
     (LIST* (INTERN-COMMON-LISP-SYMBOL "RETURN-FROM")
      (CL-TRANSLATE-GLOBAL-SYMBOL
       (YIELD-RENAMED-NAME-IF-NATIVE
        (%METHOD-SLOT.SLOT-NAME
         (%TRANSLATION-UNIT.THE-OBJECT *CURRENTTRANSLATIONUNIT*))
        KWD-CL-TRANSLATE-COMMON-LISP KWD-CL-TRANSLATE-FUNCTION))
      (CONCATENATE RETURNVALUES NIL))))))

;;; (DEFUN (CL-TRANSLATE-BOOLEAN-TEST OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-BOOLEAN-TEST (TREE INVERT?)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-CL-TRANSLATE-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-NOT)
        (CL:LET* ((POSTREE (%%VALUE (%%REST TREE))))
         (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TEST
          (CL-TRANSLATE-BOOLEAN-TEST POSTREE (CL:NOT INVERT?)))))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-AND)
         (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-OR))
        (CL:LET* ((CURSOR (%%REST TREE)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
          (CL:SETF (%%VALUE CURSOR)
           (CL-TRANSLATE-BOOLEAN-TEST (%%VALUE CURSOR) CL:NIL))
          (CL:SETQ CURSOR (%%REST CURSOR))))
        (CL:IF (CL:EQ (%%VALUE TREE) SYM-CL-TRANSLATE-STELLA-AND)
         (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "AND"))
         (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "OR")))
        (CL:WHEN INVERT?
         (CL:SETQ TREE
          (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL)))
        (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TEST TREE))
       ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-TYPED-SYS)
        (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TEST
         (CL-TRANSLATE-BOOLEAN-TEST (%%VALUE (%%REST TREE)) INVERT?)))
       (CL:T)))))
   (CL:T))
  (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TEST
   (CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE INVERT?)))

;;; (DEFUN (CL-TRANSLATE-PLAIN-BOOLEAN-TEST OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-PLAIN-BOOLEAN-TEST (TREE INVERT?)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-CL-TRANSLATE-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
      (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
       (DESTRUCTURE-CALL-TREE TREE))
      (CL:COND
       ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-<)
         (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-<=)
         (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-=)
         (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA->=)
         (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA->))
        (CL:WHEN (OPTIMIZE-BOOLEAN-TESTS?)
         (CL:WHEN INVERT?
          (CL:COND
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-<)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-STELLA->=))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-<=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-STELLA->))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-STELLA-!=))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA->=)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-STELLA-<))
           ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA->)
            (CL:SETQ OPERATOR SYM-CL-TRANSLATE-STELLA-<=))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              OPERATOR "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
          (CL:SETQ INVERT? CL:NIL)))
        (CL:SETQ TREE
         (CONS (LOOKUP *CL-OPERATOR-TABLE* OPERATOR)
          (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL)))
        (CL:IF INVERT?
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST
          (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))
       ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-EQ?)
        (CL:WHEN (OPTIMIZE-BOOLEAN-TESTS?)
         (CL:LET*
          ((ARGTYPE1 (WALKED-EXPRESSION-TYPE (%%VALUE ARGUMENTS)))
           (ARGTYPE2
            (WALKED-EXPRESSION-TYPE (%%VALUE (%%REST ARGUMENTS)))))
          (CL:IF
           (CL:AND
            (SUB-TYPE-SPEC-OF? ARGTYPE1
             SGT-CL-TRANSLATE-STELLA-LITERAL)
            (SUB-TYPE-SPEC-OF? ARGTYPE2
             SGT-CL-TRANSLATE-STELLA-LITERAL))
           (CL:COND
            ((CL:OR (CL:EQ ARGTYPE1 SGT-CL-TRANSLATE-STELLA-STRING)
              (SUB-TYPE-SPEC-OF? ARGTYPE1
               SGT-CL-TRANSLATE-STELLA-BOOLEAN))
             (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQ")))
            ((SUB-TYPE-SPEC-OF? ARGTYPE1
              SGT-CL-TRANSLATE-STELLA-NUMBER)
             (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "=")))
            (CL:T
             (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQL"))))
           (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "EQ")))
          (FIRST-SETTER TREE OPERATOR)))
        (CL:SETF (%%REST TREE)
         (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE)))
        (CL:IF INVERT?
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST
          (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))
       ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NULL?)
         (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-DEFINED?))
        (CL:WHEN (METHOD-CALL-INLINING-ENABLED?)
         (CL:COND
          ((CL:OR (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-OBJECT)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-SECOND-CLASS-OBJECT)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-STRING)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-ARRAY)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-INTEGER)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-LONG-INTEGER)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-FLOAT)
            (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-CODE))
           (CL:IF (CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-ARRAY)
            (CL:SETQ TREE
             (CONS
              (CL-TRANSLATE-GLOBAL-SYMBOL
               SYM-CL-TRANSLATE-STELLA-NULL-ARRAY?)
              (CONS (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS)) NIL)))
            (CL:SETQ TREE
             (CONS
              (CL:IF (SUBTYPE-OF? OWNER SGT-CL-TRANSLATE-STELLA-NUMBER)
               (INTERN-COMMON-LISP-SYMBOL "=")
               (INTERN-COMMON-LISP-SYMBOL "EQ"))
              (CONS (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS))
               (CONS
                (CL-TRANSLATE-A-TREE
                 (TYPE-TO-WALKED-NULL-VALUE-TREE OWNER OWNER))
                NIL)))))
           (CL:COND
            ((CL:EQ OWNER SGT-CL-TRANSLATE-STELLA-FLOAT)
             (FIRST-SETTER TREE (INTERN-COMMON-LISP-SYMBOL "=")))
            (CL:T))
           (CL:IF
            (CL:OR
             (CL:AND INVERT?
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-NULL?))
             (CL:AND (CL:NOT INVERT?)
              (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-DEFINED?)))
            (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST
             (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
            (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))
          (CL:T)))
        (CL:SETQ TREE
         (CONS (CL-TRANSLATE-GLOBAL-SYMBOL OPERATOR)
          (CONS (CL-TRANSLATE-A-TREE (%%VALUE ARGUMENTS)) NIL)))
        (CL:IF INVERT?
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST
          (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
         (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))
       (CL:T)))))
   (CL:T))
  (CL:SETQ TREE (CL-TRANSLATE-A-TREE TREE))
  (CL:IF INVERT?
   (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST
    (LIST* (INTERN-COMMON-LISP-SYMBOL "NOT") TREE NIL))
   (CL:RETURN-FROM CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE)))

;;; (DEFUN (CL-TRANSLATE-WHILE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-WHILE-TREE (TREE)
  (CL:LET*
   ((TEST (CL-TRANSLATE-BOOLEAN-TEST (%%VALUE (%%REST TREE)) CL:NIL))
    (BODY (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST TREE)))))
   (CL:SETF (%%REST (%%REST TREE)) NIL)
   (CL:RETURN-FROM CL-TRANSLATE-WHILE-TREE
    (CL:IF (CL:EQ BODY NIL)
     (LIST* (INTERN-COMMON-LISP-SYMBOL "LOOP")
      SYM-CL-TRANSLATE-STELLA-WHILE TEST NIL)
     (LIST* (INTERN-COMMON-LISP-SYMBOL "LOOP")
      SYM-CL-TRANSLATE-STELLA-WHILE TEST
      (CONS SYM-CL-TRANSLATE-STELLA-DO
       (CONCATENATE (MAYBE-WRAP-WITH-CONTINUE-LABEL BODY) NIL)))))))

;;; (DEFUN (CL-TRANSLATE-CONDITIONAL-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CONDITIONAL-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (TEST (%%VALUE (%%REST TREE)))
    (BODY (%%REST (%%REST TREE))))
   (CL:SETF (%%REST (%%REST TREE)) NIL)
   (CL:LET* ((TEST-VALUE-000 OPERATOR))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-IF)
       (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CHOOSE))
      (CL:RETURN-FROM CL-TRANSLATE-CONDITIONAL-TREE
       (LIST* (INTERN-COMMON-LISP-SYMBOL "IF")
        (CL-TRANSLATE-BOOLEAN-TEST TEST CL:NIL)
        (CONS (CL-TRANSLATE-A-TREE (%%VALUE BODY))
         (CONS (CL-TRANSLATE-A-TREE (%%VALUE (%%REST BODY))) NIL)))))
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-WHEN)
      (CL:RETURN-FROM CL-TRANSLATE-CONDITIONAL-TREE
       (LIST* (INTERN-COMMON-LISP-SYMBOL "WHEN")
        (CL-TRANSLATE-BOOLEAN-TEST TEST CL:NIL)
        (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES BODY) NIL))))
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-UNLESS)
      (CL:RETURN-FROM CL-TRANSLATE-CONDITIONAL-TREE
       (LIST* (INTERN-COMMON-LISP-SYMBOL "WHEN")
        (CL-TRANSLATE-BOOLEAN-TEST TEST CL:T)
        (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES BODY) NIL))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (CL-TRANSLATE-COND-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-COND-TREE (TREE)
  (CL:LET* ((CONDITION NULL) (ITER-000 (%%REST TREE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CONDITION (%%VALUE ITER-000))
    (CL:IF
     (CL:EQ (%%VALUE CONDITION) SYM-CL-TRANSLATE-STELLA-OTHERWISE)
     (CL:SETF (%%VALUE CONDITION) (INTERN-COMMON-LISP-SYMBOL "T"))
     (CL:SETF (%%VALUE CONDITION)
      (CL-TRANSLATE-BOOLEAN-TEST (%%VALUE CONDITION) CL:NIL)))
    (CL:SETF (%%REST CONDITION)
     (CL-TRANSLATE-LIST-OF-TREES (%%REST CONDITION)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:SETF (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "COND"))
  (CL:RETURN-FROM CL-TRANSLATE-COND-TREE TREE))

;;; (DEFUN (CL-TRANSLATE-CASE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CASE-TREE (TREE)
  (CL:LET* ((OTHERWISE? CL:NIL))
   (SECOND-SETTER TREE (CL-TRANSLATE-A-TREE (%%VALUE (%%REST TREE))))
   (CL:LET* ((COND NULL) (ITER-000 (%%REST (%%REST TREE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ COND (%%VALUE ITER-000))
     (CL:COND
      ((CL:EQ (%%VALUE COND) SYM-CL-TRANSLATE-STELLA-OTHERWISE)
       (CL:SETQ OTHERWISE? CL:T)
       (FIRST-SETTER COND (INTERN-COMMON-LISP-SYMBOL "OTHERWISE")))
      ((CONS? (%%VALUE COND))
       (FIRST-SETTER COND (CL-TRANSLATE-LIST-OF-TREES (%%VALUE COND))))
      (CL:T (FIRST-SETTER COND (CL-TRANSLATE-A-TREE (%%VALUE COND)))))
     (CL:SETF (%%REST COND) (CL-TRANSLATE-LIST-OF-TREES (%%REST COND)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (FIRST-SETTER TREE
    (CL:IF OTHERWISE? (INTERN-COMMON-LISP-SYMBOL "CASE")
     (INTERN-COMMON-LISP-SYMBOL "ECASE")))
   (CL:RETURN-FROM CL-TRANSLATE-CASE-TREE TREE)))

;;; (DEFUN (CL-TRANSLATE-BOOLEAN-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-BOOLEAN-TREE (TREE)
  (CL:RETURN-FROM CL-TRANSLATE-BOOLEAN-TREE
   (CL-TRANSLATE-BOOLEAN-TEST TREE CL:NIL)))

;;; (DEFUN (CL-TRANSLATE-CLASS-NAME OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-CLASS-NAME (CLASS)
  (CL:WHEN
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES)
   (CL:COND
    ((CL:EQ (%CLASS.CLASS-TYPE CLASS) SGT-CL-TRANSLATE-STELLA-CONS)
     (CL:RETURN-FROM CL-TRANSLATE-CLASS-NAME
      (INTERN-COMMON-LISP-SYMBOL "CONS")))
    (CL:T)))
  (CL:COND
   ((CL:NOT
     (CL:EQ
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-CL-TRANSLATE-STELLA-CLASS-CL-NATIVE-TYPE
        NULL-STRING-WRAPPER))
      STELLA::NULL-STRING))
    (CL:LET*
     ((NATIVETYPE
       (%STRING-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
         SYM-CL-TRANSLATE-STELLA-CLASS-CL-NATIVE-TYPE
         NULL-STRING-WRAPPER))))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVETYPE))
     (CL:WHEN (CL:= (POSITION NATIVETYPE #\: 0) NULL-INTEGER)
      (CL:SETQ NATIVETYPE (CONCATENATE "CL:" NATIVETYPE)))
     (CL:RETURN-FROM CL-TRANSLATE-CLASS-NAME
      (NEW-VERBATIM-STRING-WRAPPER NATIVETYPE))))
   (CL:T
    (CL:RETURN-FROM CL-TRANSLATE-CLASS-NAME
     (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))))))

;;; (DEFUN (YIELD-STRUCT-CONSTRUCTOR-NAME OBJECT) ...)

(CL:DEFUN YIELD-STRUCT-CONSTRUCTOR-NAME (CLASS)
  (CL:RETURN-FROM YIELD-STRUCT-CONSTRUCTOR-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (%SURROGATE.HOME-CONTEXT (%CLASS.CLASS-TYPE CLASS))
    (CONCATENATE "%MAKE-"
     (%SURROGATE.SYMBOL-NAME (%CLASS.CLASS-TYPE CLASS))))))

;;; (DEFUN (CL-TRANSLATE-MAKE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-MAKE-TREE (TREE)
  (CL:LET*
   ((CLASS
     (%SURROGATE.SURROGATE-VALUE (TYPIFY (%%VALUE (%%REST TREE)))))
    (CLASSSYMBOL (CL-TRANSLATE-CLASS-NAME CLASS)) (OTREE NULL))
   (CL:WHEN
    (CL:AND (CL:EQ CLASSSYMBOL (INTERN-COMMON-LISP-SYMBOL "CONS"))
     (MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES))
    (CL:RETURN-FROM CL-TRANSLATE-MAKE-TREE
     (LIST* (INTERN-COMMON-LISP-SYMBOL "CONS")
      (INTERN-COMMON-LISP-SYMBOL "NIL")
      (INTERN-COMMON-LISP-SYMBOL "NIL") NIL)))
   (CL:COND
    ((EXCEPTION-CLASS? CLASS)
     (CL:SETQ OTREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "MAKE-CONDITION")
       (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") CLASSSYMBOL NIL)
       (CL-TRANSLATE-GLOBAL-SYMBOL
        SYM-CL-TRANSLATE-STELLA-*CONDITION-MESSAGE-KEYWORD*)
       (CONS
        (CONS
         (CL-TRANSLATE-GLOBAL-SYMBOL
          SYM-CL-TRANSLATE-STELLA-REPLACE-SUBSTRINGS)
         (CONS (CL-TRANSLATE-A-TREE (%%VALUE (%%REST (%%REST TREE))))
          (LIST* (WRAP-STRING "~~") (WRAP-STRING "~") NIL)))
        NIL))))
    ((CL:OR
      (CL:NOT
       (MEMB? *CURRENT-STELLA-FEATURES*
        KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS))
      (CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? CLASS))
     (CL:SETQ OTREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "MAKE-INSTANCE")
       (LIST* (INTERN-COMMON-LISP-SYMBOL "QUOTE") CLASSSYMBOL NIL)
       NIL)))
    ((MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)
     (CL:SETQ OTREE
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-CLSYS-MAKE)
       (CONS CLASSSYMBOL
        (CONS (WRAP-INTEGER (CL:1+ (LENGTH (CL-STRUCT-SLOTS CLASS))))
         NIL)))))
    (CL:T
     (CL:SETQ OTREE (CONS (YIELD-STRUCT-CONSTRUCTOR-NAME CLASS) NIL))))
   (CL:RETURN-FROM CL-TRANSLATE-MAKE-TREE OTREE)))

;;; (DEFUN (CL-TRANSLATE-NEW-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NEW-TREE (TREE)
  (CL:WHEN (ARRAY-TYPE-SPECIFIER? (%%VALUE (%%REST TREE)))
   (CL:RETURN-FROM CL-TRANSLATE-NEW-TREE
    (CL-TRANSLATE-NEW-ARRAY-TREE TREE)))
  (CL:LET*
   ((TYPESPEC (%%VALUE (%%REST TREE)))
    (CONSTRUCTORNAME
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-CONSTRUCTOR-NAME
       (GET-STELLA-CLASS
        (CL:IF (TYPE? TYPESPEC) TYPESPEC
         (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE TYPESPEC))
        CL:T))))
    (REQUIREDARGREFS
     (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST TREE)))))
   (CL:RETURN-FROM CL-TRANSLATE-NEW-TREE
    (CONS CONSTRUCTORNAME (CONCATENATE REQUIREDARGREFS NIL)))))

;;; (DEFUN (CL-TRANSLATE-NEW-ARRAY-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-NEW-ARRAY-TREE (TREE)
  (CL:LET*
   ((INITIALELEMENT (%%VALUE (%%REST (%%REST TREE))))
    (DIMENSIONS
     (CL-TRANSLATE-LIST-OF-TREES (%%REST (%%REST (%%REST TREE))))))
   (CL:SETQ INITIALELEMENT NULL)
   (CL:RETURN-FROM CL-TRANSLATE-NEW-ARRAY-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "MAKE-ARRAY")
     (CL:IF (CL:= (LENGTH DIMENSIONS) 1) (%%VALUE DIMENSIONS)
      (CONS (INTERN-COMMON-LISP-SYMBOL "LIST")
       (CONCATENATE DIMENSIONS NIL)))
     (CONCATENATE
      (CL:IF (CL:NOT (CL:EQ INITIALELEMENT NULL))
       (LIST* KWD-CL-TRANSLATE-INITIAL-ELEMENT
        (CL-TRANSLATE-A-TREE INITIALELEMENT) NIL)
       NIL)
      NIL)))))

;;; (DEFUN (CL-TRANSLATE-OPERATOR-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-OPERATOR-TREE (TREE)
  (CL:LET* ((OPERATOR NULL) (OWNER NULL) (ARGUMENTS NULL))
   (CL:MULTIPLE-VALUE-SETQ (OPERATOR OWNER ARGUMENTS)
    (DESTRUCTURE-CALL-TREE TREE))
   (CL:SETQ OWNER OWNER)
   (CL:COND
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-+)
     (CL:WHEN
      (CL:AND (CL:= (LENGTH ARGUMENTS) 2)
       (MEMBER? ARGUMENTS ONE-WRAPPER))
      (CL:IF (EQL? (%%VALUE ARGUMENTS) ONE-WRAPPER)
       (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
       (CL:SETF (%%REST ARGUMENTS) NIL))
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "1+"))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA--)
     (CL:WHEN
      (CL:AND (CL:= (LENGTH ARGUMENTS) 2)
       (EQL? (%%VALUE (%%REST ARGUMENTS)) ONE-WRAPPER))
      (CL:SETF (%%REST ARGUMENTS) NIL)
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "1-"))))
    ((CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-EQ?)
     (CL:RETURN-FROM CL-TRANSLATE-OPERATOR-TREE
      (CL-TRANSLATE-PLAIN-BOOLEAN-TEST TREE CL:NIL)))
    (CL:T))
   (CL:COND
    ((CL:OR (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-+)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA--)
      (CL:EQ OPERATOR SYM-CL-TRANSLATE-STELLA-*)
      (CL:EQ OPERATOR |SYM-CL-TRANSLATE-STELLA-/|))
     (CL:SETQ OPERATOR (LOOKUP *CL-OPERATOR-TABLE* OPERATOR)))
    (CL:T))
   (CL:RETURN-FROM CL-TRANSLATE-OPERATOR-TREE
    (CONS (CL-TRANSLATE-GLOBAL-SYMBOL OPERATOR)
     (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES ARGUMENTS) NIL)))))

;;; (DEFUN (YIELD-FORMAT-ARGUMENTS CONS) ...)

(CL:DEFUN YIELD-FORMAT-ARGUMENTS (TREE)
  (CL:LET* ((FORMATSTRING "") (FORMATARGUMENTS NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FORMATSTRING))
   (CL:SETF (%%REST (%%REST TREE)) (REVERSE (%%REST (%%REST TREE))))
   (CL:LET* ((ARG NULL) (ITER-000 (%%REST (%%REST TREE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000))
     (CL:COND
      ((STRING? ARG)
       (CL:SETQ FORMATSTRING
        (CONCATENATE (%STRING-WRAPPER.WRAPPER-VALUE ARG)
         FORMATSTRING)))
      ((CL:EQ ARG EOL)
       (CL:SETQ FORMATSTRING (CONCATENATE "~%" FORMATSTRING)))
      (CL:T (CL:SETQ FORMATSTRING (CONCATENATE "~A" FORMATSTRING))
       (CL:SETQ FORMATARGUMENTS
        (CONS (CL-TRANSLATE-A-TREE ARG) FORMATARGUMENTS))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ FORMATARGUMENTS
    (CONS (WRAP-STRING FORMATSTRING) FORMATARGUMENTS))
   (CL:RETURN-FROM YIELD-FORMAT-ARGUMENTS FORMATARGUMENTS)))

;;; (DEFUN (YIELD-PRINT-TREE CONS) ...)

(CL:DEFUN YIELD-PRINT-TREE (TREE)
  (CL:LET*
   ((STREAM (%%VALUE (%%REST TREE))) (ARGUMENTS (%%REST (%%REST TREE)))
    (ARGUMENTTYPE NULL) (PRINTOPERATOR NULL)
    (COMPOUNDEDSTRING STELLA::NULL-STRING) (PRINTFORMS NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING COMPOUNDEDSTRING))
   (CL:SETQ STREAM (CL-TRANSLATE-A-TREE STREAM))
   (CL:LET* ((ARG NULL) (ITER-000 ARGUMENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:COND
       ((CL:EQ ARG EOL) (CL:SETQ PRINTFORMS (CONS ARG PRINTFORMS))
        (CL:SETQ COMPOUNDEDSTRING STELLA::NULL-STRING))
       (CL:T
        (CL:SETQ ARGUMENTTYPE
         (TYPE-SPEC-TO-BASE-TYPE (WALKED-EXPRESSION-TYPE ARG)))
        (CL:COND
         ((CL:EQ ARGUMENTTYPE SGT-CL-TRANSLATE-STELLA-STRING)
          (CL:SETQ PRINTOPERATOR
           (INTERN-COMMON-LISP-SYMBOL "WRITE-STRING")))
         (CL:T
          (CL:IF
           (SUBTYPE-OF? ARGUMENTTYPE SGT-CL-TRANSLATE-STELLA-OBJECT)
           (CL:SETQ PRINTOPERATOR SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
           (CL:SETQ PRINTOPERATOR
            (INTERN-COMMON-LISP-SYMBOL "PRINC")))))
        (CL:COND
         ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE ARG))
          (CL:PROGN
           (CL:WHEN
            (CL:NOT (CL:EQ COMPOUNDEDSTRING STELLA::NULL-STRING))
            (CL:SETQ COMPOUNDEDSTRING
             (CONCATENATE COMPOUNDEDSTRING
              (%STRING-WRAPPER.WRAPPER-VALUE ARG)))
            (FIRST-SETTER PRINTFORMS (WRAP-STRING COMPOUNDEDSTRING))
            (CL:GO :CONTINUE))
           (CL:SETQ COMPOUNDEDSTRING
            (%STRING-WRAPPER.WRAPPER-VALUE ARG))))
         (CL:T (CL:SETQ COMPOUNDEDSTRING STELLA::NULL-STRING)))
        (CL:COND
         ((CL:EQ
           (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS PRINTOPERATOR
            ARGUMENTTYPE
            (CL:NOT
             (CL:EQ PRINTOPERATOR
              SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)))
           SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
          (CL:SETQ PRINTFORMS
           (CONS (CL-TRANSLATE-A-TREE ARG) PRINTFORMS)))
         (CL:T
          (CL:SETQ PRINTFORMS
           (CONS (CL-TRANSLATE-A-TREE ARG) PRINTFORMS))))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ PRINTFORMS (REVERSE PRINTFORMS))
   (CL:RETURN-FROM YIELD-PRINT-TREE
    (CONS
     (CL-TRANSLATE-GLOBAL-SYMBOL
      SYM-CL-TRANSLATE-STELLA-%%PRINT-STREAM)
     (CONS STREAM (CONCATENATE PRINTFORMS NIL))))))

;;; (DEFUN (CL-TRANSLATE-PRINT-STREAM-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-PRINT-STREAM-TREE (TREE)
  (CL:LET* ((STREAM (%%VALUE (%%REST TREE))))
   (CL:COND
    ((CL:EQ STREAM KWD-CL-TRANSLATE-WARN)
     (CL:RETURN-FROM CL-TRANSLATE-PRINT-STREAM-TREE
      (CONS (INTERN-COMMON-LISP-SYMBOL "WARN")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    ((CL:EQ STREAM KWD-CL-TRANSLATE-ERROR)
     (CL:RETURN-FROM CL-TRANSLATE-PRINT-STREAM-TREE
      (CONS (INTERN-COMMON-LISP-SYMBOL "ERROR")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    ((CL:EQ STREAM KWD-CL-TRANSLATE-CONTINUABLE-ERROR)
     (CL:RETURN-FROM CL-TRANSLATE-PRINT-STREAM-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "CERROR")
       (WRAP-STRING "Continue anyway? ")
       (CONCATENATE (YIELD-FORMAT-ARGUMENTS TREE) NIL))))
    (CL:T
     (CL:RETURN-FROM CL-TRANSLATE-PRINT-STREAM-TREE
      (YIELD-PRINT-TREE TREE))))))

;;; (DEFUN (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-CALL-FUNCTION-CODE-TREE (TREE)
  (CL:LET*
   ((METHODCODE?
     (CL:EQ (%%VALUE TREE)
      SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD-CODE))
    (OTREE (%%REST TREE)))
   (CL:SETF (%%REST OTREE) (CL-TRANSLATE-LIST-OF-TREES (%%REST OTREE)))
   (FIRST-SETTER OTREE
    (CL:IF
     (CL:AND METHODCODE?
      (MEMB? *CURRENT-STELLA-FEATURES*
       KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS))
     SYM-CL-TRANSLATE-STELLA-CLSYS-METHOD-CODE-CALL
     (INTERN-COMMON-LISP-SYMBOL "FUNCALL")))
   (CL:RETURN-FROM CL-TRANSLATE-CALL-FUNCTION-CODE-TREE OTREE)))

;;; (DEFUN (CL-TRANSLATE-INLINE-CALL-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-INLINE-CALL-TREE (TREE)
  (CL:LET*
   ((CALLTREE (%%VALUE (%%REST TREE)))
    (METHOD (SLOT-FROM-EXPRESSION-TREE CALLTREE))
    (ARGS
     (CL:IF
      (CL:EQ (%%VALUE CALLTREE)
       SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION)
      (NTH-REST CALLTREE 2) (NTH-REST CALLTREE 3)))
    (TRANSLATEDARGS (CL-TRANSLATE-LIST-OF-TREES ARGS))
    (USEDCOMPLEXARGS NIL) (ARGUMENT NULL)
    (BODY
     (LOOKUP-VERBATIM-TREE
      (WALK-VERBATIM-TREE (INLINABLE-METHOD-BODY METHOD)) NULL))
    (PARAMETERS (METHOD-PARAMETER-NAMES METHOD))
    (PARAMETERTYPES (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (PARINDEX 0) (OTREE NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARINDEX))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE BODY) SGT-CL-TRANSLATE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((ELT NULL) (ITER-000 BODY))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ ELT (%%VALUE ITER-000))
         (CL:WHEN (CONS? ELT) (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:WHEN ALWAYS?-000
        (CL:SETQ OTREE
         (CONS
          (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS (%%VALUE BODY) NIL-LIST)
          NIL))
        (CL:LET* ((BARG NULL) (ITER-001 (%%REST BODY)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ BARG (%%VALUE ITER-001))
          (CL:COND
           ((MEMBER? PARAMETERS BARG)
            (CL:SETQ PARINDEX (POSITION PARAMETERS BARG 0))
            (CL:SETQ ARGUMENT (NTH TRANSLATEDARGS PARINDEX))
            (CL:WHEN (MEMBER? USEDCOMPLEXARGS ARGUMENT)
             (CL:SETQ OTREE NIL) (CL:RETURN))
            (CL:WHEN (CONS? ARGUMENT)
             (CL:SETQ USEDCOMPLEXARGS (CONS ARGUMENT USEDCOMPLEXARGS))
             (CL:SETQ ARGUMENT
              (CL-YIELD-TYPED-EXPRESSION-TREE ARGUMENT
               (NTH PARAMETERTYPES PARINDEX))))
            (CL:SETQ OTREE (CONS ARGUMENT OTREE)))
           (CL:T
            (CL:SETQ OTREE
             (CONS (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS BARG NIL-LIST)
              OTREE))))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:WHEN (CL:NOT (CL:EQ OTREE NIL))
         (CL:RETURN-FROM CL-TRANSLATE-INLINE-CALL-TREE
          (CL-YIELD-TYPED-EXPRESSION-TREE (REVERSE OTREE)
           (TYPE METHOD))))))))
    (CL:T))
   (CL:LET*
    ((PAR NULL) (ITER-002 (%LIST.THE-CONS-LIST PARAMETERS)) (ARG NULL)
     (ITER-003 TRANSLATEDARGS) (COLLECT-000 NULL))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
      (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ PAR (%%VALUE ITER-002))
     (CL:SETQ ARG (%%VALUE ITER-003))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (CONS (CL-TRANSLATE-LOCAL-SYMBOL PAR) (CONS ARG NIL))
         NIL))
       (CL:IF (CL:EQ OTREE NIL) (CL:SETQ OTREE COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST OTREE COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CONS (CL-TRANSLATE-LOCAL-SYMBOL PAR) (CONS ARG NIL))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-002 (%%REST ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (CL:RETURN-FROM CL-TRANSLATE-INLINE-CALL-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "LET") OTREE
     (CONCATENATE
      (CL-YIELD-DECLARE-TREE
       (CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES METHOD)
       CL:NIL)
      (CONS
       (CL-YIELD-TYPED-EXPRESSION-TREE
        (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS (COPY-CONS-TREE BODY)
         PARAMETERS)
        (TYPE METHOD))
       NIL))))))

;;; (DEFUN (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-VERBATIM-BODY-SYMBOLS (BODY PARAMETERS)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE BODY)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-CL-TRANSLATE-STELLA-CONS)
     (CL:PROGN
      (CL:IF (CL:NOT (CL:EQ BODY NIL))
       (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-BODY-SYMBOLS
        (CONS
         (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS (%%VALUE BODY) PARAMETERS)
         (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS (%%REST BODY)
          PARAMETERS)))
       (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-BODY-SYMBOLS NIL))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (MEMBER? PARAMETERS BODY)
       (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-BODY-SYMBOLS
        (CL-TRANSLATE-LOCAL-SYMBOL BODY))
       (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-BODY-SYMBOLS
        (CL-TRANSLATE-GLOBAL-SYMBOL BODY)))))
    (CL:T (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-BODY-SYMBOLS BODY)))))

;;; (DEFUN (CL-TRANSLATE-THE-CODE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-THE-CODE-TREE (TREE)
  (CL:LET*
   ((NAME
     (CL:IF (CL:EQ (%%VALUE (%%REST TREE)) KWD-CL-TRANSLATE-FUNCTION)
      (%%VALUE (%%REST (%%REST TREE))) (FOURTH TREE))))
   (CL:RETURN-FROM CL-TRANSLATE-THE-CODE-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "FUNCTION")
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (YIELD-RENAMED-NAME-IF-NATIVE NAME KWD-CL-TRANSLATE-COMMON-LISP
       KWD-CL-TRANSLATE-FUNCTION))
     NIL))))

;;; (DEFUN (CL-TRANSLATE-VERBATIM-TREE OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-VERBATIM-TREE (TREE)
  (CL:LET* ((CURSOR (%%REST TREE)) (VERBATIMCODE NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (CL:EQ (%%VALUE CURSOR) KWD-CL-TRANSLATE-COMMON-LISP)
     (CL:SETQ VERBATIMCODE (%%VALUE (%%REST CURSOR)))
     (CL:SETF (%%VALUE (%%REST CURSOR)) NULL) (CL:RETURN))
    (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))
   (CL:RETURN-FROM CL-TRANSLATE-VERBATIM-TREE VERBATIMCODE)))

;;; (DEFUN (CL-TRANSLATE-INLINE-TREE CONS) ...)

(CL:DEFUN CL-TRANSLATE-INLINE-TREE (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE))
    (BODY (CL-TRANSLATE-LIST-OF-TREES (%%REST TREE))))
   (CL:LET* ((TEST-VALUE-000 OPERATOR))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-INLINE)
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "INLINE")))
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-IGNORE)
      (CL:SETQ OPERATOR (INTERN-COMMON-LISP-SYMBOL "IGNORE")))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM CL-TRANSLATE-INLINE-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "DECLARE")
     (CONS OPERATOR (CONCATENATE BODY NIL)) NIL))))

;;; (DEFUN (GENERATE-CL-TYPE-DECLARATIONS? BOOLEAN) ...)

(CL:DEFUN GENERATE-CL-TYPE-DECLARATIONS? ()
  (CL:RETURN-FROM GENERATE-CL-TYPE-DECLARATIONS?
   (METHOD-CALL-INLINING-ENABLED?)))

;;; (DEFUN (LOOKUP-CL-TYPE-FROM-STELLA-TYPE OBJECT) ...)

(CL:DEFUN LOOKUP-CL-TYPE-FROM-STELLA-TYPE (TYPE)
  (CL:WHEN (CL:OR (CL:EQ TYPE NULL) (ANCHORED-TYPE-SPECIFIER? TYPE))
   (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE NULL))
  (CL:LET* ((BASETYPE (TYPE-SPEC-TO-BASE-TYPE TYPE)))
   (CL:COND
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-INTEGER)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "FIXNUM")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-SHORT-INTEGER)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "FIXNUM")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-FLOAT)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "DOUBLE-FLOAT")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-STRING)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "SIMPLE-STRING")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-MUTABLE-STRING)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "SIMPLE-STRING")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR)
     (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (INTERN-COMMON-LISP-SYMBOL "SIMPLE-VECTOR")))
    ((CL:EQ BASETYPE SGT-CL-TRANSLATE-STELLA-ARRAY)
     (CL:WHEN (ARRAY-TYPE-SPECIFIER? TYPE)
      (CL:CASE (ARRAY-TYPE-RANK TYPE)
       (1
        (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
         (INTERN-COMMON-LISP-SYMBOL "SIMPLE-VECTOR")))
       (CL:OTHERWISE
        (CL:LET* ((RANK (ARRAY-TYPE-RANK TYPE)) (DIMENSIONS NIL))
         (CL:DECLARE (CL:TYPE CL:FIXNUM RANK))
         (CL:WHEN (CL:<= RANK 5)
          (CL:LET*
           ((DIM NULL)
            (ITER-000
             (%LIST.THE-CONS-LIST (ARRAY-TYPE-DIMENSIONS TYPE)))
            (COLLECT-000 NULL))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ DIM (%%VALUE ITER-000))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-000
               (CONS
                (CL:IF (CL:EQ DIM NULL) (INTERN-COMMON-LISP-SYMBOL "*")
                 DIM)
                NIL))
              (CL:IF (CL:EQ DIMENSIONS NIL)
               (CL:SETQ DIMENSIONS COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST DIMENSIONS COLLECT-000)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-000)
               (CONS
                (CL:IF (CL:EQ DIM NULL) (INTERN-COMMON-LISP-SYMBOL "*")
                 DIM)
                NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE
           (LIST* (INTERN-COMMON-LISP-SYMBOL "ARRAY")
            (INTERN-COMMON-LISP-SYMBOL "T") DIMENSIONS NIL))))))))
    (CL:T))
   (CL:RETURN-FROM LOOKUP-CL-TYPE-FROM-STELLA-TYPE NULL)))

;;; (DEFUN (CL-YIELD-TYPED-EXPRESSION-TREE OBJECT) ...)

(CL:DEFUN CL-YIELD-TYPED-EXPRESSION-TREE (TREE TYPE)
  (CL:LET* ((CLTYPE (LOOKUP-CL-TYPE-FROM-STELLA-TYPE TYPE)))
   (CL:COND
    ((CL:NOT (CL:EQ CLTYPE NULL))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-CL-TRANSLATE-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN
         (CL:AND
          (CL:EQ (%%VALUE TREE) (INTERN-COMMON-LISP-SYMBOL "THE"))
          (EQL? (%%VALUE (%%REST TREE)) CLTYPE))
         (CL:RETURN-FROM CL-YIELD-TYPED-EXPRESSION-TREE TREE))))
      (CL:T))
     (CL:RETURN-FROM CL-YIELD-TYPED-EXPRESSION-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "THE") CLTYPE
       (CONS TREE NIL))))
    (CL:T (CL:RETURN-FROM CL-YIELD-TYPED-EXPRESSION-TREE TREE)))))

;;; (DEFUN (CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES CONS) ...)

(CL:DEFUN CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES (METHOD)
  (CL:LET* ((TYPES NIL) (CLTYPE NULL))
   (CL:LET*
    ((TSPEC NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
     (PNAME NULL)
     (ITER-001 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD))))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ TSPEC (%%VALUE ITER-000))
     (CL:SETQ PNAME (%%VALUE ITER-001))
     (CL:SETQ CLTYPE
      (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
       (COMPUTE-RELATIVE-TYPE-SPEC TSPEC
        (%METHOD-SLOT.SLOT-OWNER METHOD))))
     (CL:WHEN (CL:NOT (CL:EQ CLTYPE NULL))
      (CL:SETQ TYPES
       (CONS
        (LIST* (INTERN-COMMON-LISP-SYMBOL "TYPE") CLTYPE
         (CONS (CL-TRANSLATE-LOCAL-SYMBOL PNAME) NIL))
        TYPES)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:RETURN-FROM CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES
    (REVERSE TYPES))))

;;; (DEFUN (CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES CONS) ...)

(CL:DEFUN CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES (BINDINGSTREE)
  (CL:LET* ((TYPES NIL) (CLTYPE NULL))
   (CL:LET* ((BINDING NULL) (ITER-000 BINDINGSTREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ BINDING (%%VALUE ITER-000))
     (CL:LET* ((TYPE (%%VALUE (%%REST BINDING))))
      (CL:WHEN (CL:NOT (CL:EQ TYPE NULL))
       (CL:SETQ CLTYPE
        (LOOKUP-CL-TYPE-FROM-STELLA-TYPE (%%VALUE (%%REST BINDING)))))
      (CL:WHEN (CL:NOT (CL:EQ CLTYPE NULL))
       (CL:SETQ TYPES
        (CONS
         (LIST* (INTERN-COMMON-LISP-SYMBOL "TYPE") CLTYPE
          (CONS (CL-TRANSLATE-LOCAL-SYMBOL (%%VALUE BINDING)) NIL))
         TYPES))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES
    (REVERSE TYPES))))

;;; (DEFUN (CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE CONS) ...)

(CL:DEFUN CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE (GLOBAL)
  (CL:LET*
   ((CLTYPE
     (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL))))
   (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
    (CL:RETURN-FROM CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE
     (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "TYPE") CLTYPE
       (CONS
        (CL-TRANSLATE-GLOBAL-SYMBOL
         (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL))
        NIL))))
    (CL:RETURN-FROM CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE
     NULL))))

;;; (DEFUN (CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS CONS) ...)

(CL:DEFUN CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS (METHOD)
  (CL:LET* ((TYPES NIL) (CLTYPE NULL))
   (CL:LET*
    ((TSPEC NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TSPEC (%%VALUE ITER-000))
     (CL:SETQ CLTYPE
      (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
       (COMPUTE-RELATIVE-TYPE-SPEC TSPEC
        (%METHOD-SLOT.SLOT-OWNER METHOD))))
     (CL:WHEN
      (SUB-TYPE-SPEC-OF? TSPEC SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST)
      (CL:SETQ TYPES (CONS (INTERN-COMMON-LISP-SYMBOL "&REST") TYPES)))
     (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
      (CL:SETQ TYPES (CONS CLTYPE TYPES))
      (CL:SETQ TYPES (CONS (INTERN-COMMON-LISP-SYMBOL "T") TYPES)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS
    (REVERSE TYPES))))

;;; (DEFUN (CL-YIELD-METHOD-RETURN-TYPE-DECLARATION OBJECT) ...)

(CL:DEFUN CL-YIELD-METHOD-RETURN-TYPE-DECLARATION (METHOD)
  (CL:LET* ((TYPES NIL) (CLTYPE NULL))
   (CL:LET*
    ((TSPEC NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TSPEC (%%VALUE ITER-000))
     (CL:SETQ CLTYPE
      (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
       (COMPUTE-RELATIVE-TYPE-SPEC TSPEC
        (%METHOD-SLOT.SLOT-OWNER METHOD))))
     (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
      (CL:SETQ TYPES (CONS CLTYPE TYPES))
      (CL:SETQ TYPES (CONS (INTERN-COMMON-LISP-SYMBOL "T") TYPES)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:EQ (%%REST TYPES) NIL)
    (CL:RETURN-FROM CL-YIELD-METHOD-RETURN-TYPE-DECLARATION
     (%%VALUE TYPES))
    (CL:RETURN-FROM CL-YIELD-METHOD-RETURN-TYPE-DECLARATION
     (CONS (INTERN-COMMON-LISP-SYMBOL "VALUES")
      (CONCATENATE (REVERSE TYPES) NIL))))))

;;; (DEFUN (CL-YIELD-METHOD-TYPE-DECLARATION-TREE CONS) ...)

(CL:DEFUN CL-YIELD-METHOD-TYPE-DECLARATION-TREE (METHOD)
  (CL:WHEN (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
   (CL:RETURN-FROM CL-YIELD-METHOD-TYPE-DECLARATION-TREE NULL))
  (CL:LET*
   ((CLTYPE
     (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (%METHOD-SLOT.SLOT-BASE-TYPE METHOD))))
   (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
    (CL:RETURN-FROM CL-YIELD-METHOD-TYPE-DECLARATION-TREE
     (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE
      (LIST* (INTERN-COMMON-LISP-SYMBOL "FTYPE")
       (LIST* (INTERN-COMMON-LISP-SYMBOL "FUNCTION")
        (CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS METHOD)
        (CONS (CL-YIELD-METHOD-RETURN-TYPE-DECLARATION METHOD) NIL))
       (CL-TRANSLATE-GLOBAL-SYMBOL
        (YIELD-RENAMED-NAME-IF-NATIVE (%METHOD-SLOT.SLOT-NAME METHOD)
         KWD-CL-TRANSLATE-COMMON-LISP KWD-CL-TRANSLATE-FUNCTION))
       NIL)))
    (CL:RETURN-FROM CL-YIELD-METHOD-TYPE-DECLARATION-TREE NULL))))

;;; (DEFUN (CL-YIELD-DECLARE-TREE CONS) ...)

(CL:DEFUN CL-YIELD-DECLARE-TREE (DECLARATIONS INCLUDE-TYPE-CHECKS?)
  (CL:WHEN (CL:EQ DECLARATIONS NIL)
   (CL:RETURN-FROM CL-YIELD-DECLARE-TREE NIL))
  (CL:LET* ((OTHERDECLARATIONS (%%REST DECLARATIONS)) (TYPECHECKS NIL))
   (CL:WHEN (CL:AND INCLUDE-TYPE-CHECKS? (CL:>= *SAFETY* 1))
    (CL:LET* ((DECL NULL) (ITER-000 DECLARATIONS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ DECL (%%VALUE ITER-000))
      (CL:WHEN (CL:<= *SAFETY* 2)
       (CL:SETQ TYPECHECKS
        (CONS (NEW-VERBATIM-STRING-WRAPPER "#+MCL") TYPECHECKS)))
      (CL:SETQ TYPECHECKS
       (CONS
        (LIST* (INTERN-COMMON-LISP-SYMBOL "CHECK-TYPE")
         (%%VALUE (%%REST (%%REST DECL)))
         (CONS (%%VALUE (%%REST DECL)) NIL))
        TYPECHECKS))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ TYPECHECKS (REVERSE TYPECHECKS)))
   (CL:LET* ((DECL NULL) (ITER-001 DECLARATIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ DECL (%%VALUE ITER-001))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ DECL NULL))
       (CL:EQ (%%VALUE DECL) (INTERN-COMMON-LISP-SYMBOL "TYPE")))
      (CL:LET* ((OTHERDECL NULL) (ITER-002 OTHERDECLARATIONS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ OTHERDECL (%%VALUE ITER-002))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ OTHERDECL NULL))
          (CL:EQ (%%VALUE OTHERDECL)
           (INTERN-COMMON-LISP-SYMBOL "TYPE"))
          (EQL? (%%VALUE (%%REST OTHERDECL)) (%%VALUE (%%REST DECL))))
         (CONCATENATE DECL (%%REST (%%REST OTHERDECL)))
         (SUBSTITUTE OTHERDECLARATIONS NULL OTHERDECL))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))
     (CL:SETQ OTHERDECLARATIONS (%%REST OTHERDECLARATIONS))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:RETURN-FROM CL-YIELD-DECLARE-TREE
    (CONS
     (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE
      (CONS (INTERN-COMMON-LISP-SYMBOL "DECLARE")
       (CONCATENATE (REMOVE DECLARATIONS NULL) NIL)))
     (CONCATENATE TYPECHECKS NIL)))))

;;; (DEFUN (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE OBJECT) ...)

(CL:DEFUN CL-CONDITIONALIZE-TYPE-DECLARATION-TREE (DECLARATION)
  (CL:RETURN-FROM CL-CONDITIONALIZE-TYPE-DECLARATION-TREE DECLARATION))

;;; (DEFUN (CL-TRANSLATE-UNIT OBJECT) ...)

(CL:DEFUN CL-TRANSLATE-UNIT (UNIT)
  (CL:LET* ((TEST-VALUE-000 (%TRANSLATION-UNIT.CATEGORY UNIT)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-GLOBAL-VARIABLE)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT UNIT)))
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-CLASS)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT UNIT)))
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-METHOD)
      (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-MACRO))
     (CL:RETURN-FROM CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFINE-METHOD-UNIT UNIT)))
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-PRINT-METHOD)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT
      (CL-TRANSLATE-DEFPRINT-UNIT UNIT)))
    ((CL:OR
      (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-STARTUP-TIME-PROGN)
      (CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-VERBATIM))
     (CL:RETURN-FROM CL-TRANSLATE-UNIT
      (CL-TRANSLATE-A-TREE (%TRANSLATION-UNIT.THE-OBJECT UNIT))))
    ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-TYPE)
     (CL:SETF (%TRANSLATION-UNIT.CATEGORY UNIT) NULL)
     (CL:RETURN-FROM CL-TRANSLATE-UNIT NIL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CL-TRANSLATE-METHOD-PARAMETERS CONS) ...)

(CL:DEFUN CL-TRANSLATE-METHOD-PARAMETERS (METHOD)
  (CL:LET*
   ((FUNCTION? (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
    (ABSTRACT? (%METHOD-SLOT.ABSTRACT? METHOD)) (OTREE NIL)
    (OPARAMETER NULL) (FIRSTPARAMETERTYPE NULL))
   (CL:LET*
    ((PARAMETER NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (METHOD-PARAMETER-NAMES METHOD)))
     (PTYPE NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)))
     (I NULL-INTEGER) (ITER-002 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
      (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ PARAMETER (%%VALUE ITER-000))
     (CL:SETQ PTYPE (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
     (CL:SETQ OPARAMETER (CL-TRANSLATE-LOCAL-SYMBOL PARAMETER))
     (CL:COND
      ((CL:AND (CL:NOT FUNCTION?) (CL:NOT ABSTRACT?) (CL:= I 1))
       (CL:SETQ FIRSTPARAMETERTYPE
        (CL-TRANSLATE-CLASS-NAME
         (TYPE-TO-CLASS (TYPE-SPEC-TO-BASE-TYPE PTYPE))))
       (CL:LET*
        ((TEST-VALUE-000
          (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
           (%METHOD-SLOT.SLOT-NAME METHOD)
           (%METHOD-SLOT.SLOT-OWNER METHOD) FUNCTION?)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-OBJECT-METHOD)
          (CL:SETQ OTREE
           (CONS
            (LIST* SYM-CL-TRANSLATE-STELLA-CLSYS-SELF
             FIRSTPARAMETERTYPE NIL)
            OTREE))
          (CL:SETQ OTREE (CONS OPARAMETER OTREE)))
         ((CL:EQ TEST-VALUE-000
           SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD)
          (CL:SETQ OTREE
           (CONS (CONS OPARAMETER (CONS FIRSTPARAMETERTYPE NIL))
            OTREE))
          (CL:SETQ OTREE
           (CONS SYM-CL-TRANSLATE-STELLA-CLSYS-DUMMY OTREE)))
         (CL:T
          (CL:SETQ OTREE
           (CONS (CONS OPARAMETER (CONS FIRSTPARAMETERTYPE NIL))
            OTREE))))))
      (CL:T (CL:SETQ OTREE (CONS OPARAMETER OTREE))))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:WHEN
    (CL:AND
     (%BOOLEAN-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-CL-TRANSLATE-STELLA-METHOD-VARIABLE-ARGUMENTS?
       FALSE-WRAPPER))
     (CL:NOT (PASS-VARIABLE-ARGUMENTS-AS-LIST? METHOD)))
    (CL:SETF (%%REST OTREE)
     (CONS (INTERN-COMMON-LISP-SYMBOL "&REST")
      (CONCATENATE (%%REST OTREE) NIL))))
   (CL:RETURN-FROM CL-TRANSLATE-METHOD-PARAMETERS (REVERSE OTREE))))

;;; (DEFUN (CL-METHOD-DEFINITION-OPERATOR SYMBOL) ...)

(CL:DEFUN CL-METHOD-DEFINITION-OPERATOR (METHOD)
  (CL:COND
   ((%METHOD-SLOT.METHOD-FUNCTION? METHOD)
    (CL:RETURN-FROM CL-METHOD-DEFINITION-OPERATOR
     (INTERN-COMMON-LISP-SYMBOL "DEFUN")))
   ((%METHOD-SLOT.ABSTRACT? METHOD)
    (CL:RETURN-FROM CL-METHOD-DEFINITION-OPERATOR
     (INTERN-COMMON-LISP-SYMBOL "DEFGENERIC")))
   ((USE-DEFCONSMETHOD? METHOD)
    (CL:RETURN-FROM CL-METHOD-DEFINITION-OPERATOR
     SYM-CL-TRANSLATE-STELLA-%%DEFCONSMETHOD))
   ((CL:OR
     (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD)
      SGT-CL-TRANSLATE-STELLA-INTEGER)
     (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD)
      SGT-CL-TRANSLATE-STELLA-LONG-INTEGER))
    (CL:RETURN-FROM CL-METHOD-DEFINITION-OPERATOR
     SYM-CL-TRANSLATE-STELLA-%%DEFINTEGERMETHOD))
   (CL:T
    (CL:RETURN-FROM CL-METHOD-DEFINITION-OPERATOR
     (INTERN-COMMON-LISP-SYMBOL "DEFMETHOD")))))

;;; (DEFUN (CL-TRANSLATE-DEFINE-METHOD-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-METHOD-UNIT (UNIT)
  (CL:LET*
   ((METHOD (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (METHODNAME (%METHOD-SLOT.SLOT-NAME METHOD))
    (DOCUMENTATION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
       SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER)))
    (FUNCTION? (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
    (BODYTREE (%TRANSLATION-UNIT.CODE-REGISTER UNIT))
    (DECLARATIONS NIL) (METHODDECLARATION NULL) (OTREE NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (CL:WHEN
    (CL:AND (CL:EQ METHODNAME SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
     (CL:EQ (%METHOD-SLOT.SLOT-OWNER METHOD)
      SGT-CL-TRANSLATE-STELLA-CONS)
     (MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES))
    (CL:RETURN-FROM CL-TRANSLATE-DEFINE-METHOD-UNIT NULL))
   (CL:LET*
    ((TEST-VALUE-000
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS METHODNAME
       (%METHOD-SLOT.SLOT-OWNER METHOD) FUNCTION?)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
      (CL:SETQ BODYTREE
       (CONS
        (LIST* SYM-CL-TRANSLATE-STELLA-SETQ
         SYM-CL-TRANSLATE-STELLA-SELF
         (CL-TRANSLATE-GLOBAL-SYMBOL
          SYM-CL-TRANSLATE-STELLA-*CLSYS-SELF*)
         NIL)
        BODYTREE)))
     ((CL:EQ TEST-VALUE-000 SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD)
      (CL:SETQ DECLARATIONS
       (CONS
        (LIST* (INTERN-COMMON-LISP-SYMBOL "IGNORE")
         SYM-CL-TRANSLATE-STELLA-CLSYS-DUMMY NIL)
        NIL)))
     (CL:T)))
   (CL:WHEN (GENERATE-CL-TYPE-DECLARATIONS?)
    (CL:SETQ DECLARATIONS
     (CONCATENATE DECLARATIONS
      (CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES METHOD)))
    (CL:SETQ METHODDECLARATION
     (CL-YIELD-METHOD-TYPE-DECLARATION-TREE METHOD)))
   (CL:IF (CL:AND (CL:NOT FUNCTION?) (%METHOD-SLOT.ABSTRACT? METHOD))
    (CL:SETQ OTREE
     (CONS (CL-METHOD-DEFINITION-OPERATOR METHOD)
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL
        (YIELD-RENAMED-NAME-IF-NATIVE METHODNAME
         KWD-CL-TRANSLATE-COMMON-LISP KWD-CL-TRANSLATE-FUNCTION))
       (CONS (CL-TRANSLATE-METHOD-PARAMETERS METHOD) NIL))))
    (CL:SETQ OTREE
     (CONS (CL-METHOD-DEFINITION-OPERATOR METHOD)
      (CONS
       (CL-TRANSLATE-GLOBAL-SYMBOL
        (YIELD-RENAMED-NAME-IF-NATIVE METHODNAME
         KWD-CL-TRANSLATE-COMMON-LISP KWD-CL-TRANSLATE-FUNCTION))
       (CONS (CL-TRANSLATE-METHOD-PARAMETERS METHOD)
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
          (CONS (WRAP-STRING DOCUMENTATION) NIL) NIL)
         (CONCATENATE (CL-YIELD-DECLARE-TREE DECLARATIONS CL:T)
          (CONCATENATE (CL-TRANSLATE-LIST-OF-TREES BODYTREE)
           (CONCATENATE
            (CL:IF
             (CL:AND (VOID? (TYPE METHOD))
              (CL:NOT (PRESERVE-TAIL-MERGE-OPTIMIZABILITY?)))
             (CONS KWD-CL-TRANSLATE-VOID NIL) NIL)
            NIL)))))))))
   (CL:WHEN
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-CL-TRANSLATE-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))
    (FREE METHOD))
   (CL:WHEN (CL:NOT (CL:EQ METHODDECLARATION NULL))
    (CL:SETQ OTREE
     (LIST* (INTERN-COMMON-LISP-SYMBOL "PROGN")
      (LIST* (INTERN-COMMON-LISP-SYMBOL "DECLAIM") METHODDECLARATION
       NIL)
      OTREE NIL)))
   (CL:RETURN-FROM CL-TRANSLATE-DEFINE-METHOD-UNIT OTREE)))

;;; (DEFUN (YIELD-CLOS-SLOT-TYPE-TREE CONS) ...)

(CL:DEFUN YIELD-CLOS-SLOT-TYPE-TREE (SLOT)
  (CL:LET*
   ((CLTYPE
     (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))))
   (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
    (CL:RETURN-FROM YIELD-CLOS-SLOT-TYPE-TREE
     (CONS
      (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE KWD-CL-TRANSLATE-TYPE)
      (CONS (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE CLTYPE)
       (LIST* KWD-CL-TRANSLATE-INITFORM
        (CL-TRANSLATE-A-TREE
         (TYPE-TO-WALKED-NULL-VALUE-TREE (TYPE-SPECIFIER SLOT)
          (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT)))
        NIL))))
    (CL:RETURN-FROM YIELD-CLOS-SLOT-TYPE-TREE NIL))))

;;; (DEFUN (YIELD-CLOS-SLOT-TREE CONS) ...)

(CL:DEFUN YIELD-CLOS-SLOT-TREE (SLOT)
  (CL:LET*
   ((SLOTNAME
     (TRUE-SLOT-NAME (%STORAGE-SLOT.SLOT-NAME SLOT)
      (%STORAGE-SLOT.SLOT-OWNER SLOT)))
    (ALLOCATION (ALLOCATION SLOT)) (ALLOCATIONFORM NIL)
    (DOCUMENTATION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
       SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER)))
    (DOCUMENTATIONFORM NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (CL:COND
    ((CL:EQ ALLOCATION KWD-CL-TRANSLATE-EMBEDDED)
     (CL:SETQ ALLOCATION KWD-CL-TRANSLATE-INSTANCE))
    (CL:T))
   (CL:WHEN (CL:NOT (CL:EQ ALLOCATION NULL))
    (CL:SETQ ALLOCATIONFORM
     (LIST* KWD-CL-TRANSLATE-ALLOCATION ALLOCATION NIL)))
   (CL:WHEN (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
    (CL:SETQ DOCUMENTATIONFORM
     (LIST* KWD-CL-TRANSLATE-DOCUMENTATION (WRAP-STRING DOCUMENTATION)
      NIL)))
   (CL:RETURN-FROM YIELD-CLOS-SLOT-TREE
    (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SLOTNAME)
     (CONCATENATE (YIELD-CLOS-SLOT-TYPE-TREE SLOT)
      (CONCATENATE DOCUMENTATIONFORM
       (CONCATENATE ALLOCATIONFORM
        (LIST* KWD-CL-TRANSLATE-ACCESSOR
         (YIELD-CLOS-SLOT-ACCESSOR-NAME SLOTNAME) NIL))))))))

;;; (DEFUN (YIELD-CLOS-CLASS-TREE CONS) ...)

(CL:DEFUN YIELD-CLOS-CLASS-TREE (CLASS)
  (CL:LET*
   ((DIRECTSUPERS NIL) (CLOSSLOTDEFS NIL)
    (DOCUMENTATION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CLASS-NATIVE-SUPERS CLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:OR
       (CL:NOT (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER)))
       (CL:NOT (TRANSLATE-TO-SINGLE-INHERITANCE-LANGUAGE?)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (CL-TRANSLATE-CLASS-NAME (TYPE-TO-CLASS SUPER)) NIL))
        (CL:IF (CL:EQ DIRECTSUPERS NIL)
         (CL:SETQ DIRECTSUPERS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST DIRECTSUPERS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CL-TRANSLATE-CLASS-NAME (TYPE-TO-CLASS SUPER)) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:EQ DIRECTSUPERS NIL)
    (CL:SETQ DIRECTSUPERS
     (CONS
      (CL-TRANSLATE-GLOBAL-SYMBOL
       SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-OBJECT)
      DIRECTSUPERS)))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (CLASS-SLOTS CLASS)) (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-001))
     (CL:TAGBODY
      (CL:WHEN (CL:AND (STORAGE-SLOT? SLOT) (NATIVE-SLOT? SLOT))
       (CL:WHEN (CL:NOT (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ (%SLOT.SLOT-BASE-TYPE SLOT) NULL))
          (CL:EQ
           (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-BASE-TYPE SLOT))
           NULL))
         (CL:WARN
          "Can't generate a native slot named `~A' for the class `~A'~% because the slot's :type `~A' is undefined."
          (%SLOT.SLOT-NAME SLOT) (CLASS-NAME CLASS)
          (%SLOT.SLOT-BASE-TYPE SLOT)))
        (CL:GO :CONTINUE))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001 (CONS (YIELD-CLOS-SLOT-TREE SLOT) NIL))
         (CL:IF (CL:EQ CLOSSLOTDEFS NIL)
          (CL:SETQ CLOSSLOTDEFS COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST CLOSSLOTDEFS COLLECT-001)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-001)
          (CONS (YIELD-CLOS-SLOT-TREE SLOT) NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
      :CONTINUE)))
   (CL:RETURN-FROM YIELD-CLOS-CLASS-TREE
    (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFCLASS")
     (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
     (CONS DIRECTSUPERS
      (CONS CLOSSLOTDEFS
       (CONCATENATE
        (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
         (CONS
          (LIST* KWD-CL-TRANSLATE-DOCUMENTATION
           (WRAP-STRING DOCUMENTATION) NIL)
          NIL)
         NIL)
        NIL)))))))

;;; (DEFUN (COMPUTE-CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ...)

(CL:DEFUN COMPUTE-CL-STRUCT-SLOTS (CLASS)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CLASS-NATIVE-SUPERS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER)))
      (CL:SETQ VALUE-000 SUPER) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((REALSUPER VALUE-000)
     (RESULT
      (CL:IF (CL:NOT (CL:EQ REALSUPER NULL))
       (COMPUTE-CL-STRUCT-SLOTS (%SURROGATE.SURROGATE-VALUE REALSUPER))
       NULL)))
    (CL:WHEN (CL:EQ RESULT NULL) (CL:SETQ RESULT (NEW-LIST)))
    (CL:LET*
     ((SUPER NULL)
      (ITER-001 (%LIST.THE-CONS-LIST (CLASS-NATIVE-SUPERS CLASS))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ SUPER (%%VALUE ITER-001))
      (CL:WHEN (CL:NOT (CL:EQ SUPER REALSUPER))
       (CL:LET*
        ((SLOT NULL)
         (ITER-002 (CLASS-SLOTS (%SURROGATE.SURROGATE-VALUE SUPER)))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-002) DO
         (CL:SETQ SLOT (%ITERATOR.VALUE ITER-002))
         (CL:WHEN (CL:AND (STORAGE-SLOT? SLOT) (NATIVE-SLOT? SLOT))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
            (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
             (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
              COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:LET*
     ((SLOT NULL)
      (ITER-003 (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS)))
      (COLLECT-001 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
      (CL:SETQ SLOT (%%VALUE ITER-003))
      (CL:WHEN (CL:AND (STORAGE-SLOT? SLOT) (NATIVE-SLOT? SLOT))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOT NIL))
         (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
          (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
           COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOT NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
      (CL:SETQ ITER-003 (%%REST ITER-003))))
    (CL:RETURN-FROM COMPUTE-CL-STRUCT-SLOTS RESULT))))

;;; (DEFUN (CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ...)

(CL:DEFUN CL-STRUCT-SLOTS (CLASS)
  (CL:LET* ((SLOTS (CLASS-CL-STRUCT-SLOTS CLASS)))
   (CL:IF (DEFINED-LIST? SLOTS) (CL:RETURN-FROM CL-STRUCT-SLOTS SLOTS)
    (CL:RETURN-FROM CL-STRUCT-SLOTS
     (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
      SYM-CL-TRANSLATE-STELLA-CLASS-CL-STRUCT-SLOTS
      (COMPUTE-CL-STRUCT-SLOTS CLASS) NULL)))))

;;; (DEFUN (CL-STRUCT-SLOT-OFFSET INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) CL-STRUCT-SLOT-OFFSET))
(CL:DEFUN CL-STRUCT-SLOT-OFFSET (SLOTNAME CLASSTYPE)
  (CL:LET*
   ((SLOTS (CL-STRUCT-SLOTS (%SURROGATE.SURROGATE-VALUE CLASSTYPE)))
    (OFFSET 1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:LET* ((SLOT NULL) (ITER-000 (%LIST.THE-CONS-LIST SLOTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-000))
     (CL:IF (CL:EQ (%STORAGE-SLOT.SLOT-NAME SLOT) SLOTNAME)
      (CL:RETURN-FROM CL-STRUCT-SLOT-OFFSET OFFSET)
      (CL:SETQ OFFSET (CL:1+ OFFSET)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Can't find slot `" (DE-UGLIFY-PARSE-TREE SLOTNAME)
      "' on CL-struct class `" (DE-UGLIFY-PARSE-TREE CLASSTYPE) "'."
      EOL)))
   (CL:RETURN-FROM CL-STRUCT-SLOT-OFFSET NULL-INTEGER)))

;;; (DEFUN (YIELD-STRUCT-SLOT-TREE CONS) ...)

(CL:DEFUN YIELD-STRUCT-SLOT-TREE (SLOT)
  (CL:LET*
   ((CLTYPE
     (LOOKUP-CL-TYPE-FROM-STELLA-TYPE
      (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))))
   (CL:IF (CL:NOT (CL:EQ CLTYPE NULL))
    (CL:RETURN-FROM YIELD-STRUCT-SLOT-TREE
     (CONS (CL-TRANSLATE-LOCAL-SYMBOL (%STORAGE-SLOT.SLOT-NAME SLOT))
      (CONS
       (CL-TRANSLATE-A-TREE
        (TYPE-TO-WALKED-NULL-VALUE-TREE (TYPE-SPECIFIER SLOT)
         (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT)))
       (CONS
        (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE KWD-CL-TRANSLATE-TYPE)
        (CONS (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE CLTYPE) NIL)))))
    (CL:RETURN-FROM YIELD-STRUCT-SLOT-TREE
     (CONS (CL-TRANSLATE-LOCAL-SYMBOL (%STORAGE-SLOT.SLOT-NAME SLOT))
      (CONS (CL-TRANSLATE-GLOBAL-SYMBOL SYM-CL-TRANSLATE-STELLA-NULL)
       NIL))))))

;;; (DEFUN (YIELD-STRUCT-SLOT-TREES CONS) ...)

(CL:DEFUN YIELD-STRUCT-SLOT-TREES (CLASS)
  (CL:LET* ((STRUCTSLOTDEFS NIL))
   (CL:LET*
    ((SLOT NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CL-STRUCT-SLOTS CLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:WHEN (CL:NOT (CL:EQ (NATIVE-SLOT-HOME SLOT CLASS) CLASS))
       (CL:WHEN
        (CL:AND
         (CL:NOT (CL:EQ (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) NULL))
         (CL:EQ
          (%SURROGATE.SURROGATE-VALUE
           (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT))
          NULL))
        (CL:WARN
         "Can't generate a native slot named `~A' for the class `~A'~% because the slot's :type `~A' is undefined."
         (%STORAGE-SLOT.SLOT-NAME SLOT) (CLASS-NAME CLASS)
         (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT)))
       (CL:GO :CONTINUE))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000 (CONS (YIELD-STRUCT-SLOT-TREE SLOT) NIL))
        (CL:IF (CL:EQ STRUCTSLOTDEFS NIL)
         (CL:SETQ STRUCTSLOTDEFS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST STRUCTSLOTDEFS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (YIELD-STRUCT-SLOT-TREE SLOT) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-STRUCT-SLOT-TREES STRUCTSLOTDEFS)))

;;; (DEFUN (YIELD-STRUCT-TREE CONS) ...)

(CL:DEFUN YIELD-STRUCT-TREE (CLASS)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CLASS-NATIVE-SUPERS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER)))
      (CL:SETQ VALUE-000 SUPER) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((SUPER VALUE-000) (TRANSLATEDSUPER NULL)
     (DOCUMENTATION
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
    (CL:IF (CL:NOT (CL:EQ SUPER NULL))
     (CL:SETQ TRANSLATEDSUPER
      (CL-TRANSLATE-GLOBAL-SYMBOL
       (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME SUPER)
        (%SURROGATE.HOME-CONTEXT SUPER) CL:T)))
     (CL:SETQ TRANSLATEDSUPER
      (CL-TRANSLATE-GLOBAL-SYMBOL
       SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-STRUCT)))
    (CL:RETURN-FROM YIELD-STRUCT-TREE
     (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFSTRUCT")
      (CONS (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
       (CONS
        (LIST* KWD-CL-TRANSLATE-CONC-NAME
         (YIELD-STRUCT-SLOT-ACCESSOR-NAME (%CLASS.CLASS-TYPE CLASS)
          SYM-CL-TRANSLATE-STELLA-)
         NIL)
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ TRANSLATEDSUPER NULL))
          (CONS (LIST* KWD-CL-TRANSLATE-INCLUDE TRANSLATEDSUPER NIL)
           NIL)
          NIL)
         (LIST*
          (LIST* KWD-CL-TRANSLATE-CONSTRUCTOR
           (YIELD-STRUCT-CONSTRUCTOR-NAME CLASS) (CONS NIL NIL))
          (LIST* KWD-CL-TRANSLATE-COPIER NIL NIL)
          (LIST* KWD-CL-TRANSLATE-PREDICATE NIL NIL) NIL))))
      (CONCATENATE
       (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
        (CONS (WRAP-STRING DOCUMENTATION) NIL) NIL)
       (CONCATENATE (YIELD-STRUCT-SLOT-TREES CLASS) NIL)))))))

;;; (DEFUN (YIELD-VECTOR-STRUCT-NAME OBJECT) ...)

(CL:DEFUN YIELD-VECTOR-STRUCT-NAME (CLASS)
  (CL:RETURN-FROM YIELD-VECTOR-STRUCT-NAME
   (YIELD-GLOBAL-LISP-SYMBOL
    (%SURROGATE.HOME-CONTEXT (%CLASS.CLASS-TYPE CLASS))
    (CONCATENATE "%" (CLASS-NAME CLASS)))))

;;; (DEFUN (YIELD-VECTOR-STRUCT-TREE CONS) ...)

(CL:DEFUN YIELD-VECTOR-STRUCT-TREE (CLASS)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CLASS-NATIVE-SUPERS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (%CLASS.MIXIN? (%SURROGATE.SURROGATE-VALUE SUPER)))
      (CL:SETQ VALUE-000 SUPER) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((SUPER VALUE-000)
     (DOCUMENTATION
      (%STRING-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-CL-TRANSLATE-STELLA-DOCUMENTATION NULL-STRING-WRAPPER))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
    (CL:RETURN-FROM YIELD-VECTOR-STRUCT-TREE
     (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFCLASS")
      (CL-TRANSLATE-GLOBAL-SYMBOL (CLASS-SYMBOL CLASS))
      (CONS
       (CL:IF (CL:NOT (CL:EQ SUPER NULL))
        (CONS
         (CL-TRANSLATE-GLOBAL-SYMBOL
          (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME SUPER)
           (%SURROGATE.HOME-CONTEXT SUPER) CL:T))
         NIL)
        NIL)
       (CONS NIL
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
          (CONS
           (LIST* KWD-CL-TRANSLATE-DOCUMENTATION
            (WRAP-STRING DOCUMENTATION) NIL)
           NIL)
          NIL)
         NIL))))))))

;;; (DEFUN (YIELD-CONDITION-TREE CONS) ...)

(CL:DEFUN YIELD-CONDITION-TREE (CLASS)
  (CL:LET* ((DEFN (YIELD-CLOS-CLASS-TREE CLASS)))
   (FIRST-SETTER DEFN (INTERN-COMMON-LISP-SYMBOL "DEFINE-CONDITION"))
   (CL:WHEN
    (CL:NOT (CL:EQ (%%REST (%%REST (%%REST (%%REST DEFN)))) NULL))
    (CL:SETF (%%REST (%%REST (%%REST (%%REST DEFN)))) NIL))
   (CL:RETURN-FROM YIELD-CONDITION-TREE DEFN)))

;;; (DEFUN (CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? BOOLEAN) ...)

(CL:DEFUN CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? (CLASS)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000
    (CL:NOT
     (SUBTYPE-OF? (%CLASS.CLASS-TYPE CLASS)
      SGT-CL-TRANSLATE-STELLA-OBJECT)))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (CREATE-NATIVE-CLASS? CLASS))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((SUPER NULL) (ITER-000 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ SUPER (%%VALUE ITER-000))
        (CL:WHEN (CL:NOT (CREATE-NATIVE-CLASS? SUPER))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? VALUE-000))))

;;; (DEFUN (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT (UNIT)
  (CL:LET* ((CLASS (%TRANSLATION-UNIT.THE-OBJECT UNIT)))
   (CL:COND
    ((EXCEPTION-CLASS? CLASS)
     (CL:RETURN-FROM CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-CONDITION-TREE CLASS)))
    ((CL:OR
      (CL:NOT
       (MEMB? *CURRENT-STELLA-FEATURES*
        KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS))
      (CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? CLASS))
     (CL:RETURN-FROM CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-CLOS-CLASS-TREE CLASS)))
    ((MEMB? *CURRENT-STELLA-FEATURES*
      KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)
     (CL:RETURN-FROM CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-VECTOR-STRUCT-TREE CLASS)))
    (CL:T
     (CL:RETURN-FROM CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT
      (YIELD-STRUCT-TREE CLASS))))))

;;; (DEFUN (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT (UNIT)
  (CL:LET*
   ((GLOBAL (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (NAME
     (CL-TRANSLATE-GLOBAL-SYMBOL
      (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL)))
    (DOCUMENTATION (%GLOBAL-VARIABLE.DOCUMENTATION GLOBAL))
    (UNBOUNDSPECIAL?
     (CL:AND (%GLOBAL-VARIABLE.VARIABLE-SPECIAL? GLOBAL)
      (CL:EQ (%TRANSLATION-UNIT.CODE-REGISTER UNIT)
       KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE)))
    (INITIALVALUETREE
     (CL-TRANSLATE-A-TREE (%TRANSLATION-UNIT.CODE-REGISTER UNIT)))
    (TYPEDECLARATIONTREE
     (CL:IF (GENERATE-CL-TYPE-DECLARATIONS?)
      (CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE GLOBAL) NULL))
    (OPERATOR (INTERN-COMMON-LISP-SYMBOL "DEFVAR")) (OTREE NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DOCUMENTATION))
   (CL:SETQ OTREE
    (CL:IF UNBOUNDSPECIAL?
     (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFVAR") NAME NIL)
     (CONS OPERATOR
      (CONS NAME
       (CONS INITIALVALUETREE
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ DOCUMENTATION STELLA::NULL-STRING))
          (CONS (WRAP-STRING DOCUMENTATION) NIL) NIL)
         NIL))))))
   (CL:WHEN (CL:NOT (CL:EQ TYPEDECLARATIONTREE NULL))
    (CL:SETQ OTREE
     (LIST* (INTERN-COMMON-LISP-SYMBOL "PROGN") OTREE
      (CONS
       (LIST* (INTERN-COMMON-LISP-SYMBOL "DECLAIM") TYPEDECLARATIONTREE
        NIL)
       NIL))))
   (CL:RETURN-FROM CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT OTREE)))

;;; (DEFUN (CL-TRANSLATE-DEFPRINT-UNIT CONS) ...)

(CL:DEFUN CL-TRANSLATE-DEFPRINT-UNIT (UNIT)
  (CL:LET*
   ((CLASS (%TRANSLATION-UNIT.THE-OBJECT UNIT))
    (BODY (%TRANSLATION-UNIT.CODE-REGISTER UNIT)) (EXTRATREES NIL))
   (CL:COND
    ((CL:EQ
      (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS
       SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT (%CLASS.CLASS-TYPE CLASS)
       CL:NIL)
      SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT)
     (CL:SETQ EXTRATREES
      (CONS
       (LIST* SYM-CL-TRANSLATE-STELLA-SETQ SYM-CL-TRANSLATE-STELLA-SELF
        (CL-TRANSLATE-GLOBAL-SYMBOL
         SYM-CL-TRANSLATE-STELLA-*CLSYS-SELF*)
        NIL)
       NIL)))
    (CL:T))
   (CL:RETURN-FROM CL-TRANSLATE-DEFPRINT-UNIT
    (LIST* (INTERN-COMMON-LISP-SYMBOL "DEFMETHOD")
     (INTERN-COMMON-LISP-SYMBOL "PRINT-OBJECT")
     (LIST*
      (LIST* SYM-CL-TRANSLATE-STELLA-SELF (CLASS-SYMBOL CLASS) NIL)
      SYM-CL-TRANSLATE-STELLA-STREAM NIL)
     (CONCATENATE EXTRATREES (CONS (CL-TRANSLATE-A-TREE BODY) NIL))))))

(CL:DEFUN HELP-STARTUP-CL-TRANSLATE1 ()
  (CL:PROGN
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA--
    (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
   (CL:SETQ |SYM-CL-TRANSLATE-STELLA-/|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "/" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-EQ?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQ?" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA->
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-!=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "!=" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-CONSES" NULL 2))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-STANDARD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS"
     NULL 2))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-VOID-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID-SYS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-TYPED-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-BAD-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD-SYS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-SLOT-VALUE-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SLOT-VALUE-SETTER" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-CALL-SUPER-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-SUPER-METHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-WITH-PROCESS-LOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-PROCESS-LOCK" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-LOOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-STARTUP-TIME-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-UNWIND-PROTECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-UNWIND-PROTECT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-HANDLER-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-HANDLER-CASE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-HANDLE-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-HANDLE-EXCEPTION" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-SIGNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-SIGNAL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SAFE-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAFE-CAST" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-BREAK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CONTINUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-WHILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHILE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-MAKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-NEW" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-MV-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-SETQ" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-CALL-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-FUNCTION-CODE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-CALL-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD-CODE" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-CL-TRANSLATE2 ()
  (CL:PROGN
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SYS-INLINE-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-INLINE-CALL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-THE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PRINT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PRINT-NATIVE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-NATIVE-STREAM" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-VERBATIM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-INLINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-CONTINUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUE" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-GET-KWD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-GET-SGT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-MODULE-LISP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-LISP-PACKAGE" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-UNESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNESCAPED" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-COMPLEX-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEX-ESCAPED" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-%%VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%VALUE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-%%REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%REST" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-SVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-SVAL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NTH-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH-SETTER" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-AREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AREF" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-AREF-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AREF-SETTER" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-ARGUMENT-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST-ITERATOR" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NORMAL-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-CALL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NON-OBJECT-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-OBJECT-METHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PRINT-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-OBJECT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-OBJECT-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-METHOD" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-CALL" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-NATIVE-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-VECTOR" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-ALLOCATE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ITERATOR" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LENGTH" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NEXT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT?" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-ARGUMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PRIMARY-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMARY-TYPE" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-SECOND-CLASS-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SECOND-CLASS-OBJECT" NULL 1))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-NULL-ARRAY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-ARRAY?" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLASS-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-*CONDITION-MESSAGE-KEYWORD*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*CONDITION-MESSAGE-KEYWORD*" NULL
     0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-CL-TRANSLATE3 ()
  (CL:PROGN
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-REPLACE-SUBSTRINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPLACE-SUBSTRINGS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-MAKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-MAKE" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-INITIAL-ELEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-ELEMENT" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-%%PRINT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%PRINT-STREAM" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-CONTINUABLE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUABLE-ERROR" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-METHOD-CODE-CALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-METHOD-CODE-CALL" NULL 0))
   (CL:SETQ SGT-CL-TRANSLATE-STELLA-SHORT-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHORT-INTEGER" NULL 1))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-GLOBAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-MACRO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MACRO" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-PRINT-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-METHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-SELF" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-DUMMY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-DUMMY" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-METHOD-VARIABLE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL
     0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-%%DEFCONSMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%DEFCONSMETHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-%%DEFINTEGERMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "%%DEFINTEGERMETHOD" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-*CLSYS-SELF*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*CLSYS-SELF*" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-INITFORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITFORM" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-EMBEDDED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMBEDDED" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-ALLOCATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATION" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-ACCESSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCESSOR" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-ROOT-OBJECT" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLASS-CL-STRUCT-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT-SLOTS" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-CLSYS-ROOT-STRUCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLSYS-ROOT-STRUCT" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-CONC-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONC-NAME" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-CONSTRUCTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRUCTOR" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-COPIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPIER" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-
    (INTERN-RIGID-SYMBOL-WRT-MODULE "" NULL 0))
   (CL:SETQ KWD-CL-TRANSLATE-INCLUDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDE" NULL 2))
   (CL:SETQ KWD-CL-TRANSLATE-UNBOUND-SPECIAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-STARTUP-CL-TRANSLATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-CL-TRANSLATE" NULL 0))
   (CL:SETQ SYM-CL-TRANSLATE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-CL-TRANSLATE4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "DESTRUCTURE-CALL-TREE"
    "(DEFUN (DESTRUCTURE-CALL-TREE SYMBOL TYPE CONS) ((TREE CONS)))"
    (CL:FUNCTION DESTRUCTURE-CALL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-CL-CONSES?"
    "(DEFUN (USE-CL-CONSES? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (ENABLED-STELLA-FEATURE? :USE-COMMON-LISP-CONSES)))"
    (CL:FUNCTION USE-CL-CONSES?) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-DEFCONSMETHOD?"
    "(DEFUN (USE-DEFCONSMETHOD? BOOLEAN) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION USE-DEFCONSMETHOD?) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-CL-STRUCTS?"
    "(DEFUN (USE-CL-STRUCTS? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (ENABLED-STELLA-FEATURE? :USE-COMMON-LISP-STRUCTS)))"
    (CL:FUNCTION USE-CL-STRUCTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "USE-VECTOR-STRUCTS?"
    "(DEFUN (USE-VECTOR-STRUCTS? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (ENABLED-STELLA-FEATURE? :USE-COMMON-LISP-VECTOR-STRUCTS)))"
    (CL:FUNCTION USE-VECTOR-STRUCTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-LIST-OF-TREES"
    "(DEFUN (CL-TRANSLATE-LIST-OF-TREES CONS) ((TREES CONS)))"
    (CL:FUNCTION CL-TRANSLATE-LIST-OF-TREES) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-VOID-SYS"
    "(DEFUN (CL-TRANSLATE-VOID-SYS CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-VOID-SYS) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-TYPED-SYS"
    "(DEFUN (CL-TRANSLATE-TYPED-SYS OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-TYPED-SYS) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-BAD-SYS"
    "(DEFUN (CL-TRANSLATE-BAD-SYS OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-BAD-SYS) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-A-TREE"
    "(DEFUN (CL-TRANSLATE-A-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION CL-TRANSLATE-A-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CL-TRANSLATE-A-TREE"
    "(DEFUN (HELP-CL-TRANSLATE-A-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION HELP-CL-TRANSLATE-A-TREE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE FLOAT-WRAPPER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE SYMBOL)))"
    (WRAP-METHOD-CODE (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE KEYWORD)))"
    (WRAP-METHOD-CODE (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CL-TRANSLATE-ATOMIC-TREE OBJECT) ((TREE SURROGATE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION CL-TRANSLATE-ATOMIC-TREE)) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-GLOBAL-SYMBOL"
    "(DEFUN (CL-TRANSLATE-GLOBAL-SYMBOL OBJECT) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION CL-TRANSLATE-GLOBAL-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-READABLE-SYMBOL-NAME"
    "(DEFUN (YIELD-READABLE-SYMBOL-NAME STRING) ((SYMBOLMODULE MODULE) (SYMBOLNAME STRING) (LOCAL? BOOLEAN)))"
    (CL:FUNCTION YIELD-READABLE-SYMBOL-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-GLOBAL-LISP-SYMBOL"
    "(DEFUN (YIELD-GLOBAL-LISP-SYMBOL OBJECT) ((SYMBOLMODULE MODULE) (SYMBOLNAME STRING)))"
    (CL:FUNCTION YIELD-GLOBAL-LISP-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-LOCAL-SYMBOL"
    "(DEFUN (CL-TRANSLATE-LOCAL-SYMBOL OBJECT) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION CL-TRANSLATE-LOCAL-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-SETQ-TREE"
    "(DEFUN (CL-TRANSLATE-SETQ-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-SETQ-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STRUCT-SLOT-ACCESSOR-NAME"
    "(DEFUN (YIELD-STRUCT-SLOT-ACCESSOR-NAME OBJECT) ((CLASSTYPE TYPE) (SLOTNAME SYMBOL)))"
    (CL:FUNCTION YIELD-STRUCT-SLOT-ACCESSOR-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CLOS-SLOT-ACCESSOR-NAME"
    "(DEFUN (YIELD-CLOS-SLOT-ACCESSOR-NAME OBJECT) ((SLOTNAME SYMBOL)))"
    (CL:FUNCTION YIELD-CLOS-SLOT-ACCESSOR-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SLOT-VALUE-READER-TREE"
    "(DEFUN (YIELD-SLOT-VALUE-READER-TREE CONS) ((SLOTNAME SYMBOL) (OBJECTREF OBJECT) (OBJECTTYPE TYPE)))"
    (CL:FUNCTION YIELD-SLOT-VALUE-READER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-SLOT-VALUE-WRITER-TREE"
    "(DEFUN (YIELD-SLOT-VALUE-WRITER-TREE CONS) ((SLOTNAME SYMBOL) (OBJECTREF OBJECT) (OBJECTTYPE TYPE) (VALUEREF OBJECT)))"
    (CL:FUNCTION YIELD-SLOT-VALUE-WRITER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-SLOT-NAME"
    "(DEFUN (TRUE-SLOT-NAME SYMBOL) ((SLOTNAME SYMBOL) (TYPE TYPE)))"
    (CL:FUNCTION TRUE-SLOT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-FIXED-SLOT-VALUE-TREE"
    "(DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-FIXED-SLOT-VALUE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE"
    "(DEFUN (CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-FIXED-SLOT-VALUE-SETTER-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CALL-METHOD-TREE"
    "(DEFUN (CL-TRANSLATE-CALL-METHOD-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-CALL-METHOD-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CALL-SUPER-METHOD-TREE"
    "(DEFUN (CL-TRANSLATE-CALL-SUPER-METHOD-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-CALL-SUPER-METHOD-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS"
    "(DEFUN (METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS SYMBOL) ((SLOTNAME SYMBOL) (OWNER TYPE) (FUNCTION? BOOLEAN)))"
    (CL:FUNCTION METHOD-CALL-TYPE-FOR-VECTOR-STRUCTS) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-NORMAL-CALL-METHOD-TREE"
    "(DEFUN (CL-TRANSLATE-NORMAL-CALL-METHOD-TREE CONS) ((OPERATOR SYMBOL) (OWNER TYPE) (ARGUMENTS CONS)))"
    (CL:FUNCTION CL-TRANSLATE-NORMAL-CALL-METHOD-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-NTH-TREE"
    "(DEFUN (CL-TRANSLATE-NTH-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-NTH-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-AREF-TREE"
    "(DEFUN (CL-TRANSLATE-AREF-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-AREF-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-ARGUMENT-LIST-TREE"
    "(DEFUN (CL-TRANSLATE-ARGUMENT-LIST-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-ARGUMENT-LIST-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "DUPLICATE-CURSOR-VARIABLE?"
    "(DEFUN (DUPLICATE-CURSOR-VARIABLE? BOOLEAN) ((VARIABLE SYMBOL) (ITERATORBINDINGS CONS)))"
    (CL:FUNCTION DUPLICATE-CURSOR-VARIABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-FOREACH-TREE"
    "(DEFUN (CL-TRANSLATE-FOREACH-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-FOREACH-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-WRAP-WITH-CONTINUE-LABEL"
    "(DEFUN (MAYBE-WRAP-WITH-CONTINUE-LABEL CONS) ((TRANSLATEDLOOPBODY CONS)))"
    (CL:FUNCTION MAYBE-WRAP-WITH-CONTINUE-LABEL) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-LET-TREE"
    "(DEFUN (CL-TRANSLATE-LET-TREE CONS) ((TREE CONS) (SPECIAL? BOOLEAN)))"
    (CL:FUNCTION CL-TRANSLATE-LET-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-SPECIAL-TREE"
    "(DEFUN (CL-TRANSLATE-SPECIAL-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-SPECIAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-STARTUP-TIME-PROGN-TREE"
    "(DEFUN (CL-TRANSLATE-STARTUP-TIME-PROGN-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-STARTUP-TIME-PROGN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-UNWIND-PROTECT-TREE"
    "(DEFUN (CL-TRANSLATE-UNWIND-PROTECT-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-UNWIND-PROTECT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-SIGNAL-TREE"
    "(DEFUN (CL-TRANSLATE-SIGNAL-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-SIGNAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-HANDLER-CASE-TREE"
    "(DEFUN (CL-TRANSLATE-HANDLER-CASE-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-HANDLER-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-HANDLE-EXCEPTION-TREE"
    "(DEFUN (CL-TRANSLATE-HANDLE-EXCEPTION-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-HANDLE-EXCEPTION-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CAST"
    "(DEFUN (CAST OBJECT) ((VALUE OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Perform a run-time type check, and then return `value'.\")"
    (CL:FUNCTION CAST) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-NUMERIC-CONSTANT"
    "(DEFUN (COERCE-NUMERIC-CONSTANT NUMBER-WRAPPER) ((CONSTANT NUMBER-WRAPPER) (TYPE TYPE)))"
    (CL:FUNCTION COERCE-NUMERIC-CONSTANT) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CAST-TREE"
    "(DEFUN (CL-TRANSLATE-CAST-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-CAST-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-RETURN-TREE"
    "(DEFUN (CL-TRANSLATE-RETURN-TREE OBJECT) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-RETURN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-BOOLEAN-TEST"
    "(DEFUN (CL-TRANSLATE-BOOLEAN-TEST OBJECT) ((TREE OBJECT) (INVERT? BOOLEAN)))"
    (CL:FUNCTION CL-TRANSLATE-BOOLEAN-TEST) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-PLAIN-BOOLEAN-TEST"
    "(DEFUN (CL-TRANSLATE-PLAIN-BOOLEAN-TEST OBJECT) ((TREE OBJECT) (INVERT? BOOLEAN)))"
    (CL:FUNCTION CL-TRANSLATE-PLAIN-BOOLEAN-TEST) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-WHILE-TREE"
    "(DEFUN (CL-TRANSLATE-WHILE-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-WHILE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CONDITIONAL-TREE"
    "(DEFUN (CL-TRANSLATE-CONDITIONAL-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-CONDITIONAL-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-COND-TREE"
    "(DEFUN (CL-TRANSLATE-COND-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-COND-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CASE-TREE"
    "(DEFUN (CL-TRANSLATE-CASE-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-CASE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-BOOLEAN-TREE"
    "(DEFUN (CL-TRANSLATE-BOOLEAN-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-BOOLEAN-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CLASS-NAME"
    "(DEFUN (CL-TRANSLATE-CLASS-NAME OBJECT) ((CLASS CLASS)))"
    (CL:FUNCTION CL-TRANSLATE-CLASS-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STRUCT-CONSTRUCTOR-NAME"
    "(DEFUN (YIELD-STRUCT-CONSTRUCTOR-NAME OBJECT) ((CLASS CLASS)))"
    (CL:FUNCTION YIELD-STRUCT-CONSTRUCTOR-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-MAKE-TREE"
    "(DEFUN (CL-TRANSLATE-MAKE-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-MAKE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-NEW-TREE"
    "(DEFUN (CL-TRANSLATE-NEW-TREE CONS) ((TREE CONS)))"
    (CL:FUNCTION CL-TRANSLATE-NEW-TREE) NULL))
  :VOID)

(CL:DEFUN STARTUP-CL-TRANSLATE ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:when (clsys-use-vector-structs-p)
      (#+:CLISP EXT:WITHOUT-PACKAGE-LOCK #+:CLISP ("COMMON-LISP")
       #-:CLISP CL:PROGN
        (CL:defmethod CL:print-object :around ((self CL:vector) stream)
          (CL:if (clsys-vector-struct-p self)
             (clsys-print-vector-struct self stream)
           (CL:call-next-method))))))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-CL-TRANSLATE1) (HELP-STARTUP-CL-TRANSLATE2)
    (HELP-STARTUP-CL-TRANSLATE3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *CL-TRUE-STRING-WRAPPER*
     (NEW-VERBATIM-STRING-WRAPPER "CL:T"))
    (CL:SETQ *CL-FALSE-STRING-WRAPPER*
     (NEW-VERBATIM-STRING-WRAPPER "CL:NIL")))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-CL-TRANSLATE4)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-NEW-ARRAY-TREE"
     "(DEFUN (CL-TRANSLATE-NEW-ARRAY-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-NEW-ARRAY-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-OPERATOR-TREE"
     "(DEFUN (CL-TRANSLATE-OPERATOR-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-OPERATOR-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-FORMAT-ARGUMENTS"
     "(DEFUN (YIELD-FORMAT-ARGUMENTS CONS) ((TREE CONS)))"
     (CL:FUNCTION YIELD-FORMAT-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-PRINT-TREE"
     "(DEFUN (YIELD-PRINT-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION YIELD-PRINT-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-PRINT-STREAM-TREE"
     "(DEFUN (CL-TRANSLATE-PRINT-STREAM-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-PRINT-STREAM-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-CALL-FUNCTION-CODE-TREE"
     "(DEFUN (CL-TRANSLATE-CALL-FUNCTION-CODE-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-CALL-FUNCTION-CODE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-INLINE-CALL-TREE"
     "(DEFUN (CL-TRANSLATE-INLINE-CALL-TREE OBJECT) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-INLINE-CALL-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-VERBATIM-BODY-SYMBOLS"
     "(DEFUN (CL-TRANSLATE-VERBATIM-BODY-SYMBOLS OBJECT) ((BODY OBJECT) (PARAMETERS (LIST OF SYMBOL))))"
     (CL:FUNCTION CL-TRANSLATE-VERBATIM-BODY-SYMBOLS) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-THE-CODE-TREE"
     "(DEFUN (CL-TRANSLATE-THE-CODE-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-THE-CODE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-VERBATIM-TREE"
     "(DEFUN (CL-TRANSLATE-VERBATIM-TREE OBJECT) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-VERBATIM-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-INLINE-TREE"
     "(DEFUN (CL-TRANSLATE-INLINE-TREE CONS) ((TREE CONS)))"
     (CL:FUNCTION CL-TRANSLATE-INLINE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-CL-TYPE-DECLARATIONS?"
     "(DEFUN (GENERATE-CL-TYPE-DECLARATIONS? BOOLEAN) ())"
     (CL:FUNCTION GENERATE-CL-TYPE-DECLARATIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-CL-TYPE-FROM-STELLA-TYPE"
     "(DEFUN (LOOKUP-CL-TYPE-FROM-STELLA-TYPE OBJECT) ((TYPE TYPE-SPEC)))"
     (CL:FUNCTION LOOKUP-CL-TYPE-FROM-STELLA-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-YIELD-TYPED-EXPRESSION-TREE"
     "(DEFUN (CL-YIELD-TYPED-EXPRESSION-TREE OBJECT) ((TREE OBJECT) (TYPE TYPE-SPEC)))"
     (CL:FUNCTION CL-YIELD-TYPED-EXPRESSION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES"
     "(DEFUN (CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES CONS) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-YIELD-METHOD-PARAMETER-TYPE-DECLARATION-TREES)
     NULL)
    (DEFINE-FUNCTION-OBJECT
     "CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES"
     "(DEFUN (CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES CONS) ((BINDINGSTREE (CONS OF CONS))))"
     (CL:FUNCTION CL-YIELD-LET-VARIABLE-TYPE-DECLARATION-TREES) NULL)
    (DEFINE-FUNCTION-OBJECT
     "CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE"
     "(DEFUN (CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE CONS) ((GLOBAL GLOBAL-VARIABLE)))"
     (CL:FUNCTION CL-YIELD-GLOBAL-VARIABLE-TYPE-DECLARATION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS"
     "(DEFUN (CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS CONS) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-YIELD-METHOD-ARGLIST-TYPE-DECLARATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-YIELD-METHOD-RETURN-TYPE-DECLARATION"
     "(DEFUN (CL-YIELD-METHOD-RETURN-TYPE-DECLARATION OBJECT) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-YIELD-METHOD-RETURN-TYPE-DECLARATION) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-YIELD-METHOD-TYPE-DECLARATION-TREE"
     "(DEFUN (CL-YIELD-METHOD-TYPE-DECLARATION-TREE CONS) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-YIELD-METHOD-TYPE-DECLARATION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-YIELD-DECLARE-TREE"
     "(DEFUN (CL-YIELD-DECLARE-TREE CONS) ((DECLARATIONS (CONS OF CONS)) (INCLUDE-TYPE-CHECKS? BOOLEAN)))"
     (CL:FUNCTION CL-YIELD-DECLARE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-CONDITIONALIZE-TYPE-DECLARATION-TREE"
     "(DEFUN (CL-CONDITIONALIZE-TYPE-DECLARATION-TREE OBJECT) ((DECLARATION OBJECT)))"
     (CL:FUNCTION CL-CONDITIONALIZE-TYPE-DECLARATION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-UNIT"
     "(DEFUN (CL-TRANSLATE-UNIT OBJECT) ((UNIT TRANSLATION-UNIT)))"
     (CL:FUNCTION CL-TRANSLATE-UNIT) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-METHOD-PARAMETERS"
     "(DEFUN (CL-TRANSLATE-METHOD-PARAMETERS CONS) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-TRANSLATE-METHOD-PARAMETERS) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-METHOD-DEFINITION-OPERATOR"
     "(DEFUN (CL-METHOD-DEFINITION-OPERATOR SYMBOL) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION CL-METHOD-DEFINITION-OPERATOR) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-DEFINE-METHOD-UNIT"
     "(DEFUN (CL-TRANSLATE-DEFINE-METHOD-UNIT CONS) ((UNIT TRANSLATION-UNIT)))"
     (CL:FUNCTION CL-TRANSLATE-DEFINE-METHOD-UNIT) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-CLOS-SLOT-TYPE-TREE"
     "(DEFUN (YIELD-CLOS-SLOT-TYPE-TREE CONS) ((SLOT STORAGE-SLOT)))"
     (CL:FUNCTION YIELD-CLOS-SLOT-TYPE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-CLOS-SLOT-TREE"
     "(DEFUN (YIELD-CLOS-SLOT-TREE CONS) ((SLOT STORAGE-SLOT)))"
     (CL:FUNCTION YIELD-CLOS-SLOT-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-CLOS-CLASS-TREE"
     "(DEFUN (YIELD-CLOS-CLASS-TREE CONS) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-CLOS-CLASS-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-CL-STRUCT-SLOTS"
     "(DEFUN (COMPUTE-CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ((CLASS CLASS)))"
     (CL:FUNCTION COMPUTE-CL-STRUCT-SLOTS) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-STRUCT-SLOTS"
     "(DEFUN (CL-STRUCT-SLOTS (LIST OF STORAGE-SLOT)) ((CLASS CLASS)))"
     (CL:FUNCTION CL-STRUCT-SLOTS) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-STRUCT-SLOT-OFFSET"
     "(DEFUN (CL-STRUCT-SLOT-OFFSET INTEGER) ((SLOTNAME SYMBOL) (CLASSTYPE TYPE)))"
     (CL:FUNCTION CL-STRUCT-SLOT-OFFSET) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-STRUCT-SLOT-TREE"
     "(DEFUN (YIELD-STRUCT-SLOT-TREE CONS) ((SLOT STORAGE-SLOT)))"
     (CL:FUNCTION YIELD-STRUCT-SLOT-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-STRUCT-SLOT-TREES"
     "(DEFUN (YIELD-STRUCT-SLOT-TREES CONS) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-STRUCT-SLOT-TREES) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-STRUCT-TREE"
     "(DEFUN (YIELD-STRUCT-TREE CONS) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-STRUCT-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-VECTOR-STRUCT-NAME"
     "(DEFUN (YIELD-VECTOR-STRUCT-NAME OBJECT) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-VECTOR-STRUCT-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-VECTOR-STRUCT-TREE"
     "(DEFUN (YIELD-VECTOR-STRUCT-TREE CONS) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-VECTOR-STRUCT-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-CONDITION-TREE"
     "(DEFUN (YIELD-CONDITION-TREE CONS) ((CLASS CLASS)))"
     (CL:FUNCTION YIELD-CONDITION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS?"
     "(DEFUN (CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS? BOOLEAN) ((CLASS CLASS)))"
     (CL:FUNCTION CL-ALWAYS-TRANSLATE-TO-CLOS-CLASS?) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT"
     "(DEFUN (CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT CONS) ((UNIT TRANSLATION-UNIT)))"
     (CL:FUNCTION CL-TRANSLATE-DEFINE-NATIVE-CLASS-UNIT) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT"
     "(DEFUN (CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT CONS) ((UNIT TRANSLATION-UNIT)))"
     (CL:FUNCTION CL-TRANSLATE-DEFINE-GLOBAL-VARIABLE-UNIT) NULL)
    (DEFINE-FUNCTION-OBJECT "CL-TRANSLATE-DEFPRINT-UNIT"
     "(DEFUN (CL-TRANSLATE-DEFPRINT-UNIT CONS) ((UNIT TRANSLATION-UNIT)))"
     (CL:FUNCTION CL-TRANSLATE-DEFPRINT-UNIT) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-CL-TRANSLATE"
     "(DEFUN STARTUP-CL-TRANSLATE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-CL-TRANSLATE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-CL-TRANSLATE-STELLA-STARTUP-CL-TRANSLATE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-CL-TRANSLATE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupClTranslate") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CL-TRUE-STRING-WRAPPER* VERBATIM-STRING-WRAPPER (NEW VERBATIM-STRING-WRAPPER :WRAPPER-VALUE \"CL:T\"))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CL-FALSE-STRING-WRAPPER* VERBATIM-STRING-WRAPPER (NEW VERBATIM-STRING-WRAPPER :WRAPPER-VALUE \"CL:NIL\"))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CL-OPERATOR-TABLE* KEY-VALUE-LIST NULL :DOCUMENTATION \"Mapping from STELLA operators to Common-Lisp operators.\")"
     NULL)
    (CL:SETQ *CL-OPERATOR-TABLE*
     (DICTIONARY SGT-CL-TRANSLATE-STELLA-KEY-VALUE-LIST
      SYM-CL-TRANSLATE-STELLA-+ (INTERN-COMMON-LISP-SYMBOL "+")
      SYM-CL-TRANSLATE-STELLA-- (INTERN-COMMON-LISP-SYMBOL "-")
      SYM-CL-TRANSLATE-STELLA-* (INTERN-COMMON-LISP-SYMBOL "*")
      |SYM-CL-TRANSLATE-STELLA-/| (INTERN-COMMON-LISP-SYMBOL "/")
      SYM-CL-TRANSLATE-STELLA-EQ? (INTERN-COMMON-LISP-SYMBOL "EQL")
      SYM-CL-TRANSLATE-STELLA-< (INTERN-COMMON-LISP-SYMBOL "<")
      SYM-CL-TRANSLATE-STELLA-<= (INTERN-COMMON-LISP-SYMBOL "<=")
      SYM-CL-TRANSLATE-STELLA->= (INTERN-COMMON-LISP-SYMBOL ">=")
      SYM-CL-TRANSLATE-STELLA-> (INTERN-COMMON-LISP-SYMBOL ">")
      SYM-CL-TRANSLATE-STELLA-= (INTERN-COMMON-LISP-SYMBOL "=")
      SYM-CL-TRANSLATE-STELLA-!= (INTERN-COMMON-LISP-SYMBOL "/=")))
    (CL:LET*
     ((USESTRUCTS? (CLSYS-USE-STRUCTS-P))
      (USEVECTORSTRUCTS? (CLSYS-USE-VECTOR-STRUCTS-P))
      (USECLCONSES? (CL:LISTP NIL)))
     (CL:WHEN USESTRUCTS?
      (%SET-STELLA-FEATURE
       (CONS-LIST KWD-CL-TRANSLATE-USE-COMMON-LISP-STRUCTS)))
     (CL:WHEN USEVECTORSTRUCTS?
      (%SET-STELLA-FEATURE
       (CONS-LIST KWD-CL-TRANSLATE-USE-COMMON-LISP-VECTOR-STRUCTS)))
     (CL:WHEN USECLCONSES?
      (%SET-STELLA-FEATURE
       (CONS-LIST KWD-CL-TRANSLATE-USE-COMMON-LISP-CONSES))))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *NEEDEXPLICITRETURN?* BOOLEAN FALSE)" NULL)))
  :VOID)
