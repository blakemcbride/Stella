;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; translate-file.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-TRANSLATE-FILE-ROOT-SOURCE-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-ROOT-NATIVE-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-ROOT-BINARY-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TRANSLATE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-JAVA NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-COMMON-LISP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-STANDALONE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-IDL NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DEFINE NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-CONS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-FINALIZE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WALK NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WINDOWS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-UNIX NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-MAC NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LETTER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-ROOT-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP-TRANSLATIONS NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-DEFINE-LOGICAL-HOST-PROPERTY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-FUNCTION NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-KEYWORD NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-GET-LOGICAL-HOST-PROPERTY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-STELLA NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-KB NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-CODE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-CPP-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-C-CODE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-C-HEADER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-OTHER NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-NONE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP-BINARY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LISP NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DIRECTORY NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-JAVAC NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-MAVEN NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-SYSTEM-UNITS-ALIST NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TWO-PASS? NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-BOOLEAN NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-FORCE-TRANSLATION? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-RECURSIVE? NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-LANGUAGE NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-ACTION NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-FILE-NAME NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-PROCESSED NULL)
(CL:DEFVAR SGT-TRANSLATE-FILE-STELLA-LIST NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-TRANSLATE-SYSTEM NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-OPTIONS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-TRANSLATE-SYSTEM NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE NULL)
(CL:DEFVAR SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *GENSYM-COUNTER* *SAFETY* TRUE-WRAPPER
  FALSE-WRAPPER *JAVA-BUILD-METHOD* NULL-CHARACTER
  *CHARACTER-TYPE-TABLE* LOGICAL-HOST-SEPARATOR NULL-INTEGER
  LOGICAL-DIRECTORY-SEPARATOR *CURRENT-STELLA-FEATURES* *CONTEXT*
  *TRANSLATIONUNITS* *TRANSLATIONPHASE* *TRANSLATOROUTPUTLANGUAGE*
  *TRANSLATIONVERBOSITYLEVEL* STANDARD-OUTPUT *MODULE* STANDARD-ERROR
  EOL STANDARD-WARNING NIL *CURRENT-SYSTEM-ACTION*
  *CURRENTSYSTEMDEFINITION*))

;;; (DEFGLOBAL *RECORD-SIGNATURES?* ...)

(CL:DEFVAR *RECORD-SIGNATURES?* CL:NIL
  "If `true', record object signatures into a persistent table.")

;;; (DEFGLOBAL *WALK-WITH-RECORDED-SIGNATURES?* ...)

(CL:DEFVAR *WALK-WITH-RECORDED-SIGNATURES?* CL:NIL
  "If `true', the walker will try to find previously recorded
signatures for referenced but undefined functions, methods, etc.")

;;; (DEFSPECIAL *USERECORDEDSIGNATURES?* ...)

(CL:DEFVAR *USERECORDEDSIGNATURES?* CL:NIL
  "If `true', `safe-lookup-slot' and `lookup-function' will
try to retrieve a previously recorded signature if normal lookup fails.")

;;; (DEFSPECIAL *DEFAULTROOTSOURCEDIRECTORY* ...)

(CL:DEFVAR *DEFAULTROOTSOURCEDIRECTORY* "ST:sources;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *DEFAULTROOTSOURCEDIRECTORY*))

;;; (DEFSPECIAL *DEFAULTROOTNATIVEDIRECTORY* ...)

(CL:DEFVAR *DEFAULTROOTNATIVEDIRECTORY* "ST:native;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *DEFAULTROOTNATIVEDIRECTORY*))

;;; (DEFSPECIAL *DEFAULTROOTBINARYDIRECTORY* ...)

(CL:DEFVAR *DEFAULTROOTBINARYDIRECTORY* "ST:bin;")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *DEFAULTROOTBINARYDIRECTORY*))

;;; (DEFSPECIAL *DEFAULTSYSTEMDEFINITIONDIRECTORIES* ...)

(CL:DEFVAR *DEFAULTSYSTEMDEFINITIONDIRECTORIES* NULL
  "Points to a list of directories containing system definition files.")

;;; (DEFUN (ROOT-SOURCE-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-SOURCE-DIRECTORY ()
  "Accessor to determine the currently active sources directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value."
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ *CURRENT-SYSTEM-ACTION* NULL))
     (CL:NOT
      (CL:EQ
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-SOURCE-DIRECTORY)
       NULL)))
    (CL:RETURN-FROM ROOT-SOURCE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%STRING-WRAPPER.WRAPPER-VALUE
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-SOURCE-DIRECTORY)))))
   ((CL:AND (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
     (CL:NOT
      (CL:EQ
       (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY
        *CURRENTSYSTEMDEFINITION*)
       STELLA::NULL-STRING)))
    (CL:RETURN-FROM ROOT-SOURCE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY
       *CURRENTSYSTEMDEFINITION*))))
   (CL:T
    (CL:RETURN-FROM ROOT-SOURCE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME *DEFAULTROOTSOURCEDIRECTORY*)))))

;;; (DEFUN (ROOT-NATIVE-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-NATIVE-DIRECTORY ()
  "Accessor to determine the currently active native directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value."
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ *CURRENT-SYSTEM-ACTION* NULL))
     (CL:NOT
      (CL:EQ
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-NATIVE-DIRECTORY)
       NULL)))
    (CL:RETURN-FROM ROOT-NATIVE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%STRING-WRAPPER.WRAPPER-VALUE
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-NATIVE-DIRECTORY)))))
   ((CL:AND (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
     (CL:NOT
      (CL:EQ
       (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY
        *CURRENTSYSTEMDEFINITION*)
       STELLA::NULL-STRING)))
    (CL:RETURN-FROM ROOT-NATIVE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY
       *CURRENTSYSTEMDEFINITION*))))
   (CL:T
    (CL:RETURN-FROM ROOT-NATIVE-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME *DEFAULTROOTNATIVEDIRECTORY*)))))

;;; (DEFUN (ROOT-BINARY-DIRECTORY FILE-NAME) ...)

(CL:DEFUN ROOT-BINARY-DIRECTORY ()
  "Accessor to determine the currently active binary directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value."
  (CL:COND
   ((CL:AND (CL:NOT (CL:EQ *CURRENT-SYSTEM-ACTION* NULL))
     (CL:NOT
      (CL:EQ
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-BINARY-DIRECTORY)
       NULL)))
    (CL:RETURN-FROM ROOT-BINARY-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%STRING-WRAPPER.WRAPPER-VALUE
       (LOOKUP *CURRENT-SYSTEM-ACTION*
        KWD-TRANSLATE-FILE-ROOT-BINARY-DIRECTORY)))))
   ((CL:AND (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
     (CL:NOT
      (CL:EQ
       (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY
        *CURRENTSYSTEMDEFINITION*)
       STELLA::NULL-STRING)))
    (CL:RETURN-FROM ROOT-BINARY-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME
      (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY
       *CURRENTSYSTEMDEFINITION*))))
   (CL:T
    (CL:RETURN-FROM ROOT-BINARY-DIRECTORY
     (TRANSLATE-LOGICAL-PATHNAME *DEFAULTROOTBINARYDIRECTORY*)))))

;;; (DEFUN (SYSTEM-DEFINITION-DIRECTORIES (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN SYSTEM-DEFINITION-DIRECTORIES ()
  (CL:LET* ((VALUE-000 NIL))
   (CL:LET*
    ((DIR NULL) (ITER-000 *DEFAULTSYSTEMDEFINITIONDIRECTORIES*)
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (WRAP-STRING
          (TRANSLATE-LOGICAL-PATHNAME
           (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
         NIL))
       (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (WRAP-STRING
          (TRANSLATE-LOGICAL-PATHNAME
           (%STRING-WRAPPER.WRAPPER-VALUE DIR)))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((VALUE-001 VALUE-000))
    (CL:RETURN-FROM SYSTEM-DEFINITION-DIRECTORIES VALUE-001))))

;;; (DEFSPECIAL *CURRENTSYSTEMDEFINITION* ...)

(CL:DEFVAR *CURRENTSYSTEMDEFINITION* NULL
  "Points to the current system.")

;;; (DEFSPECIAL *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* ...)

(CL:DEFVAR *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* ""
  "Points to a path from the root directory down
to a local directory containing sources, natives, or binaries.")
(CL:DECLAIM
 (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))

;;; (DEFUN (TOP-LEVEL-STELLA-SYSTEM-DIRECTORY? BOOLEAN) ...)

(CL:DEFUN TOP-LEVEL-STELLA-SYSTEM-DIRECTORY? (DIRECTORY)
  "Return TRUE if `directory' is a top-level STELLA installation directory
containing one or more STELLA systems.  We currently determine this solely by looking
for the existence of at least one relevant top-level native directory.  This is needed
to find system root directories and other relevant STELLA installation directories."
  (CL:LET*
   ((NATIVENAME
     (RELATIVE-UNLOGICALIZE-PATHNAME *DEFAULTROOTNATIVEDIRECTORY*))
    (SOURCENAME
     (RELATIVE-UNLOGICALIZE-PATHNAME *DEFAULTROOTSOURCEDIRECTORY*)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVENAME SOURCENAME))
   (CL:RETURN-FROM TOP-LEVEL-STELLA-SYSTEM-DIRECTORY?
    (CL:OR
     (PROBE-FILE? (CONCATENATE-FILE-NAMES DIRECTORY NATIVENAME "cpp"))
     (PROBE-FILE? (CONCATENATE-FILE-NAMES DIRECTORY NATIVENAME "java"))
     (PROBE-FILE? (CONCATENATE-FILE-NAMES DIRECTORY NATIVENAME "lisp"))
     (PROBE-FILE?
      (CONCATENATE-FILE-NAMES DIRECTORY SOURCENAME "systems"))))))

;;; (DEFUN (HANDLE-IN-MODULE-TREE BOOLEAN BOOLEAN) ...)

(CL:DEFUN HANDLE-IN-MODULE-TREE (TREE SEENINMODULE? ERRORONINMODULE?)
  (CL:LET* ((OPERATOR (%%VALUE TREE)) (FIRSTARG NULL))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
     (CL:PROGN
      (CL:LET*
       ((TEST-VALUE-000
         (CL:IF (%MODULE.CASE-SENSITIVE? *MODULE*)
          (STRING-UPCASE (%SYMBOL.SYMBOL-NAME OPERATOR))
          (%SYMBOL.SYMBOL-NAME OPERATOR))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
       (CL:COND
        ((STRING-EQL? TEST-VALUE-000 "IN-PACKAGE")
         (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
          (CL:VALUES CL:T SEENINMODULE?)))
        ((STRING-EQL? TEST-VALUE-000 "IN-MODULE")
         (CL:WHEN (CL:AND SEENINMODULE? ERRORONINMODULE?)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
             " Additional IN-MODULE declaration: `"
             (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
          (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
           (CL:VALUES CL:NIL SEENINMODULE?)))
         (CL:SETQ FIRSTARG (%%VALUE (%%REST TREE)))
         (CL:COND
          ((SUBTYPE-OF-STRING? (SAFE-PRIMARY-TYPE FIRSTARG))
           (CL:PROGN
            (CHANGE-MODULE (%STRING-WRAPPER.WRAPPER-VALUE FIRSTARG))
            (CL:SETQ SEENINMODULE? CL:T)))
          (CL:T
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
              " Ignoring illegal IN-MODULE declaration: `"
              (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))))
         (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
          (CL:VALUES CL:NIL SEENINMODULE?)))
        ((CL:OR (STRING-EQL? TEST-VALUE-000 "DEFMODULE")
          (STRING-EQL? TEST-VALUE-000 "VERBATIM")))
        (CL:T
         (CL:WHEN (CL:NOT SEENINMODULE?)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-WARNING)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
             " Missing IN-MODULE declaration, translating into module STELLA."
             EOL)))
          (CHANGE-MODULE "STELLA") (CL:SETQ SEENINMODULE? CL:T)))))))
    (CL:T))
   (CL:RETURN-FROM HANDLE-IN-MODULE-TREE
    (CL:VALUES CL:NIL SEENINMODULE?))))

;;; (DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE ...)

(CL:DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE (FILE TARGETLANGUAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TARGETLANGUAGE))
  #+MCL
  (CL:CHECK-TYPE TARGETLANGUAGE CL:SIMPLE-STRING)
  (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-TRANSLATE)
  (CL:COND ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA))
   (CL:T
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Translating `" FILE "' to `" TARGETLANGUAGE "'..." EOL))
    (TRANSLATE-ALL-UNITS)))
  (OUTPUT-ALL-UNITS-TO-FILE FILE)
  :VOID)

;;; (DEFUN OPERATE-ON-FILE ...)

(CL:DEFUN OPERATE-ON-FILE (FILE OPERATION)
  (CL:LET*
   ((TARGETLANGUAGE (%KEYWORD.SYMBOL-NAME *TRANSLATOROUTPUTLANGUAGE*))
    (CURRENTMODULE *MODULE*) (CURRENTCONTEXT *CONTEXT*)
    (SEENINMODULE? CL:NIL) (SKIP? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TARGETLANGUAGE))
   (CL:SETQ FILE (TRANSLATE-LOGICAL-PATHNAME FILE))
   (CL:WHEN (CL:EQ OPERATION NULL)
    (CL:SETQ OPERATION KWD-TRANSLATE-FILE-TRANSLATE))
   (CL:LET*
    ((*TRANSLATIONPHASE* NULL) (*TRANSLATIONERRORS* 0)
     (*TRANSLATIONWARNINGS* 0) (*TRANSLATIONNOTES* 0)
     (*CURRENTFILENAME* (FILE-BASE-NAME FILE)) (*MODULE* CURRENTMODULE)
     (*CONTEXT* CURRENTCONTEXT))
    (CL:DECLARE
     (CL:SPECIAL *TRANSLATIONPHASE* *TRANSLATIONERRORS*
      *TRANSLATIONWARNINGS* *TRANSLATIONNOTES* *CURRENTFILENAME*
      *MODULE* *CONTEXT*))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
      *TRANSLATIONNOTES*)
     (CL:TYPE CL:SIMPLE-STRING *CURRENTFILENAME*))
    (CL:COND
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
      (CL:SETQ TARGETLANGUAGE "Common Lisp"))
     ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
       (CL:EQ *TRANSLATOROUTPUTLANGUAGE*
        KWD-TRANSLATE-FILE-CPP-STANDALONE))
      (CL:SETQ TARGETLANGUAGE "C++"))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-IDL)
      (CL:SETQ TARGETLANGUAGE "IDL"))
     ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
      (CL:SETQ TARGETLANGUAGE "Java"))
     (CL:T))
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Processing `" FILE "':" EOL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "*** Pass 1, generating objects..." EOL))
    (CL:LET* ((*TRANSIENTOBJECTS?* CL:T))
     (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
     (CL:LET*
      ((TREE NULL)
       (ITER-000 (S-EXPRESSIONS (NEW-INPUT-FILE-STREAM FILE))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
       (CL:LET* ((*TRANSIENTOBJECTS?* CL:NIL))
        (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE TREE)
           SGT-TRANSLATE-FILE-STELLA-CONS)
          (CL:PROGN
           (CL:MULTIPLE-VALUE-SETQ (SKIP? SEENINMODULE?)
            (HANDLE-IN-MODULE-TREE TREE SEENINMODULE? CL:T))
           (CL:WHEN (CL:NOT SKIP?)
            (CL:LET* ((*TRANSLATIONPHASE* KWD-TRANSLATE-FILE-DEFINE))
             (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
             (WALK-TOP-LEVEL-TREE TREE CL:T)))))
         (CL:T))))))
    (REVERSE *TRANSLATIONUNITS*)
    (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-DEFINE))
     (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "*** Pass 2, finalizing objects..." EOL))
     (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-FINALIZE)
     (FINALIZE-CLASSES-AND-SLOTS)
     (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-FINALIZE))
      (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "*** Pass 3, walking objects..." EOL))
      (CL:SETQ *TRANSLATIONPHASE* KWD-TRANSLATE-FILE-WALK)
      (CL:WHEN
       (CL:NOT
        (CL:OR (USE-HARDCODED-SYMBOLS?)
         (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)))
       (CLEAR-SYMBOL-REGISTRY))
      (CL:LET*
       ((*USERECORDEDSIGNATURES?* *WALK-WITH-RECORDED-SIGNATURES?*))
       (CL:DECLARE (CL:SPECIAL *USERECORDEDSIGNATURES?*))
       (WALK-ALL-PHASE-ONE-UNITS))
      (CL:WHEN (CL:NOT (CL:EQ OPERATION KWD-TRANSLATE-FILE-WALK))
       (TRANSLATE-AND-OUTPUT-UNITS-TO-FILE FILE TARGETLANGUAGE))
      (CL:WHEN *RECORD-SIGNATURES?*
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Recording object signatures..." EOL)
       (RECORD-SIGNATURES-OF-ALL-UNITS FILE))))
    (SUMMARIZE-TRANSLATION-ERRORS)))
  :VOID)

;;; (DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ...)

(CL:DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ()
  (CL:LET*
   ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ UNIT (%%VALUE ITER-000)) (FREE UNIT)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CLEAR *TRANSLATIONUNITS*)
  (SWEEP-TRANSIENTS)
  :VOID)

;;; (DEFUN TRANSLATE-FILE ...)

(CL:DEFUN TRANSLATE-FILE (FILE OUTPUTLANGUAGE ASPARTOFSYSTEM?)
  (CL:LET* ((MODE KWD-TRANSLATE-FILE-TRANSLATE))
   (CL:LET*
    ((*JAVA-INDENT-CHARS* 0) (*IDL-INDENT-CHARS* 0)
     (*CPP-INDENT-CHARS* 0))
    (CL:DECLARE
     (CL:SPECIAL *JAVA-INDENT-CHARS* *IDL-INDENT-CHARS*
      *CPP-INDENT-CHARS*))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM *JAVA-INDENT-CHARS* *IDL-INDENT-CHARS*
      *CPP-INDENT-CHARS*))
    (CL:COND
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)
      (CL:WHEN ASPARTOFSYSTEM? (CL:SETQ MODE KWD-TRANSLATE-FILE-WALK)))
     (CL:T))
    (CL:IF ASPARTOFSYSTEM? (OPERATE-ON-FILE FILE MODE)
     (CL:LET*
      ((*TRANSLATOROUTPUTLANGUAGE* *TRANSLATOROUTPUTLANGUAGE*)
       (*TRANSLATIONUNITS* (NEW-LIST)))
      (CL:DECLARE
       (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE* *TRANSLATIONUNITS*))
      (%SET-TRANSLATOR-OUTPUT-LANGUAGE OUTPUTLANGUAGE)
      (OPERATE-ON-FILE FILE MODE)
      (CL:COND
       ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-CPP-STANDALONE))
       (CL:T (CLEAN-UP-TRANSLATION-UNITS-SPECIAL)))))))
  :VOID)

;;; (DEFUN OUTPUT-ALL-UNITS-TO-FILE ...)

(CL:DEFUN OUTPUT-ALL-UNITS-TO-FILE (SOURCEFILE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
    (CL:LET* ((*JAVA-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *JAVA-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *JAVA-INDENT-CHARS*))
     (JAVA-OUTPUT-ALL-UNITS-TO-FILE)))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-IDL)
    (CL:LET* ((*IDL-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *IDL-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *IDL-INDENT-CHARS*))
     (IDL-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE)))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE*
      KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (CL:LET* ((*CPP-INDENT-CHARS* 0))
     (CL:DECLARE (CL:SPECIAL *CPP-INDENT-CHARS*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *CPP-INDENT-CHARS*))
     (CPP-OUTPUT-ALL-UNITS-TO-FILE SOURCEFILE)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN RECORD-SIGNATURES-OF-ALL-UNITS ...)

(CL:DEFUN RECORD-SIGNATURES-OF-ALL-UNITS (SOURCEFILE)
  (CL:SETQ SOURCEFILE SOURCEFILE)
  :VOID)

;;; (DEFUN (TRANSLATE-WITH-COPYRIGHT-HEADER? BOOLEAN) ...)

(CL:DEFUN TRANSLATE-WITH-COPYRIGHT-HEADER? ()
  (CL:RETURN-FROM TRANSLATE-WITH-COPYRIGHT-HEADER?
   (MEMB? *CURRENT-STELLA-FEATURES*
    KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER)))

;;; (DEFUN OUTPUT-COPYRIGHT-HEADER ...)

(CL:DEFUN OUTPUT-COPYRIGHT-HEADER (STREAM)
  (CL:WHEN
   (CL:OR (CL:NOT (TRANSLATE-WITH-COPYRIGHT-HEADER?))
    (CL:EQ *CURRENTSYSTEMDEFINITION* NULL)
    (CL:EQ (%SYSTEM-DEFINITION.BANNER *CURRENTSYSTEMDEFINITION*)
     STELLA::NULL-STRING))
   (CL:RETURN-FROM OUTPUT-COPYRIGHT-HEADER))
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "#|" EOL))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE*
      KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "/*" EOL))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:LET*
   ((SUBSTITUTION-LIST (NEW-KEY-VALUE-LIST))
    (BSTREAM
     (MAKE-TOKENIZER-STRING-STREAM
      (%SYSTEM-DEFINITION.BANNER *CURRENTSYSTEMDEFINITION*))))
   (FILL-IN-DATE-SUBSTITUTION SUBSTITUTION-LIST)
   (SUBSTITUTE-TEMPLATE-VARIABLES-TO-STREAM BSTREAM STREAM
    SUBSTITUTION-LIST))
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "|#"))
   ((CL:OR (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
     (CL:EQ *TRANSLATOROUTPUTLANGUAGE*
      KWD-TRANSLATE-FILE-CPP-STANDALONE))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "*/"))
   (CL:T
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
      "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) EOL EOL)
  :VOID)

;;; (DEFUN OUTPUT-FILE-HEADER ...)

(CL:DEFUN OUTPUT-FILE-HEADER (STREAM FILE)
  (CL:COND
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL-OUTPUT-FILE-HEADER STREAM FILE CL:T))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)
    (JAVA-OUTPUT-FILE-HEADER STREAM FILE))
   ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-CPP)
    (CPP-OUTPUT-FILE-HEADER STREAM FILE))
   (CL:T (CL-OUTPUT-FILE-HEADER STREAM FILE CL:NIL)))
  :VOID)

;;; (DEFGLOBAL *OS* ...)

(CL:DEFVAR *OS* NULL
  "The operating system we are running on.  Currently,
either :UNIX, :WINDOWS, or :MAC.  Note that on the Mac OS X, the
OS can be either :UNIX or :MAC, depending on which file naming 
conventions are being observed by the software.")

;;; (DEFUN (OPERATING-SYSTEM KEYWORD) ...)

(CL:DEFUN OPERATING-SYSTEM ()
  (CL:COND
   ((CL:OR (PROBE-FILE? "C:\\AUTOEXEC.BAT") (PROBE-FILE? "C:\\IO.SYS")
     (PROBE-FILE? "C:\\BOOT.INI") (STARTS-WITH? "" "win" 0))
    (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-WINDOWS))
   ((CL:MEMBER :UNIX CL:*FEATURES*)
    (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-UNIX))
   (CL:T (CL:RETURN-FROM OPERATING-SYSTEM KWD-TRANSLATE-FILE-MAC))))

;;; (DEFUN (DIRECTORY-SEPARATOR CHARACTER) ...)

(CL:DEFUN DIRECTORY-SEPARATOR ()
  (CL:LET* ((SEPARATOR #\?))
   (CL:LET ((NAME (CL:NAMESTRING (CL:MAKE-PATHNAME :DIRECTORY '(:ABSOLUTE "foo")))))
                        (CL:SETQ SEPARATOR (CL:CHAR NAME (CL:1- (CL:LENGTH NAME)))))
   (CL:RETURN-FROM DIRECTORY-SEPARATOR SEPARATOR)))

;;; (DEFUN (DIRECTORY-SEPARATOR-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING)
  DIRECTORY-SEPARATOR-STRING))
(CL:DEFUN DIRECTORY-SEPARATOR-STRING ()
  (CL:RETURN-FROM DIRECTORY-SEPARATOR-STRING
   (MAKE-STRING 1 (DIRECTORY-SEPARATOR))))

;;; (DEFUN (DIRECTORY-SEPARATOR-FOR-FILE CHARACTER) ...)

(CL:DEFUN DIRECTORY-SEPARATOR-FOR-FILE (FILE)
  (CL:IF (LOGICAL-PATHNAME? FILE)
   (CL:RETURN-FROM DIRECTORY-SEPARATOR-FOR-FILE
    LOGICAL-DIRECTORY-SEPARATOR)
   (CL:RETURN-FROM DIRECTORY-SEPARATOR-FOR-FILE (DIRECTORY-SEPARATOR))))

;;; (DEFCONSTANT TYPE-SEPARATOR ...)

(CL:DEFVAR TYPE-SEPARATOR #\.)

;;; (DEFUN (FILE-NAME-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-DIRECTORY (FILE)
  "Return the directory component of `file' including the final
directory separator or the empty string if `file' does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of `file'"
  (CL:LET*
   ((START 0) (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH FILE)))
    (SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START LENGTH))
   (CL:WHEN (LOGICAL-PATHNAME? FILE)
    (CL:SETQ START (CL:1+ (POSITION FILE LOGICAL-HOST-SEPARATOR 0))))
   (CL:LOOP WHILE
    (CL:AND (CL:< START LENGTH)
     (CL:NOT (CL:= (POSITION FILE SEPARATOR START) NULL-INTEGER)))
    DO (CL:SETQ START (CL:1+ (POSITION FILE SEPARATOR START))))
   (CL:RETURN-FROM FILE-NAME-DIRECTORY (SUBSEQUENCE FILE 0 START))))

;;; (DEFUN (DIRECTORY-FILE-NAME FILE-NAME) ...)

(CL:DEFUN DIRECTORY-FILE-NAME (DIRECTORY)
  "Return `directory' as a file name, i.e., without a terminating
directory separator."
  (CL:LET*
   ((SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE DIRECTORY))
    (LAST (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH DIRECTORY)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LAST))
   (CL:IF
    (CL:AND (CL:>= LAST 0)
     (CL:EQL
      (CL:LET ((SELF DIRECTORY) (POSITION LAST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR))
    (CL:RETURN-FROM DIRECTORY-FILE-NAME (SUBSEQUENCE DIRECTORY 0 LAST))
    (CL:RETURN-FROM DIRECTORY-FILE-NAME DIRECTORY))))

;;; (DEFUN (FILE-NAME-AS-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-AS-DIRECTORY (FILE)
  "Return `file' interpreted as a directory, i.e., with a
terminating directory separator.  If `file' is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory."
  (CL:LET*
   ((SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE))
    (LAST (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH FILE)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LAST))
   (CL:IF
    (CL:OR (CL:< LAST 0)
     (CL:EQL
      (CL:LET ((SELF FILE) (POSITION LAST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR))
    (CL:RETURN-FROM FILE-NAME-AS-DIRECTORY FILE)
    (CL:RETURN-FROM FILE-NAME-AS-DIRECTORY
     (CONCATENATE FILE (MAKE-STRING 1 SEPARATOR))))))

;;; (DEFUN (DIRECTORY-PARENT-DIRECTORY FILE-NAME) ...)

(CL:DEFUN DIRECTORY-PARENT-DIRECTORY (DIRECTORY LEVEL)
  "Return the `level'-th parent directory component of `directory'
including the final directory separator, or the empty string if `directory' does
not have that many parents."
  (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL))
  #+MCL
  (CL:CHECK-TYPE LEVEL CL:FIXNUM)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 LEVEL)
    (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I)
    (CL:SETQ DIRECTORY
     (FILE-NAME-DIRECTORY (DIRECTORY-FILE-NAME DIRECTORY)))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (CL:RETURN-FROM DIRECTORY-PARENT-DIRECTORY DIRECTORY))

;;; (DEFUN (FILE-NAME-WITHOUT-DEVICE FILE-NAME) ...)

(CL:DEFUN FILE-NAME-WITHOUT-DEVICE (FILE)
  "Return the file name portion of `file' by removing any
physical device components.  This is just like `logical-pathname-without-host'
but only looks for one-character device strings as used in Windows."
  (CL:LET* ((SEPARATOR #\:))
   (CL:IF
    (CL:AND (CL:>= (CL:THE CL:FIXNUM (CL:LENGTH FILE)) 2)
     (CL:EQL
      (CL:LET ((SELF FILE) (POSITION 1))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR)
     (CL:EQ
      (CL:AREF *CHARACTER-TYPE-TABLE*
       (CL:THE CL:FIXNUM
        (CL:CHAR-CODE
         (CL:LET ((SELF FILE) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))))
      KWD-TRANSLATE-FILE-LETTER))
    (CL:RETURN-FROM FILE-NAME-WITHOUT-DEVICE
     (SUBSEQUENCE FILE 2 NULL-INTEGER))
    (CL:RETURN-FROM FILE-NAME-WITHOUT-DEVICE FILE))))

;;; (DEFUN (FILE-NAME-WITHOUT-DIRECTORY FILE-NAME) ...)

(CL:DEFUN FILE-NAME-WITHOUT-DIRECTORY (FILE)
  "Return the file name portion of `file' by removing any
directory and logical host components."
  (CL:LET* ((START 0) (SEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE FILE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START))
   (CL:IF (CL:EQL SEPARATOR LOGICAL-HOST-SEPARATOR)
    (CL:SETQ FILE (LOGICAL-PATHNAME-WITHOUT-HOST FILE))
    (CL:SETQ FILE (FILE-NAME-WITHOUT-DEVICE FILE)))
   (CL:LOOP WHILE
    (CL:NOT (CL:= (POSITION FILE SEPARATOR START) NULL-INTEGER)) DO
    (CL:SETQ START (CL:1+ (POSITION FILE SEPARATOR START))))
   (CL:RETURN-FROM FILE-NAME-WITHOUT-DIRECTORY
    (SUBSEQUENCE FILE START NULL-INTEGER))))

;;; (DEFUN (FILE-NAME-WITHOUT-EXTENSION FILE-NAME) ...)

(CL:DEFUN FILE-NAME-WITHOUT-EXTENSION (FILE)
  "Remove `file's extension (or type) if there is any and
return the result."
  (CL:LET* ((START 0) (END NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
   (CL:LOOP WHILE
    (CL:NOT (CL:= (POSITION FILE TYPE-SEPARATOR START) NULL-INTEGER))
    DO (CL:SETQ END (POSITION FILE TYPE-SEPARATOR START))
    (CL:SETQ START (CL:1+ END)))
   (CL:RETURN-FROM FILE-NAME-WITHOUT-EXTENSION
    (SUBSEQUENCE FILE 0 END))))

;;; (DEFUN (FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) FILE-EXTENSION))
(CL:DEFUN FILE-EXTENSION (FILE)
  "Return `file's extension (or type) if it has any including
the separator character."
  (CL:LET* ((START 0) (END NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
   (CL:LOOP WHILE
    (CL:NOT (CL:= (POSITION FILE TYPE-SEPARATOR START) NULL-INTEGER))
    DO (CL:SETQ END (POSITION FILE TYPE-SEPARATOR START))
    (CL:SETQ START (CL:1+ END)))
   (CL:COND
    ((CL:= END NULL-INTEGER)
     (CL:RETURN-FROM FILE-EXTENSION STELLA::NULL-STRING))
    ((CL:NOT
      (CL:= (POSITION FILE (DIRECTORY-SEPARATOR-FOR-FILE FILE) END)
       NULL-INTEGER))
     (CL:RETURN-FROM FILE-EXTENSION STELLA::NULL-STRING))
    (CL:T
     (CL:RETURN-FROM FILE-EXTENSION
      (SUBSEQUENCE FILE END NULL-INTEGER))))))

;;; (DEFUN (FILE-BASE-NAME FILE-NAME) ...)

(CL:DEFUN FILE-BASE-NAME (FILE)
  "Remove `file's directory (including logical host) and
extension components and return the result."
  (CL:RETURN-FROM FILE-BASE-NAME
   (FILE-NAME-WITHOUT-EXTENSION (FILE-NAME-WITHOUT-DIRECTORY FILE))))

;;; (DEFCONSTANT LOGICAL-DIRECTORY-SEPARATOR ...)

(CL:DEFVAR LOGICAL-DIRECTORY-SEPARATOR #\;)

;;; (DEFCONSTANT LOGICAL-HOST-SEPARATOR ...)

(CL:DEFVAR LOGICAL-HOST-SEPARATOR #\:)

;;; (DEFGLOBAL *LOGICAL-HOST-TABLE* ...)

(CL:DEFVAR *LOGICAL-HOST-TABLE* NULL)

;;; (DEFUN DEFINE-LOGICAL-HOST-PROPERTY ...)

(CL:DEFUN %DEFINE-LOGICAL-HOST-PROPERTY (HOST PROPERTY VALUE)
  "Define `property' with `value' for the logical host `host'.
As a side-effect, this also defines `host' as a logical host (both
`property' and `value' can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with `host' are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of `(CL:logical-pathname-translations host)' if we are
running in Lisp, which allows us to depend on the native
`CL:translate-logical-pathname' for more complex translation operations."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:SETQ HOST (STRING-UPCASE HOST))
  (CL:LET* ((PROPERTIES (LOOKUP *LOGICAL-HOST-TABLE* HOST)))
   (CL:WHEN (CL:EQ PROPERTIES NULL)
    (CL:SETQ PROPERTIES (NEW-KEY-VALUE-LIST))
    (INSERT-AT *LOGICAL-HOST-TABLE* HOST PROPERTIES))
   (CL:WHEN (CL:NOT (CL:EQ PROPERTY NULL))
    (CL:COND
     ((CL:EQ PROPERTY KWD-TRANSLATE-FILE-ROOT-DIRECTORY)
      (INSERT-AT PROPERTIES PROPERTY NULL)
      (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
       (INSERT-AT PROPERTIES PROPERTY
        (WRAP-STRING
         (TRANSLATE-LOGICAL-PATHNAME
          (FILE-NAME-AS-DIRECTORY
           (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))))))
     ((CL:EQ PROPERTY KWD-TRANSLATE-FILE-LISP-TRANSLATIONS)
      (INSERT-AT PROPERTIES PROPERTY VALUE))
     (CL:T (CL:WARN "Illegal host property: `~A'" PROPERTY)))))
  :VOID)

(CL:DEFUN DEFINE-LOGICAL-HOST-PROPERTY-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFINE-LOGICAL-HOST-PROPERTY
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%%VALUE (%%REST ARGUMENTS)) (%%VALUE (%%REST (%%REST ARGUMENTS))))
  :VOID)

(CL:DEFMACRO DEFINE-LOGICAL-HOST-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define `property' with `value' for the logical host `host'.
As a side-effect, this also defines `host' as a logical host (both
`property' and `value' can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with `host' are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of `(CL:logical-pathname-translations host)' if we are
running in Lisp, which allows us to depend on the native
`CL:translate-logical-pathname' for more complex translation operations."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DEFINE-LOGICAL-HOST-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFINE-LOGICAL-HOST-PROPERTY)))

;;; (DEFUN (LOOKUP-LOGICAL-HOST-PROPERTY OBJECT) ...)

(CL:DEFUN LOOKUP-LOGICAL-HOST-PROPERTY (HOST PROPERTY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:SETQ HOST (STRING-UPCASE HOST))
  (CL:LET* ((PROPERTIES (LOOKUP *LOGICAL-HOST-TABLE* HOST)))
   (CL:IF (CL:EQ PROPERTIES NULL)
    (CL:RETURN-FROM LOOKUP-LOGICAL-HOST-PROPERTY NULL)
    (CL:RETURN-FROM LOOKUP-LOGICAL-HOST-PROPERTY
     (LOOKUP PROPERTIES PROPERTY)))))

;;; (DEFUN (GET-LOGICAL-HOST-PROPERTY OBJECT) ...)

(CL:DEFUN %GET-LOGICAL-HOST-PROPERTY (HOST PROPERTY)
  "Lookup the value of `property' for the logical host `host'."
  (CL:RETURN-FROM %GET-LOGICAL-HOST-PROPERTY
   (LOOKUP-LOGICAL-HOST-PROPERTY (COERCE-VALUE-TO-STRING HOST CL:T)
    (COERCE-VALUE-TO-TYPE PROPERTY SGT-TRANSLATE-FILE-STELLA-KEYWORD
     CL:T))))

(CL:DEFMACRO GET-LOGICAL-HOST-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Lookup the value of `property' for the logical host `host'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/GET-LOGICAL-HOST-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE GET-LOGICAL-HOST-PROPERTY)))

;;; (DEFUN (LOGICAL-HOST? BOOLEAN) ...)

(CL:DEFUN LOGICAL-HOST? (HOST)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOGICAL-HOST?
   (CL:NOT
    (CL:EQ (LOOKUP *LOGICAL-HOST-TABLE* (STRING-UPCASE HOST)) NULL))))

;;; (DEFUN (LOGICAL-PATHNAME? BOOLEAN) ...)

(CL:DEFUN LOGICAL-PATHNAME? (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((HOST (GET-LOGICAL-HOST-NAME PATHNAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST))
   (CL:RETURN-FROM LOGICAL-PATHNAME?
    (CL:AND (CL:NOT (CL:EQ HOST STELLA::NULL-STRING))
     (LOGICAL-HOST? HOST)))))

;;; (DEFUN (ABSOLUTE-PATHNAME? BOOLEAN) ...)

(CL:DEFUN ABSOLUTE-PATHNAME? (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((SEPARATOR (DIRECTORY-SEPARATOR)))
   (CL:COND
    ((LOGICAL-PATHNAME? PATHNAME)
     (CL:SETQ SEPARATOR LOGICAL-DIRECTORY-SEPARATOR)
     (CL:SETQ PATHNAME (LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME)))
    (CL:T (CL:SETQ PATHNAME (FILE-NAME-WITHOUT-DEVICE PATHNAME))))
   (CL:RETURN-FROM ABSOLUTE-PATHNAME?
    (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH PATHNAME)) 0)
     (CL:EQL
      (CL:LET ((SELF PATHNAME) (POSITION 0))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      SEPARATOR)))))

;;; (DEFUN (GET-LOGICAL-HOST-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  GET-LOGICAL-HOST-NAME))
(CL:DEFUN GET-LOGICAL-HOST-NAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((SEPARATORPOS (POSITION PATHNAME LOGICAL-HOST-SEPARATOR 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
   (CL:IF
    (CL:AND (CL:NOT (CL:= SEPARATORPOS NULL-INTEGER))
     (CL:>= SEPARATORPOS 1))
    (CL:RETURN-FROM GET-LOGICAL-HOST-NAME
     (SUBSEQUENCE PATHNAME 0 SEPARATORPOS))
    (CL:RETURN-FROM GET-LOGICAL-HOST-NAME STELLA::NULL-STRING))))

;;; (DEFUN (LOGICAL-PATHNAME-WITHOUT-HOST STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  LOGICAL-PATHNAME-WITHOUT-HOST))
(CL:DEFUN LOGICAL-PATHNAME-WITHOUT-HOST (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:LET* ((HOSTNAME (GET-LOGICAL-HOST-NAME PATHNAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOSTNAME))
   (CL:IF (CL:EQ HOSTNAME STELLA::NULL-STRING)
    (CL:RETURN-FROM LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME)
    (CL:RETURN-FROM LOGICAL-PATHNAME-WITHOUT-HOST
     (SUBSEQUENCE PATHNAME
      (CL:1+ (CL:THE CL:FIXNUM (CL:LENGTH HOSTNAME))) NULL-INTEGER)))))

;;; (DEFUN (TRANSLATE-LOGICAL-PATHNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  TRANSLATE-LOGICAL-PATHNAME))
(CL:DEFUN TRANSLATE-LOGICAL-PATHNAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (LOGICAL-PATHNAME? PATHNAME))
   (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME PATHNAME))
  (CL:LET*
   ((HOST (GET-LOGICAL-HOST-NAME PATHNAME))
    (TRANSLATEDPATHNAME PATHNAME))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST TRANSLATEDPATHNAME))
   (CL:LET*
    ((TRANSLATIONS
      (LOOKUP-LOGICAL-HOST-PROPERTY HOST
       KWD-TRANSLATE-FILE-LISP-TRANSLATIONS))
     (LTRANSLATIONS
      (CL:IGNORE-ERRORS (CL:LOGICAL-PATHNAME-TRANSLATIONS HOST))))
    (CL:WHEN
     (CL:OR (CL:NOT (CL:EQ TRANSLATIONS NULL))
      (CL:NOT (CL:EQ LTRANSLATIONS NIL)))
     (CL:progn
              (CL:unless ltranslations
                (CL:setf (CL:logical-pathname-translations host)
                  (lispify translations)))
              (setq translatedPathname
                (CL:namestring (%%translate-logical-pathname pathName))))
     (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME TRANSLATEDPATHNAME)))
   (CL:SETQ TRANSLATEDPATHNAME
    (SUBSTITUTE (LOGICAL-PATHNAME-WITHOUT-HOST PATHNAME)
     (DIRECTORY-SEPARATOR) LOGICAL-DIRECTORY-SEPARATOR))
   (CL:LET*
    ((ROOTDIRECTORY
      (LOOKUP-LOGICAL-HOST-PROPERTY HOST
       KWD-TRANSLATE-FILE-ROOT-DIRECTORY)))
    (CL:WHEN (CL:NOT (CL:EQ ROOTDIRECTORY NULL))
     (CL:WHEN (ABSOLUTE-PATHNAME? TRANSLATEDPATHNAME)
      (CL:SETQ TRANSLATEDPATHNAME
       (SUBSEQUENCE TRANSLATEDPATHNAME 1 NULL-INTEGER)))
     (CL:SETQ TRANSLATEDPATHNAME
      (CONCATENATE (%STRING-WRAPPER.WRAPPER-VALUE ROOTDIRECTORY)
       TRANSLATEDPATHNAME))))
   (CL:RETURN-FROM TRANSLATE-LOGICAL-PATHNAME TRANSLATEDPATHNAME)))

;;; (DEFUN (UNLOGICALIZE-PATHNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  UNLOGICALIZE-PATHNAME))
(CL:DEFUN UNLOGICALIZE-PATHNAME (PATHNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM UNLOGICALIZE-PATHNAME
   (TRANSLATE-LOGICAL-PATHNAME PATHNAME)))

;;; (DEFUN (RELATIVE-UNLOGICALIZE-PATHNAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  RELATIVE-UNLOGICALIZE-PATHNAME))
(CL:DEFUN RELATIVE-UNLOGICALIZE-PATHNAME (PATHNAME)
  "If `pathName' is a logical pathname translate it, however, remove the
:root-directory prefix of the logical host.  Otherwise, return `pathName' as is."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
  #+MCL
  (CL:CHECK-TYPE PATHNAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (LOGICAL-PATHNAME? PATHNAME))
   (CL:RETURN-FROM RELATIVE-UNLOGICALIZE-PATHNAME PATHNAME))
  (CL:LET*
   ((HOST (GET-LOGICAL-HOST-NAME PATHNAME))
    (ROOTPREFIX (TRANSLATE-LOGICAL-PATHNAME (CONCATENATE HOST ":"))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST ROOTPREFIX))
   (CL:RETURN-FROM RELATIVE-UNLOGICALIZE-PATHNAME
    (SUBSEQUENCE (TRANSLATE-LOGICAL-PATHNAME PATHNAME)
     (CL:THE CL:FIXNUM (CL:LENGTH ROOTPREFIX)) NULL-INTEGER))))

;;; (DEFUN (MERGE-FILE-NAMES FILE-NAME) ...)

(CL:DEFUN MERGE-FILE-NAMES (BASEFILE DEFAULTS)
  "Parse `baseFile', supply any missing components from
`defaults' if supplied and return the result."
  (CL:LET*
   ((BASESEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE BASEFILE))
    (BASEHOST (GET-LOGICAL-HOST-NAME BASEFILE))
    (BASEDIRECTORY
     (LOGICAL-PATHNAME-WITHOUT-HOST (FILE-NAME-DIRECTORY BASEFILE)))
    (BASENAME (FILE-BASE-NAME BASEFILE))
    (BASEEXTENSION (FILE-EXTENSION BASEFILE))
    (DEFAULTSSEPARATOR (DIRECTORY-SEPARATOR-FOR-FILE DEFAULTS))
    (MERGED? CL:NIL) (RESULT NULL))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING BASEHOST BASEDIRECTORY BASEEXTENSION))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQL BASESEPARATOR DEFAULTSSEPARATOR))
     (MEMBER? BASEFILE BASESEPARATOR)
     (MEMBER? DEFAULTS DEFAULTSSEPARATOR))
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "merge-file-names: base file and defaults use different syntax")))
   (CL:WHEN (CL:EQ BASEHOST STELLA::NULL-STRING)
    (CL:SETQ BASEHOST (GET-LOGICAL-HOST-NAME DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (CL:EQ BASEHOST STELLA::NULL-STRING)))))
   (CL:WHEN (STRING-EQL? BASEDIRECTORY "")
    (CL:SETQ BASEDIRECTORY
     (LOGICAL-PATHNAME-WITHOUT-HOST (FILE-NAME-DIRECTORY DEFAULTS)))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (STRING-EQL? BASEDIRECTORY "")))))
   (CL:WHEN (CL:EQ BASENAME STELLA::NULL-STRING)
    (CL:SETQ BASENAME (FILE-BASE-NAME DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED? (CL:NOT (CL:EQ BASENAME STELLA::NULL-STRING)))))
   (CL:WHEN (CL:EQ BASEEXTENSION STELLA::NULL-STRING)
    (CL:SETQ BASEEXTENSION (FILE-EXTENSION DEFAULTS))
    (CL:SETQ MERGED?
     (CL:OR MERGED?
      (CL:NOT (CL:EQ BASEEXTENSION STELLA::NULL-STRING)))))
   (CL:WHEN (CL:NOT MERGED?)
    (CL:RETURN-FROM MERGE-FILE-NAMES BASEFILE))
   (CL:SETQ RESULT (NEW-OUTPUT-STRING-STREAM))
   (CL:WHEN (CL:NOT (CL:EQ BASEHOST STELLA::NULL-STRING))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM RESULT)
     BASEHOST LOGICAL-HOST-SEPARATOR))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM RESULT)
    BASEDIRECTORY)
   (CL:WHEN (CL:NOT (CL:EQ BASENAME STELLA::NULL-STRING))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM RESULT)
     BASENAME))
   (CL:WHEN (CL:NOT (CL:EQ BASEEXTENSION STELLA::NULL-STRING))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM RESULT)
     BASEEXTENSION))
   (CL:RETURN-FROM MERGE-FILE-NAMES (THE-STRING-READER RESULT))))

;;; (DEFUN (CONCATENATE-FILE-NAMES FILE-NAME) ...)

(CL:DEFUN CONCATENATE-FILE-NAMES (FILE CL:&REST OTHERFILES)
  "Intelligently join `file' and `otherFiles' into a concatenated path where each
component is separated by a single separator (similar to Python's os.path.join).  Keeps the result
a logical pathname as long as possible, but converts to physical as soon as any of `otherFiles'
contain a physical directory separator."
  (CL:LET* ((SEPARATOR (DIRECTORY-SEPARATOR)))
   (CL:LET* ((OTHERFILE STELLA::NULL-STRING) (ITER-000 OTHERFILES))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ OTHERFILE (CL:POP ITER-000))
     (CL:COND ((ABSOLUTE-PATHNAME? OTHERFILE) (CL:SETQ FILE OTHERFILE))
      (CL:T
       (CL:WHEN
        (CL:AND (DEFINED? SEPARATOR) (MEMBER? OTHERFILE SEPARATOR))
        (CL:SETQ FILE (TRANSLATE-LOGICAL-PATHNAME FILE))
        (CL:SETQ SEPARATOR NULL-CHARACTER))
       (CL:SETQ FILE
        (CONCATENATE (FILE-NAME-AS-DIRECTORY FILE) OTHERFILE))))))
   (CL:RETURN-FROM CONCATENATE-FILE-NAMES FILE)))

;;; (DEFGLOBAL *TYPE-TO-FILE-EXTENSION-TABLE* ...)

(CL:DEFVAR *TYPE-TO-FILE-EXTENSION-TABLE* NULL
  "Used by `select-file-extension'.")

;;; (DEFUN (COMPUTE-COMMON-LISP-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  COMPUTE-COMMON-LISP-FILE-EXTENSION))
(CL:DEFUN COMPUTE-COMMON-LISP-FILE-EXTENSION (TYPE)
  (CL:WHEN (CL:NOT (RUNNING-AS-LISP?))
   (CL:ERROR
    (NEW-STELLA-EXCEPTION
     "Shouldn't call COMPUTE-COMMON-LISP-FILE-EXTENSION unless running in Lisp")))
  (CL:LET* ((SUFFIX STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUFFIX))
   (CL:COND
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
     (CL:SETQ SUFFIX
      (cl:pathname-type (cl:compile-file-pathname "foo.lisp")))
     (CL:COND
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS)
       (CL:SETQ SUFFIX (CONCATENATE "s" SUFFIX)))
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:SETQ SUFFIX (CONCATENATE "vs" SUFFIX)))
      (CL:T)))
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
     (CL:COND
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS)
       (CL:SETQ SUFFIX ".slisp"))
      ((MEMB? *CURRENT-STELLA-FEATURES*
        KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS)
       (CL:SETQ SUFFIX ".vslisp"))
      (CL:T (CL:SETQ SUFFIX ".lisp")))
     (cl:let* ((lispType 
                  (CL:pathname-type (CL:concatenate 'CL:string "dummy" suffix)))
                 (dummyPath
                  (CL:make-pathname :name "f" :type lispType)))
         (cl:setq suffix (CL:SUBSEQ (CL:namestring dummyPath) 2))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TYPE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM COMPUTE-COMMON-LISP-FILE-EXTENSION
    (CONCATENATE "." SUFFIX))))

;;; (DEFUN (DEFAULT-COMMON-LISP-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  DEFAULT-COMMON-LISP-FILE-EXTENSION))
(CL:DEFUN DEFAULT-COMMON-LISP-FILE-EXTENSION (TYPE)
  (CL:COND
   ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
    (CL:COND
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-WINDOWS)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".lsp"))
     (CL:T
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".lisp"))))
   ((CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
    (CL:COND
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-MAC)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".cfsl"))
     ((CL:EQ *OS* KWD-TRANSLATE-FILE-WINDOWS)
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".fas"))
     (CL:T
      (CL:RETURN-FROM DEFAULT-COMMON-LISP-FILE-EXTENSION ".fasl"))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" TYPE "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (SELECT-FILE-EXTENSION STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) SELECT-FILE-EXTENSION))
(CL:DEFUN SELECT-FILE-EXTENSION (TYPE)
  (CL:LET* ((EXTENSION STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-TO-FILE-EXTENSION-TABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%%VALUE ENTRY) TYPE)
      (CL:SETQ EXTENSION
       (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST ENTRY)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:COND
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-DIRECTORY)
     (CL:RETURN-FROM SELECT-FILE-EXTENSION
      (DIRECTORY-SEPARATOR-STRING)))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY))
     (CL:IF (RUNNING-AS-LISP?)
      (CL:RETURN-FROM SELECT-FILE-EXTENSION
       (COMPUTE-COMMON-LISP-FILE-EXTENSION TYPE))
      (CL:RETURN-FROM SELECT-FILE-EXTENSION
       (DEFAULT-COMMON-LISP-FILE-EXTENSION TYPE))))
    (CL:T))
   (CL:RETURN-FROM SELECT-FILE-EXTENSION EXTENSION)))

;;; (DEFUN (CLASSIFY-FILE-EXTENSION KEYWORD) ...)

(CL:DEFUN CLASSIFY-FILE-EXTENSION (FILE)
  (CL:LET* ((EXTENSION (FILE-EXTENSION FILE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:WHEN (CL:EQ EXTENSION STELLA::NULL-STRING)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-NONE))
   (CL:LET* ((ENTRY NULL) (ITER-000 *TYPE-TO-FILE-EXTENSION-TABLE*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (CL:WHEN (EQL-TO-STRING? (%%VALUE (%%REST ENTRY)) EXTENSION)
      (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION (%%VALUE ENTRY)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (RUNNING-AS-LISP?)
    (CL:WHEN
     (STRING-EQL?
      (COMPUTE-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP)
      EXTENSION)
     (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP))
    (CL:WHEN
     (STRING-EQL?
      (COMPUTE-COMMON-LISP-FILE-EXTENSION
       KWD-TRANSLATE-FILE-LISP-BINARY)
      EXTENSION)
     (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION
      KWD-TRANSLATE-FILE-LISP-BINARY)))
   (CL:WHEN
    (STRING-EQL?
     (DEFAULT-COMMON-LISP-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP)
     EXTENSION)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-LISP))
   (CL:WHEN
    (STRING-EQL?
     (DEFAULT-COMMON-LISP-FILE-EXTENSION
      KWD-TRANSLATE-FILE-LISP-BINARY)
     EXTENSION)
    (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION
     KWD-TRANSLATE-FILE-LISP-BINARY))
   (CL:RETURN-FROM CLASSIFY-FILE-EXTENSION KWD-TRANSLATE-FILE-OTHER)))

;;; (DEFUN (GET-ROOT-DIRECTORY-FROM-FILE-TYPE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-ROOT-DIRECTORY-FROM-FILE-TYPE))
(CL:DEFUN GET-ROOT-DIRECTORY-FROM-FILE-TYPE (TYPE)
  "Given a normalized file `type', determine which STELLA installation
root directory tree it naturally belongs to (i.e., source, native or binary)."
  (CL:LET* ((ROOT STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ROOT))
   (CL:COND
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-STELLA)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-KB))
     (CL:SETQ ROOT (ROOT-SOURCE-DIRECTORY)))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP-BINARY)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-DIRECTORY))
     (CL:SETQ ROOT (ROOT-BINARY-DIRECTORY)))
    (CL:T (CL:SETQ ROOT (ROOT-NATIVE-DIRECTORY))))
   (CL:RETURN-FROM GET-ROOT-DIRECTORY-FROM-FILE-TYPE ROOT)))

;;; (DEFUN (GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION FILE-NAME) ...)

(CL:DEFUN GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION (FILE)
  "Given a `file', determine which STELLA installation root directory
tree it naturally belongs to based on its extension (i.e., source, native or binary)."
  (CL:RETURN-FROM GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION
   (GET-ROOT-DIRECTORY-FROM-FILE-TYPE (CLASSIFY-FILE-EXTENSION FILE))))

;;; (DEFGLOBAL *LISP-SPLITTER-PATH* ...)

(CL:DEFVAR *LISP-SPLITTER-PATH* "lisp")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *LISP-SPLITTER-PATH*))

;;; (DEFGLOBAL *JAVA-SPLITTER-PATH* ...)

(CL:DEFVAR *JAVA-SPLITTER-PATH* "java")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *JAVA-SPLITTER-PATH*))

;;; (DEFGLOBAL *CPP-SPLITTER-PATH* ...)

(CL:DEFVAR *CPP-SPLITTER-PATH* "cpp")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CPP-SPLITTER-PATH*))

;;; (DEFUN (GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE))
(CL:DEFUN GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE (TYPE)
  "Compute a language-specific native subdirectory that should
be used for files of `type'.  If `type' does not naturally suggest which native
language it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types."
  (CL:LET* ((SPLITTERPATH ""))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SPLITTERPATH))
   (CL:COND
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-LISP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-COMMON-LISP))
     (CL:SETQ SPLITTERPATH *LISP-SPLITTER-PATH*))
    ((CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
     (CL:SETQ SPLITTERPATH *JAVA-SPLITTER-PATH*))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP-HEADER)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-CPP-CODE)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-C-HEADER)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-C-CODE))
     (CL:SETQ SPLITTERPATH *CPP-SPLITTER-PATH*))
    ((CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-NONE)
      (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
     (CL:RETURN-FROM GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE
      (GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE
       *TRANSLATOROUTPUTLANGUAGE*)))
    (CL:T))
   (CL:RETURN-FROM GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE
    SPLITTERPATH)))

;;; (DEFUN (GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE))
(CL:DEFUN GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE (TYPE)
  "Compute a native system subdirectory that should be used
for files of `type'.  If `type' does not naturally suggest which native language
it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types."
  (CL:LET*
   ((SYSTEMDIRECTORY "")
    (JAVA?
     (CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
      (CL:AND
       (CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER)
        (CL:EQ TYPE KWD-TRANSLATE-FILE-NONE))
       (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMDIRECTORY))
   (CL:WHEN JAVA?
    (CL:COND
     ((CL:EQ *JAVA-BUILD-METHOD* KWD-TRANSLATE-FILE-JAVAC)
      (CL:RETURN-FROM GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE ""))
     ((CL:EQ *JAVA-BUILD-METHOD* KWD-TRANSLATE-FILE-MAVEN)
      (CL:WHEN (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
       (CL:RETURN-FROM GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE
        (%SYSTEM-DEFINITION.NAME *CURRENTSYSTEMDEFINITION*))))
     (CL:T)))
   (CL:WHEN
    (CL:NOT (BLANK-STRING? *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:SETQ SYSTEMDIRECTORY *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
   (CL:WHEN
    (CL:AND (BLANK-STRING? SYSTEMDIRECTORY)
     (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL)))
    (CL:SETQ SYSTEMDIRECTORY
     (%SYSTEM-DEFINITION.NAME *CURRENTSYSTEMDEFINITION*)))
   (CL:RETURN-FROM GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE
    SYSTEMDIRECTORY)))

;;; (DEFUN (GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE))
(CL:DEFUN GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE (TYPE)
  "Compute a native source subdirectory that should be used
for files of `type'.  If `type' does not naturally suggest which native language
it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types."
  (CL:LET*
   ((DIRECTORY "")
    (JAVA?
     (CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
      (CL:AND
       (CL:OR (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER)
        (CL:EQ TYPE KWD-TRANSLATE-FILE-NONE))
       (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-TRANSLATE-FILE-JAVA)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DIRECTORY))
   (CL:WHEN JAVA?
    (CL:COND
     ((CL:EQ *JAVA-BUILD-METHOD* KWD-TRANSLATE-FILE-MAVEN)
      (CL:SETQ DIRECTORY (CONCATENATE-FILE-NAMES "src" "main" "java")))
     (CL:T))
    (CL:SETQ DIRECTORY
     (CONCATENATE-FILE-NAMES DIRECTORY
      (JAVA-PACKAGE-PREFIX *MODULE* (DIRECTORY-SEPARATOR-STRING)))))
   (CL:RETURN-FROM GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE
    DIRECTORY)))

;;; (DEFUN (MAKE-FILE-NAME-FROM-RELATIVE-PATH FILE-NAME) ...)

(CL:DEFUN MAKE-FILE-NAME-FROM-RELATIVE-PATH (FILEPATH TYPE)
  (CL:RETURN-FROM MAKE-FILE-NAME-FROM-RELATIVE-PATH
   (MAKE-FILE-NAME (IMPLODE-PATHNAME FILEPATH) TYPE CL:T)))

;;; (DEFUN (MAKE-FILE-NAME FILE-NAME) ...)

(CL:DEFUN MAKE-FILE-NAME (FILEPATH TYPE RELATIVE?)
  "Make an absolute file-name string from 'filePath' with directory location
and file extension determined by 'type' and 'relative?'.  `type' is the main determiner
for whether we are creating a source, native or binary pathname in the respective root
directories, and it also controls the new extension of the resulting pathname replacing any
one on `filePath'.  If 'relative?' is TRUE, then the respective root directory prefix is appended,
plus any additional relevant language, system and source subdirectories.  If 'relative?' is
FALSE, then the current directory prefix of `filePath' as indicated by its extension is switched
to the new root directory indicated by `type'.  In this case, only the root and language directories
are inserted, but all the remaining source directory components are left the same (thus, this will
generally not do the right thing for Java file names).  This function takes the dynamic state of
currently active systems and modules into account."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILEPATH))
  #+MCL
  (CL:CHECK-TYPE FILEPATH CL:SIMPLE-STRING)
  (CL:LET*
   ((EXTENSION (SELECT-FILE-EXTENSION TYPE)) (ROOTPATH "")
    (LANGUAGEDIR "") (SYSTEMDIR "") (SOURCEDIR ""))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING EXTENSION ROOTPATH LANGUAGEDIR SYSTEMDIR
     SOURCEDIR))
   (CL:COND
    (RELATIVE?
     (CL:SETQ ROOTPATH (GET-ROOT-DIRECTORY-FROM-FILE-TYPE TYPE))
     (CL:SETQ LANGUAGEDIR
      (GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE TYPE))
     (CL:SETQ SYSTEMDIR (GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE TYPE))
     (CL:SETQ SOURCEDIR
      (GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE TYPE))
     (CL:WHEN (CL:NOT (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
      (CL:SETQ FILEPATH (FILE-NAME-WITHOUT-EXTENSION FILEPATH))))
    (CL:T
     (CL:LET*
      ((ROOTPREFIX
        (FILE-NAME-AS-DIRECTORY
         (GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION FILEPATH))))
      (CL:WHEN (CL:NOT (CL:EQ TYPE KWD-TRANSLATE-FILE-OTHER))
       (CL:SETQ FILEPATH (FILE-NAME-WITHOUT-EXTENSION FILEPATH)))
      (CL:WHEN
       (CL:NOT
        (MEMBER?
         (GET-QUOTED-TREE "((:STELLA :KB) \"/STELLA\")" "/STELLA")
         TYPE))
       (CL:LET*
        ((RELATIVEPATH (RELATIVIZE-FILE-NAME FILEPATH ROOTPREFIX)))
        (CL:WHEN (CL:NOT (STRING-EQL? FILEPATH RELATIVEPATH))
         (CL:SETQ ROOTPATH (GET-ROOT-DIRECTORY-FROM-FILE-TYPE TYPE))
         (CL:SETQ LANGUAGEDIR
          (GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE TYPE))
         (CL:SETQ FILEPATH RELATIVEPATH)))))))
   (CL:RETURN-FROM MAKE-FILE-NAME
    (CONCATENATE-FILE-NAMES ROOTPATH LANGUAGEDIR SYSTEMDIR SOURCEDIR
     (CONCATENATE FILEPATH EXTENSION)))))

;;; (DEFUN (RELATIVIZE-FILE-NAME FILE-NAME) ...)

(CL:DEFUN RELATIVIZE-FILE-NAME (FILE ROOTPATH)
  (CL:LET* ((ABSOLUTE? (CL:= (STRING-SEARCH FILE ROOTPATH 0) 0)))
   (CL:IF ABSOLUTE?
    (CL:RETURN-FROM RELATIVIZE-FILE-NAME
     (SUBSEQUENCE FILE (CL:THE CL:FIXNUM (CL:LENGTH ROOTPATH))
      NULL-INTEGER))
    (CL:RETURN-FROM RELATIVIZE-FILE-NAME FILE))))

;;; (DEFUN (HELP-IMPLODE-PATHNAME FILE-NAME) ...)

(CL:DEFUN HELP-IMPLODE-PATHNAME (FILENAME)
  (CL:LET* ((EXTENSION (FILE-EXTENSION FILENAME)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXTENSION))
   (CL:IF (CL:EQ EXTENSION STELLA::NULL-STRING)
    (CL:RETURN-FROM HELP-IMPLODE-PATHNAME
     (MAYBE-TRUNCATE-FILENAME FILENAME))
    (CL:RETURN-FROM HELP-IMPLODE-PATHNAME
     (CONCATENATE (MAYBE-TRUNCATE-FILENAME (FILE-BASE-NAME FILENAME))
      EXTENSION)))))

;;; (DEFUN (IMPLODE-PATHNAME FILE-NAME) ...)

(CL:DEFUN IMPLODE-PATHNAME (FILEPATH)
  (CL:LET* ((FILE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE FILEPATH)
      SGT-TRANSLATE-FILE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((PATH-LENGTH (LENGTH FILEPATH)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM PATH-LENGTH)) (CL:SETQ FILE "")
       (CL:LET*
        ((NAME NULL) (ITER-000 FILEPATH) (N NULL-INTEGER) (ITER-001 1)
         (UPPER-BOUND-000 PATH-LENGTH)
         (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM N ITER-001 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
          (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
         DO (CL:SETQ NAME (%%VALUE ITER-000)) (CL:SETQ N ITER-001)
         (CL:IF (CL:= N PATH-LENGTH)
          (CL:SETQ FILE
           (CONCATENATE FILE
            (HELP-IMPLODE-PATHNAME
             (%STRING-WRAPPER.WRAPPER-VALUE NAME))))
          (CL:SETQ FILE
           (CONCATENATE FILE (%STRING-WRAPPER.WRAPPER-VALUE NAME)
            (DIRECTORY-SEPARATOR-STRING))))
         (CL:SETQ ITER-000 (%%REST ITER-000))
         (CL:SETQ ITER-001 (CL:1+ ITER-001)))))))
    (CL:T
     (CL:SETQ FILE
      (HELP-IMPLODE-PATHNAME
       (%STRING-WRAPPER.WRAPPER-VALUE FILEPATH)))))
   (CL:RETURN-FROM IMPLODE-PATHNAME FILE)))

;;; (DEFSPECIAL *DONTTRUNCATEFILENAMES?* ...)

(CL:DEFVAR *DONTTRUNCATEFILENAMES?* CL:NIL
  "When TRUE, overrides normal truncation of file names.")

;;; (DEFUN (MAYBE-TRUNCATE-FILENAME FILE-NAME) ...)

(CL:DEFUN MAYBE-TRUNCATE-FILENAME (BAREFILENAME)
  (CL:WHEN *DONTTRUNCATEFILENAMES?*
   (CL:RETURN-FROM MAYBE-TRUNCATE-FILENAME BAREFILENAME))
  (CL:LET* ((MAXIMUMLENGTH 999))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MAXIMUMLENGTH))
   (CL:COND
    ((CL:EQ *OS* KWD-TRANSLATE-FILE-MAC)
     (CL:SETQ MAXIMUMLENGTH (CL:- 31 5)))
    (CL:T))
   (CL:WHEN
    (CL:> (CL:THE CL:FIXNUM (CL:LENGTH BAREFILENAME)) MAXIMUMLENGTH)
    (CL:LET* ((ORIGINALFILENAME BAREFILENAME))
     (CL:SETQ BAREFILENAME
      (SUBSEQUENCE BAREFILENAME 0 (CL:1- MAXIMUMLENGTH)))
     (CL:WARN
      "Truncating name of file.~%   Original: `~A'    Truncated: `~A'~%"
      ORIGINALFILENAME BAREFILENAME)))
   (CL:RETURN-FROM MAYBE-TRUNCATE-FILENAME BAREFILENAME)))

;;; (DEFUN (FIND-SOURCE-FROM-NATIVE-FILE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  FIND-SOURCE-FROM-NATIVE-FILE-NAME))
(CL:DEFUN FIND-SOURCE-FROM-NATIVE-FILE-NAME (NATIVEFILENAME)
  "Try to find a STELLA source file based on the name and system components of `nativeFileName'.
This will generally search the current STELLA systems path, since the tree where a native file resides is not
necessarily the one where the corresponding source file is also.  This will only work for Lisp and C++ files
where the basename of translated files corresponds to the source file from which they were derived.  The main
purpose for this is to support the Emacs Lisp/STELLA interface to find function definitions."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVEFILENAME))
  #+MCL
  (CL:CHECK-TYPE NATIVEFILENAME CL:SIMPLE-STRING)
  (CL:LET*
   ((NATIVEDIR (FILE-NAME-DIRECTORY NATIVEFILENAME))
    (NATIVENAME
     (FILE-NAME-WITHOUT-EXTENSION (FILE-BASE-NAME NATIVEFILENAME)))
    (NATIVESYSTEMDIR STELLA::NULL-STRING)
    (SOURCEFILENAME STELLA::NULL-STRING)
    (SOURCESDIR
     (RELATIVE-UNLOGICALIZE-PATHNAME *DEFAULTROOTSOURCEDIRECTORY*))
    (STELLADIRECTORIES (BUILD-STELLA-SYSTEMS-PATH)))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING NATIVESYSTEMDIR SOURCEFILENAME
     SOURCESDIR))
   (CL:LET* ((LEVEL NULL-INTEGER) (ITER-000 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM LEVEL ITER-000))
    (CL:LOOP WHILE CL:T DO (CL:SETQ LEVEL ITER-000)
     (CL:SETQ NATIVESYSTEMDIR
      (DIRECTORY-PARENT-DIRECTORY NATIVEDIR LEVEL))
     (CL:WHEN (BLANK-STRING? NATIVESYSTEMDIR) (CL:RETURN))
     (CL:SETQ NATIVESYSTEMDIR
      (SUBSEQUENCE NATIVEDIR
       (CL:THE CL:FIXNUM (CL:LENGTH NATIVESYSTEMDIR)) NULL-INTEGER))
     (CL:SETQ SOURCEFILENAME
      (CONCATENATE-FILE-NAMES NATIVESYSTEMDIR
       (CONCATENATE NATIVENAME ".ste")))
     (CL:LET* ((DIR NULL) (ITER-001 STELLADIRECTORIES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ DIR (%%VALUE ITER-001))
       (CL:WHEN
        (PROBE-FILE?
         (CONCATENATE-FILE-NAMES (%STRING-WRAPPER.WRAPPER-VALUE DIR)
          SOURCESDIR SOURCEFILENAME))
        (CL:RETURN-FROM FIND-SOURCE-FROM-NATIVE-FILE-NAME
         (CONCATENATE-FILE-NAMES (%STRING-WRAPPER.WRAPPER-VALUE DIR)
          SOURCESDIR SOURCEFILENAME)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM FIND-SOURCE-FROM-NATIVE-FILE-NAME
    STELLA::NULL-STRING)))

;;; (DEFUN (LANGUAGE-TO-FILE-TYPE KEYWORD) ...)

(CL:DEFUN LANGUAGE-TO-FILE-TYPE (LANGUAGE)
  (CL:COND
   ((CL:EQ LANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
    (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE KWD-TRANSLATE-FILE-LISP))
   ((CL:EQ LANGUAGE KWD-TRANSLATE-FILE-CPP)
    (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE KWD-TRANSLATE-FILE-CPP-CODE))
   (CL:T (CL:RETURN-FROM LANGUAGE-TO-FILE-TYPE LANGUAGE))))

;;; (DEFUN (REROOT-FILE-NAME FILE-NAME) ...)

(CL:DEFUN REROOT-FILE-NAME (FILE FROMROOT TOROOT)
  (CL:LET* ((ABSOLUTE? (CL:= (STRING-SEARCH FILE FROMROOT 0) 0)))
   (CL:IF ABSOLUTE?
    (CL:IF (STRING-EQL? FROMROOT TOROOT)
     (CL:RETURN-FROM REROOT-FILE-NAME FILE)
     (CL:RETURN-FROM REROOT-FILE-NAME
      (CONCATENATE TOROOT
       (SUBSEQUENCE FILE (CL:THE CL:FIXNUM (CL:LENGTH FROMROOT))
        NULL-INTEGER))))
    (CL:RETURN-FROM REROOT-FILE-NAME (CONCATENATE TOROOT FILE)))))

;;; (DEFUN (FILE-YOUNGER-THAN? THREE-VALUED-BOOLEAN) ...)

(CL:DEFUN FILE-YOUNGER-THAN? (FILE1 FILE2)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE1 FILE2))
  #+MCL
  (CL:CHECK-TYPE FILE1 CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FILE2 CL:SIMPLE-STRING)
  (CL:IF
   (CL:OR (CL:NOT (PROBE-FILE? FILE1)) (CL:NOT (PROBE-FILE? FILE2)))
   (CL:RETURN-FROM FILE-YOUNGER-THAN? NULL)
   (CL:LET*
    ((FILE1-DATE (FILE-WRITE-DATE FILE1))
     (FILE2-DATE (FILE-WRITE-DATE FILE2)))
    (CL:IF (CL:OR (CL:EQ FILE1-DATE NULL) (CL:EQ FILE2-DATE NULL))
     (CL:RETURN-FROM FILE-YOUNGER-THAN? NULL)
     (CL:RETURN-FROM FILE-YOUNGER-THAN?
      (CL:IF (GREATER-EQUAL? FILE1-DATE FILE2-DATE) TRUE-WRAPPER
       FALSE-WRAPPER))))))

;;; (DEFUN (STELLA-NEED-TO-TRANSLATE? BOOLEAN) ...)

(CL:DEFUN STELLA-NEED-TO-TRANSLATE? (FILE LANGUAGE)
  (CL:WHEN (CL:EQ LANGUAGE KWD-TRANSLATE-FILE-JAVA)
   (CL:RETURN-FROM STELLA-NEED-TO-TRANSLATE? CL:T))
  (CL:LET*
   ((SOURCEFILE
     (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
      KWD-TRANSLATE-FILE-STELLA CL:T))
    (TRANSLATEDFILE
     (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
      (LANGUAGE-TO-FILE-TYPE LANGUAGE) CL:T)))
   (CL:RETURN-FROM STELLA-NEED-TO-TRANSLATE?
    (CL:AND (PROBE-FILE? SOURCEFILE)
     (CL:NOT
      (CL:EQ (FILE-YOUNGER-THAN? TRANSLATEDFILE SOURCEFILE)
       TRUE-WRAPPER))))))

;;; (DEFUN (STELLA-NEED-TO-COMPILE? BOOLEAN) ...)

(CL:DEFUN STELLA-NEED-TO-COMPILE? (FILE)
  (CL:LET*
   ((SOURCEFILE
     (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
      KWD-TRANSLATE-FILE-LISP CL:T))
    (COMPILEDFILE
     (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
      KWD-TRANSLATE-FILE-LISP-BINARY CL:T)))
   (CL:RETURN-FROM STELLA-NEED-TO-COMPILE?
    (CL:NOT
     (CL:EQ (FILE-YOUNGER-THAN? COMPILEDFILE SOURCEFILE)
      TRUE-WRAPPER)))))

;;; (DEFUN (SYSTEM-NEEDS-TRANSLATION? BOOLEAN) ...)

(CL:DEFUN SYSTEM-NEEDS-TRANSLATION? (SYSTEMNAME LANGUAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((*CURRENTSYSTEMDEFINITION* (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
    (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
     (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
   (CL:DECLARE
    (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
     *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
   (CL:PROGN
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((FILE NULL)
       (ITER-000
        (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FILE (%%VALUE ITER-000))
       (CL:WHEN (STELLA-NEED-TO-TRANSLATE? FILE LANGUAGE)
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN FOUND?-000
      (CL:RETURN-FROM SYSTEM-NEEDS-TRANSLATION? CL:T)))
    (CL:LET* ((STARTUP-FILE (SYSTEM-STARTUP-FILE-NAME NULL)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STARTUP-FILE))
     (CL:WHEN
      (CL:NOT
       (PROBE-FILE?
        (MAKE-FILE-NAME STARTUP-FILE KWD-TRANSLATE-FILE-STELLA CL:T)))
      (CL:RETURN-FROM SYSTEM-NEEDS-TRANSLATION? CL:T))
     (CL:RETURN-FROM SYSTEM-NEEDS-TRANSLATION?
      (STELLA-NEED-TO-TRANSLATE? (WRAP-STRING STARTUP-FILE)
       LANGUAGE))))))

;;; (DEFUN (COMPUTE-FILE-UNITS-MODULE MODULE) ...)

(CL:DEFUN COMPUTE-FILE-UNITS-MODULE (FILEUNITS)
  (CL:LET* ((UNIT NULL) (ITER-000 (%LIST.THE-CONS-LIST FILEUNITS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ UNIT (%%VALUE ITER-000))
    (CL:WHEN
     (CL:NOT (CL:EQ (%TRANSLATION-UNIT.TU-HOME-MODULE UNIT) NULL))
     (CL:RETURN-FROM COMPUTE-FILE-UNITS-MODULE
      (%TRANSLATION-UNIT.TU-HOME-MODULE UNIT)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM COMPUTE-FILE-UNITS-MODULE *MODULE*))

;;; (DEFUN (CONCATENATE-SYSTEM-UNITS (LIST OF TRANSLATION-UNIT)) ...)

(CL:DEFUN CONCATENATE-SYSTEM-UNITS (SYSTEMUNITS)
  (CL:LET* ((HEAD (CONS NULL NIL)) (CURSOR HEAD))
   (CL:LET*
    ((FILE NULL) (UNITS NULL)
     (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST SYSTEMUNITS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ FILE (%KV-CONS.KEY ITER-000))
     (CL:SETQ UNITS (%KV-CONS.VALUE ITER-000)) (CL:SETQ FILE FILE)
     (CL:WHEN (NON-EMPTY? UNITS)
      (CONCATENATE CURSOR (%LIST.THE-CONS-LIST UNITS))
      (CL:SETQ CURSOR (%LIST.THE-CONS-LIST UNITS)))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
   (CL:LET* ((SELF-000 (NEW-LIST)))
    (CL:SETF (%LIST.THE-CONS-LIST SELF-000) (%%REST HEAD))
    (CL:LET* ((VALUE-000 SELF-000))
     (CL:RETURN-FROM CONCATENATE-SYSTEM-UNITS VALUE-000)))))

;;; (DEFUN (TRANSLATE-SYSTEM BOOLEAN) ...)

(CL:DEFUN %TRANSLATE-SYSTEM (SYSTEMNAME |LANGUAGE&OPTIONS|)
  "Translate all of the STELLA source files in system `systemName' into
`language' (the optional first argument).  The following keyword/value
`options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?' (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:recursive?' (default false): if true, perform `translate-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((OPTIONS |LANGUAGE&OPTIONS|))
   (CL:WHEN
    (CL:NOT
     (MEMBER?
      (GET-QUOTED-TREE "((:COMMON-LISP :CPP :JAVA) \"/STELLA\")"
       "/STELLA")
      (%%VALUE OPTIONS)))
    (CL:SETQ OPTIONS (CONS (RUNNING-IN-LANGUAGE) OPTIONS)))
   (CL:LET*
    ((THEOPTIONS
      (PARSE-OPTIONS (%%REST OPTIONS)
       (LIST* KWD-TRANSLATE-FILE-TWO-PASS?
        SGT-TRANSLATE-FILE-STELLA-BOOLEAN
        KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS?
        SGT-TRANSLATE-FILE-STELLA-BOOLEAN
        KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS?
        SGT-TRANSLATE-FILE-STELLA-BOOLEAN
        KWD-TRANSLATE-FILE-FORCE-TRANSLATION?
        SGT-TRANSLATE-FILE-STELLA-BOOLEAN KWD-TRANSLATE-FILE-RECURSIVE?
        SGT-TRANSLATE-FILE-STELLA-BOOLEAN KWD-TRANSLATE-FILE-LANGUAGE
        SGT-TRANSLATE-FILE-STELLA-KEYWORD KWD-TRANSLATE-FILE-ACTION
        SGT-TRANSLATE-FILE-STELLA-KEYWORD
        KWD-TRANSLATE-FILE-ROOT-SOURCE-DIRECTORY
        SGT-TRANSLATE-FILE-STELLA-FILE-NAME
        KWD-TRANSLATE-FILE-ROOT-NATIVE-DIRECTORY
        SGT-TRANSLATE-FILE-STELLA-FILE-NAME
        KWD-TRANSLATE-FILE-ROOT-BINARY-DIRECTORY
        SGT-TRANSLATE-FILE-STELLA-FILE-NAME
        KWD-TRANSLATE-FILE-PROCESSED SGT-TRANSLATE-FILE-STELLA-LIST
        NIL)
       CL:T CL:NIL))
     (LANGUAGE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-TRANSLATE-FILE-LANGUAGE
       (%%VALUE OPTIONS)))
     (TWOPASS?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-TRANSLATE-FILE-TWO-PASS?
        (CL:IF (CL:NOT (SYSTEM-LOADED-OR-STARTED-UP? SYSTEMNAME))
         TRUE-WRAPPER FALSE-WRAPPER))))
     (PRODUCTIONMODE?
      (CL:OR
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
        (LOOKUP-WITH-DEFAULT THEOPTIONS
         KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS? TRUE-WRAPPER))
       (CL:NOT
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
         (LOOKUP-WITH-DEFAULT THEOPTIONS
          KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS? FALSE-WRAPPER)))))
     (FORCETRANSLATION?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS
        KWD-TRANSLATE-FILE-FORCE-TRANSLATION? FALSE-WRAPPER)))
     (RECURSIVE?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-TRANSLATE-FILE-RECURSIVE?
        FALSE-WRAPPER)))
     (PROCESSED
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-TRANSLATE-FILE-PROCESSED
       (LIST)))
     (ACTION
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-TRANSLATE-FILE-ACTION
       KWD-TRANSLATE-FILE-TRANSLATE-SYSTEM))
     (TRANSLATEDSOMETHING? CL:NIL) (OLDGENSYMCOUNTER *GENSYM-COUNTER*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM OLDGENSYMCOUNTER))
    (INSERT-AT THEOPTIONS KWD-TRANSLATE-FILE-LANGUAGE LANGUAGE)
    (INSERT-AT THEOPTIONS KWD-TRANSLATE-FILE-ACTION ACTION)
    (INSERT-AT THEOPTIONS KWD-TRANSLATE-FILE-PROCESSED PROCESSED)
    (CL:UNWIND-PROTECT
     (CL:LET*
      ((*TRANSLATOROUTPUTLANGUAGE* *TRANSLATOROUTPUTLANGUAGE*)
       (*TRANSLATIONPHASE* NULL) (*SAFETY* *SAFETY*)
       (*RECYCLING-ENABLED?*
        (CL:NOT (CL:EQ LANGUAGE KWD-TRANSLATE-FILE-JAVA)))
       (*CURRENT-STELLA-FEATURES* (COPY *CURRENT-STELLA-FEATURES*))
       (*CURRENT-SYSTEM-ACTION* THEOPTIONS))
      (CL:DECLARE
       (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE* *TRANSLATIONPHASE*
        *SAFETY* *RECYCLING-ENABLED?* *CURRENT-STELLA-FEATURES*
        *CURRENT-SYSTEM-ACTION*))
      (CL:DECLARE (CL:TYPE CL:FIXNUM *SAFETY*))
      (CL:LET*
       ((*CURRENTSYSTEMDEFINITION*
         (GET-SYSTEM-DEFINITION SYSTEMNAME CL:T))
        (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
         (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)))
       (CL:DECLARE
        (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
         *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
       (CL:DECLARE
        (CL:TYPE CL:SIMPLE-STRING
         *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
       (CL:PROGN (INSERT-NEW PROCESSED (WRAP-STRING SYSTEMNAME))
        (CL:WHEN
         (CL:AND RECURSIVE?
          (CL:NOT
           (CL:EQ
            (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
             *CURRENTSYSTEMDEFINITION*)
            NULL)))
         (CL:LET*
          ((REQSYS NULL)
           (ITER-000
            (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS
             *CURRENTSYSTEMDEFINITION*)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ REQSYS (%%VALUE ITER-000))
           (CL:WHEN (CL:NOT (MEMBER? PROCESSED REQSYS))
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
             "Translating required system `" (UNWRAP-STRING REQSYS) "'"
             EOL)
            (%TRANSLATE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE REQSYS)
             (CONS-LIST KWD-TRANSLATE-FILE-OPTIONS THEOPTIONS)))
           (CL:SETQ ITER-000 (%%REST ITER-000)))))
        (CL:SETQ *GENSYM-COUNTER* -1)
        (%SET-STELLA-FEATURE
         (CONS-LIST KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER
          KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS
          KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS))
        (%UNSET-STELLA-FEATURE
         (CONS-LIST KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS))
        (%SET-TRANSLATOR-OUTPUT-LANGUAGE LANGUAGE)
        (COMPUTE-OPTIMIZATION-LEVELS *CURRENTSYSTEMDEFINITION*
         PRODUCTIONMODE?)
        (CL:WHEN
         (CL:OR FORCETRANSLATION?
          (SYSTEM-NEEDS-TRANSLATION? SYSTEMNAME LANGUAGE))
         (CREATE-SYSTEM-STARTUP-FILE *CURRENTSYSTEMDEFINITION*)
         (CL:SETQ TRANSLATEDSOMETHING?
          (HELP-TRANSLATE-SYSTEM
           (FILES-PLUS-SYSTEM-STARTUP
            (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*))
           TWOPASS? FORCETRANSLATION?)))
        (TRANSFER-NATIVE-SYSTEM-FILES LANGUAGE)
        (TRANSFER-DATA-FILES LANGUAGE))))
     (CL:SETQ *GENSYM-COUNTER* OLDGENSYMCOUNTER))
    (CL:RETURN-FROM %TRANSLATE-SYSTEM TRANSLATEDSOMETHING?))))

(CL:DEFUN TRANSLATE-SYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM TRANSLATE-SYSTEM-EVALUATOR-WRAPPER
   (CL:IF
    (%TRANSLATE-SYSTEM
     (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
     (%%REST ARGUMENTS))
    TRUE-WRAPPER FALSE-WRAPPER)))

(CL:DEFMACRO TRANSLATE-SYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Translate all of the STELLA source files in system `systemName' into
`language' (the optional first argument).  The following keyword/value
`options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?' (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:recursive?' (default false): if true, perform `translate-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/TRANSLATE-SYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE TRANSLATE-SYSTEM)))

;;; (DEFUN (HELP-TRANSLATE-SYSTEM BOOLEAN) ...)

(CL:DEFUN HELP-TRANSLATE-SYSTEM (FILES TWOPASS? FORCETRANSLATION?)
  (CL:LET* ((*TRANSLATIONUNITS* (NEW-LIST)))
   (CL:DECLARE (CL:SPECIAL *TRANSLATIONUNITS*))
   (CL:LET*
    ((OUTPUTLANGUAGE *TRANSLATOROUTPUTLANGUAGE*)
     (FILENAME STELLA::NULL-STRING) (TRANSLATEDFILE? CL:NIL)
     (WALKEDUNITS (NEW-KEY-VALUE-LIST)))
    (CLEAR-SYMBOL-REGISTRY)
    (CL:WHEN TWOPASS?
     (CL:LET* ((FILE NULL) (ITER-000 FILES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FILE (%%VALUE ITER-000))
       (CL:TAGBODY
        (CL:WHEN
         (CL:OR FORCETRANSLATION?
          (STELLA-NEED-TO-TRANSLATE? FILE OUTPUTLANGUAGE)
          (CL:NOT
           (%SYSTEM-DEFINITION.LOADED? *CURRENTSYSTEMDEFINITION*)))
         (CL:SETQ FILENAME
          (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
           KWD-TRANSLATE-FILE-STELLA CL:T))
         (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Warning: File `" FILENAME "' does not exist." EOL)
          (CL:GO :CONTINUE))
         (OPERATE-ON-FILE FILENAME KWD-TRANSLATE-FILE-DEFINE)
         (CLEAN-UP-TRANSLATION-UNITS-SPECIAL)
         (CL:SETQ TRANSLATEDFILE? CL:T))
        :CONTINUE)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN TRANSLATEDFILE?
      (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "*** Pass 2, finalizing objects..." EOL))
      (FINALIZE-CLASSES-AND-SLOTS)))
    (CL:LET* ((FILE NULL) (ITER-001 FILES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ FILE (%%VALUE ITER-001))
      (CL:TAGBODY
       (CL:WHEN
        (CL:OR FORCETRANSLATION?
         (STELLA-NEED-TO-TRANSLATE? FILE OUTPUTLANGUAGE))
        (CL:SETQ FILENAME
         (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE FILE)
          KWD-TRANSLATE-FILE-STELLA CL:T))
        (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Warning: File `" FILENAME "' does not exist." EOL)
         (CL:GO :CONTINUE))
        (OPERATE-ON-FILE FILENAME KWD-TRANSLATE-FILE-WALK)
        (INSERT-AT WALKEDUNITS (WRAP-STRING FILENAME)
         *TRANSLATIONUNITS*)
        (CL:SETQ *TRANSLATIONUNITS* (NEW-LIST)))
       :CONTINUE)
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (REVERSE WALKEDUNITS)
    (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "    ==============================" EOL))
    (CL:COND
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
      (CL-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-CPP)
      (CPP-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     ((CL:EQ OUTPUTLANGUAGE KWD-TRANSLATE-FILE-JAVA)
      (JAVA-TRANSLATE-WALKED-SYSTEM-UNITS WALKEDUNITS))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" OUTPUTLANGUAGE "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CLEAR-SYMBOL-REGISTRY)
    (CL:RETURN-FROM HELP-TRANSLATE-SYSTEM TRANSLATEDFILE?))))

;;; (DEFUN TRANSFER-NATIVE-SYSTEM-FILES ...)

(CL:DEFUN TRANSFER-NATIVE-SYSTEM-FILES (OUTPUT-LANGUAGE)
  (CL:LET* ((NATIVE-FILES NULL))
   (CL:COND
    ((CL:EQ OUTPUT-LANGUAGE KWD-TRANSLATE-FILE-COMMON-LISP)
     (CL:SETQ NATIVE-FILES
      (%SYSTEM-DEFINITION.LISP-ONLY-FILES *CURRENTSYSTEMDEFINITION*)))
    ((CL:EQ OUTPUT-LANGUAGE KWD-TRANSLATE-FILE-JAVA)
     (CL:SETQ NATIVE-FILES
      (%SYSTEM-DEFINITION.JAVA-ONLY-FILES *CURRENTSYSTEMDEFINITION*)))
    ((CL:EQ OUTPUT-LANGUAGE KWD-TRANSLATE-FILE-CPP)
     (CL:SETQ NATIVE-FILES
      (%SYSTEM-DEFINITION.CPP-ONLY-FILES *CURRENTSYSTEMDEFINITION*)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" OUTPUT-LANGUAGE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:NOT (CL:EQ NATIVE-FILES NULL))
    (CL:SETQ NATIVE-FILES
     (DIFFERENCE NATIVE-FILES
      (SYSTEM-DEFINITION-SOURCE-FILES *CURRENTSYSTEMDEFINITION*)))
    (TRANSFER-FILES NATIVE-FILES OUTPUT-LANGUAGE)))
  :VOID)

;;; (DEFUN TRANSFER-DATA-FILES ...)

(CL:DEFUN TRANSFER-DATA-FILES (OUTPUT-LANGUAGE)
  (CL:LET*
   ((DATA-FILES
     (%SYSTEM-DEFINITION.DATA-FILES *CURRENTSYSTEMDEFINITION*)))
   (CL:WHEN (CL:NOT (CL:EQ DATA-FILES NULL))
    (TRANSFER-FILES DATA-FILES OUTPUT-LANGUAGE)))
  :VOID)

;;; (DEFUN TRANSFER-FILES ...)

(CL:DEFUN TRANSFER-FILES (FILES OUTPUT-LANGUAGE)
  (CL:WHEN
   (STRING-EQL? (ROOT-SOURCE-DIRECTORY) (ROOT-NATIVE-DIRECTORY))
   (CL:RETURN-FROM TRANSFER-FILES))
  (CL:LET*
   ((FLOTSAMFILENAME "")
    (SYSTEM-SUB-DIRECTORY
     (CL:IF (STRING-EQL? *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* "") ""
      (FILE-NAME-AS-DIRECTORY *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING FLOTSAMFILENAME SYSTEM-SUB-DIRECTORY))
   (CL:WHEN (CL:EQ OUTPUT-LANGUAGE KWD-TRANSLATE-FILE-JAVA)
    (CL:SETQ FLOTSAMFILENAME
     (JAVA-YIELD-FLOTSAM-CLASS-NAME
      (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))))
   (CL:LET*
    ((*MODULE* (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((F NULL) (ITER-000 FILES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ F (%%VALUE ITER-000))
      (CL:LET*
       ((FILENAME (%STRING-WRAPPER.WRAPPER-VALUE F))
        (TYPE (CLASSIFY-FILE-EXTENSION FILENAME))
        (RELATIVEFILENAME
         (RELATIVIZE-FILE-NAME FILENAME (ROOT-SOURCE-DIRECTORY)))
        (FROMFILENAME STELLA::NULL-STRING)
        (TOFILENAME STELLA::NULL-STRING))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
       (CL:COND
        ((CL:EQ TYPE KWD-TRANSLATE-FILE-JAVA)
         (CL:WHEN
          (STRING-EQL? (FILE-BASE-NAME FILENAME) FLOTSAMFILENAME)
          (CL:WARN
           "Native Java filename `~A'~% conflicts with the Java catchall class' filename"
           FLOTSAMFILENAME)))
        (CL:T))
       (CL:SETQ FROMFILENAME
        (CONCATENATE-FILE-NAMES (ROOT-SOURCE-DIRECTORY)
         SYSTEM-SUB-DIRECTORY FILENAME))
       (CL:SETQ TOFILENAME (MAKE-FILE-NAME RELATIVEFILENAME TYPE CL:T))
       (CL:WHEN
        (CL:NOT
         (CL:EQ (FILE-YOUNGER-THAN? TOFILENAME FROMFILENAME)
          TRUE-WRAPPER))
        (CL:WHEN (CL:>= *TRANSLATIONVERBOSITYLEVEL* 1)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "Copying `" FROMFILENAME "'" EOL " to `" TOFILENAME "' ..."
          EOL))
        (%ENSURE-DIRECTORIES-EXIST TOFILENAME)
        (COPY-FILE FROMFILENAME TOFILENAME)))
      (CL:SETQ ITER-000 (%%REST ITER-000))))))
  :VOID)

(CL:DEFUN HELP-STARTUP-TRANSLATE-FILE1 ()
  (CL:PROGN
   (CL:SETQ KWD-TRANSLATE-FILE-ROOT-SOURCE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-SOURCE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-ROOT-NATIVE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-NATIVE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-ROOT-BINARY-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-BINARY-DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-TRANSLATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-STANDALONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-STANDALONE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-IDL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ KWD-TRANSLATE-FILE-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WALK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WALK" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-TRANSLATE-WITH-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-WITH-COPYRIGHT-HEADER"
     NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WINDOWS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WINDOWS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-UNIX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIX" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-MAC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAC" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LETTER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP-TRANSLATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-TRANSLATIONS" NULL 2))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-DEFINE-LOGICAL-HOST-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-LOGICAL-HOST-PROPERTY" NULL
     0))
   (CL:SETQ KWD-TRANSLATE-FILE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-GET-LOGICAL-HOST-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-LOGICAL-HOST-PROPERTY" NULL
     0))
   (CL:SETQ KWD-TRANSLATE-FILE-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-KB
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-CODE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-CPP-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-HEADER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-C-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-CODE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-C-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-HEADER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-OTHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP-BINARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-BINARY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-COMMON-LISP-VECTOR-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-VECTOR-STRUCTS"
     NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-JAVAC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVAC" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-MAVEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAVEN" NULL 2))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-SYSTEM-UNITS-ALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-UNITS-ALIST" NULL 0))
   (CL:SETQ KWD-TRANSLATE-FILE-TWO-PASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TWO-PASS?" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ KWD-TRANSLATE-FILE-DEVELOPMENT-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-PRODUCTION-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-FORCE-TRANSLATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-TRANSLATION?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-RECURSIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECURSIVE?" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-LANGUAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LANGUAGE" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTION" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-FILE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-NAME" NULL 1))
   (CL:SETQ KWD-TRANSLATE-FILE-PROCESSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCESSED" NULL 2))
   (CL:SETQ SGT-TRANSLATE-FILE-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ KWD-TRANSLATE-FILE-TRANSLATE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-SYSTEM" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-OPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTIONS" NULL 2))
   (CL:SETQ KWD-TRANSLATE-FILE-WARN-ABOUT-MISSING-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-MISSING-METHODS" NULL
     2))
   (CL:SETQ KWD-TRANSLATE-FILE-WARN-ABOUT-UNDEFINED-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL
     2))
   (CL:SETQ KWD-TRANSLATE-FILE-USE-HARDCODED-SYMBOLS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-HARDCODED-SYMBOLS" NULL 2))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-TRANSLATE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-SYSTEM" NULL 0))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TRANSLATE-FILE" NULL 0))
   (CL:SETQ SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-TRANSLATE-FILE2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "ROOT-SOURCE-DIRECTORY"
    "(DEFUN (ROOT-SOURCE-DIRECTORY FILE-NAME) () :DOCUMENTATION \"Accessor to determine the currently active sources directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ROOT-SOURCE-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "ROOT-NATIVE-DIRECTORY"
    "(DEFUN (ROOT-NATIVE-DIRECTORY FILE-NAME) () :DOCUMENTATION \"Accessor to determine the currently active native directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ROOT-NATIVE-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "ROOT-BINARY-DIRECTORY"
    "(DEFUN (ROOT-BINARY-DIRECTORY FILE-NAME) () :DOCUMENTATION \"Accessor to determine the currently active binary directory root.
If it is defined as an option in the currently active system action, use that.
If we have an active system, use its value, otherwise use the STELLA default value.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ROOT-BINARY-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITION-DIRECTORIES"
    "(DEFUN (SYSTEM-DEFINITION-DIRECTORIES (CONS OF STRING-WRAPPER)) ())"
    (CL:FUNCTION SYSTEM-DEFINITION-DIRECTORIES) NULL)
   (DEFINE-FUNCTION-OBJECT "TOP-LEVEL-STELLA-SYSTEM-DIRECTORY?"
    "(DEFUN (TOP-LEVEL-STELLA-SYSTEM-DIRECTORY? BOOLEAN) ((DIRECTORY FILE-NAME)) :DOCUMENTATION \"Return TRUE if `directory' is a top-level STELLA installation directory
containing one or more STELLA systems.  We currently determine this solely by looking
for the existence of at least one relevant top-level native directory.  This is needed
to find system root directories and other relevant STELLA installation directories.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TOP-LEVEL-STELLA-SYSTEM-DIRECTORY?) NULL)
   (DEFINE-FUNCTION-OBJECT "HANDLE-IN-MODULE-TREE"
    "(DEFUN (HANDLE-IN-MODULE-TREE BOOLEAN BOOLEAN) ((TREE CONS) (SEENINMODULE? BOOLEAN) (ERRORONINMODULE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION HANDLE-IN-MODULE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-AND-OUTPUT-UNITS-TO-FILE"
    "(DEFUN TRANSLATE-AND-OUTPUT-UNITS-TO-FILE ((FILE FILE-NAME) (TARGETLANGUAGE STRING)))"
    (CL:FUNCTION TRANSLATE-AND-OUTPUT-UNITS-TO-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATE-ON-FILE"
    "(DEFUN OPERATE-ON-FILE ((FILE FILE-NAME) (OPERATION KEYWORD)))"
    (CL:FUNCTION OPERATE-ON-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAN-UP-TRANSLATION-UNITS-SPECIAL"
    "(DEFUN CLEAN-UP-TRANSLATION-UNITS-SPECIAL ())"
    (CL:FUNCTION CLEAN-UP-TRANSLATION-UNITS-SPECIAL) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-FILE"
    "(DEFUN TRANSLATE-FILE ((FILE FILE-NAME) (OUTPUTLANGUAGE KEYWORD) (ASPARTOFSYSTEM? BOOLEAN)))"
    (CL:FUNCTION TRANSLATE-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-ALL-UNITS-TO-FILE"
    "(DEFUN OUTPUT-ALL-UNITS-TO-FILE ((SOURCEFILE FILE-NAME)))"
    (CL:FUNCTION OUTPUT-ALL-UNITS-TO-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-SIGNATURES-OF-ALL-UNITS"
    "(DEFUN RECORD-SIGNATURES-OF-ALL-UNITS ((SOURCEFILE FILE-NAME)))"
    (CL:FUNCTION RECORD-SIGNATURES-OF-ALL-UNITS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-WITH-COPYRIGHT-HEADER?"
    "(DEFUN (TRANSLATE-WITH-COPYRIGHT-HEADER? BOOLEAN) ())"
    (CL:FUNCTION TRANSLATE-WITH-COPYRIGHT-HEADER?) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-COPYRIGHT-HEADER"
    "(DEFUN OUTPUT-COPYRIGHT-HEADER ((STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION OUTPUT-COPYRIGHT-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "OUTPUT-FILE-HEADER"
    "(DEFUN OUTPUT-FILE-HEADER ((STREAM OUTPUT-STREAM) (FILE FILE-NAME)))"
    (CL:FUNCTION OUTPUT-FILE-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "OPERATING-SYSTEM"
    "(DEFUN (OPERATING-SYSTEM KEYWORD) ())"
    (CL:FUNCTION OPERATING-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR"
    "(DEFUN (DIRECTORY-SEPARATOR CHARACTER) ())"
    (CL:FUNCTION DIRECTORY-SEPARATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR-STRING"
    "(DEFUN (DIRECTORY-SEPARATOR-STRING STRING) ())"
    (CL:FUNCTION DIRECTORY-SEPARATOR-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-SEPARATOR-FOR-FILE"
    "(DEFUN (DIRECTORY-SEPARATOR-FOR-FILE CHARACTER) ((FILE FILE-NAME)))"
    (CL:FUNCTION DIRECTORY-SEPARATOR-FOR-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-DIRECTORY"
    "(DEFUN (FILE-NAME-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return the directory component of `file' including the final
directory separator or the empty string if `file' does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of `file'\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-FILE-NAME"
    "(DEFUN (DIRECTORY-FILE-NAME FILE-NAME) ((DIRECTORY FILE-NAME)) :DOCUMENTATION \"Return `directory' as a file name, i.e., without a terminating
directory separator.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DIRECTORY-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-AS-DIRECTORY"
    "(DEFUN (FILE-NAME-AS-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return `file' interpreted as a directory, i.e., with a
terminating directory separator.  If `file' is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-AS-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "DIRECTORY-PARENT-DIRECTORY"
    "(DEFUN (DIRECTORY-PARENT-DIRECTORY FILE-NAME) ((DIRECTORY FILE-NAME) (LEVEL INTEGER)) :DOCUMENTATION \"Return the `level'-th parent directory component of `directory'
including the final directory separator, or the empty string if `directory' does
not have that many parents.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DIRECTORY-PARENT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-WITHOUT-DEVICE"
    "(DEFUN (FILE-NAME-WITHOUT-DEVICE FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return the file name portion of `file' by removing any
physical device components.  This is just like `logical-pathname-without-host'
but only looks for one-character device strings as used in Windows.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-WITHOUT-DEVICE) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-WITHOUT-DIRECTORY"
    "(DEFUN (FILE-NAME-WITHOUT-DIRECTORY FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Return the file name portion of `file' by removing any
directory and logical host components.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-WITHOUT-DIRECTORY) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-NAME-WITHOUT-EXTENSION"
    "(DEFUN (FILE-NAME-WITHOUT-EXTENSION FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Remove `file's extension (or type) if there is any and
return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-NAME-WITHOUT-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-EXTENSION"
    "(DEFUN (FILE-EXTENSION STRING) ((FILE FILE-NAME)) :DOCUMENTATION \"Return `file's extension (or type) if it has any including
the separator character.\" :PUBLIC? TRUE)" (CL:FUNCTION FILE-EXTENSION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-BASE-NAME"
    "(DEFUN (FILE-BASE-NAME FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Remove `file's directory (including logical host) and
extension components and return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FILE-BASE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-LOGICAL-HOST-PROPERTY"
    "(DEFUN DEFINE-LOGICAL-HOST-PROPERTY ((HOST STRING) (PROPERTY KEYWORD) (VALUE OBJECT)) :DOCUMENTATION \"Define `property' with `value' for the logical host `host'.
As a side-effect, this also defines `host' as a logical host (both
`property' and `value' can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with `host' are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of `(CL:logical-pathname-translations host)' if we are
running in Lisp, which allows us to depend on the native
`CL:translate-logical-pathname' for more complex translation operations.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %DEFINE-LOGICAL-HOST-PROPERTY)
    (CL:FUNCTION DEFINE-LOGICAL-HOST-PROPERTY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LOGICAL-HOST-PROPERTY"
    "(DEFUN (LOOKUP-LOGICAL-HOST-PROPERTY OBJECT) ((HOST STRING) (PROPERTY KEYWORD)))"
    (CL:FUNCTION LOOKUP-LOGICAL-HOST-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-LOGICAL-HOST-PROPERTY"
    "(DEFUN (GET-LOGICAL-HOST-PROPERTY OBJECT) ((HOST OBJECT) (PROPERTY OBJECT)) :DOCUMENTATION \"Lookup the value of `property' for the logical host `host'.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %GET-LOGICAL-HOST-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-HOST?"
    "(DEFUN (LOGICAL-HOST? BOOLEAN) ((HOST STRING)))"
    (CL:FUNCTION LOGICAL-HOST?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-PATHNAME?"
    "(DEFUN (LOGICAL-PATHNAME? BOOLEAN) ((PATHNAME STRING)))"
    (CL:FUNCTION LOGICAL-PATHNAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "ABSOLUTE-PATHNAME?"
    "(DEFUN (ABSOLUTE-PATHNAME? BOOLEAN) ((PATHNAME STRING)))"
    (CL:FUNCTION ABSOLUTE-PATHNAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-LOGICAL-HOST-NAME"
    "(DEFUN (GET-LOGICAL-HOST-NAME STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION GET-LOGICAL-HOST-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGICAL-PATHNAME-WITHOUT-HOST"
    "(DEFUN (LOGICAL-PATHNAME-WITHOUT-HOST STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION LOGICAL-PATHNAME-WITHOUT-HOST) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOGICAL-PATHNAME"
    "(DEFUN (TRANSLATE-LOGICAL-PATHNAME STRING) ((PATHNAME STRING)))"
    (CL:FUNCTION TRANSLATE-LOGICAL-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "UNLOGICALIZE-PATHNAME"
    "(DEFUN (UNLOGICALIZE-PATHNAME STRING) ((PATHNAME STRING)) :GLOBALLY-INLINE? TRUE (RETURN (TRANSLATE-LOGICAL-PATHNAME PATHNAME)))"
    (CL:FUNCTION UNLOGICALIZE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIVE-UNLOGICALIZE-PATHNAME"
    "(DEFUN (RELATIVE-UNLOGICALIZE-PATHNAME STRING) ((PATHNAME STRING)) :DOCUMENTATION \"If `pathName' is a logical pathname translate it, however, remove the
:root-directory prefix of the logical host.  Otherwise, return `pathName' as is.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RELATIVE-UNLOGICALIZE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "MERGE-FILE-NAMES"
    "(DEFUN (MERGE-FILE-NAMES FILE-NAME) ((BASEFILE FILE-NAME) (DEFAULTS FILE-NAME)) :DOCUMENTATION \"Parse `baseFile', supply any missing components from
`defaults' if supplied and return the result.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MERGE-FILE-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCATENATE-FILE-NAMES"
    "(DEFUN (CONCATENATE-FILE-NAMES FILE-NAME) ((FILE FILE-NAME) |&REST| (OTHERFILES FILE-NAME)) :DOCUMENTATION \"Intelligently join `file' and `otherFiles' into a concatenated path where each
component is separated by a single separator (similar to Python's os.path.join).  Keeps the result
a logical pathname as long as possible, but converts to physical as soon as any of `otherFiles'
contain a physical directory separator.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONCATENATE-FILE-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-COMMON-LISP-FILE-EXTENSION"
    "(DEFUN (COMPUTE-COMMON-LISP-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION COMPUTE-COMMON-LISP-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-COMMON-LISP-FILE-EXTENSION"
    "(DEFUN (DEFAULT-COMMON-LISP-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION DEFAULT-COMMON-LISP-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-FILE-EXTENSION"
    "(DEFUN (SELECT-FILE-EXTENSION STRING) ((TYPE KEYWORD)))"
    (CL:FUNCTION SELECT-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASSIFY-FILE-EXTENSION"
    "(DEFUN (CLASSIFY-FILE-EXTENSION KEYWORD) ((FILE FILE-NAME)))"
    (CL:FUNCTION CLASSIFY-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ROOT-DIRECTORY-FROM-FILE-TYPE"
    "(DEFUN (GET-ROOT-DIRECTORY-FROM-FILE-TYPE STRING) ((TYPE KEYWORD)) :DOCUMENTATION \"Given a normalized file `type', determine which STELLA installation
root directory tree it naturally belongs to (i.e., source, native or binary).\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-ROOT-DIRECTORY-FROM-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION"
    "(DEFUN (GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION FILE-NAME) ((FILE FILE-NAME)) :DOCUMENTATION \"Given a `file', determine which STELLA installation root directory
tree it naturally belongs to based on its extension (i.e., source, native or binary).\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-ROOT-DIRECTORY-FROM-FILE-EXTENSION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE"
    "(DEFUN (GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE STRING) ((TYPE KEYWORD)) :DOCUMENTATION \"Compute a language-specific native subdirectory that should
be used for files of `type'.  If `type' does not naturally suggest which native
language it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-LANGUAGE-SUBDIRECTORY-FROM-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE"
    "(DEFUN (GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE STRING) ((TYPE KEYWORD)) :DOCUMENTATION \"Compute a native system subdirectory that should be used
for files of `type'.  If `type' does not naturally suggest which native language
it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SYSTEM-SUBDIRECTORY-FROM-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE"
    "(DEFUN (GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE STRING) ((TYPE KEYWORD)) :DOCUMENTATION \"Compute a native source subdirectory that should be used
for files of `type'.  If `type' does not naturally suggest which native language
it is associated with, key in on the current translation output language.
Returns the empty string for unhandled types.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-NATIVE-SOURCE-SUBDIRECTORY-FROM-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-FILE-NAME-FROM-RELATIVE-PATH"
    "(DEFUN (MAKE-FILE-NAME-FROM-RELATIVE-PATH FILE-NAME) ((FILEPATH OBJECT) (TYPE KEYWORD)))"
    (CL:FUNCTION MAKE-FILE-NAME-FROM-RELATIVE-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-FILE-NAME"
    "(DEFUN (MAKE-FILE-NAME FILE-NAME) ((FILEPATH STRING) (TYPE KEYWORD) (RELATIVE? BOOLEAN)) :DOCUMENTATION \"Make an absolute file-name string from 'filePath' with directory location
and file extension determined by 'type' and 'relative?'.  `type' is the main determiner
for whether we are creating a source, native or binary pathname in the respective root
directories, and it also controls the new extension of the resulting pathname replacing any
one on `filePath'.  If 'relative?' is TRUE, then the respective root directory prefix is appended,
plus any additional relevant language, system and source subdirectories.  If 'relative?' is
FALSE, then the current directory prefix of `filePath' as indicated by its extension is switched
to the new root directory indicated by `type'.  In this case, only the root and language directories
are inserted, but all the remaining source directory components are left the same (thus, this will
generally not do the right thing for Java file names).  This function takes the dynamic state of
currently active systems and modules into account.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MAKE-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIVIZE-FILE-NAME"
    "(DEFUN (RELATIVIZE-FILE-NAME FILE-NAME) ((FILE FILE-NAME) (ROOTPATH FILE-NAME)))"
    (CL:FUNCTION RELATIVIZE-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-IMPLODE-PATHNAME"
    "(DEFUN (HELP-IMPLODE-PATHNAME FILE-NAME) ((FILENAME FILE-NAME)))"
    (CL:FUNCTION HELP-IMPLODE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "IMPLODE-PATHNAME"
    "(DEFUN (IMPLODE-PATHNAME FILE-NAME) ((FILEPATH OBJECT)))"
    (CL:FUNCTION IMPLODE-PATHNAME) NULL)
   (DEFINE-FUNCTION-OBJECT "MAYBE-TRUNCATE-FILENAME"
    "(DEFUN (MAYBE-TRUNCATE-FILENAME FILE-NAME) ((BAREFILENAME FILE-NAME)))"
    (CL:FUNCTION MAYBE-TRUNCATE-FILENAME) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-SOURCE-FROM-NATIVE-FILE-NAME"
    "(DEFUN (FIND-SOURCE-FROM-NATIVE-FILE-NAME STRING) ((NATIVEFILENAME STRING)) :DOCUMENTATION \"Try to find a STELLA source file based on the name and system components of `nativeFileName'.
This will generally search the current STELLA systems path, since the tree where a native file resides is not
necessarily the one where the corresponding source file is also.  This will only work for Lisp and C++ files
where the basename of translated files corresponds to the source file from which they were derived.  The main
purpose for this is to support the Emacs Lisp/STELLA interface to find function definitions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-SOURCE-FROM-NATIVE-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "LANGUAGE-TO-FILE-TYPE"
    "(DEFUN (LANGUAGE-TO-FILE-TYPE KEYWORD) ((LANGUAGE KEYWORD)))"
    (CL:FUNCTION LANGUAGE-TO-FILE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "REROOT-FILE-NAME"
    "(DEFUN (REROOT-FILE-NAME FILE-NAME) ((FILE FILE-NAME) (FROMROOT FILE-NAME) (TOROOT FILE-NAME)))"
    (CL:FUNCTION REROOT-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "FILE-YOUNGER-THAN?"
    "(DEFUN (FILE-YOUNGER-THAN? THREE-VALUED-BOOLEAN) ((FILE1 STRING) (FILE2 STRING)))"
    (CL:FUNCTION FILE-YOUNGER-THAN?) NULL))
  :VOID)

(CL:DEFUN STARTUP-TRANSLATE-FILE ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:SETQ *LOGICAL-HOST-TABLE* (NEW-STRING-HASH-TABLE))
   (%DEFINE-LOGICAL-HOST-PROPERTY "ST" NULL NULL)
   (%DEFINE-LOGICAL-HOST-PROPERTY "PL" NULL NULL))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-TRANSLATE-FILE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *DEFAULTSYSTEMDEFINITIONDIRECTORIES*
     (CONS-LIST
      (WRAP-STRING
       (CONCATENATE-FILE-NAMES *DEFAULTROOTSOURCEDIRECTORY*
        "systems;"))
      (WRAP-STRING "ST:systems;")))
    (CL:SETQ *OS* (OPERATING-SYSTEM))
    (CL:SETQ *TYPE-TO-FILE-EXTENSION-TABLE*
     (LIST* (LIST* KWD-TRANSLATE-FILE-STELLA (WRAP-STRING ".ste") NIL)
      (LIST* KWD-TRANSLATE-FILE-KB (WRAP-STRING ".kb") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP (WRAP-STRING ".cc") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP-CODE (WRAP-STRING ".cc") NIL)
      (LIST* KWD-TRANSLATE-FILE-CPP-HEADER (WRAP-STRING ".hh") NIL)
      (LIST* KWD-TRANSLATE-FILE-C-CODE (WRAP-STRING ".c") NIL)
      (LIST* KWD-TRANSLATE-FILE-C-HEADER (WRAP-STRING ".h") NIL)
      (LIST* KWD-TRANSLATE-FILE-JAVA (WRAP-STRING ".java") NIL)
      (LIST* KWD-TRANSLATE-FILE-IDL (WRAP-STRING ".idl") NIL)
      (LIST* KWD-TRANSLATE-FILE-OTHER (WRAP-STRING "") NIL)
      (LIST* KWD-TRANSLATE-FILE-NONE (WRAP-STRING "") NIL) NIL)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE SYSTEM-UNITS-ALIST (KEY-VALUE-LIST OF STRING-WRAPPER (LIST OF TRANSLATION-UNIT)))"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-TRANSLATE-FILE2)
    (DEFINE-FUNCTION-OBJECT "STELLA-NEED-TO-TRANSLATE?"
     "(DEFUN (STELLA-NEED-TO-TRANSLATE? BOOLEAN) ((FILE OBJECT) (LANGUAGE KEYWORD)))"
     (CL:FUNCTION STELLA-NEED-TO-TRANSLATE?) NULL)
    (DEFINE-FUNCTION-OBJECT "STELLA-NEED-TO-COMPILE?"
     "(DEFUN (STELLA-NEED-TO-COMPILE? BOOLEAN) ((FILE OBJECT)))"
     (CL:FUNCTION STELLA-NEED-TO-COMPILE?) NULL)
    (DEFINE-FUNCTION-OBJECT "SYSTEM-NEEDS-TRANSLATION?"
     "(DEFUN (SYSTEM-NEEDS-TRANSLATION? BOOLEAN) ((SYSTEMNAME STRING) (LANGUAGE KEYWORD)))"
     (CL:FUNCTION SYSTEM-NEEDS-TRANSLATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-FILE-UNITS-MODULE"
     "(DEFUN (COMPUTE-FILE-UNITS-MODULE MODULE) ((FILEUNITS (LIST OF TRANSLATION-UNIT))))"
     (CL:FUNCTION COMPUTE-FILE-UNITS-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "CONCATENATE-SYSTEM-UNITS"
     "(DEFUN (CONCATENATE-SYSTEM-UNITS (LIST OF TRANSLATION-UNIT)) ((SYSTEMUNITS SYSTEM-UNITS-ALIST)))"
     (CL:FUNCTION CONCATENATE-SYSTEM-UNITS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-SYSTEM"
     "(DEFUN (TRANSLATE-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Translate all of the STELLA source files in system `systemName' into
`language' (the optional first argument).  The following keyword/value
`options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?' (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:recursive?' (default false): if true, perform `translate-system' with the provided
options on `systemName' as well as all its required systems and so on.  Required
systems will be processed first.  Note that even without this option, any required
systems that have not yet been loaded or started up will also be processed, since
that is assumed when loading `systemName' and supporting modules from a definition file.

`:root-source-directory', `:root-native-directory', `:root-binary-directory': if
specified these directories will be used to override the respective paths provided
in system definitions or computed as defaults from a system's home location.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %TRANSLATE-SYSTEM)
     (CL:FUNCTION TRANSLATE-SYSTEM-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "HELP-TRANSLATE-SYSTEM"
     "(DEFUN (HELP-TRANSLATE-SYSTEM BOOLEAN) ((FILES (CONS OF STRING-WRAPPER)) (TWOPASS? BOOLEAN) (FORCETRANSLATION? BOOLEAN)))"
     (CL:FUNCTION HELP-TRANSLATE-SYSTEM) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSFER-NATIVE-SYSTEM-FILES"
     "(DEFUN TRANSFER-NATIVE-SYSTEM-FILES ((OUTPUT-LANGUAGE KEYWORD)))"
     (CL:FUNCTION TRANSFER-NATIVE-SYSTEM-FILES) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSFER-DATA-FILES"
     "(DEFUN TRANSFER-DATA-FILES ((OUTPUT-LANGUAGE KEYWORD)))"
     (CL:FUNCTION TRANSFER-DATA-FILES) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSFER-FILES"
     "(DEFUN TRANSFER-FILES ((FILES (CONS OF STRING-WRAPPER)) (OUTPUT-LANGUAGE KEYWORD)))"
     (CL:FUNCTION TRANSFER-FILES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-TRANSLATE-FILE"
     "(DEFUN STARTUP-TRANSLATE-FILE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-TRANSLATE-FILE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-TRANSLATE-FILE-STELLA-STARTUP-TRANSLATE-FILE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-TRANSLATE-FILE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupTranslateFile") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *RECORD-SIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', record object signatures into a persistent table.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *WALK-WITH-RECORDED-SIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', the walker will try to find previously recorded
signatures for referenced but undefined functions, methods, etc.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *USERECORDEDSIGNATURES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', `safe-lookup-slot' and `lookup-function' will
try to retrieve a previously recorded signature if normal lookup fails.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DEFAULTROOTSOURCEDIRECTORY* STRING \"ST:sources;\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DEFAULTROOTNATIVEDIRECTORY* STRING \"ST:native;\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DEFAULTROOTBINARYDIRECTORY* STRING \"ST:bin;\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DEFAULTSYSTEMDEFINITIONDIRECTORIES* (CONS OF STRING-WRAPPER) (CONS-LIST (CONCATENATE-FILE-NAMES *DEFAULTROOTSOURCEDIRECTORY* \"systems;\") \"ST:systems;\") :DOCUMENTATION \"Points to a list of directories containing system definition files.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENTSYSTEMDEFINITION* SYSTEM-DEFINITION NULL :DOCUMENTATION \"Points to the current system.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *CURRENTSYSTEMDEFINITIONSUBDIRECTORY* STRING \"\" :DOCUMENTATION \"Points to a path from the root directory down
to a local directory containing sources, natives, or binaries.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *OS* KEYWORD (OPERATING-SYSTEM) :DOCUMENTATION \"The operating system we are running on.  Currently,
either :UNIX, :WINDOWS, or :MAC.  Note that on the Mac OS X, the
OS can be either :UNIX or :MAC, depending on which file naming 
conventions are being observed by the software.\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT TYPE-SEPARATOR CHARACTER #\\.)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT LOGICAL-DIRECTORY-SEPARATOR CHARACTER #\\;)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT LOGICAL-HOST-SEPARATOR CHARACTER #\\:)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOGICAL-HOST-TABLE* (STRING-HASH-TABLE OF STRING KEY-VALUE-LIST) NULL)"
     NULL)
    (CL:LET*
     ((SYSTEM (GET-SYSTEM-DEFINITION "stella" CL:NIL))
      (ROOTDIR
       (CL:IF (CL:NOT (CL:EQ SYSTEM NULL))
        (FIND-SYSTEM-ROOT-DIRECTORY SYSTEM) STELLA::NULL-STRING)))
     (CL:WHEN (CL:NOT (BLANK-STRING? ROOTDIR))
      (%DEFINE-LOGICAL-HOST-PROPERTY "ST"
       KWD-TRANSLATE-FILE-ROOT-DIRECTORY (WRAP-STRING ROOTDIR))))
    (REGISTER-NATIVE-NAME
     SYM-TRANSLATE-FILE-STELLA-DEFINE-LOGICAL-HOST-PROPERTY
     KWD-TRANSLATE-FILE-COMMON-LISP KWD-TRANSLATE-FILE-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-TRANSLATE-FILE-STELLA-GET-LOGICAL-HOST-PROPERTY
     KWD-TRANSLATE-FILE-COMMON-LISP KWD-TRANSLATE-FILE-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *TYPE-TO-FILE-EXTENSION-TABLE* (CONS OF CONS) (BQUOTE ((:STELLA \".ste\") (:KB \".kb\") (:CPP \".cc\") (:CPP-CODE \".cc\") (:CPP-HEADER \".hh\") (:C-CODE \".c\") (:C-HEADER \".h\") (:JAVA \".java\") (:IDL \".idl\") (:OTHER \"\") (:NONE \"\"))) :DOCUMENTATION \"Used by `select-file-extension'.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LISP-SPLITTER-PATH* STRING \"lisp\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *JAVA-SPLITTER-PATH* STRING \"java\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *CPP-SPLITTER-PATH* STRING \"cpp\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *DONTTRUNCATEFILENAMES?* BOOLEAN FALSE :DOCUMENTATION \"When TRUE, overrides normal truncation of file names.\")"
     NULL)
    (REGISTER-NATIVE-NAME SYM-TRANSLATE-FILE-STELLA-TRANSLATE-SYSTEM
     KWD-TRANSLATE-FILE-COMMON-LISP KWD-TRANSLATE-FILE-FUNCTION)))
  :VOID)
