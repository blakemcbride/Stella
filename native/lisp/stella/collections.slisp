;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; collections.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-COLLECTIONS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-SET NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-VECTOR NULL)
(CL:DEFVAR KWD-COLLECTIONS-CPP NULL)
(CL:DEFVAR KWD-COLLECTIONS-FUNCTION NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-VECTOR NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-VECTOR-SEQUENCE NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-HEAP NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-FILL-POINTER NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-SIZE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-INITIAL-SIZE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-FREE-ELEMENTS NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-EQUAL-TEST? NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUCKET-INDEX NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUCKET-CURSOR NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-THE-MAP NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-CROSSOVER-POINT NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-HASH-SET NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-CONS NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-LIST NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-1D-ARRAY NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-OBJECT-ARRAY NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-1D-FLOAT-ARRAY NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-FLOAT-ARRAY NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-2D-ARRAY NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-2D-FLOAT-ARRAY NULL)
(CL:DEFVAR SGT-COLLECTIONS-STELLA-BUFFERED-STRING NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUFFER NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-BUFFER-SIZE NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-STRING-BUFFER NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS NULL)
(CL:DEFVAR SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-CHARACTER TRUE-WRAPPER
  FALSE-WRAPPER *INTEGER-MSB-MASK* NULL-INTEGER NIL))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF COLLECTION) OBJECT)
  "Return true iff `object' is a member of the collection `self'."
  (CL:LET* ((I NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ I (%ITERATOR.VALUE ITER-000))
    (CL:WHEN (EQL? I OBJECT) (CL:RETURN-FROM MEMBER? CL:T))))
  (CL:RETURN-FROM MEMBER? CL:NIL))

;;; (DEFUN (STELLA-COLLECTION? BOOLEAN) ...)

(CL:DEFUN STELLA-COLLECTION? (SELF)
  "Return `true' if `self' is a native collection."
  (CL:RETURN-FROM STELLA-COLLECTION?
   (ISA? SELF SGT-COLLECTIONS-STELLA-COLLECTION)))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF COLLECTION))
  "Return `true' if the collection `self' forbids duplicate values."
  (CL:RETURN-FROM NO-DUPLICATES? CL:NIL))

;;; (DEFMETHOD (NO-DUPLICATES? BOOLEAN) ...)

(CL:DEFMETHOD NO-DUPLICATES? ((SELF SET))
  (CL:RETURN-FROM NO-DUPLICATES? CL:T))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF COLLECTION))
  "Return `true' if the collection `self' is ordered."
  (CL:RETURN-FROM ORDERED? CL:NIL))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SEQUENCE))
  (CL:RETURN-FROM ORDERED? CL:T))

;;; (DEFMETHOD (ORDERED? BOOLEAN) ...)

(CL:DEFMETHOD ORDERED? ((SELF SET))
  (CL:RETURN-FROM ORDERED? CL:NIL))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF SET) VALUE)
  "Add `value' to the set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:SETF (%SET.THE-CONS-LIST SELF)
    (CONS VALUE (%SET.THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD PUSH ...)

(CL:DEFMETHOD PUSH ((SELF SET) VALUE)
  "Add `value' to the front of set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:SETF (%SET.THE-CONS-LIST SELF)
    (CONS VALUE (%SET.THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD INSERT-LAST ...)

(CL:DEFMETHOD INSERT-LAST ((SELF SET) VALUE)
  "Add `value' to the end of set `self' unless it is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF VALUE))
   (CL:LET*
    ((CURSOR (%SET.THE-CONS-LIST SELF)) (LASTCONS (CONS VALUE NIL)))
    (CL:IF (CL:EQ CURSOR NIL)
     (CL:SETF (%SET.THE-CONS-LIST SELF) LASTCONS)
     (ADD-CONS-TO-END-OF-CONS-LIST CURSOR LASTCONS))))
  :VOID)

;;; (DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-DUPLICATES ((SELF SET))
  (CL:RETURN-FROM REMOVE-DUPLICATES SELF))

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF SET) NEW OLD)
  "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member."
  (CL:WHEN (CL:NOT (MEMBER? SELF NEW))
   (CL:SETF (%SET.THE-CONS-LIST SELF)
    (SUBSTITUTE (%SET.THE-CONS-LIST SELF) NEW OLD)))
  (CL:RETURN-FROM SUBSTITUTE SELF))

;;; (DEFMETHOD (CONCATENATE SET) ...)

(CL:DEFMETHOD CONCATENATE ((SET1 SET) SET2 CL:&REST OTHERSETS)
  "Union `set2' and all `otherSets' onto the end of `set1'.
The operation is destructive wrt `set1', but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism."
  (CL:LET* ((RESULTSET (%SET.THE-CONS-LIST SET1)))
   (CL:LET*
    ((ELT NULL) (ITER-000 (%LIST.THE-CONS-LIST SET2))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ELT (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (MEMBER? RESULTSET ELT))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ELT NIL))
        (CL:IF (CL:EQ RESULTSET NIL) (CL:SETQ RESULTSET COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST RESULTSET COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ELT NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:> (CL:LENGTH OTHERSETS) 0)
    (CL:LET* ((OSET NULL) (ITER-001 OTHERSETS))
     (CL:LOOP WHILE ITER-001 DO (CL:SETQ OSET (CL:POP ITER-001))
      (CL:LET*
       ((ELT NULL) (ITER-002 (%LIST.THE-CONS-LIST OSET))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ ELT (%%VALUE ITER-002))
        (CL:WHEN (CL:NOT (MEMBER? RESULTSET ELT))
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN (CL:SETQ COLLECT-001 (CONS ELT NIL))
           (CL:IF (CL:EQ RESULTSET NIL) (CL:SETQ RESULTSET COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST RESULTSET COLLECT-001)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS ELT NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))))
   (CL:SETF (%SET.THE-CONS-LIST SET1) RESULTSET)
   (CL:RETURN-FROM CONCATENATE SET1)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X SET) Y)
  "Return TRUE iff `x' and `y' are SET's with equivalent members.
Uses `equal?' to test equality of elements.  This is more general than
`equivalent-sets?', since that only uses an `eql?' test."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-SET)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH X) (LENGTH Y)))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((ALWAYS?-000 CL:T))
        (CL:LET* ((ELTX NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
         (CL:LOOP WHILE (NEXT? ITER-000) DO
          (CL:SETQ ELTX (%LIST-ITERATOR.VALUE ITER-000))
          (CL:LET* ((TEST-VALUE-001 CL:NIL))
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((ELTY NULL) (ITER-001 (ALLOCATE-ITERATOR Y)))
             (CL:LOOP WHILE (NEXT? ITER-001) DO
              (CL:SETQ ELTY (%LIST-ITERATOR.VALUE ITER-001))
              (CL:WHEN (EQUAL? ELTX ELTY) (CL:SETQ FOUND?-000 CL:T)
               (CL:RETURN))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000))
           (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001))
           (CL:WHEN TEST-VALUE-001 (CL:SETQ ALWAYS?-000 CL:NIL)
            (CL:RETURN)))))
        (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
      (CL:LET* ((VALUE-000 TEST-VALUE-000))
       (CL:RETURN-FROM OBJECT-EQUAL? VALUE-000)))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF SET))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  (CL:LET* ((CURSOR (%SET.THE-CONS-LIST SELF)) (CODE 95880665))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LOOP (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN))
    (CL:SETQ CODE
     (CL:THE CL:FIXNUM
      (CL:LOGXOR CODE
       (CL:THE CL:FIXNUM (SAFE-EQUAL-HASH-CODE (%%VALUE CURSOR))))))
    (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFUN (SET SET) ...)

(CL:DEFUN SET (CL:&REST VALUES)
  "Return a set containing `values', in order."
  (CL:LET* ((SET (NEW-SET)))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:WHEN (CL:NOT (MEMBER? SET V))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
        (CL:IF (CL:EQ (%SET.THE-CONS-LIST SET) NIL)
         (CL:SETF (%SET.THE-CONS-LIST SET) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%SET.THE-CONS-LIST SET)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:RETURN-FROM SET SET)))

;;; (DEFMETHOD PRINT-VECTOR ...)

(CL:DEFMETHOD PRINT-VECTOR ((SELF VECTOR) STREAM)
  (CL:IF (CL:= (LENGTH SELF) 0) (%%PRINT-STREAM STREAM "|i|[]")
   (CL:LET* ((I 0) (LIMIT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM I LIMIT))
    (%%PRINT-STREAM STREAM "|i|[")
    (CL:LET*
     ((ELEMENT NULL) (VECTOR-000 SELF) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ELEMENT
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
        INDEX-000))
      (%%PRINT-STREAM STREAM ELEMENT) (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))
      (CL:WHEN (CL:< I (LENGTH SELF)) (%%PRINT-STREAM STREAM " "))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:IF (CL:OR (CL:<= I LIMIT) (CL:= I (LENGTH SELF)))
     (%%PRINT-STREAM STREAM "]") (%%PRINT-STREAM STREAM " ...]"))))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF VECTOR))
  "Return `true' if `self' has length 0."
  (CL:RETURN-FROM EMPTY? (CL:= (%VECTOR.ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF VECTOR))
  "Return `true' if `self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY? (> (%VECTOR.ARRAY-SIZE SELF) 0)))

;;; (DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST ((SELF VECTOR))
  (CL:RETURN-FROM FIRST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0)))

;;; (DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND ((SELF VECTOR))
  (CL:RETURN-FROM SECOND
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 1)))

;;; (DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD ((SELF VECTOR))
  (CL:RETURN-FROM THIRD
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 2)))

;;; (DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH ((SELF VECTOR))
  (CL:RETURN-FROM FOURTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 3)))

;;; (DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH ((SELF VECTOR))
  (CL:RETURN-FROM FIFTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 4)))

;;; (DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH ((SELF VECTOR) POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
    POSITION)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF VECTOR))
  "Return the last item in the vector `self'."
  (CL:RETURN-FROM LAST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:1- (%VECTOR.ARRAY-SIZE SELF))))))

;;; (DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIRST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIRST-SETTER
   (CL:LET ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD SECOND-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM SECOND-SETTER
   (CL:LET ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD THIRD-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM THIRD-SETTER
   (CL:LET ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION 2))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FOURTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FOURTH-SETTER
   (CL:LET ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION 3))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FIFTH-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM FIFTH-SETTER
   (CL:LET ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION 4))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF VECTOR) VALUE POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH-SETTER
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION POSITION))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF VECTOR) VALUE)
  (CL:RETURN-FROM LAST-SETTER
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION (CL:1- (%VECTOR.ARRAY-SIZE SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR))
  (CL:RETURN-FROM LENGTH (%VECTOR.ARRAY-SIZE SELF)))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF VECTOR) OBJECT)
  (CL:LET* ((ARRAY (%VECTOR.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:WHEN (EQL? (CL:AREF ARRAY I) OBJECT)
      (CL:RETURN-FROM MEMBER? CL:T))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM MEMBER? CL:NIL)))

;;; (DEFMETHOD (POSITION INTEGER) ...)

(CL:DEFMETHOD POSITION ((SELF VECTOR) OBJECT START)
  "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only 
consider the portion starting at `start', however, the returned position 
will always be relative to the entire vector."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  (CL:WHEN (CL:= START NULL-INTEGER) (CL:SETQ START 0))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 START)
    (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
    (CL:SETQ I ITER-000)
    (CL:WHEN
     (EQL?
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) I)
      OBJECT)
     (CL:RETURN-FROM POSITION I))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (CL:RETURN-FROM POSITION NULL-INTEGER))

;;; (DEFMETHOD (LAST-POSITION INTEGER) ...)

(CL:DEFMETHOD LAST-POSITION ((SELF VECTOR) OBJECT END)
  "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only 
consider the portion ending at index `end', however, the returned position 
will always be relative to the entire vector."
  (CL:DECLARE (CL:TYPE CL:FIXNUM END))
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:WHEN (CL:= END NULL-INTEGER) (CL:SETQ END (CL:1- (LENGTH SELF))))
  (CL:LET* ((I NULL-INTEGER) (ITER-000 (REVERSE (INTERVAL 0 END))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ I (%REVERSE-INTEGER-INTERVAL-ITERATOR.VALUE ITER-000))
    (CL:WHEN
     (EQL?
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) I)
      OBJECT)
     (CL:RETURN-FROM LAST-POSITION I))))
  (CL:RETURN-FROM LAST-POSITION NULL-INTEGER))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%VECTOR.ARRAY-SIZE SELF))
   (CL:ERROR (NEW-STELLA-EXCEPTION "Out-of-bounds array access")))
  (CL:LET
   ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF VECTOR))
  "Return a copy of the vector `self'."
  (CL:LET*
   ((SIZE (%VECTOR.ARRAY-SIZE SELF))
    (SOURCEARRAY (%VECTOR.THE-ARRAY SELF)) (COPY (NEW-VECTOR SIZE))
    (COPYARRAY (%VECTOR.THE-ARRAY COPY)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE)
    (CL:TYPE CL:SIMPLE-VECTOR SOURCEARRAY COPYARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF COPYARRAY) (VALUE (CL:AREF SOURCEARRAY I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF VECTOR))
  (CL:LET*
   ((SIZE (%VECTOR.ARRAY-SIZE SELF)) (ARRAY (%VECTOR.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE)
    (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

;;; (DEFUN (VECTOR VECTOR) ...)

(CL:DEFUN VECTOR (CL:&REST VALUES)
  "Return a vector containing `values', in order."
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:LENGTH VALUES))))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%VECTOR.THE-ARRAY VECTOR)) (VALUE V) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:RETURN-FROM VECTOR VECTOR)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X VECTOR) Y)
  "Return TRUE iff the vectors `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-VECTOR)
    (CL:PROGN
     (CL:WHEN (CL:= (%VECTOR.ARRAY-SIZE X) (%VECTOR.ARRAY-SIZE Y))
      (CL:LET*
       ((ELTX NULL) (VECTOR-000 X) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (ELTY NULL) (VECTOR-001 Y)
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000)
         (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:SETQ ELTX
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ ELTY
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (CL:NOT (EQUAL? ELTX ELTY))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF VECTOR))
  "Return an `equal?' hash code for `self'."
  (CL:LET* ((CURSOR (LENGTH SELF)) (CODE 66435053))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR CODE))
   (CL:LOOP
    (CL:IF (CL:= CURSOR 0) (CL:RETURN) (CL:SETQ CURSOR (CL:1- CURSOR)))
    (CL:SETQ CODE
     (CL:THE CL:FIXNUM
      (CL:LOGXOR CODE
       (CL:THE CL:FIXNUM
        (SAFE-EQUAL-HASH-CODE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
          CURSOR))))))
    (CL:SETQ CODE
     (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CODE 1)) 0)
      (CL:LET ((ARG CODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
       (CL:THE CL:FIXNUM
        (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
         *INTEGER-UNSIGNED-BITS-MASK*)))
      (CL:THE CL:FIXNUM
       (CL:LOGIOR
        (CL:THE CL:FIXNUM
         (CL:LET ((ARG CODE) (COUNT 1))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
          (CL:THE CL:FIXNUM
           (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
        *INTEGER-MSB-MASK*)))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%EXTENSIBLE-VECTOR.ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%EXTENSIBLE-VECTOR.ARRAY-SIZE SELF)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET
   ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  :VOID)

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) OFFSET VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:WHEN (CL:>= OFFSET (%EXTENSIBLE-SYMBOL-ARRAY.ARRAY-SIZE SELF))
   (CL:LET* ((SIZE (%EXTENSIBLE-SYMBOL-ARRAY.ARRAY-SIZE SELF)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
    (CL:LOOP WHILE (CL:>= OFFSET SIZE) DO (CL:SETQ SIZE (CL:* 2 SIZE)))
    (RESIZE-VECTOR SELF SIZE)))
  (CL:LET
   ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  (CL:WHEN
   (CL:> OFFSET (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET SELF))
   (CL:SETF (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET SELF) OFFSET))
  :VOID)

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF VECTOR-SEQUENCE))
  "Return `true' if `self' has length 0."
  (CL:RETURN-FROM EMPTY?
   (CL:= (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF VECTOR-SEQUENCE))
  "Return `true' if `self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY?
   (> (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF) 0)))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM LENGTH (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF VECTOR-SEQUENCE))
  "Return the last item in the vector `self'."
  (CL:RETURN-FROM LAST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:1- (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF))))))

;;; (DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF VECTOR-SEQUENCE) VALUE)
  (CL:RETURN-FROM LAST-SETTER
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION (CL:1- (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) VALUE)
  "Append `value' to the END of the sequence `self'.  
Resize the array if necessary."
  (CL:LET* ((OLDLENGTH (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDLENGTH))
   (CL:WHEN (CL:= OLDLENGTH (%VECTOR-SEQUENCE.ARRAY-SIZE SELF))
    (RESIZE-VECTOR SELF (CL:* (%VECTOR-SEQUENCE.ARRAY-SIZE SELF) 2)))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION OLDLENGTH))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF) (CL:1+ OLDLENGTH)))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF CUSTOM-VECTOR-SEQUENCE) VALUE)
  "Append `value' to the END of the sequence `self'.  
Resize the array if necessary."
  (CL:LET* ((OLDLENGTH (%CUSTOM-VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDLENGTH))
   (CL:WHEN (CL:= OLDLENGTH (%CUSTOM-VECTOR-SEQUENCE.ARRAY-SIZE SELF))
    (CL:WHEN (CL:<= (%CUSTOM-VECTOR-SEQUENCE.RESIZE-FACTOR SELF) 1.0d0)
     (CL:ERROR
      "Safety violation: CUSTOM-VECTOR-SEQUENCE.insert: resize factor needs to be > 1"))
    (RESIZE-VECTOR SELF
     (CL:TRUNCATE
      (CL:* (%CUSTOM-VECTOR-SEQUENCE.ARRAY-SIZE SELF)
       (%CUSTOM-VECTOR-SEQUENCE.RESIZE-FACTOR SELF)))))
   (CL:LET
    ((SELF (%VECTOR.THE-ARRAY SELF)) (VALUE VALUE)
     (POSITION OLDLENGTH))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%CUSTOM-VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)
    (CL:1+ OLDLENGTH)))
  :VOID)

;;; (DEFMETHOD (REMOVE VECTOR-SEQUENCE) ...)

(CL:DEFMETHOD REMOVE ((SELF VECTOR-SEQUENCE) VALUE)
  "Remove `value' from the sequence `self', and left shift
the values after it to close the gap."
  (CL:LET*
   ((ARRAY (%VECTOR-SEQUENCE.THE-ARRAY SELF))
    (LENGTH (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)) (NHITS 0))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY)
    (CL:TYPE CL:FIXNUM LENGTH NHITS))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- LENGTH)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:COND
      ((EQL? (CL:AREF ARRAY I) VALUE) (CL:SETQ NHITS (CL:1+ NHITS)))
      ((CL:> NHITS 0)
       (CL:LET
        ((SELF ARRAY) (VALUE (CL:AREF ARRAY I))
         (POSITION (CL:- I NHITS)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF)
    (CL:- LENGTH NHITS))
   (CL:LET*
    ((I NULL-INTEGER)
     (ITER-001 (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF))
     (UPPER-BOUND-001 (CL:1- LENGTH)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-001)
     (CL:LET ((SELF ARRAY) (VALUE NULL) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:RETURN-FROM REMOVE SELF)))

;;; (DEFMETHOD (REVERSE (LIKE SELF)) ...)

(CL:DEFMETHOD REVERSE ((SELF VECTOR-SEQUENCE))
  "Reverse the order of elements in the active portion of `self'."
  (CL:LET*
   ((ARRAY (%VECTOR-SEQUENCE.THE-ARRAY SELF)) (BOTTOM 0)
    (TOP (CL:1- (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF))) (ELT NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY)
    (CL:TYPE CL:FIXNUM BOTTOM TOP))
   (CL:LOOP WHILE (CL:< BOTTOM TOP) DO
    (CL:SETQ ELT (CL:AREF ARRAY BOTTOM))
    (CL:LET
     ((SELF ARRAY) (VALUE (CL:AREF ARRAY TOP)) (POSITION BOTTOM))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET ((SELF ARRAY) (VALUE ELT) (POSITION TOP))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ BOTTOM (CL:1+ BOTTOM)) (CL:SETQ TOP (CL:1- TOP)))
   (CL:RETURN-FROM REVERSE SELF)))

;;; (DEFUN COPY-VECTOR-SEQUENCE ...)

(CL:DEFUN COPY-VECTOR-SEQUENCE (SOURCE COPY)
  (CL:LET*
   ((SOURCEARRAY (%VECTOR-SEQUENCE.THE-ARRAY SOURCE))
    (COPYARRAY (%VECTOR-SEQUENCE.THE-ARRAY COPY))
    (LENGTH (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SOURCE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SOURCEARRAY COPYARRAY)
    (CL:TYPE CL:FIXNUM LENGTH))
   (CL:SETF (%VECTOR-SEQUENCE.SEQUENCE-LENGTH COPY) LENGTH)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- LENGTH)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF COPYARRAY) (VALUE (CL:AREF SOURCEARRAY I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

;;; (DEFMETHOD (COPY (VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF VECTOR-SEQUENCE))
  "Return a copy of the vector sequence `self'."
  (CL:LET*
   ((COPY (NEW-VECTOR-SEQUENCE (%VECTOR-SEQUENCE.ARRAY-SIZE SELF))))
   (COPY-VECTOR-SEQUENCE SELF COPY) (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD (COPY (CUSTOM-VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF CUSTOM-VECTOR-SEQUENCE))
  "Return a copy of the vector sequence `self'."
  (CL:LET*
   ((COPY
     (NEW-CUSTOM-VECTOR-SEQUENCE
      (%CUSTOM-VECTOR-SEQUENCE.ARRAY-SIZE SELF))))
   (CL:SETF (%CUSTOM-VECTOR-SEQUENCE.RESIZE-FACTOR COPY)
    (%CUSTOM-VECTOR-SEQUENCE.RESIZE-FACTOR SELF))
   (COPY-VECTOR-SEQUENCE SELF COPY) (CL:RETURN-FROM COPY COPY)))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF VECTOR-SEQUENCE))
  "Clear `self' by setting its active length to zero."
  (CL:SETF (%VECTOR-SEQUENCE.SEQUENCE-LENGTH SELF) 0)
  :VOID)

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X VECTOR-SEQUENCE) Y)
  "Return TRUE iff the sequences `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y)
     SGT-COLLECTIONS-STELLA-VECTOR-SEQUENCE)
    (CL:PROGN
     (CL:WHEN
      (CL:= (%VECTOR-SEQUENCE.SEQUENCE-LENGTH X)
       (%VECTOR-SEQUENCE.SEQUENCE-LENGTH Y))
      (CL:LET*
       ((ELTX NULL) (VECTOR-000 X) (INDEX-000 0)
        (LENGTH-000 (%VECTOR-SEQUENCE.SEQUENCE-LENGTH VECTOR-000))
        (ELTY NULL) (VECTOR-001 Y) (INDEX-001 0)
        (LENGTH-001 (%VECTOR-SEQUENCE.SEQUENCE-LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000)
         (CL:< INDEX-001 LENGTH-001))
        DO
        (CL:SETQ ELTX
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ ELTY
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN (CL:NOT (EQUAL? ELTX ELTY))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF VECTOR))
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER ITERATOR)
    (LENGTH SELF))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR)))

;;; (DEFUN (VECTOR-NEXT? BOOLEAN) ...)

(CL:DEFUN VECTOR-NEXT? (SELF)
  (CL:LET* ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:WHEN
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF)
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY
        (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT SELF)))
      CURSOR))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
     (CL:1+ CURSOR))
    (CL:RETURN-FROM VECTOR-NEXT? CL:T))
   (CL:RETURN-FROM VECTOR-NEXT? CL:NIL)))

;;; (DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD BUT-LAST ((SELF VECTOR))
  "Generate all but the last element of the vector `self'."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR) SELF)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER ITERATOR)
    (CL:1- (%VECTOR.ARRAY-SIZE SELF)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION VECTOR-NEXT?))
   (CL:RETURN-FROM BUT-LAST ITERATOR)))

;;; (DEFMETHOD (SORT (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT ((SELF VECTOR) PREDICATE)
  "Perform a destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order.  If `predicate' is `null', a
suitable '<' predicate is chosen depending on the first element of `self',
and it is assumed that all elements of `self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (CL:LET* ((LENGTH (LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:COND ((CL:= LENGTH 0) (CL:RETURN-FROM SORT SELF))
    ((CL:EQ PREDICATE NULL)
     (CL:SETQ PREDICATE
      (CHOOSE-SORT-PREDICATE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
        0)))))
   (HEAP-SORT-NATIVE-VECTOR (%VECTOR.THE-ARRAY SELF) (LENGTH SELF)
    PREDICATE)
   (CL:RETURN-FROM SORT SELF)))

;;; (DEFMETHOD (SORT-TUPLES (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT-TUPLES ((SELF VECTOR) N PREDICATE)
  "Just like `sort' but assumes each element of `self' is a tuple (a cons)
whose `n'-th element (0-based) will be used for comparison."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET* ((LENGTH (LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:COND ((CL:= LENGTH 0) (CL:RETURN-FROM SORT-TUPLES SELF))
    ((CL:EQ PREDICATE NULL)
     (CL:SETQ PREDICATE
      (CHOOSE-SORT-PREDICATE
       (NTH
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0)
        N)))))
   (CL:LET*
    ((*SORT-TUPLE-COMPARE-PREDICATE* PREDICATE)
     (*SORT-TUPLE-COMPARE-INDEX* N))
    (CL:DECLARE
     (CL:SPECIAL *SORT-TUPLE-COMPARE-PREDICATE*
      *SORT-TUPLE-COMPARE-INDEX*))
    (CL:DECLARE (CL:TYPE CL:FIXNUM *SORT-TUPLE-COMPARE-INDEX*))
    (HEAP-SORT-NATIVE-VECTOR (%VECTOR.THE-ARRAY SELF) (LENGTH SELF)
     (CL:FUNCTION SORT-TUPLE-COMPARE?))
    (CL:RETURN-FROM SORT-TUPLES SELF))))

;;; (DEFMETHOD (SORT-OBJECTS (VECTOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT-OBJECTS ((SELF VECTOR) SLOT PREDICATE)
  "Just like `sort' but assumes each element of `self' has a `slot'
whose value will be used for comparison.  Elements must be descendants of
STANDARD OBJECT.  Note that while this will work with literal-valued slots,
it will cause value wrapping everytime `slot' is read."
  (CL:LET* ((LENGTH (LENGTH SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:COND ((CL:= LENGTH 0) (CL:RETURN-FROM SORT-OBJECTS SELF))
    ((CL:EQ PREDICATE NULL)
     (CL:SETQ PREDICATE
      (CHOOSE-SORT-PREDICATE
       (READ-SLOT-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0)
        SLOT)))))
   (CL:LET*
    ((*SORT-TUPLE-COMPARE-PREDICATE* PREDICATE)
     (*SORT-OBJECTS-COMPARE-SLOT* SLOT))
    (CL:DECLARE
     (CL:SPECIAL *SORT-TUPLE-COMPARE-PREDICATE*
      *SORT-OBJECTS-COMPARE-SLOT*))
    (HEAP-SORT-NATIVE-VECTOR (%VECTOR.THE-ARRAY SELF) (LENGTH SELF)
     (CL:FUNCTION SORT-OBJECTS-COMPARE?))
    (CL:RETURN-FROM SORT-OBJECTS SELF))))

;;; (DEFUN HEAP-SORT-NATIVE-VECTOR ...)

(CL:DEFUN HEAP-SORT-NATIVE-VECTOR (VECTOR SIZE PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VECTOR)
   (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE VECTOR CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (HEAP-SORT-HEAPIFY VECTOR SIZE PREDICATE)
  (CL:LET* ((END (CL:1- SIZE)) (AUX NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM END))
   (CL:LOOP WHILE (CL:> END 0) DO (CL:SETQ AUX (CL:AREF VECTOR 0))
    (CL:LET ((SELF VECTOR) (VALUE (CL:AREF VECTOR END)) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET ((SELF VECTOR) (VALUE AUX) (POSITION END))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ END (CL:1- END))
    (HEAP-SORT-SIFT-DOWN VECTOR 0 END PREDICATE)))
  :VOID)

;;; (DEFUN HEAP-SORT-HEAPIFY ...)

(CL:DEFUN HEAP-SORT-HEAPIFY (VECTOR SIZE PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VECTOR)
   (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE VECTOR CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((START
     (CL:1-
      (CL:LET ((ARG SIZE) (COUNT 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
       (CL:THE CL:FIXNUM
        (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START))
   (CL:LOOP WHILE (CL:>= START 0) DO
    (HEAP-SORT-SIFT-DOWN VECTOR START (CL:1- SIZE) PREDICATE)
    (CL:SETQ START (CL:1- START))))
  :VOID)

;;; (DEFUN HEAP-SORT-SIFT-DOWN ...)

(CL:DEFUN HEAP-SORT-SIFT-DOWN (VECTOR START END PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VECTOR)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE VECTOR CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET* ((ROOT START) (CHILD 0) (AUX NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ROOT CHILD))
   (CL:LOOP (CL:SETQ CHILD (CL:1+ (CL:THE CL:FIXNUM (CL:ASH ROOT 1))))
    (CL:WHEN (CL:> CHILD END) (CL:RETURN))
    (CL:WHEN
     (CL:AND (CL:< CHILD END)
      (CL:FUNCALL PREDICATE (CL:AREF VECTOR CHILD)
       (CL:AREF VECTOR (CL:THE CL:FIXNUM (CL:1+ CHILD)))))
     (CL:SETQ CHILD (CL:1+ CHILD)))
    (CL:COND
     ((CL:FUNCALL PREDICATE (CL:AREF VECTOR ROOT)
       (CL:AREF VECTOR CHILD))
      (CL:SETQ AUX (CL:AREF VECTOR ROOT))
      (CL:LET
       ((SELF VECTOR) (VALUE (CL:AREF VECTOR CHILD)) (POSITION ROOT))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET ((SELF VECTOR) (VALUE AUX) (POSITION CHILD))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ROOT CHILD))
     (CL:T (CL:RETURN-FROM HEAP-SORT-SIFT-DOWN)))))
  :VOID)

;;; (DEFUN (QUICK-SORT-PICK-SPLIT-ELEMENT OBJECT) ...)

(CL:DEFUN QUICK-SORT-PICK-SPLIT-ELEMENT (VECTOR START END PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VECTOR)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE VECTOR CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET*
   ((SPLITELEMENT (CL:AREF VECTOR START))
    (MIDDLE
     (CL:LET ((ARG (CL:+ START END)) (COUNT 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
      (CL:THE CL:FIXNUM
       (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MIDDLE)) (CL:SETQ END (CL:1- END))
   (CL:IF (CL:FUNCALL PREDICATE SPLITELEMENT (CL:AREF VECTOR MIDDLE))
    (CL:COND
     ((CL:FUNCALL PREDICATE (CL:AREF VECTOR MIDDLE)
       (CL:AREF VECTOR END))
      (CL:SETQ SPLITELEMENT (CL:AREF VECTOR MIDDLE))
      (CL:LET
       ((SELF VECTOR) (VALUE (CL:AREF VECTOR START)) (POSITION MIDDLE))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     ((CL:FUNCALL PREDICATE SPLITELEMENT (CL:AREF VECTOR END))
      (CL:SETQ SPLITELEMENT (CL:AREF VECTOR END))
      (CL:LET
       ((SELF VECTOR) (VALUE (CL:AREF VECTOR START)) (POSITION END))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:T))
    (CL:COND ((CL:FUNCALL PREDICATE SPLITELEMENT (CL:AREF VECTOR END)))
     ((CL:FUNCALL PREDICATE (CL:AREF VECTOR MIDDLE)
       (CL:AREF VECTOR END))
      (CL:SETQ SPLITELEMENT (CL:AREF VECTOR END))
      (CL:LET
       ((SELF VECTOR) (VALUE (CL:AREF VECTOR START)) (POSITION END))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:T (CL:SETQ SPLITELEMENT (CL:AREF VECTOR MIDDLE))
      (CL:LET
       ((SELF VECTOR) (VALUE (CL:AREF VECTOR START)) (POSITION MIDDLE))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))))
   (CL:RETURN-FROM QUICK-SORT-PICK-SPLIT-ELEMENT SPLITELEMENT)))

;;; (DEFUN QUICK-SORT-NATIVE-VECTOR ...)

(CL:DEFUN QUICK-SORT-NATIVE-VECTOR (VECTOR START END PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VECTOR)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE VECTOR CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LOOP
   (CL:LET*
    ((LENGTH (CL:- END START)) (SPLITELEMENT NULL) (ELEMENT NULL)
     (LOWCURSOR START) (HIGHCURSOR END))
    (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH LOWCURSOR HIGHCURSOR))
    (CL:COND
     ((CL:<= LENGTH 1) (CL:RETURN-FROM QUICK-SORT-NATIVE-VECTOR))
     ((CL:>= LENGTH 10)
      (CL:SETQ SPLITELEMENT
       (QUICK-SORT-PICK-SPLIT-ELEMENT VECTOR START END PREDICATE)))
     (CL:T (CL:SETQ SPLITELEMENT (CL:AREF VECTOR START))))
    (CL:LOOP WHILE (CL:< LOWCURSOR HIGHCURSOR) DO
     (CL:LOOP WHILE (CL:< LOWCURSOR HIGHCURSOR) DO
      (CL:SETQ HIGHCURSOR (CL:1- HIGHCURSOR))
      (CL:SETQ ELEMENT (CL:AREF VECTOR HIGHCURSOR))
      (CL:WHEN (CL:FUNCALL PREDICATE ELEMENT SPLITELEMENT)
       (CL:LET ((SELF VECTOR) (VALUE ELEMENT) (POSITION LOWCURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:RETURN)))
     (CL:LOOP WHILE (CL:< LOWCURSOR HIGHCURSOR) DO
      (CL:SETQ LOWCURSOR (CL:1+ LOWCURSOR))
      (CL:SETQ ELEMENT (CL:AREF VECTOR LOWCURSOR))
      (CL:WHEN (CL:FUNCALL PREDICATE SPLITELEMENT ELEMENT)
       (CL:LET ((SELF VECTOR) (VALUE ELEMENT) (POSITION HIGHCURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:RETURN))))
    (CL:LET ((SELF VECTOR) (VALUE SPLITELEMENT) (POSITION HIGHCURSOR))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:COND
     ((CL:<
       (CL:LET ((ARG (CL:+ START END)) (COUNT 1))
        (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
        (CL:THE CL:FIXNUM
         (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))
       HIGHCURSOR)
      (QUICK-SORT-NATIVE-VECTOR VECTOR (CL:1+ HIGHCURSOR) END
       PREDICATE)
      (CL:SETQ END HIGHCURSOR))
     (CL:T (QUICK-SORT-NATIVE-VECTOR VECTOR START HIGHCURSOR PREDICATE)
      (CL:SETQ START (CL:1+ HIGHCURSOR))))))
  :VOID)

(CL:DEFUN NEW-HEAP (PREDICATE ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-HEAP))
   (CL:SETF (%HEAP.PREDICATE SELF) PREDICATE)
   (CL:SETF (%HEAP.ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%HEAP.THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%HEAP.FILL-POINTER SELF) 0) (INITIALIZE-VECTOR SELF)
   (INITIALIZE-HEAP SELF) (CL:RETURN-FROM NEW-HEAP SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HEAP))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-HEAP))

(CL:DEFUN ACCESS-HEAP-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-PREDICATE)
    (CL:IF SETVALUE?
     (CL:SETF (%HEAP.PREDICATE SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%HEAP.PREDICATE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-FILL-POINTER)
    (CL:IF SETVALUE?
     (CL:SETF (%HEAP.FILL-POINTER SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%HEAP.FILL-POINTER SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-HEAP-SLOT-VALUE VALUE))

;;; (DEFMETHOD INITIALIZE-HEAP ...)

(CL:DEFMETHOD INITIALIZE-HEAP ((SELF HEAP))
  (CL:LET* ((SIZE (%HEAP.ARRAY-SIZE SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
   (CL:WHEN (CL:<= SIZE 0)
    (CL:ERROR "Safety violation: Trying to create an empty heap")))
  :VOID)

;;; (DEFMETHOD (COPY (HEAP OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD COPY ((SELF HEAP))
  "Return a copy of the heap `self'."
  (CL:LET* ((LENGTH (%HEAP.FILL-POINTER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:LET*
    ((SELF-000
      (NEW-HEAP (%HEAP.PREDICATE SELF) (%HEAP.ARRAY-SIZE SELF))))
    (CL:SETF (%HEAP.FILL-POINTER SELF-000) LENGTH)
    (CL:LET*
     ((COPY SELF-000) (SOURCEARRAY (%HEAP.THE-ARRAY SELF))
      (COPYARRAY (%HEAP.THE-ARRAY COPY)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SOURCEARRAY COPYARRAY))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- LENGTH)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
       (CL:SETQ I ITER-000)
       (CL:LET
        ((SELF COPYARRAY) (VALUE (CL:AREF SOURCEARRAY I)) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (CL:RETURN-FROM COPY COPY)))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF HEAP))
  "Clear `self' by setting its active length to zero."
  (CL:SETF (%HEAP.FILL-POINTER SELF) 0)
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF HEAP))
  "Return the length of the currently filled portion of `self'."
  (CL:RETURN-FROM LENGTH (%HEAP.FILL-POINTER SELF)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF HEAP))
  "Return TRUE if `self' is empty."
  (CL:RETURN-FROM EMPTY? (CL:= (%HEAP.FILL-POINTER SELF) 0)))

;;; (DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LAST ((SELF HEAP))
  "Return the last item in the heap `self' which will be the
largest or best item if `self' is a sorted min-heap with a '<' predicate."
  (CL:RETURN-FROM LAST
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:1- (LENGTH SELF))))))

;;; (DEFMETHOD (HEAP-ROOT (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD HEAP-ROOT ((SELF HEAP))
  "Return the root of `self' (NULL if `self' is empty).
The root contains the minimum element of a min-heap with '<' predicate."
  (CL:RETURN-FROM HEAP-ROOT
   (CL:IF (EMPTY? SELF) NULL
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0))))

;;; (DEFMETHOD (FAST-HEAP-ROOT (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD FAST-HEAP-ROOT ((SELF HEAP))
  "Return the root of `self' which is assumed to be non-empty."
  (CL:RETURN-FROM FAST-HEAP-ROOT
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0)))

;;; (DEFUN HEAP-SIFT-UP ...)

(CL:DEFUN HEAP-SIFT-UP (HEAP START END VALUE PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR HEAP)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE HEAP CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET* ((PARENT NULL-INTEGER) (CHILD END))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARENT CHILD))
   (CL:LET ((SELF HEAP) (VALUE VALUE) (POSITION END))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LOOP WHILE (CL:> CHILD START) DO
    (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND CHILD 1)) 0)
     (CL:SETQ PARENT
      (CL:LET ((ARG (CL:- CHILD 2)) (COUNT 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
       (CL:THE CL:FIXNUM
        (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
     (CL:SETQ PARENT
      (CL:LET ((ARG (CL:1- CHILD)) (COUNT 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
       (CL:THE CL:FIXNUM
        (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
    (CL:COND
     ((CL:FUNCALL PREDICATE VALUE (CL:AREF HEAP PARENT))
      (CL:LET
       ((SELF HEAP) (VALUE (CL:AREF HEAP PARENT)) (POSITION CHILD))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET ((SELF HEAP) (VALUE VALUE) (POSITION PARENT))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ CHILD PARENT))
     (CL:T (CL:RETURN)))))
  :VOID)

;;; (DEFUN HEAP-SIFT-DOWN ...)

(CL:DEFUN HEAP-SIFT-DOWN (HEAP START END VALUE PREDICATE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR HEAP)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE HEAP CL:SIMPLE-VECTOR)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET*
   ((PARENT START) (CHILD NULL-INTEGER) (LEFTCHILD NULL)
    (RIGHTCHILD NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARENT CHILD))
   (CL:LET ((SELF HEAP) (VALUE VALUE) (POSITION START))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETQ END (CL:1- END))
   (CL:LOOP
    (CL:SETQ CHILD (CL:1+ (CL:THE CL:FIXNUM (CL:ASH PARENT 1))))
    (CL:COND ((CL:> CHILD END) (CL:RETURN))
     ((CL:= CHILD END)
      (CL:WHEN
       (CL:NOT (CL:FUNCALL PREDICATE (CL:AREF HEAP CHILD) VALUE))
       (CL:RETURN)))
     (CL:T (CL:SETQ LEFTCHILD (CL:AREF HEAP CHILD))
      (CL:SETQ RIGHTCHILD
       (CL:AREF HEAP (CL:THE CL:FIXNUM (CL:1+ CHILD))))
      (CL:COND
       ((CL:FUNCALL PREDICATE LEFTCHILD VALUE)
        (CL:WHEN
         (CL:AND (CL:FUNCALL PREDICATE RIGHTCHILD VALUE)
          (CL:FUNCALL PREDICATE RIGHTCHILD LEFTCHILD))
         (CL:SETQ CHILD (CL:1+ CHILD))))
       ((CL:FUNCALL PREDICATE RIGHTCHILD VALUE)
        (CL:SETQ CHILD (CL:1+ CHILD)))
       (CL:T (CL:RETURN)))))
    (CL:LET
     ((SELF HEAP) (VALUE (CL:AREF HEAP CHILD)) (POSITION PARENT))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET ((SELF HEAP) (VALUE VALUE) (POSITION CHILD))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ PARENT CHILD)))
  :VOID)

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF HEAP) VALUE)
  "Insert `value' into `self' and restore the heap property.
Signal an error if there is no more room in `self'.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap."
  (CL:LET*
   ((VALUES (%HEAP.THE-ARRAY SELF))
    (FILLPOINTER (%HEAP.FILL-POINTER SELF))
    (PREDICATE (%HEAP.PREDICATE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VALUES)
    (CL:TYPE CL:FIXNUM FILLPOINTER))
   (CL:COND
    ((CL:< FILLPOINTER (%HEAP.ARRAY-SIZE SELF))
     (HEAP-SIFT-UP VALUES 0 FILLPOINTER VALUE PREDICATE)
     (CL:SETF (%HEAP.FILL-POINTER SELF) (CL:1+ FILLPOINTER)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "HEAP.insert: heap overflow, can't insert new value: `" VALUE
       "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  :VOID)

;;; (DEFMETHOD REPLACE-HEAP-ROOT ...)

(CL:DEFMETHOD REPLACE-HEAP-ROOT ((SELF HEAP) VALUE)
  "Replace the current root of `self' with `value' and restore
the heap property.  Signal an error if `self' is empty.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap."
  (CL:LET*
   ((VALUES (%HEAP.THE-ARRAY SELF))
    (FILLPOINTER (%HEAP.FILL-POINTER SELF))
    (PREDICATE (%HEAP.PREDICATE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VALUES)
    (CL:TYPE CL:FIXNUM FILLPOINTER))
   (CL:IF (CL:= FILLPOINTER 0)
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "HEAP.replace-heap-root: can't replace root of an empty heap"))
    (HEAP-SIFT-DOWN VALUES 0 FILLPOINTER VALUE PREDICATE)))
  :VOID)

;;; (DEFMETHOD INSERT-IF-BETTER ...)

(CL:DEFMETHOD INSERT-IF-BETTER ((SELF HEAP) VALUE)
  "Insert `value' into `self' and restore the heap property.
If `self' has available room, simply insert `value'.  If the heap is full, only
insert `value' if it is better than the current root (i.e., if `value' is
greater than the minimum of `self' for the case of a min-heap where `self's
`predicate' has `<' semantics).  In that case, replace the root of `self'
and restore the heap property.  This is useful to build and maintain a
heap with some top-N elements (relative to `predicate') where the root (or
minimum) of `self' is the currently weakest element at the end of the list."
  (CL:LET*
   ((VALUES (%HEAP.THE-ARRAY SELF))
    (FILLPOINTER (%HEAP.FILL-POINTER SELF))
    (PREDICATE (%HEAP.PREDICATE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VALUES)
    (CL:TYPE CL:FIXNUM FILLPOINTER))
   (CL:COND
    ((CL:= FILLPOINTER (%HEAP.ARRAY-SIZE SELF))
     (CL:WHEN
      (CL:FUNCALL PREDICATE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SELF)) 0)
       VALUE)
      (HEAP-SIFT-DOWN VALUES 0 FILLPOINTER VALUE PREDICATE)))
    (CL:T (HEAP-SIFT-UP VALUES 0 FILLPOINTER VALUE PREDICATE)
     (CL:SETF (%HEAP.FILL-POINTER SELF) (CL:1+ FILLPOINTER)))))
  :VOID)

;;; (DEFMETHOD HEAPIFY ...)

(CL:DEFMETHOD HEAPIFY ((SELF HEAP))
  "Restore the heap property of `self' according to its
`predicate'.  Normally, this is not needed, since insert operations
preserve the heap property.  However, this can be useful after bulk
insertion of values or if `predicate' has been changed."
  (CL:LET*
   ((VALUES (%HEAP.THE-ARRAY SELF))
    (FILLPOINTER (%HEAP.FILL-POINTER SELF))
    (PREDICATE (%HEAP.PREDICATE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VALUES)
    (CL:TYPE CL:FIXNUM FILLPOINTER))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- FILLPOINTER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (HEAP-SIFT-UP VALUES 0 I (CL:AREF VALUES I) PREDICATE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

;;; (DEFMETHOD (SORT (HEAP OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD SORT ((SELF HEAP) PREDICATE)
  "Sort the heap `self' according to `predicate' (in
ascending order if `predicate' has `<' semantics).  If `predicate'
is NULL simply use `self's internal predicate (the normal case).
If it is different from `self's internal predicate, heapify `self' first
according to the new predicate, store the new predicate in `self' and
then sort the heap.  Note that a sorted array automatically satisfies
the heap property.  This is slightly different than a regular heap
sort due to the way HEAP's are maintained; however, the complexity is
the same."
  (CL:LET*
   ((VALUES (%HEAP.THE-ARRAY SELF)) (CURSOR (%HEAP.FILL-POINTER SELF))
    (VALUE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR VALUES)
    (CL:TYPE CL:FIXNUM CURSOR))
   (CL:COND
    ((CL:EQ PREDICATE NULL) (CL:SETQ PREDICATE (%HEAP.PREDICATE SELF)))
    ((CL:NOT (CL:EQL PREDICATE (%HEAP.PREDICATE SELF)))
     (CL:SETF (%HEAP.PREDICATE SELF) PREDICATE) (HEAPIFY SELF)))
   (CL:LOOP WHILE (CL:> CURSOR 0) DO (CL:SETQ CURSOR (CL:1- CURSOR))
    (CL:SETQ VALUE (CL:AREF VALUES CURSOR))
    (CL:LET
     ((SELF VALUES) (VALUE (CL:AREF VALUES 0)) (POSITION CURSOR))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (HEAP-SIFT-DOWN VALUES 0 CURSOR VALUE PREDICATE))
   (CL:SETQ CURSOR (%HEAP.FILL-POINTER SELF))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000))
    (CL:LOOP WHILE CL:T DO (CL:SETQ I ITER-000)
     (CL:SETQ CURSOR (CL:1- CURSOR))
     (CL:WHEN (CL:>= I CURSOR) (CL:RETURN))
     (CL:SETQ VALUE (CL:AREF VALUES I))
     (CL:LET
      ((SELF VALUES) (VALUE (CL:AREF VALUES CURSOR)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET ((SELF VALUES) (VALUE VALUE) (POSITION CURSOR))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM SORT SELF)))

;;; (DEFGLOBAL *USE-STELLA-HASH-TABLES?* ...)

(CL:DEFVAR *USE-STELLA-HASH-TABLES?* CL-USER::*use-stella-hash-tables?*)

(CL:DEFUN NEW-STELLA-HASH-TABLE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-STELLA-HASH-TABLE))
   (CL:SETF (%STELLA-HASH-TABLE.THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%STELLA-HASH-TABLE.THE-HASH-TABLE SELF) NULL)
   (CL:SETF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF) CL:NIL)
   (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF) NULL-INTEGER)
   (CL:SETF (%STELLA-HASH-TABLE.INITIAL-SIZE SELF) 50)
   (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF) NULL-INTEGER)
   (CL:SETF (%STELLA-HASH-TABLE.THE-TABLE SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-STELLA-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE))

(CL:DEFUN ACCESS-STELLA-HASH-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%STELLA-HASH-TABLE.SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-INITIAL-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE.INITIAL-SIZE SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%STELLA-HASH-TABLE.INITIAL-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-FREE-ELEMENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-EQUAL-TEST?)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STELLA-HASH-TABLE-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* ...)

(CL:DEFVAR *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* 1.0d0)
(CL:DECLAIM
 (CL:TYPE CL:DOUBLE-FLOAT *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))

;;; (DEFUN INITIALIZE-STELLA-HASH-TABLE ...)

(CL:DEFUN INITIALIZE-STELLA-HASH-TABLE (SELF)
  (CL:LET*
   ((SIZE
     (PICK-HASH-TABLE-SIZE-PRIME
      (FLOOR
       (CL:/ (%STELLA-HASH-TABLE.INITIAL-SIZE SELF)
        *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))))
    (TABLE (CL:MAKE-ARRAY SIZE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE)
    (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF TABLE I) NULL)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%STELLA-HASH-TABLE.THE-TABLE SELF) TABLE)
   (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF) SIZE)
   (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
    (FLOOR (CL:* SIZE *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*))))
  :VOID)

;;; (DEFMETHOD INITIALIZE-HASH-TABLE ...)

(CL:DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STELLA-HASH-TABLE))
  "Initialize the STELLA hash table `self'.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation."
  :VOID)

;;; (DEFUN REHASH-STELLA-HASH-TABLE ...)

(CL:DEFUN REHASH-STELLA-HASH-TABLE (SELF NEWSIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NEWSIZE))
  #+MCL
  (CL:CHECK-TYPE NEWSIZE CL:FIXNUM)
  (CL:WHEN (NULL-ARRAY? (%STELLA-HASH-TABLE.THE-TABLE SELF))
   (INITIALIZE-STELLA-HASH-TABLE SELF)
   (CL:RETURN-FROM REHASH-STELLA-HASH-TABLE))
  (CL:LET*
   ((SIZE (%STELLA-HASH-TABLE.SIZE SELF))
    (TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF))
    (NEWTABLE (CL:MAKE-ARRAY NEWSIZE)) (NEWBUCKETINDEX 0)
    (NEWBUCKET NULL) (CURSOR NULL) (CURRENT NULL)
    (EQUALTEST? (%STELLA-HASH-TABLE.EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE NEWBUCKETINDEX)
    (CL:TYPE CL:SIMPLE-VECTOR TABLE NEWTABLE))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NEWSIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF NEWTABLE I) NULL)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-001) (CL:SETQ CURSOR (CL:AREF TABLE I))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
      (CL:IF EQUALTEST?
       (CL:SETQ NEWBUCKETINDEX
        (CL:LET
         ((CODE (EQUAL-HASH-CODE (%KV-CONS.KEY CURSOR)))
          (SIZE NEWSIZE))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM
            (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))
       (CL:SETQ NEWBUCKETINDEX
        (CL:LET
         ((CODE (HASH-CODE (%KV-CONS.KEY CURSOR))) (SIZE NEWSIZE))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM
            (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE)))))
      (CL:SETQ NEWBUCKET (CL:AREF NEWTABLE NEWBUCKETINDEX))
      (CL:SETQ CURRENT CURSOR) (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))
      (CL:COND
       ((CL:NOT (CL:EQ NEWBUCKET NULL))
        (CL:SETF (%KV-CONS.REST CURRENT) (%KV-CONS.REST NEWBUCKET))
        (CL:SETF (%KV-CONS.REST NEWBUCKET) CURRENT))
       (CL:T (CL:SETF (CL:AREF NEWTABLE NEWBUCKETINDEX) CURRENT)
        (CL:SETF (%KV-CONS.REST CURRENT) NULL))))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETF (%STELLA-HASH-TABLE.THE-TABLE SELF) NEWTABLE)
   (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF) NEWSIZE)
   (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
    (MAX
     (CL:+ (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
      (FLOOR
       (CL:* (CL:- NEWSIZE SIZE)
        *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH*)))
     0)))
  :VOID)

;;; (DEFUN STELLA-HASH-TABLE-INSERT-AT ...)

(CL:DEFUN STELLA-HASH-TABLE-INSERT-AT (SELF KEY VALUE)
  (CL:LET*
   ((TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF))
    (FREE (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)) (BUCKETINDEX 0)
    (BUCKET NULL) (EQUALTEST? (%STELLA-HASH-TABLE.EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
    (CL:TYPE CL:FIXNUM FREE BUCKETINDEX))
   (CL:WHEN (NULL-ARRAY? TABLE) (INITIALIZE-STELLA-HASH-TABLE SELF)
    (CL:SETQ TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF))
    (CL:SETQ FREE (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
   (CL:WHEN (CL:= FREE 0)
    (REHASH-STELLA-HASH-TABLE SELF
     (PICK-HASH-TABLE-SIZE-PRIME
      (CL:1+ (%STELLA-HASH-TABLE.SIZE SELF))))
    (CL:SETQ TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF))
    (CL:SETQ FREE (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
   (CL:IF EQUALTEST?
    (CL:SETQ BUCKETINDEX
     (CL:LET
      ((CODE (EQUAL-HASH-CODE KEY))
       (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM
         (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE))))
    (CL:SETQ BUCKETINDEX
     (CL:LET
      ((CODE (HASH-CODE KEY)) (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM
         (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE)))))
   (CL:SETQ BUCKET (CL:AREF TABLE BUCKETINDEX))
   (CL:COND
    ((CL:EQ BUCKET NULL)
     (CL:LET* ((SELF-000 (NEW-KV-CONS)))
      (CL:SETF (%KV-CONS.KEY SELF-000) KEY)
      (CL:SETF (%KV-CONS.VALUE SELF-000) VALUE)
      (CL:SETF (CL:AREF TABLE BUCKETINDEX) SELF-000))
     (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF) (CL:1- FREE)))
    (CL:T
     (CL:LET* ((CURSOR BUCKET))
      (CL:COND
       (EQUALTEST?
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ CURSOR NULL))
          (CL:NOT (EQUAL? (%KV-CONS.KEY CURSOR) KEY)))
         DO (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))))
       (CL:T
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ CURSOR NULL))
          (CL:NOT (EQL? (%KV-CONS.KEY CURSOR) KEY)))
         DO (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))))
      (CL:COND
       ((CL:NOT (CL:EQ CURSOR NULL))
        (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE))
       (CL:T
        (CL:LET* ((SELF-001 (NEW-KV-CONS)))
         (CL:SETF (%KV-CONS.KEY SELF-001) KEY)
         (CL:SETF (%KV-CONS.VALUE SELF-001) VALUE)
         (CL:SETF (%KV-CONS.REST SELF-001) (%KV-CONS.REST BUCKET))
         (CL:SETF (%KV-CONS.REST BUCKET) SELF-001))
        (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
         (CL:1- FREE))))))))
  :VOID)

;;; (DEFUN STELLA-HASH-TABLE-REMOVE-AT ...)

(CL:DEFUN STELLA-HASH-TABLE-REMOVE-AT (SELF KEY)
  (CL:LET*
   ((TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF)) (BUCKETINDEX 0)
    (BUCKET NULL) (EQUALTEST? (%STELLA-HASH-TABLE.EQUAL-TEST? SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
    (CL:TYPE CL:FIXNUM BUCKETINDEX))
   (CL:WHEN (NULL-ARRAY? TABLE)
    (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
   (CL:IF EQUALTEST?
    (CL:SETQ BUCKETINDEX
     (CL:LET
      ((CODE (EQUAL-HASH-CODE KEY))
       (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM
         (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE))))
    (CL:SETQ BUCKETINDEX
     (CL:LET
      ((CODE (HASH-CODE KEY)) (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
      (CL:THE CL:FIXNUM
       (CL:REM
        (CL:THE CL:FIXNUM
         (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
        SIZE)))))
   (CL:SETQ BUCKET (CL:AREF TABLE BUCKETINDEX))
   (CL:COND
    ((CL:EQ BUCKET NULL) (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    ((CL:AND (CL:NOT EQUALTEST?) (EQL? (%KV-CONS.KEY BUCKET) KEY))
     (CL:SETF (CL:AREF TABLE BUCKETINDEX) (%KV-CONS.REST BUCKET))
     (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
      (CL:1+ (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
     (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    ((CL:AND EQUALTEST? (EQUAL? (%KV-CONS.KEY BUCKET) KEY))
     (CL:SETF (CL:AREF TABLE BUCKETINDEX) (%KV-CONS.REST BUCKET))
     (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
      (CL:1+ (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
     (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
    (CL:T
     (CL:LET* ((TRAILER BUCKET))
      (CL:SETQ BUCKET (%KV-CONS.REST BUCKET))
      (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
       (CL:COND
        ((CL:AND (CL:NOT EQUALTEST?) (EQL? (%KV-CONS.KEY BUCKET) KEY))
         (CL:SETF (%KV-CONS.REST TRAILER) (%KV-CONS.REST BUCKET))
         (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
          (CL:1+ (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
         (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
        ((CL:AND EQUALTEST? (EQUAL? (%KV-CONS.KEY BUCKET) KEY))
         (CL:SETF (%KV-CONS.REST TRAILER) (%KV-CONS.REST BUCKET))
         (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)
          (CL:1+ (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))
         (CL:RETURN-FROM STELLA-HASH-TABLE-REMOVE-AT))
        (CL:T (CL:SETQ TRAILER BUCKET)
         (CL:SETQ BUCKET (%KV-CONS.REST BUCKET)))))))))
  :VOID)

;;; (DEFUN (STELLA-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN STELLA-HASH-TABLE-LOOKUP (SELF KEY)
  (CL:LET* ((TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF)) (BUCKET NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:WHEN (NULL-ARRAY? TABLE)
    (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP NULL))
   (CL:COND
    ((%STELLA-HASH-TABLE.EQUAL-TEST? SELF)
     (CL:SETQ BUCKET
      (CL:AREF TABLE
       (CL:THE CL:FIXNUM
        (CL:LET
         ((CODE (EQUAL-HASH-CODE KEY))
          (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM
            (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
      (CL:IF (EQUAL? (%KV-CONS.KEY BUCKET) KEY)
       (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP
        (%KV-CONS.VALUE BUCKET))
       (CL:SETQ BUCKET (%KV-CONS.REST BUCKET)))))
    (CL:T
     (CL:SETQ BUCKET
      (CL:AREF TABLE
       (CL:THE CL:FIXNUM
        (CL:LET
         ((CODE (HASH-CODE KEY)) (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
         (CL:THE CL:FIXNUM
          (CL:REM
           (CL:THE CL:FIXNUM
            (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
           SIZE))))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
      (CL:IF (EQL? (%KV-CONS.KEY BUCKET) KEY)
       (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP
        (%KV-CONS.VALUE BUCKET))
       (CL:SETQ BUCKET (%KV-CONS.REST BUCKET))))))
   (CL:RETURN-FROM STELLA-HASH-TABLE-LOOKUP NULL)))

;;; (DEFUN (STELLA-STRING-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFUN STELLA-STRING-HASH-TABLE-LOOKUP (SELF KEY)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  #+MCL
  (CL:CHECK-TYPE KEY CL:SIMPLE-STRING)
  (CL:LET* ((TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF)) (BUCKET NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:WHEN (NULL-ARRAY? TABLE)
    (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP NULL))
   (CL:SETQ BUCKET
    (CL:AREF TABLE
     (CL:THE CL:FIXNUM
      (CL:LET
       ((CODE (CL:THE CL:FIXNUM (CL:SXHASH KEY)))
        (SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
       (CL:THE CL:FIXNUM
        (CL:REM
         (CL:THE CL:FIXNUM
          (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
         SIZE))))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ BUCKET NULL)) DO
    (CL:IF
     (STRING-EQL? (%STRING-WRAPPER.WRAPPER-VALUE (%KV-CONS.KEY BUCKET))
      KEY)
     (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP
      (%KV-CONS.VALUE BUCKET))
     (CL:SETQ BUCKET (%KV-CONS.REST BUCKET))))
   (CL:RETURN-FROM STELLA-STRING-HASH-TABLE-LOOKUP NULL)))

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF STELLA-HASH-TABLE) KEY)
  "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:RETURN-FROM LOOKUP (STELLA-HASH-TABLE-LOOKUP SELF KEY)))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF STELLA-HASH-TABLE) KEY VALUE)
  "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (STELLA-HASH-TABLE-INSERT-AT SELF KEY VALUE)
  (CL:RETURN-FROM INSERT-AT)
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF STELLA-HASH-TABLE) KEY)
  "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (STELLA-HASH-TABLE-REMOVE-AT SELF KEY)
  (CL:RETURN-FROM REMOVE-AT)
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF STELLA-HASH-TABLE))
  "Return the number of entries in `self'."
  (CL:IF (NULL-ARRAY? (%STELLA-HASH-TABLE.THE-TABLE SELF))
   (CL:RETURN-FROM LENGTH 0)
   (CL:RETURN-FROM LENGTH
    (CL:- (%STELLA-HASH-TABLE.SIZE SELF)
     (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF)))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF STELLA-HASH-TABLE))
  "Return TRUE if `self' has zero entries."
  (CL:RETURN-FROM EMPTY? (CL:= (LENGTH SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF STELLA-HASH-TABLE))
  "Return TRUE if `self' has at least 1 entry."
  (CL:RETURN-FROM NON-EMPTY? (> (LENGTH SELF) 0)))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF STELLA-HASH-TABLE))
  "Return a copy of the hash table `self'.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.)."
  (CL:LET* ((SIZE (%STELLA-HASH-TABLE.SIZE SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
   (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE)))
    (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF-000) SIZE)
    (CL:SETF (%STELLA-HASH-TABLE.INITIAL-SIZE SELF-000)
     (%STELLA-HASH-TABLE.INITIAL-SIZE SELF))
    (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF-000)
     (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF))
    (CL:SETF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF-000)
     (%STELLA-HASH-TABLE.EQUAL-TEST? SELF))
    (CL:LET*
     ((COPY SELF-000) (TABLE (%STELLA-HASH-TABLE.THE-TABLE SELF))
      (TABLECOPY TABLE) (BUCKET NULL))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE TABLECOPY))
     (CL:WHEN (CL:NOT (NULL-ARRAY? TABLE))
      (CL:SETQ TABLECOPY (CL:MAKE-ARRAY SIZE))
      (CL:SETF (%STELLA-HASH-TABLE.THE-TABLE COPY) TABLECOPY)
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000) (CL:SETQ BUCKET (CL:AREF TABLE I))
        (CL:IF (CL:NOT (CL:EQ BUCKET NULL))
         (CL:SETF (CL:AREF TABLECOPY I) (COPY-KV-CONS-LIST BUCKET))
         (CL:SETF (CL:AREF TABLECOPY I) NULL))
        (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
     (CL:RETURN-FROM COPY COPY)))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF STELLA-HASH-TABLE))
  "Remove all entries from `self'.  This will result in a
re-initialization of the table upon the first insertion into `self'."
  (CL:SETF (%STELLA-HASH-TABLE.THE-TABLE SELF) STELLA::NULL-1D-ARRAY)
  (CL:SETF (%STELLA-HASH-TABLE.SIZE SELF) NULL-INTEGER)
  (CL:SETF (%STELLA-HASH-TABLE.FREE-ELEMENTS SELF) NULL-INTEGER)
  :VOID)

;;; (DEFMETHOD (CONSIFY (CONS OF CONS)) ...)

(CL:DEFMETHOD CONSIFY ((SELF STELLA-HASH-TABLE))
  "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%STELLA-HASH-TABLE-ITERATOR.KEY ITER-000))
     (CL:SETQ VALUE (%STELLA-HASH-TABLE-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X STELLA-HASH-TABLE) Y)
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y)
     SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE)
    (CL:PROGN
     (CL:WHEN (CL:= (LENGTH X) (LENGTH Y))
      (CL:LET*
       ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ KEY (%STELLA-HASH-TABLE-ITERATOR.KEY ITER-000))
        (CL:SETQ VALUE (%STELLA-HASH-TABLE-ITERATOR.VALUE ITER-000))
        (CL:WHEN (CL:NOT (EQUAL? VALUE (LOOKUP Y KEY)))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF STELLA-HASH-TABLE))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  (CL:LET* ((CODE 36273463)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%STELLA-HASH-TABLE-ITERATOR.KEY ITER-000))
     (CL:SETQ VALUE (%STELLA-HASH-TABLE-ITERATOR.VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE KEY)))))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE VALUE)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

(CL:DEFUN NEW-STELLA-HASH-TABLE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-STELLA-HASH-TABLE-ITERATOR))
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.KEY SELF) NULL)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF) NULL)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF) 0)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-TABLE SELF)
    STELLA::NULL-1D-ARRAY)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.SIZE SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-STELLA-HASH-TABLE-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-HASH-TABLE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR))

(CL:DEFUN ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.SIZE SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%STELLA-HASH-TABLE-ITERATOR.SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUCKET-INDEX)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUCKET-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF STELLA-HASH-TABLE))
  "Allocate an iterator for `self'."
  (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE-ITERATOR)))
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.SIZE SELF-000)
    (%STELLA-HASH-TABLE.SIZE SELF))
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-TABLE SELF-000)
    (%STELLA-HASH-TABLE.THE-TABLE SELF))
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF-000) 0)
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF-000) NULL)
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM ALLOCATE-ITERATOR VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF STELLA-HASH-TABLE-ITERATOR))
  (CL:LET* ((CURSOR (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF)))
   (CL:COND
    ((%STELLA-HASH-TABLE-ITERATOR.FIRST-ITERATION? SELF)
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.FIRST-ITERATION? SELF)
      CL:NIL))
    ((CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))))
   (CL:WHEN (CL:EQ CURSOR NULL)
    (CL:LET*
     ((TABLE (%STELLA-HASH-TABLE-ITERATOR.BUCKET-TABLE SELF))
      (INDEX (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF))
      (SIZE (%STELLA-HASH-TABLE-ITERATOR.SIZE SELF)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE)
      (CL:TYPE CL:FIXNUM INDEX SIZE))
     (CL:WHEN (NULL-ARRAY? TABLE) (CL:RETURN-FROM NEXT? CL:NIL))
     (CL:LOOP WHILE (CL:AND (CL:EQ CURSOR NULL) (CL:< INDEX SIZE)) DO
      (CL:SETQ CURSOR (CL:AREF TABLE INDEX))
      (CL:SETQ INDEX (CL:1+ INDEX)))
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-INDEX SELF) INDEX)
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF)
      CURSOR)))
   (CL:COND
    ((CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.KEY SELF)
      (%KV-CONS.KEY CURSOR))
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.VALUE SELF)
      (%KV-CONS.VALUE CURSOR))
     (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF) CURSOR)
     (CL:RETURN-FROM NEXT? CL:T))
    (CL:T (CL:RETURN-FROM NEXT? CL:NIL)))))

;;; (DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD VALUE-SETTER ((SELF STELLA-HASH-TABLE-ITERATOR) VALUE)
  (CL:LET* ((CURSOR (%STELLA-HASH-TABLE-ITERATOR.BUCKET-CURSOR SELF)))
   (CL:WHEN (CL:NOT (CL:EQ CURSOR NULL))
    (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE))
   (CL:SETF (%STELLA-HASH-TABLE-ITERATOR.VALUE SELF) VALUE)
   (CL:RETURN-FROM VALUE-SETTER VALUE)))

;;; (DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ...)

(CL:DEFMETHOD KEY-SETTER ((SELF STELLA-HASH-TABLE-ITERATOR) KEY)
  (CL:ERROR
   (NEW-STELLA-EXCEPTION
    "Cannot change the key of a STELLA-HASH-TABLE item")))

;;; (DEFGLOBAL *KEY-VALUE-MAP-CROSSOVER-POINT* ...)

(CL:DEFVAR *KEY-VALUE-MAP-CROSSOVER-POINT* NULL-INTEGER
  "Point where we switch from using a KV-CONS table
representation to a STELLA hash table to preserve O(1) access.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *KEY-VALUE-MAP-CROSSOVER-POINT*))

(CL:DEFUN NEW-KEY-VALUE-MAP ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-KEY-VALUE-MAP))
   (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)
    *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%KEY-VALUE-MAP.INITIAL-SIZE SELF)
    *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%KEY-VALUE-MAP.EQUAL-TEST? SELF) CL:NIL)
   (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) NULL)
   (CL:RETURN-FROM NEW-KEY-VALUE-MAP SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEY-VALUE-MAP))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP))

(CL:DEFUN ACCESS-KEY-VALUE-MAP-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-THE-MAP)
    (CL:IF SETVALUE? (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) VALUE)
     (CL:SETQ VALUE (%KEY-VALUE-MAP.THE-MAP SELF))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-EQUAL-TEST?)
    (CL:IF SETVALUE?
     (CL:SETF (%KEY-VALUE-MAP.EQUAL-TEST? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%KEY-VALUE-MAP.EQUAL-TEST? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-INITIAL-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%KEY-VALUE-MAP.INITIAL-SIZE SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%KEY-VALUE-MAP.INITIAL-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-CROSSOVER-POINT)
    (CL:IF SETVALUE?
     (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KEY-VALUE-MAP-SLOT-VALUE VALUE))

;;; (DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD LOOKUP ((SELF KEY-VALUE-MAP) KEY)
  "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET*
   ((MAP (%KEY-VALUE-MAP.THE-MAP SELF))
    (CROSSOVER (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:COND
    ((CL:= CROSSOVER 0)
     (CL:RETURN-FROM LOOKUP (STELLA-HASH-TABLE-LOOKUP MAP KEY)))
    (CL:T
     (CL:LET* ((CURSOR MAP))
      (CL:IF (%KEY-VALUE-MAP.EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KV-CONS.KEY CURSOR) KEY)
         (CL:RETURN-FROM LOOKUP (%KV-CONS.VALUE CURSOR)))
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
         (CL:RETURN-FROM LOOKUP (%KV-CONS.VALUE CURSOR)))
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))))
      (CL:RETURN-FROM LOOKUP NULL))))))

;;; (DEFMETHOD INSERT-AT ...)

(CL:DEFMETHOD INSERT-AT ((SELF KEY-VALUE-MAP) KEY VALUE)
  "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET*
   ((MAP (%KEY-VALUE-MAP.THE-MAP SELF))
    (CROSSOVER (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:WHEN (CL:EQ MAP NULL)
    (CL:COND
     ((CL:> (%KEY-VALUE-MAP.INITIAL-SIZE SELF)
       *KEY-VALUE-MAP-CROSSOVER-POINT*)
      (CL:LET* ((SELF-000 (NEW-STELLA-HASH-TABLE)))
       (CL:SETF (%STELLA-HASH-TABLE.INITIAL-SIZE SELF-000)
        (%KEY-VALUE-MAP.INITIAL-SIZE SELF))
       (CL:SETF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF-000)
        (%KEY-VALUE-MAP.EQUAL-TEST? SELF))
       (CL:SETQ MAP SELF-000))
      (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) MAP)
      (CL:SETQ CROSSOVER 0))
     (CL:T (CL:SETQ CROSSOVER *KEY-VALUE-MAP-CROSSOVER-POINT*)))
    (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) CROSSOVER))
   (CL:COND
    ((CL:= CROSSOVER 0) (STELLA-HASH-TABLE-INSERT-AT MAP KEY VALUE))
    (CL:T
     (CL:LET* ((CURSOR MAP))
      (CL:IF (%KEY-VALUE-MAP.EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KV-CONS.KEY CURSOR) KEY)
         (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE)
         (CL:RETURN-FROM INSERT-AT))
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY)
         (CL:SETF (%KV-CONS.VALUE CURSOR) VALUE)
         (CL:RETURN-FROM INSERT-AT))
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))))
      (CL:SETQ CURSOR (KV-CONS KEY VALUE MAP))
      (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) CURSOR)
      (CL:SETQ CROSSOVER (CL:1- CROSSOVER))
      (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) CROSSOVER)
      (CL:WHEN (CL:= CROSSOVER 0)
       (CL:LET* ((SELF-001 (NEW-STELLA-HASH-TABLE)))
        (CL:SETF (%STELLA-HASH-TABLE.EQUAL-TEST? SELF-001)
         (%KEY-VALUE-MAP.EQUAL-TEST? SELF))
        (CL:SETQ MAP SELF-001))
       (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) MAP)
       (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 CURSOR))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
         (CL:SETQ KEY (%KV-CONS.KEY ITER-000))
         (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
         (STELLA-HASH-TABLE-INSERT-AT MAP KEY VALUE)
         (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))))))))
  :VOID)

;;; (DEFMETHOD REMOVE-AT ...)

(CL:DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-MAP) KEY)
  "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET*
   ((MAP (%KEY-VALUE-MAP.THE-MAP SELF))
    (CROSSOVER (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CROSSOVER))
   (CL:COND ((CL:= CROSSOVER 0) (STELLA-HASH-TABLE-REMOVE-AT MAP KEY))
    (CL:T
     (CL:LET* ((CURSOR MAP) (TRAILER MAP))
      (CL:IF (%KEY-VALUE-MAP.EQUAL-TEST? SELF)
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQUAL? (%KV-CONS.KEY CURSOR) KEY) (CL:RETURN))
        (CL:SETQ TRAILER CURSOR)
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NULL)) DO
        (CL:WHEN (EQL? (%KV-CONS.KEY CURSOR) KEY) (CL:RETURN))
        (CL:SETQ TRAILER CURSOR)
        (CL:SETQ CURSOR (%KV-CONS.REST CURSOR))))
      (CL:COND ((CL:EQ CURSOR NULL) (CL:RETURN-FROM REMOVE-AT))
       ((CL:EQ CURSOR TRAILER)
        (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) (%KV-CONS.REST CURSOR)))
       (CL:T (CL:SETF (%KV-CONS.REST TRAILER) (%KV-CONS.REST CURSOR))))
      (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)
       (CL:1+ CROSSOVER))))))
  :VOID)

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF KEY-VALUE-MAP))
  "Return the number of entries in `self'."
  (CL:LET* ((MAP (%KEY-VALUE-MAP.THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM LENGTH 0))
    ((CL:= (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM LENGTH (LENGTH MAP)))
    (CL:T (CL:RETURN-FROM LENGTH (LENGTH MAP))))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF KEY-VALUE-MAP))
  "Return TRUE if `self' has zero entries."
  (CL:LET* ((MAP (%KEY-VALUE-MAP.THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM EMPTY? CL:T))
    ((CL:= (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM EMPTY? (CL:= (LENGTH MAP) 0)))
    (CL:T (CL:RETURN-FROM EMPTY? CL:NIL)))))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF KEY-VALUE-MAP))
  "Return TRUE if `self' has at least 1 entry."
  (CL:LET* ((MAP (%KEY-VALUE-MAP.THE-MAP SELF)))
   (CL:COND ((CL:EQ MAP NULL) (CL:RETURN-FROM NON-EMPTY? CL:NIL))
    ((CL:= (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM NON-EMPTY? (> (LENGTH MAP) 0)))
    (CL:T (CL:RETURN-FROM NON-EMPTY? CL:T)))))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF KEY-VALUE-MAP))
  "Return a copy of the map `self'.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.)."
  (CL:LET* ((SELF-000 (NEW-KEY-VALUE-MAP)))
   (CL:SETF (%KEY-VALUE-MAP.EQUAL-TEST? SELF-000)
    (%KEY-VALUE-MAP.EQUAL-TEST? SELF))
   (CL:SETF (%KEY-VALUE-MAP.INITIAL-SIZE SELF-000)
    (%KEY-VALUE-MAP.INITIAL-SIZE SELF))
   (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF-000)
    (%KEY-VALUE-MAP.CROSSOVER-POINT SELF))
   (CL:LET* ((COPY SELF-000) (MAP (%KEY-VALUE-MAP.THE-MAP SELF)))
    (CL:IF (CL:= (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) 0)
     (CL:SETF (%KEY-VALUE-MAP.THE-MAP COPY) (COPY MAP))
     (CL:SETF (%KEY-VALUE-MAP.THE-MAP COPY) (COPY-KV-CONS-LIST MAP)))
    (CL:RETURN-FROM COPY COPY))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF KEY-VALUE-MAP))
  "Reset `self' to have zero entries."
  (CL:SETF (%KEY-VALUE-MAP.THE-MAP SELF) NULL)
  (CL:SETF (%KEY-VALUE-MAP.CROSSOVER-POINT SELF)
   *KEY-VALUE-MAP-CROSSOVER-POINT*)
  :VOID)

;;; (DEFMETHOD (ALLOCATE-ITERATOR (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF KEY-VALUE-MAP))
  "Allocate an iterator for `self'.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results."
  (CL:LET* ((MAP (%KEY-VALUE-MAP.THE-MAP SELF)))
   (CL:COND
    ((CL:= (%KEY-VALUE-MAP.CROSSOVER-POINT SELF) 0)
     (CL:RETURN-FROM ALLOCATE-ITERATOR (ALLOCATE-ITERATOR MAP)))
    (CL:T
     (CL:LET* ((SELF-000 (NEW-KEY-VALUE-LIST)))
      (CL:SETF (%KEY-VALUE-LIST.THE-KV-LIST SELF-000) MAP)
      (CL:LET* ((VALUE-000 (ALLOCATE-ITERATOR SELF-000)))
       (CL:RETURN-FROM ALLOCATE-ITERATOR VALUE-000)))))))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF KEY-VALUE-MAP))
  "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
     (CL:SETQ VALUE (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CONS KEY (CONS VALUE NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X KEY-VALUE-MAP) Y)
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y)
     SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP)
    (CL:PROGN
     (CL:WHEN (CL:= (LENGTH X) (LENGTH Y))
      (CL:LET*
       ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR X)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
        (CL:SETQ VALUE (%DICTIONARY-ITERATOR.VALUE ITER-000))
        (CL:WHEN (CL:NOT (EQUAL? VALUE (LOOKUP Y KEY)))
         (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))))
      (CL:RETURN-FROM OBJECT-EQUAL? CL:T))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF KEY-VALUE-MAP))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  (CL:LET* ((CODE 2137005)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
     (CL:SETQ VALUE (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE KEY)))))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE VALUE)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

(CL:DEFUN NEW-HASH-SET ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-HASH-SET))
   (CL:SETF (%HASH-SET.CROSSOVER-POINT SELF)
    *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%HASH-SET.INITIAL-SIZE SELF)
    *KEY-VALUE-MAP-CROSSOVER-POINT*)
   (CL:SETF (%HASH-SET.EQUAL-TEST? SELF) CL:NIL)
   (CL:SETF (%HASH-SET.THE-MAP SELF) NULL)
   (CL:RETURN-FROM NEW-HASH-SET SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HASH-SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-HASH-SET))

;;; (DEFUN (HASH-SET HASH-SET) ...)

(CL:DEFUN HASH-SET (CL:&REST VALUES)
  "Return an `eql?' HASH-SET containing `values'."
  (CL:LET* ((SET (NEW-HASH-SET)))
   (CL:LET* ((V NULL) (ITER-000 VALUES))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (INSERT-AT SET V V)))
   (CL:RETURN-FROM HASH-SET SET)))

;;; (DEFUN (COERCE-TO-HASH-SET HASH-SET) ...)

(CL:DEFUN COERCE-TO-HASH-SET (SELF EQUALTEST?)
  "Coerce the collection `self' into a HASH-SET.  Use an
equal test if `equalTest?' is TRUE (`equalTest?' will be ignored if `self'
already is a HASH-SET)."
  (CL:LET* ((CHOOSE-VALUE-000 NULL))
   (CL:IF (ISA? SELF SGT-COLLECTIONS-STELLA-HASH-SET)
    (CL:SETQ CHOOSE-VALUE-000 SELF)
    (CL:LET* ((SELF-000 (NEW-HASH-SET)))
     (CL:SETF (%HASH-SET.EQUAL-TEST? SELF-000) EQUALTEST?)
     (CL:SETQ CHOOSE-VALUE-000 SELF-000)))
   (CL:LET* ((THESET CHOOSE-VALUE-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-COLLECTIONS-STELLA-HASH-SET)
       (CL:PROGN))
      ((CL:EQ TEST-VALUE-000 SGT-COLLECTIONS-STELLA-CONS)
       (CL:PROGN
        (CL:LET* ((ELT NULL) (ITER-000 SELF))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ ELT (%%VALUE ITER-000)) (INSERT-AT THESET ELT ELT)
          (CL:SETQ ITER-000 (%%REST ITER-000))))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-COLLECTIONS-STELLA-LIST)
       (CL:PROGN
        (CL:LET* ((ELT NULL) (ITER-001 (%LIST.THE-CONS-LIST SELF)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ ELT (%%VALUE ITER-001)) (INSERT-AT THESET ELT ELT)
          (CL:SETQ ITER-001 (%%REST ITER-001))))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-COLLECTIONS-STELLA-VECTOR)
       (CL:PROGN
        (CL:LET*
         ((ELT NULL) (VECTOR-000 SELF) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ELT
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (INSERT-AT THESET ELT ELT)
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-COLLECTIONS-STELLA-COLLECTION)
       (CL:PROGN
        (CL:LET* ((ELT NULL) (ITER-002 (ALLOCATE-ITERATOR SELF)))
         (CL:LOOP WHILE (NEXT? ITER-002) DO
          (CL:SETQ ELT (%ITERATOR.VALUE ITER-002))
          (INSERT-AT THESET ELT ELT)))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "coerce-to-hash-set: don't know how to coerce a `"
         (PRIMARY-TYPE SELF) "' into a hash-set")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:RETURN-FROM COERCE-TO-HASH-SET THESET))))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF HASH-SET) OBJECT)
  "Return TRUE iff `object' is a member of the set `self'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:RETURN-FROM MEMBER? (CL:NOT (CL:EQ (LOOKUP SELF OBJECT) NULL))))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF HASH-SET) VALUE)
  "Add `value' to the set `self' unless it is already a member.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (INSERT-AT SELF VALUE VALUE)
  :VOID)

;;; (DEFMETHOD (REMOVE (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE ((SELF HASH-SET) VALUE)
  "Destructively remove `value' from the set `self' if it is a member and
return `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of
`self' is TRUE."
  (REMOVE-AT SELF VALUE)
  (CL:RETURN-FROM REMOVE SELF))

;;; (DEFMETHOD (REMOVE-IF (LIKE SELF)) ...)

(CL:DEFMETHOD REMOVE-IF ((SELF HASH-SET) TEST?)
  "Destructively remove all elements of the set `self' for which
'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'."
  (CL:LET* ((ELEMENT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ ELEMENT (%DICTIONARY-ITERATOR.VALUE ITER-000))
    (CL:WHEN (CL:FUNCALL TEST? ELEMENT) (REMOVE-AT SELF ELEMENT))))
  (CL:RETURN-FROM REMOVE-IF SELF))

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF HASH-SET))
  "Remove and return an arbitrary element of the set `self'.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to `pop',
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases."
  (CL:LET* ((ELEMENT NULL) (SETMAP (%HASH-SET.THE-MAP SELF)))
   (CL:WHEN (CL:NOT (CL:EQ SETMAP NULL))
    (CL:COND
     ((CL:= (%HASH-SET.CROSSOVER-POINT SELF) 0)
      (CL:LET*
       ((MAP SETMAP) (TABLE (%STELLA-HASH-TABLE.THE-TABLE MAP))
        (BUCKET NULL))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
       (CL:WHEN (CL:NOT (NULL-ARRAY? TABLE))
        (CL:LET*
         ((I NULL-INTEGER) (ITER-000 0)
          (UPPER-BOUND-000 (CL:1- (%STELLA-HASH-TABLE.SIZE MAP))))
         (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
         (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
          (CL:SETQ I ITER-000) (CL:SETQ BUCKET (CL:AREF TABLE I))
          (CL:WHEN (CL:NOT (CL:EQ BUCKET NULL))
           (CL:SETQ ELEMENT (%KV-CONS.KEY BUCKET)) (CL:RETURN))
          (CL:SETQ ITER-000 (CL:1+ ITER-000)))))))
     (CL:T
      (CL:LET* ((MAP (%HASH-SET.THE-MAP SELF)))
       (CL:WHEN (CL:NOT (CL:EQ MAP NULL))
        (CL:SETQ ELEMENT (%KV-CONS.KEY MAP)))))))
   (CL:WHEN (CL:NOT (CL:EQ ELEMENT NULL)) (REMOVE-AT SELF ELEMENT))
   (CL:RETURN-FROM POP ELEMENT)))

;;; (DEFMETHOD (SUBSTITUTE (LIKE SELF)) ...)

(CL:DEFMETHOD SUBSTITUTE ((SELF HASH-SET) NEW OLD)
  "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.  Uses an `eql?' test by default or `equal?'
if `equal-test?' of `self' is TRUE."
  (CL:WHEN (CL:NOT (MEMBER? SELF NEW)) (REMOVE-AT SELF OLD)
   (INSERT-AT SELF NEW NEW))
  (CL:RETURN-FROM SUBSTITUTE SELF))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF HASH-SET))
  "Return a copy of the set `self'.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.)."
  (CL:LET* ((SELF-000 (NEW-HASH-SET)))
   (CL:SETF (%HASH-SET.EQUAL-TEST? SELF-000)
    (%HASH-SET.EQUAL-TEST? SELF))
   (CL:SETF (%HASH-SET.INITIAL-SIZE SELF-000)
    (%HASH-SET.INITIAL-SIZE SELF))
   (CL:SETF (%HASH-SET.CROSSOVER-POINT SELF-000)
    (%HASH-SET.CROSSOVER-POINT SELF))
   (CL:LET* ((COPY SELF-000) (MAP (%HASH-SET.THE-MAP SELF)))
    (CL:IF (CL:= (%HASH-SET.CROSSOVER-POINT SELF) 0)
     (CL:SETF (%HASH-SET.THE-MAP COPY) (COPY MAP))
     (CL:SETF (%HASH-SET.THE-MAP COPY) (COPY-KV-CONS-LIST MAP)))
    (CL:RETURN-FROM COPY COPY))))

;;; (DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD CONSIFY ((SELF HASH-SET))
  "Collect all entries of `self' into a cons list and return the result."
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR SELF))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ VALUE (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:RETURN-FROM CONSIFY RESULT)))

;;; (DEFMETHOD (SUBSET? BOOLEAN) ...)

(CL:DEFMETHOD SUBSET? ((SELF HASH-SET) OTHERSET)
  "Return true if every element of `self' also occurs in `otherSet'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (<= (LENGTH SELF) (LENGTH OTHERSET)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM SUBSET? VALUE-000))))

;;; (DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ...)

(CL:DEFMETHOD EQUIVALENT-SETS? ((SELF HASH-SET) OTHERSET)
  "Return true if every element of `self' occurs in `otherSet' and vice versa.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (CL:= (LENGTH SELF) (LENGTH OTHERSET)))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM EQUIVALENT-SETS? VALUE-000))))

;;; (DEFMETHOD (INTERSECTION HASH-SET) ...)

(CL:DEFMETHOD INTERSECTION ((SELF HASH-SET) OTHERSET)
  "Return the set intersection of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((SELF-000 (NEW-HASH-SET)))
   (CL:SETF (%HASH-SET.EQUAL-TEST? SELF-000)
    (%HASH-SET.EQUAL-TEST? SELF))
   (CL:LET* ((RESULT SELF-000) (AUX SELF))
    (CL:WHEN (CL:> (LENGTH SELF) (LENGTH OTHERSET))
     (CL:SETQ SELF OTHERSET) (CL:SETQ OTHERSET AUX))
    (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
      (CL:WHEN (CL:NOT (CL:EQ (LOOKUP OTHERSET ELT) NULL))
       (INSERT-AT RESULT ELT ELT))))
    (CL:RETURN-FROM INTERSECTION RESULT))))

;;; (DEFMETHOD (UNION HASH-SET) ...)

(CL:DEFMETHOD UNION ((SELF HASH-SET) OTHERSET)
  "Return the set union of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((RESULT NULL) (AUX SELF))
   (CL:WHEN (CL:< (LENGTH SELF) (LENGTH OTHERSET))
    (CL:SETQ SELF OTHERSET) (CL:SETQ OTHERSET AUX))
   (CL:SETQ RESULT (COPY SELF))
   (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR OTHERSET)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (INSERT-AT RESULT ELT ELT)))
   (CL:RETURN-FROM UNION RESULT)))

;;; (DEFMETHOD (DIFFERENCE HASH-SET) ...)

(CL:DEFMETHOD DIFFERENCE ((SELF HASH-SET) OTHERSET)
  "Return the set difference of `self' and `otherSet' as a new set (i.e.,
all elements that are in `self' but not in `otherSet').  Uses an `eql?' test
by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((RESULT NULL))
   (CL:COND
    ((CL:> (LENGTH SELF) (CL:* (LENGTH OTHERSET) 2))
     (CL:SETQ RESULT (COPY SELF))
     (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR OTHERSET)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
       (CL:WHEN (CL:NOT (CL:EQ (LOOKUP RESULT ELT) NULL))
        (REMOVE-AT RESULT ELT)))))
    (CL:T
     (CL:LET* ((SELF-000 (NEW-HASH-SET)))
      (CL:SETF (%HASH-SET.EQUAL-TEST? SELF-000)
       (%HASH-SET.EQUAL-TEST? SELF))
      (CL:SETQ RESULT SELF-000))
     (CL:LET* ((ELT NULL) (ITER-001 (ALLOCATE-ITERATOR SELF)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO
       (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-001))
       (CL:WHEN (CL:EQ (LOOKUP OTHERSET ELT) NULL)
        (INSERT-AT RESULT ELT ELT))))))
   (CL:RETURN-FROM DIFFERENCE RESULT)))

;;; (DEFMETHOD (SUBTRACT HASH-SET) ...)

(CL:DEFMETHOD SUBTRACT ((SELF HASH-SET) OTHERSET)
  "Return the set difference of `self' and `otherSet' by destructively
removing elements from `self' that also occur in `otherSet'.  Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ (LOOKUP OTHERSET ELT) NULL))
     (REMOVE-AT SELF ELT))))
  (CL:RETURN-FROM SUBTRACT SELF))

;;; (DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQUAL? ((X HASH-SET) Y)
  "Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.
This is equivalent to calling `equivalent-sets?'."
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE Y) SGT-COLLECTIONS-STELLA-HASH-SET)
    (CL:PROGN (CL:RETURN-FROM OBJECT-EQUAL? (EQUIVALENT-SETS? X Y))))
   (CL:T))
  (CL:RETURN-FROM OBJECT-EQUAL? CL:NIL))

;;; (DEFMETHOD (EQUAL-HASH-CODE INTEGER) ...)

(CL:DEFMETHOD EQUAL-HASH-CODE ((SELF HASH-SET))
  "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  (CL:LET* ((CODE 7971569)) (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:LET* ((ELT NULL) (ITER-000 (ALLOCATE-ITERATOR SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ELT (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:SETQ CODE
      (CL:THE CL:FIXNUM
       (CL:LOGXOR CODE (CL:THE CL:FIXNUM (EQUAL-HASH-CODE ELT)))))))
   (CL:RETURN-FROM EQUAL-HASH-CODE CODE)))

(CL:DEFUN NEW-1D-ARRAY (DIM1)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DIM1))
  #+MCL
  (CL:CHECK-TYPE DIM1 CL:FIXNUM)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-1D-ARRAY))
   (CL:SETF (%1D-ARRAY.DIM1 SELF) DIM1)
   (CL:SETF (%1D-ARRAY.THE-ARRAY SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-DIMENSIONAL-ARRAY SELF)
   (CL:RETURN-FROM NEW-1D-ARRAY SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 1D-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-1D-ARRAY))

(CL:DEFMETHOD 1D-AREF-ADDRESS ((SELF 1D-ARRAY) I)
  "Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-ADDRESS I))

(CL:DEFMETHOD 1D-AREF-SETTER ((SELF 1D-ARRAY) VALUE I)
  "Set the element of `self' at position `[i]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%1D-ARRAY.THE-ARRAY SELF)) I)
    VALUE)))

(CL:DEFMETHOD 1D-AREF ((SELF 1D-ARRAY) I)
  "Return the element of `self' at position `[i]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%1D-ARRAY.THE-ARRAY SELF)) I)))

(CL:DEFMETHOD INITIALIZE-ARRAY ((SELF 1D-ARRAY) INITIALVALUE)
  "Initialize the elements of `self' with `initialValue'."
  (CL:LET* ((ARRAY (%1D-ARRAY.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF ARRAY I) INITIALVALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

(CL:DEFMETHOD LENGTH ((SELF 1D-ARRAY))
  "Return the total number of elements in `self'."
  (CL:RETURN-FROM LENGTH (%1D-ARRAY.DIM1 SELF)))

(CL:DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF 1D-ARRAY))
  (CL:SETF (%1D-ARRAY.THE-ARRAY SELF) (CL:MAKE-ARRAY (LENGTH SELF)))
  :VOID)

(CL:DEFUN NEW-1D-FLOAT-ARRAY (DIM1)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DIM1))
  #+MCL
  (CL:CHECK-TYPE DIM1 CL:FIXNUM)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-1D-FLOAT-ARRAY))
   (CL:SETF (%1D-FLOAT-ARRAY.DIM1 SELF) DIM1)
   (CL:SETF (%1D-FLOAT-ARRAY.THE-ARRAY SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-DIMENSIONAL-ARRAY SELF)
   (CL:RETURN-FROM NEW-1D-FLOAT-ARRAY SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 1D-FLOAT-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-1D-FLOAT-ARRAY))

(CL:DEFMETHOD 1D-AREF-ADDRESS ((SELF 1D-FLOAT-ARRAY) I)
  "Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-ADDRESS I))

(CL:DEFMETHOD 1D-AREF-SETTER ((SELF 1D-FLOAT-ARRAY) VALUE I)
  "Set the element of `self' at position `[i]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE) (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%1D-FLOAT-ARRAY.THE-ARRAY SELF))
     I)
    VALUE)))

(CL:DEFMETHOD 1D-AREF ((SELF 1D-FLOAT-ARRAY) I)
  "Return the element of `self' at position `[i]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%1D-FLOAT-ARRAY.THE-ARRAY SELF))
    I)))

(CL:DEFMETHOD INITIALIZE-ARRAY ((SELF 1D-FLOAT-ARRAY) INITIALVALUE)
  "Initialize the elements of `self' with `initialValue'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT INITIALVALUE))
  #+MCL
  (CL:CHECK-TYPE INITIALVALUE CL:DOUBLE-FLOAT)
  (CL:LET* ((ARRAY (%1D-FLOAT-ARRAY.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF ARRAY I) INITIALVALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

(CL:DEFMETHOD LENGTH ((SELF 1D-FLOAT-ARRAY))
  "Return the total number of elements in `self'."
  (CL:RETURN-FROM LENGTH (%1D-FLOAT-ARRAY.DIM1 SELF)))

(CL:DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF 1D-FLOAT-ARRAY))
  (CL:SETF (%1D-FLOAT-ARRAY.THE-ARRAY SELF)
   (CL:MAKE-ARRAY (LENGTH SELF)))
  :VOID)

(CL:DEFUN NEW-2D-ARRAY (DIM2 DIM1)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DIM2 DIM1))
  #+MCL
  (CL:CHECK-TYPE DIM2 CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE DIM1 CL:FIXNUM)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-2D-ARRAY))
   (CL:SETF (%2D-ARRAY.DIM2 SELF) DIM2)
   (CL:SETF (%2D-ARRAY.DIM1 SELF) DIM1)
   (CL:SETF (%2D-ARRAY.THE-ARRAY SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-DIMENSIONAL-ARRAY SELF)
   (CL:RETURN-FROM NEW-2D-ARRAY SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 2D-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-2D-ARRAY))

(CL:DEFMETHOD 2D-AREF-ADDRESS ((SELF 2D-ARRAY) I J)
  "Return the 1D address of the element at position `[i, j]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF-ADDRESS
   (CL:+ (CL:* I (%2D-ARRAY.DIM2 SELF)) J)))

(CL:DEFMETHOD 2D-AREF-SETTER ((SELF 2D-ARRAY) VALUE I J)
  "Set the element of `self' at position `[i, j]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-ARRAY.THE-ARRAY SELF))
     (CL:THE CL:FIXNUM (CL:+ (CL:* I (%2D-ARRAY.DIM2 SELF)) J)))
    VALUE)))

(CL:DEFMETHOD 2D-AREF ((SELF 2D-ARRAY) I J)
  "Return the element of `self' at position `[i, j]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-ARRAY.THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:+ (CL:* I (%2D-ARRAY.DIM2 SELF)) J)))))

(CL:DEFMETHOD LENGTH ((SELF 2D-ARRAY))
  "Return the total number of elements in `self'."
  (CL:RETURN-FROM LENGTH
   (CL:* (%2D-ARRAY.DIM1 SELF) (%2D-ARRAY.DIM2 SELF))))

(CL:DEFMETHOD 1D-AREF-ADDRESS ((SELF 2D-ARRAY) I)
  "Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-ADDRESS I))

(CL:DEFMETHOD 1D-AREF-SETTER ((SELF 2D-ARRAY) VALUE I)
  "Set the element of `self' at position `[i]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-ARRAY.THE-ARRAY SELF)) I)
    VALUE)))

(CL:DEFMETHOD 1D-AREF ((SELF 2D-ARRAY) I)
  "Return the element of `self' at position `[i]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-ARRAY.THE-ARRAY SELF)) I)))

(CL:DEFMETHOD INITIALIZE-ARRAY ((SELF 2D-ARRAY) INITIALVALUE)
  "Initialize the elements of `self' with `initialValue'."
  (CL:LET* ((ARRAY (%2D-ARRAY.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF ARRAY I) INITIALVALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

(CL:DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF 2D-ARRAY))
  (CL:SETF (%2D-ARRAY.THE-ARRAY SELF) (CL:MAKE-ARRAY (LENGTH SELF)))
  :VOID)

(CL:DEFUN NEW-2D-FLOAT-ARRAY (DIM2 DIM1)
  (CL:DECLARE (CL:TYPE CL:FIXNUM DIM2 DIM1))
  #+MCL
  (CL:CHECK-TYPE DIM2 CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE DIM1 CL:FIXNUM)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-2D-FLOAT-ARRAY))
   (CL:SETF (%2D-FLOAT-ARRAY.DIM2 SELF) DIM2)
   (CL:SETF (%2D-FLOAT-ARRAY.DIM1 SELF) DIM1)
   (CL:SETF (%2D-FLOAT-ARRAY.THE-ARRAY SELF) STELLA::NULL-1D-ARRAY)
   (INITIALIZE-DIMENSIONAL-ARRAY SELF)
   (CL:RETURN-FROM NEW-2D-FLOAT-ARRAY SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 2D-FLOAT-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-2D-FLOAT-ARRAY))

(CL:DEFMETHOD 2D-AREF-ADDRESS ((SELF 2D-FLOAT-ARRAY) I J)
  "Return the 1D address of the element at position `[i, j]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF-ADDRESS
   (CL:+ (CL:* I (%2D-FLOAT-ARRAY.DIM2 SELF)) J)))

(CL:DEFMETHOD 2D-AREF-SETTER ((SELF 2D-FLOAT-ARRAY) VALUE I J)
  "Set the element of `self' at position `[i, j]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE) (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-FLOAT-ARRAY.THE-ARRAY SELF))
     (CL:THE CL:FIXNUM (CL:+ (CL:* I (%2D-FLOAT-ARRAY.DIM2 SELF)) J)))
    VALUE)))

(CL:DEFMETHOD 2D-AREF ((SELF 2D-FLOAT-ARRAY) I J)
  "Return the element of `self' at position `[i, j]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I J))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE J CL:FIXNUM)
  (CL:RETURN-FROM 2D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-FLOAT-ARRAY.THE-ARRAY SELF))
    (CL:THE CL:FIXNUM (CL:+ (CL:* I (%2D-FLOAT-ARRAY.DIM2 SELF)) J)))))

(CL:DEFMETHOD LENGTH ((SELF 2D-FLOAT-ARRAY))
  "Return the total number of elements in `self'."
  (CL:RETURN-FROM LENGTH
   (CL:* (%2D-FLOAT-ARRAY.DIM1 SELF) (%2D-FLOAT-ARRAY.DIM2 SELF))))

(CL:DEFMETHOD 1D-AREF-ADDRESS ((SELF 2D-FLOAT-ARRAY) I)
  "Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-ADDRESS I))

(CL:DEFMETHOD 1D-AREF-SETTER ((SELF 2D-FLOAT-ARRAY) VALUE I)
  "Set the element of `self' at position `[i]' to `value'
and return the result."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE) (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF-SETTER
   (CL:SETF
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-FLOAT-ARRAY.THE-ARRAY SELF))
     I)
    VALUE)))

(CL:DEFMETHOD 1D-AREF ((SELF 2D-FLOAT-ARRAY) I)
  "Return the element of `self' at position `[i]'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:RETURN-FROM 1D-AREF
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%2D-FLOAT-ARRAY.THE-ARRAY SELF))
    I)))

(CL:DEFMETHOD INITIALIZE-ARRAY ((SELF 2D-FLOAT-ARRAY) INITIALVALUE)
  "Initialize the elements of `self' with `initialValue'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT INITIALVALUE))
  #+MCL
  (CL:CHECK-TYPE INITIALVALUE CL:DOUBLE-FLOAT)
  (CL:LET* ((ARRAY (%2D-FLOAT-ARRAY.THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000) (CL:SETF (CL:AREF ARRAY I) INITIALVALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
  :VOID)

(CL:DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF 2D-FLOAT-ARRAY))
  (CL:SETF (%2D-FLOAT-ARRAY.THE-ARRAY SELF)
   (CL:MAKE-ARRAY (LENGTH SELF)))
  :VOID)

;;; (DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD THE-ARRAY-READER ((SELF 1D-ARRAY))
  (CL:RETURN-FROM THE-ARRAY-READER (%1D-ARRAY.THE-ARRAY SELF)))

;;; (DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD THE-ARRAY-READER ((SELF 1D-FLOAT-ARRAY))
  (CL:RETURN-FROM THE-ARRAY-READER (%1D-FLOAT-ARRAY.THE-ARRAY SELF)))

;;; (DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD THE-ARRAY-READER ((SELF 2D-ARRAY))
  (CL:RETURN-FROM THE-ARRAY-READER (%2D-ARRAY.THE-ARRAY SELF)))

;;; (DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD THE-ARRAY-READER ((SELF 2D-FLOAT-ARRAY))
  (CL:RETURN-FROM THE-ARRAY-READER (%2D-FLOAT-ARRAY.THE-ARRAY SELF)))

(CL:DEFUN NEW-BUFFERED-STRING ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-BUFFERED-STRING))
   (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) 0)
   (CL:SETF (%BUFFERED-STRING.BUFFER-SIZE SELF) 16)
   (CL:SETF (%BUFFERED-STRING.BUFFER SELF)
    (MAKE-RAW-MUTABLE-STRING 16))
   (CL:RETURN-FROM NEW-BUFFERED-STRING SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BUFFERED-STRING))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-COLLECTIONS-STELLA-BUFFERED-STRING))

(CL:DEFUN ACCESS-BUFFERED-STRING-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUFFER)
    (CL:IF SETVALUE?
     (CL:SETF (%BUFFERED-STRING.BUFFER SELF)
      (%MUTABLE-STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-MUTABLE-STRING (%BUFFERED-STRING.BUFFER SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-BUFFER-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%BUFFERED-STRING.BUFFER-SIZE SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%BUFFERED-STRING.BUFFER-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-COLLECTIONS-STELLA-FILL-POINTER)
    (CL:IF SETVALUE?
     (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%BUFFERED-STRING.FILL-POINTER SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-BUFFERED-STRING-SLOT-VALUE VALUE))

;;; (DEFMETHOD (RESIZE-BUFFER MUTABLE-STRING) ...)

(CL:DEFMETHOD RESIZE-BUFFER ((SELF BUFFERED-STRING) SIZE)
  "Change the size of `self' to `size'.  If `size' is smaller
than the current size of `self', it's buffer will be truncated."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((OLDSIZE (%BUFFERED-STRING.BUFFER-SIZE SELF))
    (OLDBUFFER (%BUFFERED-STRING.BUFFER SELF)) (NEWBUFFER OLDBUFFER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDSIZE)
    (CL:TYPE CL:SIMPLE-STRING OLDBUFFER NEWBUFFER))
   (CL:COND
    ((CL:= OLDSIZE 0)
     (CL:SETQ NEWBUFFER (MAKE-RAW-MUTABLE-STRING SIZE))
     (CL:SETF (%BUFFERED-STRING.BUFFER SELF) NEWBUFFER)
     (CL:SETF (%BUFFERED-STRING.BUFFER-SIZE SELF) SIZE))
    ((CL:= SIZE OLDSIZE))
    (CL:T
     (CL:LET* ((L (%BUFFERED-STRING.FILL-POINTER SELF)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM L))
      (CL:SETQ NEWBUFFER (MAKE-RAW-MUTABLE-STRING SIZE))
      (CL:SETF (%BUFFERED-STRING.BUFFER SELF) NEWBUFFER)
      (CL:SETF (%BUFFERED-STRING.BUFFER-SIZE SELF) SIZE)
      (CL:WHEN (CL:< SIZE L) (CL:SETQ L SIZE)
       (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) L))
      (CL:LOOP WHILE (CL:> L 0) DO (CL:SETQ L (CL:1- L))
       (CL:LET
        ((SELF NEWBUFFER)
         (CH
          (CL:LET ((SELF OLDBUFFER) (POSITION L))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (POSITION L))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))))))
   (CL:RETURN-FROM RESIZE-BUFFER NEWBUFFER)))

;;; (DEFMETHOD (ENSURE-FREE-SPACE MUTABLE-STRING) ...)

(CL:DEFMETHOD ENSURE-FREE-SPACE ((SELF BUFFERED-STRING) SIZE)
  "Ensure `self' is big enough to accommodate an additional item of `size'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:COND
   ((CL:> (CL:+ (%BUFFERED-STRING.FILL-POINTER SELF) SIZE)
     (%BUFFERED-STRING.BUFFER-SIZE SELF))
    (CL:RETURN-FROM ENSURE-FREE-SPACE
     (RESIZE-BUFFER SELF
      (MAX (CL:* (%BUFFERED-STRING.BUFFER-SIZE SELF) 2)
       (CL:+ (%BUFFERED-STRING.FILL-POINTER SELF) SIZE)))))
   (CL:T
    (CL:RETURN-FROM ENSURE-FREE-SPACE (%BUFFERED-STRING.BUFFER SELF)))))

;;; (DEFMETHOD (FREE-SPACE INTEGER) ...)

(CL:DEFMETHOD FREE-SPACE ((SELF BUFFERED-STRING))
  "Return the amount of free space in `self'."
  (CL:RETURN-FROM FREE-SPACE
   (CL:- (%BUFFERED-STRING.BUFFER-SIZE SELF)
    (%BUFFERED-STRING.FILL-POINTER SELF))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF BUFFERED-STRING))
  (CL:RETURN-FROM LENGTH (%BUFFERED-STRING.FILL-POINTER SELF)))

;;; (DEFMETHOD (LENGTH-SETTER INTEGER) ...)

(CL:DEFMETHOD LENGTH-SETTER ((SELF BUFFERED-STRING) NEWLENGTH)
  "Reset the length of `self' to `newLength'.  Fill in NULL characters if `newLength' 
is greater than the current length.  This is the safe way to reset the fill pointer."
  (CL:DECLARE (CL:TYPE CL:FIXNUM NEWLENGTH))
  #+MCL
  (CL:CHECK-TYPE NEWLENGTH CL:FIXNUM)
  (CL:LET* ((FP (%BUFFERED-STRING.FILL-POINTER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FP))
   (CL:COND
    ((CL:< NEWLENGTH 0)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Out-of-bounds: cannot set string buffer to negative length: `"
       NEWLENGTH "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
    ((CL:< NEWLENGTH FP)
     (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) NEWLENGTH))
    ((CL:> NEWLENGTH FP) (ENSURE-FREE-SPACE SELF (CL:- NEWLENGTH FP))
     (CL:LET* ((BUF (%BUFFERED-STRING.BUFFER SELF)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUF))
      (CL:LOOP WHILE (CL:< FP NEWLENGTH) DO
       (CL:LET ((SELF BUF) (CH NULL-CHARACTER) (POSITION FP))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ FP (CL:1+ FP)))
      (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) NEWLENGTH))))
   (CL:RETURN-FROM LENGTH-SETTER NEWLENGTH)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF BUFFERED-STRING))
  "Return `true' if `self' has length 0."
  (CL:RETURN-FROM EMPTY? (CL:= (%BUFFERED-STRING.FILL-POINTER SELF) 0)))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF BUFFERED-STRING))
  "Return `true' if `self' has length > 0."
  (CL:RETURN-FROM NON-EMPTY? (> (%BUFFERED-STRING.FILL-POINTER SELF) 0)))

;;; (DEFMETHOD (NTH CHARACTER) ...)

(CL:DEFMETHOD NTH ((SELF BUFFERED-STRING) POSITION)
  "Return the character in `self' at `position'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH
   (CL:LET ((SELF (%BUFFERED-STRING.BUFFER SELF)) (POSITION POSITION))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
     (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFMETHOD (NTH-SETTER CHARACTER) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF BUFFERED-STRING) CH POSITION)
  "Set the character in `self' at `position' to `ch'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM NTH-SETTER
   (CL:LET
    ((SELF (%BUFFERED-STRING.BUFFER SELF)) (CH CH) (POSITION POSITION))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (SETF
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION))
     (CL:THE CL:CHARACTER CH)))))

;;; (DEFMETHOD (LAST CHARACTER) ...)

(CL:DEFMETHOD LAST ((SELF BUFFERED-STRING))
  "Return the last character in `self'."
  (CL:RETURN-FROM LAST
   (CL:LET
    ((SELF (%BUFFERED-STRING.BUFFER SELF))
     (POSITION (CL:1- (%BUFFERED-STRING.FILL-POINTER SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
     (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFMETHOD (LAST-SETTER CHARACTER) ...)

(CL:DEFMETHOD LAST-SETTER ((SELF BUFFERED-STRING) VALUE)
  (CL:RETURN-FROM LAST-SETTER
   (CL:LET
    ((SELF (%BUFFERED-STRING.BUFFER SELF)) (CH VALUE)
     (POSITION (CL:1- (%BUFFERED-STRING.FILL-POINTER SELF))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (SETF
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION))
     (CL:THE CL:CHARACTER CH)))))

;;; (DEFMETHOD APPEND-STRING ...)

(CL:DEFMETHOD APPEND-STRING ((SELF BUFFERED-STRING) VALUE)
  "Append `value' to the END of the string `self'.  
Resize the buffer if necessary."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:LET*
   ((VALLENGTH (CL:THE CL:FIXNUM (CL:LENGTH VALUE))) (VALCURSOR 0)
    (BUFSIZE (%BUFFERED-STRING.BUFFER-SIZE SELF))
    (BUFCURSOR (%BUFFERED-STRING.FILL-POINTER SELF))
    (BUFFER (%BUFFERED-STRING.BUFFER SELF)))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM VALLENGTH VALCURSOR BUFSIZE BUFCURSOR)
    (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:WHEN (CL:> (CL:+ BUFCURSOR VALLENGTH) BUFSIZE)
    (CL:SETQ BUFFER
     (RESIZE-BUFFER SELF
      (MAX (CL:* BUFSIZE 2) (CL:+ BUFCURSOR VALLENGTH)))))
   (CL:LOOP WHILE (CL:< VALCURSOR VALLENGTH) DO
    (CL:LET
     ((SELF BUFFER)
      (CH
       (CL:LET ((SELF VALUE) (POSITION VALCURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))))
      (POSITION BUFCURSOR))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (SETF
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))
      (CL:THE CL:CHARACTER CH)))
    (CL:SETQ VALCURSOR (CL:1+ VALCURSOR))
    (CL:SETQ BUFCURSOR (CL:1+ BUFCURSOR)))
   (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) BUFCURSOR))
  :VOID)

;;; (DEFMETHOD APPEND-CHARACTER ...)

(CL:DEFMETHOD APPEND-CHARACTER ((SELF BUFFERED-STRING) CHAR)
  "Append `char' to the END of the string `self'.  
Resize the buffer if necessary."
  (CL:LET*
   ((BUFSIZE (%BUFFERED-STRING.BUFFER-SIZE SELF))
    (BUFCURSOR (%BUFFERED-STRING.FILL-POINTER SELF))
    (BUFFER (%BUFFERED-STRING.BUFFER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM BUFSIZE BUFCURSOR)
    (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:WHEN (CL:>= BUFCURSOR BUFSIZE)
    (CL:SETQ BUFFER (RESIZE-BUFFER SELF (CL:* (MAX BUFSIZE 1) 2))))
   (CL:LET ((SELF BUFFER) (CH CHAR) (POSITION BUFCURSOR))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (SETF
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION))
     (CL:THE CL:CHARACTER CH)))
   (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) (CL:1+ BUFCURSOR)))
  :VOID)

;;; (DEFMETHOD (POP CHARACTER) ...)

(CL:DEFMETHOD POP ((SELF BUFFERED-STRING))
  (CL:LET* ((BUFCURSOR (%BUFFERED-STRING.FILL-POINTER SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM BUFCURSOR))
   (CL:COND
    ((CL:> BUFCURSOR 0) (CL:SETQ BUFCURSOR (CL:1- BUFCURSOR))
     (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) BUFCURSOR)
     (CL:RETURN-FROM POP
      (CL:LET
       ((SELF (%BUFFERED-STRING.BUFFER SELF)) (POSITION BUFCURSOR))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))))
    (CL:T (CL:RETURN-FROM POP NULL-CHARACTER)))))

;;; (DEFMETHOD (COPY STRING-BUFFER) ...)

(CL:DEFMETHOD COPY ((SELF BUFFERED-STRING))
  (CL:LET* ((SELF-000 (NEW-BUFFERED-STRING)))
   (CL:SETF (%BUFFERED-STRING.BUFFER-SIZE SELF-000)
    (%BUFFERED-STRING.BUFFER-SIZE SELF))
   (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF-000)
    (%BUFFERED-STRING.FILL-POINTER SELF))
   (CL:LET* ((COPY SELF-000))
    (CL:SETF (%BUFFERED-STRING.BUFFER COPY)
     (CL:THE CL:SIMPLE-STRING
      (CL:COPY-SEQ
       (CL:THE CL:SIMPLE-STRING
        (SUBSEQUENCE (%BUFFERED-STRING.BUFFER SELF) 0 NULL-INTEGER)))))
    (CL:RETURN-FROM COPY COPY))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((SELF BUFFERED-STRING))
  "Clear `self' by setting its active length to zero."
  (CL:SETF (%BUFFERED-STRING.FILL-POINTER SELF) 0)
  :VOID)

;;; (DEFMETHOD (THE-STRING STRING) ...)

(CL:DEFMETHOD THE-STRING ((SELF BUFFERED-STRING))
  "Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string."
  (CL:RETURN-FROM THE-STRING
   (SUBSEQUENCE (%BUFFERED-STRING.BUFFER SELF) 0
    (%BUFFERED-STRING.FILL-POINTER SELF))))

;;; (DEFMETHOD (SUBSEQUENCE STRING) ...)

(CL:DEFMETHOD SUBSEQUENCE ((SELF BUFFERED-STRING) START END)
  "Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:WHEN (CL:= END NULL-INTEGER)
   (CL:SETQ END (%BUFFERED-STRING.FILL-POINTER SELF)))
  (CL:RETURN-FROM SUBSEQUENCE
   (SUBSEQUENCE (%BUFFERED-STRING.BUFFER SELF) START END)))

(CL:DEFUN HELP-STARTUP-COLLECTIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-COLLECTIONS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 0))
   (CL:SETQ KWD-COLLECTIONS-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-COLLECTIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-COLLECTIONS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-VECTOR-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR-SEQUENCE" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-HEAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HEAP" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-FILL-POINTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILL-POINTER" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-HASH-TABLE" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-INITIAL-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-SIZE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-FREE-ELEMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FREE-ELEMENTS" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-EQUAL-TEST?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUAL-TEST?" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-STELLA-HASH-TABLE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-HASH-TABLE-ITERATOR" NULL
     1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUCKET-INDEX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUCKET-INDEX" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUCKET-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUCKET-CURSOR" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-KEY-VALUE-MAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-MAP" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-THE-MAP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-MAP" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-CROSSOVER-POINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CROSSOVER-POINT" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-HASH-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-SET" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-1D-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1D-ARRAY" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-OBJECT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-ARRAY" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-1D-FLOAT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1D-FLOAT-ARRAY" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-FLOAT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-ARRAY" NULL 0))
   (CL:SETQ SGT-COLLECTIONS-STELLA-2D-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "2D-ARRAY" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-2D-FLOAT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "2D-FLOAT-ARRAY" NULL 1))
   (CL:SETQ SGT-COLLECTIONS-STELLA-BUFFERED-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFERED-STRING" NULL 1))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUFFER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFER" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-BUFFER-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFER-SIZE" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-STRING-BUFFER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-BUFFER" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-COLLECTIONS" NULL 0))
   (CL:SETQ SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-COLLECTIONS2 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HEAP"
       "(DEFCLASS HEAP (VECTOR) :DOCUMENTATION \"Implements a Min or Max heap depending on the semantics
of `predicate' (Min if `predicate' has a `<' semantics).  This is useful
for in-place sorting (even though we have specialzed sort routines for that)
or to maintain top-N lists with log(N) insertion time.  We place this under
VECTOR instead of VECTOR-SEQUENCE for now, since sequential order isn't
really maintained or accessible until we sort the heap.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((PREDICATE :TYPE FUNCTION-CODE :REQUIRED? TRUE) (FILL-POINTER :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-HEAP)")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-HEAP))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-HEAP-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-HASH-TABLE"
       "(DEFCLASS STELLA-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-TABLE :TYPE (ARRAY () OF KV-CONS)) (SIZE :TYPE INTEGER) (INITIAL-SIZE :TYPE INTEGER :INITIALLY 50 :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial hash table
will be sized to hold at least that many elements.\") (FREE-ELEMENTS :TYPE INTEGER) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the
equality test and `equal-hash-code' as the hash function, otherwise,
use `eql?' and `hash-code' (the default).\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STELLA-HASH-TABLE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STELLA-HASH-TABLE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "STELLA-HASH-TABLE-ITERATOR"
       "(DEFCLASS STELLA-HASH-TABLE-ITERATOR (DICTIONARY-ITERATOR) :DOCUMENTATION \"Iterator class for STELLA-HASH-TABLE's.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.\" :SLOTS ((SIZE :TYPE INTEGER) (BUCKET-TABLE :TYPE (ARRAY () OF KV-CONS)) (BUCKET-INDEX :TYPE INTEGER :INITIALLY 0) (BUCKET-CURSOR :TYPE KV-CONS)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STELLA-HASH-TABLE-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STELLA-HASH-TABLE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KEY-VALUE-MAP"
       "(DEFCLASS KEY-VALUE-MAP (DICTIONARY) :DOCUMENTATION \"Full-featured dictionary class that supports `eql?' or
`equal?' equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table.\" :PUBLIC? TRUE :SLOTS ((THE-MAP :TYPE OBJECT) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the
equality test (and `equal-hash-code' as the hash function), otherwise,
use `eql?' (and `hash-code') (the default).\") (INITIAL-SIZE :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT* :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial table
will be sized to hold at least that many elements.\") (CROSSOVER-POINT :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT*)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-KEY-VALUE-MAP))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-KEY-VALUE-MAP-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HASH-SET"
       "(DEFCLASS HASH-SET (KEY-VALUE-MAP SET-MIXIN) :DOCUMENTATION \"Full-featured set class that supports `eql?' or `equal?'
equality tests, O(1) insert and `member?' operations & O(N) `intersection'
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space.\" :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-HASH-SET)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DIMENSIONAL-ARRAY-MIXIN"
    "(DEFCLASS DIMENSIONAL-ARRAY-MIXIN () :MIXIN? TRUE :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :SLOTS ((DIM1 :TYPE INTEGER :REQUIRED? TRUE) (THE-ARRAY :TYPE (ARRAY () OF (LIKE (ANY-VALUE SELF))))) :INITIALIZER INITIALIZE-DIMENSIONAL-ARRAY)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "2-DIMENSIONAL-ARRAY-MIXIN"
    "(DEFCLASS 2-DIMENSIONAL-ARRAY-MIXIN (DIMENSIONAL-ARRAY-MIXIN) :MIXIN? TRUE :PUBLIC? TRUE :SLOTS ((DIM2 :TYPE INTEGER :REQUIRED? TRUE)))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-DIMENSIONAL-ARRAY"
    "(DEFCLASS ABSTRACT-DIMENSIONAL-ARRAY (ABSTRACT-COLLECTION) :DOCUMENTATION \"Array objects that are aware of their dimensions.\" :PUBLIC? TRUE :ABSTRACT? TRUE :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "1D-ARRAY"
       "(DEFCLASS 1D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"1-dimensional array with OBJECT values.  This is more or
less equivalent to VECTOR (fewer methods) but kept here for symmetry.\" :PUBLIC? TRUE :SYNONYMS (OBJECT-ARRAY) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-1D-ARRAY)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "1D-FLOAT-ARRAY"
       "(DEFCLASS 1D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"1-dimensional array with float values.\" :PUBLIC? TRUE :SYNONYMS (FLOAT-ARRAY) :PARAMETERS ((ANY-VALUE :TYPE FLOAT)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-1D-FLOAT-ARRAY)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "2D-ARRAY"
       "(DEFCLASS 2D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"2-dimensional array with object values.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-2D-ARRAY)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "2D-FLOAT-ARRAY"
       "(DEFCLASS 2D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"2-dimensional array with float values.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE FLOAT)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-2D-FLOAT-ARRAY)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BUFFERED-STRING"
       "(DEFCLASS BUFFERED-STRING (STANDARD-OBJECT) :SYNONYMS (STRING-BUFFER) :SLOTS ((BUFFER :TYPE MUTABLE-STRING :INITIALLY (MAKE-RAW-MUTABLE-STRING 16)) (BUFFER-SIZE :TYPE INTEGER :INITIALLY 16) (FILL-POINTER :TYPE INTEGER :INITIALLY 0)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BUFFERED-STRING))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-BUFFERED-STRING-SLOT-VALUE))))
  :VOID)

(CL:DEFUN HELP-STARTUP-COLLECTIONS3 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF COLLECTION) (OBJECT OBJECT)) :DOCUMENTATION \"Return true iff `object' is a member of the collection `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION MEMBER?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF COLLECTION)) :DOCUMENTATION \"Return `self' with duplicates removed.  Preserves the
original order of the remaining members.\" :PUBLIC? TRUE :ABSTRACT? TRUE)"
    NULL NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-COLLECTION?"
    "(DEFUN (STELLA-COLLECTION? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `self' is a native collection.\")"
    (CL:FUNCTION STELLA-COLLECTION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' forbids duplicate values.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION NO-DUPLICATES?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NO-DUPLICATES?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' is ordered.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION ORDERED?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SEQUENCE)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ORDERED?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ORDERED?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PUSH ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the front of set `self' unless it is already a member.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION PUSH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-LAST ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the end of set `self' unless it is already a member.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF SET)))"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE-DUPLICATES)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION SUBSTITUTE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE SET) ((SET1 SET) (SET2 LIST) |&REST| (OTHERSETS LIST)) :DOCUMENTATION \"Union `set2' and all `otherSets' onto the end of `set1'.
The operation is destructive wrt `set1', but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CONCATENATE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff `x' and `y' are SET's with equivalent members.
Uses `equal?' to test equality of elements.  This is more general than
`equivalent-sets?', since that only uses an `eql?' test.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUAL-HASH-CODE)) NULL)
   (DEFINE-FUNCTION-OBJECT "SET"
    "(DEFUN (SET SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a set containing `values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SET) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-VECTOR ((SELF VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION PRINT-VECTOR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NON-EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FIRST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 1)))"
    (WRAP-METHOD-CODE (CL:FUNCTION SECOND)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 2)))"
    (WRAP-METHOD-CODE (CL:FUNCTION THIRD)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 3)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FOURTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 4)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FIFTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (THE-ARRAY SELF) POSITION)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector `self'.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 0) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FIRST-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 1) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION SECOND-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 2) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION THIRD-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 3) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FOURTH-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 4) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FIFTH-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH (THE-ARRAY SELF) POSITION) VALUE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NTH-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION MEMBER?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only 
consider the portion starting at `start', however, the returned position 
will always be relative to the entire vector.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION POSITION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (END INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only 
consider the portion ending at index `end', however, the returned position 
will always be relative to the entire vector.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST-POSITION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a copy of the vector `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF VECTOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR"
    "(DEFUN (VECTOR VECTOR) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a vector containing `values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X VECTOR) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff the vectors `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF VECTOR)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUAL-HASH-CODE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (LENGTH SELF) 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (> (LENGTH SELF) 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NON-EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SEQUENCE-LENGTH SELF)))"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector `self'.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append `value' to the END of the sequence `self'.  
Resize the array if necessary.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF CUSTOM-VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append `value' to the END of the sequence `self'.  
Resize the array if necessary.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove `value' from the sequence `self', and left shift
the values after it to close the gap.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Reverse the order of elements in the active portion of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REVERSE)) NULL)
   (DEFINE-FUNCTION-OBJECT "COPY-VECTOR-SEQUENCE"
    "(DEFUN COPY-VECTOR-SEQUENCE ((SOURCE VECTOR-SEQUENCE) (COPY VECTOR-SEQUENCE)))"
    (CL:FUNCTION COPY-VECTOR-SEQUENCE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return a copy of the vector sequence `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (CUSTOM-VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ((SELF CUSTOM-VECTOR-SEQUENCE)) :DOCUMENTATION \"Return a copy of the vector sequence `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Clear `self' by setting its active length to zero.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X VECTOR-SEQUENCE) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff the sequences `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-COLLECTIONS4 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)))"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-ITERATOR)) NULL)
   (DEFINE-FUNCTION-OBJECT "VECTOR-NEXT?"
    "(DEFUN (VECTOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION VECTOR-NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Generate all but the last element of the vector `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION BUT-LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order.  If `predicate' is `null', a
suitable '<' predicate is chosen depending on the first element of `self',
and it is assumed that all elements of `self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")"
    (WRAP-METHOD-CODE (CL:FUNCTION SORT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT-TUPLES (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (N INTEGER) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Just like `sort' but assumes each element of `self' is a tuple (a cons)
whose `n'-th element (0-based) will be used for comparison.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION SORT-TUPLES)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT-OBJECTS (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (SLOT STORAGE-SLOT) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Just like `sort' but assumes each element of `self' has a `slot'
whose value will be used for comparison.  Elements must be descendants of
STANDARD OBJECT.  Note that while this will work with literal-valued slots,
it will cause value wrapping everytime `slot' is read.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION SORT-OBJECTS)) NULL)
   (DEFINE-FUNCTION-OBJECT "HEAP-SORT-NATIVE-VECTOR"
    "(DEFUN HEAP-SORT-NATIVE-VECTOR ((VECTOR NATIVE-VECTOR) (SIZE INTEGER) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION HEAP-SORT-NATIVE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "HEAP-SORT-HEAPIFY"
    "(DEFUN HEAP-SORT-HEAPIFY ((VECTOR NATIVE-VECTOR) (SIZE INTEGER) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION HEAP-SORT-HEAPIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "HEAP-SORT-SIFT-DOWN"
    "(DEFUN HEAP-SORT-SIFT-DOWN ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION HEAP-SORT-SIFT-DOWN) NULL)
   (DEFINE-FUNCTION-OBJECT "QUICK-SORT-PICK-SPLIT-ELEMENT"
    "(DEFUN (QUICK-SORT-PICK-SPLIT-ELEMENT OBJECT) ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION QUICK-SORT-PICK-SPLIT-ELEMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "QUICK-SORT-NATIVE-VECTOR"
    "(DEFUN QUICK-SORT-NATIVE-VECTOR ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION QUICK-SORT-NATIVE-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD INITIALIZE-HEAP ((SELF HEAP)))"
    (WRAP-METHOD-CODE (CL:FUNCTION INITIALIZE-HEAP)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (HEAP OF (LIKE (ANY-VALUE SELF)))) ((SELF HEAP)) :DOCUMENTATION \"Return a copy of the heap `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF HEAP)) :DOCUMENTATION \"Clear `self' by setting its active length to zero.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF HEAP)) :DOCUMENTATION \"Return the length of the currently filled portion of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF HEAP)) :DOCUMENTATION \"Return TRUE if `self' is empty.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the last item in the heap `self' which will be the
largest or best item if `self' is a sorted min-heap with a '<' predicate.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (HEAP-ROOT (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the root of `self' (NULL if `self' is empty).
The root contains the minimum element of a min-heap with '<' predicate.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION HEAP-ROOT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FAST-HEAP-ROOT (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the root of `self' which is assumed to be non-empty.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FAST-HEAP-ROOT)) NULL)
   (DEFINE-FUNCTION-OBJECT "HEAP-SIFT-UP"
    "(DEFUN HEAP-SIFT-UP ((HEAP NATIVE-VECTOR) (START INTEGER) (END INTEGER) (VALUE (LIKE (ANY-VALUE SELF))) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION HEAP-SIFT-UP) NULL)
   (DEFINE-FUNCTION-OBJECT "HEAP-SIFT-DOWN"
    "(DEFUN HEAP-SIFT-DOWN ((HEAP NATIVE-VECTOR) (START INTEGER) (END INTEGER) (VALUE (LIKE (ANY-VALUE SELF))) (PREDICATE FUNCTION-CODE)))"
    (CL:FUNCTION HEAP-SIFT-DOWN) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert `value' into `self' and restore the heap property.
Signal an error if there is no more room in `self'.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REPLACE-HEAP-ROOT ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Replace the current root of `self' with `value' and restore
the heap property.  Signal an error if `self' is empty.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REPLACE-HEAP-ROOT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-IF-BETTER ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert `value' into `self' and restore the heap property.
If `self' has available room, simply insert `value'.  If the heap is full, only
insert `value' if it is better than the current root (i.e., if `value' is
greater than the minimum of `self' for the case of a min-heap where `self's
`predicate' has `<' semantics).  In that case, replace the root of `self'
and restore the heap property.  This is useful to build and maintain a
heap with some top-N elements (relative to `predicate') where the root (or
minimum) of `self' is the currently weakest element at the end of the list.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-IF-BETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD HEAPIFY ((SELF HEAP)) :DOCUMENTATION \"Restore the heap property of `self' according to its
`predicate'.  Normally, this is not needed, since insert operations
preserve the heap property.  However, this can be useful after bulk
insertion of values or if `predicate' has been changed.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION HEAPIFY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SORT (HEAP OF (LIKE (ANY-VALUE SELF)))) ((SELF HEAP) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Sort the heap `self' according to `predicate' (in
ascending order if `predicate' has `<' semantics).  If `predicate'
is NULL simply use `self's internal predicate (the normal case).
If it is different from `self's internal predicate, heapify `self' first
according to the new predicate, store the new predicate in `self' and
then sort the heap.  Note that a sorted array automatically satisfies
the heap property.  This is slightly different than a regular heap
sort due to the way HEAP's are maintained; however, the complexity is
the same.\" :PUBLIC? TRUE)" (WRAP-METHOD-CODE (CL:FUNCTION SORT)) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-STELLA-HASH-TABLE"
    "(DEFUN INITIALIZE-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE)))"
    (CL:FUNCTION INITIALIZE-STELLA-HASH-TABLE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Initialize the STELLA hash table `self'.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION INITIALIZE-HASH-TABLE)) NULL)
   (DEFINE-FUNCTION-OBJECT "REHASH-STELLA-HASH-TABLE"
    "(DEFUN REHASH-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE) (NEWSIZE INTEGER)))"
    (CL:FUNCTION REHASH-STELLA-HASH-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-INSERT-AT"
    "(DEFUN STELLA-HASH-TABLE-INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT) (VALUE OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-INSERT-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-REMOVE-AT"
    "(DEFUN STELLA-HASH-TABLE-REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-REMOVE-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-HASH-TABLE-LOOKUP"
    "(DEFUN (STELLA-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))"
    (CL:FUNCTION STELLA-HASH-TABLE-LOOKUP) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-STRING-HASH-TABLE-LOOKUP"
    "(DEFUN (STELLA-STRING-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY STRING)))"
    (CL:FUNCTION STELLA-STRING-HASH-TABLE-LOOKUP) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LOOKUP)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NON-EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return a copy of the hash table `self'.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Remove all entries from `self'.  This will result in a
re-initialization of the table upon the first insertion into `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY (CONS OF CONS)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CONSIFY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X STELLA-HASH-TABLE) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUAL-HASH-CODE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Allocate an iterator for `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-ITERATOR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF STELLA-HASH-TABLE-ITERATOR)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))"
    (WRAP-METHOD-CODE (CL:FUNCTION VALUE-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))))"
    (WRAP-METHOD-CODE (CL:FUNCTION KEY-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LOOKUP)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE-AT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NON-EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return a copy of the map `self'.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Reset `self' to have zero entries.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Allocate an iterator for `self'.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-ITERATOR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CONSIFY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X KEY-VALUE-MAP) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUAL-HASH-CODE)) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-COLLECTIONS5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "HASH-SET"
    "(DEFUN (HASH-SET HASH-SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return an `eql?' HASH-SET containing `values'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION HASH-SET) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-HASH-SET"
    "(DEFUN (COERCE-TO-HASH-SET HASH-SET) ((SELF OBJECT) (EQUALTEST? BOOLEAN)) :DOCUMENTATION \"Coerce the collection `self' into a HASH-SET.  Use an
equal test if `equalTest?' is TRUE (`equalTest?' will be ignored if `self'
already is a HASH-SET).\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-HASH-SET) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF HASH-SET) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE iff `object' is a member of the set `self'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION MEMBER?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE (LIKE SELF)) ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Destructively remove `value' from the set `self' if it is a member and
return `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of
`self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REMOVE-IF (LIKE SELF)) ((SELF HASH-SET) (TEST? FUNCTION-CODE)) :DOCUMENTATION \"Destructively remove all elements of the set `self' for which
'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REMOVE-IF)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF HASH-SET)) :DOCUMENTATION \"Remove and return an arbitrary element of the set `self'.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to `pop',
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases.\" :PUBLIC? TRUE)" (WRAP-METHOD-CODE (CL:FUNCTION POP))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF HASH-SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.  Uses an `eql?' test by default or `equal?'
if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION SUBSTITUTE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF HASH-SET)) :DOCUMENTATION \"Return a copy of the set `self'.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.).\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF HASH-SET)) :DOCUMENTATION \"Collect all entries of `self' into a cons list and return the result.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CONSIFY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSET? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' also occurs in `otherSet'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION SUBSET?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' occurs in `otherSet' and vice versa.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUIVALENT-SETS?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTERSECTION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set intersection of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INTERSECTION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (UNION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set union of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION UNION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DIFFERENCE HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' as a new set (i.e.,
all elements that are in `self' but not in `otherSet').  Uses an `eql?' test
by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION DIFFERENCE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBTRACT HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' by destructively
removing elements from `self' that also occur in `otherSet'.  Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION SUBTRACT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X HASH-SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.
This is equivalent to calling `equivalent-sets?'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION OBJECT-EQUAL?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF HASH-SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EQUAL-HASH-CODE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF DIMENSIONAL-ARRAY-MIXIN)) (SETF (THE-ARRAY SELF) (NEW (ARRAY () OF (LIKE (ANY-VALUE SELF))) :SIZE (LENGTH SELF))))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF DIMENSIONAL-ARRAY-MIXIN)) :DOCUMENTATION \"Return the total number of elements in `self'.\" :PUBLIC? TRUE (RETURN (DIM1 SELF)))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-ARRAY ((SELF DIMENSIONAL-ARRAY-MIXIN) (INITIALVALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Initialize the elements of `self' with `initialValue'.\" :PUBLIC? TRUE (LET ((ARRAY (THE-ARRAY SELF))) (FOREACH I IN (INTERVAL 0 (1- (LENGTH SELF))) DO (SETF (AREF ARRAY I) INITIALVALUE))))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (1D-AREF (LIKE (ANY-VALUE SELF))) ((SELF DIMENSIONAL-ARRAY-MIXIN) (I INTEGER)) :DOCUMENTATION \"Return the element of `self' at position `[i]'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (AREF (THE-ARRAY SELF) I)))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (1D-AREF-SETTER (LIKE (ANY-VALUE SELF))) ((SELF DIMENSIONAL-ARRAY-MIXIN) (VALUE (LIKE (ANY-VALUE SELF))) (I INTEGER)) :DOCUMENTATION \"Set the element of `self' at position `[i]' to `value'
and return the result.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (AREF (THE-ARRAY SELF) I) VALUE)))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (1D-AREF-ADDRESS INTEGER) ((SELF DIMENSIONAL-ARRAY-MIXIN) (I INTEGER)) :DOCUMENTATION \"Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN I))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN)) :DOCUMENTATION \"Return the total number of elements in `self'.\" :PUBLIC? TRUE (RETURN (* (DIM1 SELF) (DIM2 SELF))))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2D-AREF (LIKE (ANY-VALUE SELF))) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Return the element of `self' at position `[i, j]'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (AREF (THE-ARRAY SELF) (+ (* I (DIM2 SELF)) J))))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2D-AREF-SETTER (LIKE (ANY-VALUE SELF))) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (VALUE (LIKE (ANY-VALUE SELF))) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Set the element of `self' at position `[i, j]' to `value'
and return the result.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (AREF (THE-ARRAY SELF) (+ (* I (DIM2 SELF)) J)) VALUE)))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2D-AREF-ADDRESS INTEGER) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Return the 1D address of the element at position `[i, j]'.
This is useful for fast element-wise iteration that doesn't need arithmetic.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (+ (* I (DIM2 SELF)) J)))"
    NULL NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ((SELF 1D-ARRAY)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-ARRAY-READER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ((SELF 1D-FLOAT-ARRAY)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-ARRAY-READER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ((SELF 2D-ARRAY)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-ARRAY-READER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-ARRAY-READER (ARRAY () OF (LIKE (ANY-VALUE SELF)))) ((SELF 2D-FLOAT-ARRAY)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-ARRAY-READER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RESIZE-BUFFER MUTABLE-STRING) ((SELF STRING-BUFFER) (SIZE INTEGER)) :DOCUMENTATION \"Change the size of `self' to `size'.  If `size' is smaller
than the current size of `self', it's buffer will be truncated.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION RESIZE-BUFFER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ENSURE-FREE-SPACE MUTABLE-STRING) ((SELF STRING-BUFFER) (SIZE INTEGER)) :DOCUMENTATION \"Ensure `self' is big enough to accommodate an additional item of `size'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ENSURE-FREE-SPACE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (FREE-SPACE INTEGER) ((SELF STRING-BUFFER)) :DOCUMENTATION \"Return the amount of free space in `self'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (- (BUFFER-SIZE SELF) (FILL-POINTER SELF))))"
    (WRAP-METHOD-CODE (CL:FUNCTION FREE-SPACE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF STRING-BUFFER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (FILL-POINTER SELF)))"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH-SETTER INTEGER) ((SELF STRING-BUFFER) (NEWLENGTH INTEGER)) :DOCUMENTATION \"Reset the length of `self' to `newLength'.  Fill in NULL characters if `newLength' 
is greater than the current length.  This is the safe way to reset the fill pointer.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF STRING-BUFFER)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (LENGTH SELF) 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF STRING-BUFFER)) :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (> (LENGTH SELF) 0)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NON-EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH CHARACTER) ((SELF STRING-BUFFER) (POSITION INTEGER)) :DOCUMENTATION \"Return the character in `self' at `position'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH (BUFFER SELF) POSITION)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER CHARACTER) ((SELF STRING-BUFFER) (CH CHARACTER) (POSITION INTEGER)) :DOCUMENTATION \"Set the character in `self' at `position' to `ch'.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH (BUFFER SELF) POSITION) CH)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NTH-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST CHARACTER) ((SELF STRING-BUFFER)) :DOCUMENTATION \"Return the last character in `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LAST-SETTER CHARACTER) ((SELF STRING-BUFFER) (VALUE CHARACTER)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LAST-SETTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD APPEND-STRING ((SELF STRING-BUFFER) (VALUE STRING)) :DOCUMENTATION \"Append `value' to the END of the string `self'.  
Resize the buffer if necessary.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION APPEND-STRING)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD APPEND-CHARACTER ((SELF STRING-BUFFER) (CHAR CHARACTER)) :DOCUMENTATION \"Append `char' to the END of the string `self'.  
Resize the buffer if necessary.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION APPEND-CHARACTER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POP CHARACTER) ((SELF STRING-BUFFER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION POP)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY STRING-BUFFER) ((SELF STRING-BUFFER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION COPY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((SELF STRING-BUFFER)) :DOCUMENTATION \"Clear `self' by setting its active length to zero.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CLEAR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-STRING STRING) ((SELF STRING-BUFFER)) :DOCUMENTATION \"Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SUBSEQUENCE (BUFFER SELF) 0 (FILL-POINTER SELF))))"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-STRING)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUBSEQUENCE STRING) ((SELF STRING-BUFFER) (START INTEGER) (END INTEGER)) :DOCUMENTATION \"Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (WHEN (NULL? END) (SETQ END (LENGTH SELF))) (RETURN (SUBSEQUENCE (BUFFER SELF) START END)))"
    (WRAP-METHOD-CODE (CL:FUNCTION SUBSEQUENCE)) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-COLLECTIONS"
    "(DEFUN STARTUP-COLLECTIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-COLLECTIONS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-COLLECTIONS-STELLA-STARTUP-COLLECTIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-COLLECTIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupCollections") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-COLLECTIONS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-COLLECTIONS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *KEY-VALUE-MAP-CROSSOVER-POINT*
     *REMOVE-DUPLICATES-CROSSOVER-POINT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (HELP-STARTUP-COLLECTIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-COLLECTIONS3)
    (HELP-STARTUP-COLLECTIONS4) (HELP-STARTUP-COLLECTIONS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (REGISTER-NATIVE-NAME SYM-COLLECTIONS-STELLA-VECTOR
     KWD-COLLECTIONS-CPP KWD-COLLECTIONS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *USE-STELLA-HASH-TABLES?* BOOLEAN (VERBATIM :COMMON-LISP \"CL-USER::*use-stella-hash-tables?*\" :CPP \"
#ifndef HAVE_SGI_HASH_MAPS
  TRUE
#else
  FALSE
#endif
\" :OTHERWISE FALSE))" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* FLOAT 1.0)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *KEY-VALUE-MAP-CROSSOVER-POINT* INTEGER *REMOVE-DUPLICATES-CROSSOVER-POINT* :DOCUMENTATION \"Point where we switch from using a KV-CONS table
representation to a STELLA hash table to preserve O(1) access.\")"
     NULL)))
  :VOID)
