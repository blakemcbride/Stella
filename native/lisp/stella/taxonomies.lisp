;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; taxonomies.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-TAXONOMIES-STELLA-STARTUP-TAXONOMIES NULL)
(CL:DEFVAR SYM-TAXONOMIES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* EOL NULL-INTEGER DELETED-LABEL
  NIL))

;;; (DEFGLOBAL *NUMBERING-INTERVAL* ...)

(CL:DEFVAR *NUMBERING-INTERVAL* 100
  "Spacing between postorder numbers for nodes.  Allows limited
incremental insertions without having to renumber the whole graph.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NUMBERING-INTERVAL*))

;;; (DEFUN (TAXONOMY-ROOT? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-ROOT? (NODE)
  "Return `true' if `node' is a taxonomy root node."
  (CL:RETURN-FROM TAXONOMY-ROOT? (CL:EQ (%PARENTS NODE) NIL)))

;;; (DEFUN ADD-TAXONOMY-ROOT ...)

(CL:DEFUN ADD-TAXONOMY-ROOT (GRAPH ROOT)
  "Add `root' as a root node to `graph'.  Only do this if
`root' does not have any parents and is not a `graph' root already."
  (INSERT-NEW (%ROOTS GRAPH) ROOT)
  :VOID)

;;; (DEFUN REMOVE-TAXONOMY-ROOT ...)

(CL:DEFUN REMOVE-TAXONOMY-ROOT (GRAPH ROOT)
  "Remove `root' from `graph's root nodes."
  (CL:WHEN (CL:NOT (CL:= (%LABEL ROOT) DELETED-LABEL))
   (REMOVE (%ROOTS GRAPH) ROOT))
  :VOID)

;;; (DEFUN UPDATE-TAXONOMY-ROOTS ...)

(CL:DEFUN UPDATE-TAXONOMY-ROOTS (GRAPH NODE)
  "Update `graph's roots according to `node's current state."
  (CL:IF (CL:EQ (%PARENTS NODE) NIL) (ADD-TAXONOMY-ROOT GRAPH NODE)
   (REMOVE-TAXONOMY-ROOT GRAPH NODE))
  :VOID)

;;; (DEFUN (CREATE-TAXONOMY-NODE TAXONOMY-NODE) ...)

(CL:DEFUN CREATE-TAXONOMY-NODE (GRAPH NODE NATIVEOBJECT ROOT?)
  "Link the taxonomy node `node' to `nativeObject' and add it
to `graph'.  If it is `null', a new node will be created.  Mark it as a root
node if `root?' is `true'.  Return the node."
  (CL:COND
   ((CL:EQ NODE NULL)
    (CL:LET* ((SELF-000 (NEW-TAXONOMY-NODE)))
     (CL:SETF (%NATIVE-OBJECT SELF-000) NATIVEOBJECT)
     (CL:SETQ NODE SELF-000)))
   (CL:T (INITIALIZE-TAXONOMY-NODE NODE)
    (CL:SETF (%NATIVE-OBJECT NODE) NATIVEOBJECT)))
  (ADD-TAXONOMY-NODE GRAPH NODE ROOT?)
  (CL:RETURN-FROM CREATE-TAXONOMY-NODE NODE))

;;; (DEFUN ADD-TAXONOMY-NODE ...)

(CL:DEFUN ADD-TAXONOMY-NODE (GRAPH NODE ROOT?)
  "Add `node' to `graph'.  Mark it as a root node if `root?'
is `true'.  Even though this is part of the API, it should rarely be needed,
since `create-taxonomy-node' does everything that's necessary."
  (CL:WHEN ROOT? (ADD-TAXONOMY-ROOT GRAPH NODE))
  (CL:SETF (%NUMBER-OF-NODES GRAPH) (CL:1+ (%NUMBER-OF-NODES GRAPH)))
  :VOID)

;;; (DEFUN REMOVE-TAXONOMY-NODE ...)

(CL:DEFUN REMOVE-TAXONOMY-NODE (GRAPH NODE)
  "Remove `node' from `graph' and disconnect incident links."
  (CL:LET*
   ((PARENTSCOPY (COPY-CONS-LIST (%PARENTS NODE)))
    (CHILDRENCOPY (COPY-CONS-LIST (%CHILDREN NODE))))
   (CL:LET* ((PARENT NULL) (ITER-000 PARENTSCOPY))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000))
     (UNLINK-TAXONOMY-NODES GRAPH PARENT NODE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((CHILD NULL) (ITER-001 CHILDRENCOPY))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-001))
     (UNLINK-TAXONOMY-NODES GRAPH NODE CHILD)
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:SETF (%INTERVALS NODE) NIL) (CL:SETF (%NATIVE-OBJECT NODE) NULL)
   (DELETED?-SETTER NODE CL:T) (REMOVE-TAXONOMY-ROOT GRAPH NODE)
   (CL:SETF (%NUMBER-OF-NODES GRAPH) (CL:1- (%NUMBER-OF-NODES GRAPH))))
  :VOID)

;;; (DEFUN CREATE-TAXONOMY-LINK ...)

(CL:DEFUN CREATE-TAXONOMY-LINK (GRAPH PARENT CHILD)
  (REMOVE-TAXONOMY-ROOT GRAPH CHILD)
  (CL:SETF (%PARENTS CHILD) (CONS PARENT (%PARENTS CHILD)))
  (CL:SETF (%CHILDREN PARENT) (CONS CHILD (%CHILDREN PARENT)))
  :VOID)

;;; (DEFUN LINK-TAXONOMY-NODES ...)

(CL:DEFUN LINK-TAXONOMY-NODES (GRAPH PARENT CHILD)
  "Cross-link `parent' and `child' in `graph'.
IMPORTANT: This will automatically insert a backlink from `child' to
`parent', so, for maximum efficiency it should not be called a second time
with the arguments reversed."
  (CL:WHEN (MEMB? (%CHILDREN PARENT) CHILD)
   (CL:RETURN-FROM LINK-TAXONOMY-NODES))
  (CL:IF (%INCREMENTAL-MODE? GRAPH)
   (PUSH (%ADDED-LINKS GRAPH) (CONS PARENT (CONS CHILD NIL)))
   (CREATE-TAXONOMY-LINK GRAPH PARENT CHILD))
  :VOID)

;;; (DEFUN INCREMENTALLY-LINK-TAXONOMY-NODES ...)

(CL:DEFUN INCREMENTALLY-LINK-TAXONOMY-NODES (GRAPH PARENT CHILD)
  (CL:WHEN (MEMB? (%CHILDREN PARENT) CHILD)
   (CL:RETURN-FROM INCREMENTALLY-LINK-TAXONOMY-NODES))
  (CREATE-TAXONOMY-LINK GRAPH PARENT CHILD)
  (CL:LET*
   ((INTERVAL NULL)
    (PARENTEXISTS? (CL:NOT (CL:EQ (%INITIAL-INTERVAL PARENT) NULL)))
    (CHILDEXISTS? (CL:NOT (CL:EQ (%INITIAL-INTERVAL CHILD) NULL))))
   (CL:COND
    (CHILDEXISTS?
     (CL:WHEN (CL:NOT PARENTEXISTS?)
      (CL:SETQ INTERVAL (CREATE-NEXT-POSTORDER-INTERVAL GRAPH))
      (CL:SETF (%INITIAL-INTERVAL PARENT) INTERVAL)
      (CL:SETF (%LABEL PARENT) (%UPPER-BOUND INTERVAL))
      (ADD-TAXONOMY-NODE-INTERVAL PARENT INTERVAL))
     (CL:LET* ((INTERVAL NULL) (ITER-000 (%INTERVALS CHILD)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ INTERVAL (%%VALUE ITER-000))
       (PROPAGATE-FOREIGN-INTERVAL PARENT INTERVAL)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:T
     (CL:WHEN (CL:NOT PARENTEXISTS?)
      (CL:SETQ INTERVAL (CREATE-NEXT-POSTORDER-INTERVAL GRAPH))
      (CL:SETF (%INITIAL-INTERVAL PARENT) INTERVAL)
      (CL:SETF (%LABEL PARENT) (%UPPER-BOUND INTERVAL))
      (ADD-TAXONOMY-NODE-INTERVAL PARENT INTERVAL))
     (CL:SETQ INTERVAL (ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE PARENT))
     (CL:WHEN (CL:EQ INTERVAL NULL)
      (CL:WHEN (%RENUMBER-IF-OUT-OF-NUMBERS? GRAPH)
       (FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY GRAPH)
       (CL:RETURN-FROM INCREMENTALLY-LINK-TAXONOMY-NODES))
      (CL:SETQ INTERVAL (CREATE-NEXT-POSTORDER-INTERVAL GRAPH)))
     (CL:SETF (%INITIAL-INTERVAL CHILD) INTERVAL)
     (CL:SETF (%LABEL CHILD) (%UPPER-BOUND INTERVAL))
     (ADD-TAXONOMY-NODE-INTERVAL CHILD INTERVAL)
     (CL:SETF (%TREE-CHILDREN PARENT)
      (CONCATENATE (%TREE-CHILDREN PARENT) (CONS CHILD NIL)))
     (PROPAGATE-FOREIGN-INTERVAL PARENT INTERVAL))))
  :VOID)

;;; (DEFUN (CREATE-NEXT-POSTORDER-INTERVAL INTERVAL) ...)

(CL:DEFUN CREATE-NEXT-POSTORDER-INTERVAL (GRAPH)
  (CL:SETF (%NUMBER-OF-FOREIGN-INTERVAL-NODES GRAPH)
   (CL:1+ (%NUMBER-OF-FOREIGN-INTERVAL-NODES GRAPH)))
  (CL:LET* ((NEWINTERVAL (NEW-INTERVAL)))
   (CL:SETF (%LOWER-BOUND NEWINTERVAL)
    (CL:1+ (%LARGEST-POSTORDER-NUMBER GRAPH)))
   (CL:SETF (%UPPER-BOUND NEWINTERVAL)
    (CL:+ (%LARGEST-POSTORDER-NUMBER GRAPH) *NUMBERING-INTERVAL*))
   (CL:SETF (%LARGEST-POSTORDER-NUMBER GRAPH)
    (%UPPER-BOUND NEWINTERVAL))
   (CL:RETURN-FROM CREATE-NEXT-POSTORDER-INTERVAL NEWINTERVAL)))

;;; (DEFUN (ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE INTERVAL) ...)

(CL:DEFUN ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE (PARENT)
  (CL:LET* ((PARENTINTERVAL (%INITIAL-INTERVAL PARENT)))
   (CL:WHEN (CL:EQ (%TREE-CHILDREN PARENT) NIL)
    (CL:WHEN
     (CL:= (%LOWER-BOUND PARENTINTERVAL) (%UPPER-BOUND PARENTINTERVAL))
     (CL:RETURN-FROM ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE NULL))
    (CL:LET* ((SELF-000 (NEW-INTERVAL)))
     (CL:SETF (%LOWER-BOUND SELF-000) (%LOWER-BOUND PARENTINTERVAL))
     (CL:SETF (%UPPER-BOUND SELF-000)
      (FLOOR
       (CL:/
        (CL:+ (%LOWER-BOUND PARENTINTERVAL)
         (%UPPER-BOUND PARENTINTERVAL))
        2.0d0)))
     (CL:LET* ((VALUE-000 SELF-000))
      (CL:RETURN-FROM ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE VALUE-000))))
   (CL:LET*
    ((RIGHTCHILD (LAST (%TREE-CHILDREN PARENT)))
     (RIGHTCHILDINTERVAL (%INITIAL-INTERVAL RIGHTCHILD)))
    (CL:WHEN
     (CL:>= (%UPPER-BOUND RIGHTCHILDINTERVAL)
      (CL:1- (%UPPER-BOUND PARENTINTERVAL)))
     (CL:RETURN-FROM ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE NULL))
    (CL:LET* ((SELF-001 (NEW-INTERVAL)))
     (CL:SETF (%LOWER-BOUND SELF-001)
      (CL:1+ (%UPPER-BOUND RIGHTCHILDINTERVAL)))
     (CL:SETF (%UPPER-BOUND SELF-001)
      (CEILING
       (CL:/
        (CL:+ (%UPPER-BOUND PARENTINTERVAL)
         (%UPPER-BOUND RIGHTCHILDINTERVAL))
        2.0d0)))
     (CL:LET* ((VALUE-001 SELF-001))
      (CL:RETURN-FROM ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE VALUE-001))))))

;;; (DEFUN UNLINK-TAXONOMY-NODES ...)

(CL:DEFUN UNLINK-TAXONOMY-NODES (GRAPH PARENT CHILD)
  "Remove link between `parent' and `child'."
  (CL:WHEN (CL:NOT (MEMB? (%CHILDREN PARENT) CHILD))
   (CL:RETURN-FROM UNLINK-TAXONOMY-NODES))
  (CL:WHEN (%INCREMENTAL-MODE? GRAPH)
   (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL))
  (CL:SETF (%CHILDREN PARENT) (REMOVE (%CHILDREN PARENT) CHILD))
  (CL:SETF (%TREE-CHILDREN PARENT)
   (REMOVE (%TREE-CHILDREN PARENT) CHILD))
  (CL:SETF (%PARENTS CHILD) (REMOVE (%PARENTS CHILD) PARENT))
  (UPDATE-TAXONOMY-ROOTS GRAPH CHILD)
  :VOID)

;;; (DEFUN INCREMENTALLY-UNLINK-TAXONOMY-NODES ...)

(CL:DEFUN INCREMENTALLY-UNLINK-TAXONOMY-NODES (GRAPH PARENT CHILD)
  (CL:PROGN (CL:SETQ GRAPH GRAPH) (CL:SETQ PARENT PARENT)
   (CL:SETQ CHILD CHILD))
  (CL:ERROR
   (NEW-STELLA-EXCEPTION
    "incrementally-unlink-taxonomy-nodes: Rewrite me!"))
  :VOID)

;;; (DEFUN (ALL-TAXONOMY-NODES (ITERATOR OF TAXONOMY-NODE)) ...)

(CL:DEFUN ALL-TAXONOMY-NODES (GRAPH)
  "Given a taxonomy `graph' that has been finalized,
return an iterator that generates all the graph's nodes."
  (CL:LET* ((SELF-000 (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ITERATOR-OBJECT SELF-000) (COPY (%ROOTS GRAPH)))
   (CL:SETF (%ITERATOR-NEXT-CODE SELF-000)
    (CL:FUNCTION ALL-TAXONOMY-NODES-NEXT?))
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM ALL-TAXONOMY-NODES VALUE-000))))

;;; (DEFUN (ALL-TAXONOMY-NODES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-TAXONOMY-NODES-NEXT? (SELF)
  (CL:LET* ((ROOTS (%ITERATOR-OBJECT SELF)))
   (CL:WHEN (EMPTY? ROOTS)
    (CL:RETURN-FROM ALL-TAXONOMY-NODES-NEXT? CL:NIL))
   (CL:SETF (%VALUE SELF) (POP ROOTS))
   (CL:LET* ((CHILD NULL) (ITER-000 (%TREE-CHILDREN (%VALUE SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-000)) (PUSH ROOTS CHILD)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM ALL-TAXONOMY-NODES-NEXT? CL:T)))

;;; (DEFUN (FIND-TAXONOMY-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-TAXONOMY-NODE (GRAPH LABEL)
  "Return some node in `graph' with label `label'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM LABEL))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:FIXNUM)
  (CL:LET* ((NODE NULL) (ITER-000 (ALL-TAXONOMY-NODES GRAPH)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ NODE (%VALUE ITER-000))
    (CL:WHEN (CL:= (%LABEL NODE) LABEL)
     (CL:RETURN-FROM FIND-TAXONOMY-NODE NODE))))
  (CL:RETURN-FROM FIND-TAXONOMY-NODE NULL))

;;; (DEFCONSTANT MARKER-LABEL ...)

(CL:DEFVAR MARKER-LABEL -99
  "Dummy label used for marking a node")
(CL:DECLAIM (CL:TYPE CL:FIXNUM MARKER-LABEL))

;;; (DEFCONSTANT DELETED-LABEL ...)

(CL:DEFVAR DELETED-LABEL -99
  "Label used for marking deleted nodes")
(CL:DECLAIM (CL:TYPE CL:FIXNUM DELETED-LABEL))

;;; (DEFUN (LABELED-TAXONOMY-NODE? BOOLEAN) ...)

(CL:DEFUN LABELED-TAXONOMY-NODE? (NODE)
  (CL:RETURN-FROM LABELED-TAXONOMY-NODE?
   (CL:NOT (CL:= (%LABEL NODE) NULL-INTEGER))))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF TAXONOMY-NODE))
  (CL:RETURN-FROM DELETED? (CL:= (%LABEL SELF) DELETED-LABEL)))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF TAXONOMY-NODE) VALUE)
  (CL:IF VALUE (CL:SETF (%LABEL SELF) DELETED-LABEL)
   (CL:SETF (%LABEL SELF) NULL-INTEGER))
  (CL:RETURN-FROM DELETED?-SETTER VALUE))

;;; (DEFUN CLEAR-TAXONOMY-NODE ...)

(CL:DEFUN CLEAR-TAXONOMY-NODE (NODE)
  "Clear all taxonomy-graph-specific information of `node',
but retain information about the native object and associated links."
  (CL:SETF (%LABEL NODE) NULL-INTEGER)
  (CL:SETF (%INTERVALS NODE) NIL)
  (CL:SETF (%INITIAL-INTERVAL NODE) NULL)
  (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND NODE) -1)
  (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND NODE) -1)
  (CL:SETF (%TREE-CHILDREN NODE) NIL)
  (CL:SETF (%TOTAL-ANCESTORS NODE) 1)
  :VOID)

;;; (DEFUN INITIALIZE-TAXONOMY-NODE ...)

(CL:DEFUN INITIALIZE-TAXONOMY-NODE (NODE)
  "Completely clear and initialize `node'."
  (CLEAR-TAXONOMY-NODE NODE)
  (CL:SETF (%PARENTS NODE) NIL)
  (CL:SETF (%CHILDREN NODE) NIL)
  (CL:SETF (%NATIVE-OBJECT NODE) NULL)
  :VOID)

;;; (DEFUN HELP-CLEAR-TAXONOMY-GRAPH ...)

(CL:DEFUN HELP-CLEAR-TAXONOMY-GRAPH (NODE)
  (CL:WHEN (CL:NOT (CL:= (%LABEL NODE) NULL-INTEGER))
   (CLEAR-TAXONOMY-NODE NODE)
   (CL:LET* ((CHILD NULL) (ITER-000 (%CHILDREN NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-000))
     (HELP-CLEAR-TAXONOMY-GRAPH CHILD)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN CLEAR-TAXONOMY-GRAPH ...)

(CL:DEFUN CLEAR-TAXONOMY-GRAPH (GRAPH)
  "Clear all taxonomy-graph-specific information of `graph',
but retain information about the native network and associated links."
  (CL:LET*
   ((ROOT NULL)
    (ITER-000
     (%THE-CONS-LIST (REMOVE-DELETED-MEMBERS (%ROOTS GRAPH)))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ROOT (%%VALUE ITER-000)) (HELP-CLEAR-TAXONOMY-GRAPH ROOT)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL)
  (CL:SETF (%NUMBER-OF-FOREIGN-INTERVAL-NODES GRAPH) 0)
  (CLEAR (%BROKEN-LINKS GRAPH))
  :VOID)

;;; (DEFUN INITIALIZE-TAXONOMY-GRAPH ...)

(CL:DEFUN INITIALIZE-TAXONOMY-GRAPH (GRAPH)
  "Completely clear the taxonomy graph `graph'.
NOTE: Any nodes associated with `graph' will not be cleared.  If they are
to be reused, they have to be cleared with `initialize-taxonomy-node'."
  (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL)
  (CL:SETF (%RENUMBER-IF-OUT-OF-NUMBERS? GRAPH) CL:NIL)
  (CL:SETF (%LARGEST-POSTORDER-NUMBER GRAPH) 0)
  (CL:SETF (%NUMBER-OF-NODES GRAPH) 0)
  (CL:SETF (%NUMBER-OF-FOREIGN-INTERVAL-NODES GRAPH) 0)
  (CL:SETF (%RENUMBER-RATIO GRAPH) 0.1d0)
  (CL:SETF (%ROOTS GRAPH) (NEW-LIST))
  (CL:SETF (%BROKEN-LINKS GRAPH) (NEW-LIST))
  (CL:SETF (%ADDED-LINKS GRAPH) (NEW-LIST))
  (CL:SETF (%REMOVED-LINKS GRAPH) (NEW-LIST))
  :VOID)

;;; (DEFSPECIAL *TAXONOMY-POSTORDER-NUMBER* ...)

(CL:DEFVAR *TAXONOMY-POSTORDER-NUMBER* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TAXONOMY-POSTORDER-NUMBER*))

;;; (DEFUN (HELP-CREATE-TAXONOMY-TREE-INTERVALS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM)
  HELP-CREATE-TAXONOMY-TREE-INTERVALS))
(CL:DEFUN HELP-CREATE-TAXONOMY-TREE-INTERVALS (SELF)
  (CL:LET*
   ((MINCHILDLABEL NULL-INTEGER) (MYLABEL NULL-INTEGER)
    (PREVPOSTNUMBER *TAXONOMY-POSTORDER-NUMBER*))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM MINCHILDLABEL MYLABEL PREVPOSTNUMBER))
   (CL:WHEN (CL:NOT (CL:EQ (%TREE-CHILDREN SELF) NIL))
    (CL:SETQ MINCHILDLABEL
     (HELP-CREATE-TAXONOMY-TREE-INTERVALS
      (%%VALUE (%TREE-CHILDREN SELF)))))
   (CL:LET* ((CHILD NULL) (ITER-000 (%%REST (%TREE-CHILDREN SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-000))
     (HELP-CREATE-TAXONOMY-TREE-INTERVALS CHILD)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ *TAXONOMY-POSTORDER-NUMBER*
    (CL:+ *TAXONOMY-POSTORDER-NUMBER* *NUMBERING-INTERVAL*))
   (CL:SETQ MYLABEL *TAXONOMY-POSTORDER-NUMBER*)
   (CL:WHEN (CL:EQ (%TREE-CHILDREN SELF) NIL)
    (CL:SETQ MINCHILDLABEL (CL:1+ PREVPOSTNUMBER)))
   (CL:SETF (%INITIAL-INTERVAL SELF)
    (INTERN-TAXONOMY-NODE-INTERVAL SELF MINCHILDLABEL MYLABEL))
   (CL:SETF (%LABEL SELF) MYLABEL)
   (CL:RETURN-FROM HELP-CREATE-TAXONOMY-TREE-INTERVALS MINCHILDLABEL)))

;;; (DEFUN CREATE-TAXONOMY-TREE-INTERVALS ...)

(CL:DEFUN CREATE-TAXONOMY-TREE-INTERVALS (GRAPH)
  (CL:LET* ((*TAXONOMY-POSTORDER-NUMBER* 0))
   (CL:DECLARE (CL:SPECIAL *TAXONOMY-POSTORDER-NUMBER*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *TAXONOMY-POSTORDER-NUMBER*))
   (CL:LET* ((ROOT NULL) (ITER-000 (%THE-CONS-LIST (%ROOTS GRAPH))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ROOT (%%VALUE ITER-000))
     (HELP-CREATE-TAXONOMY-TREE-INTERVALS ROOT)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%LARGEST-POSTORDER-NUMBER GRAPH)
    *TAXONOMY-POSTORDER-NUMBER*))
  :VOID)

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((INTERVAL INTERVAL) N)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:RETURN-FROM MEMBER?
   (CL:AND (CL:>= N (%LOWER-BOUND INTERVAL))
    (CL:<= N (%UPPER-BOUND INTERVAL)))))

;;; (DEFUN (SUBINTERVAL-OF? BOOLEAN) ...)

(CL:DEFUN SUBINTERVAL-OF? (SUBINTERVAL SUPERINTERVAL)
  (CL:RETURN-FROM SUBINTERVAL-OF?
   (CL:AND
    (CL:<= (%UPPER-BOUND SUBINTERVAL) (%UPPER-BOUND SUPERINTERVAL))
    (CL:>= (%LOWER-BOUND SUBINTERVAL) (%LOWER-BOUND SUPERINTERVAL)))))

;;; (DEFUN (MERGE-INTERVALS INTERVAL) ...)

(CL:DEFUN MERGE-INTERVALS (LEFTINTERVAL RIGHTINTERVAL)
  (CL:LET* ((SELF-000 (NEW-INTERVAL)))
   (CL:SETF (%LOWER-BOUND SELF-000) (%LOWER-BOUND LEFTINTERVAL))
   (CL:SETF (%UPPER-BOUND SELF-000) (%UPPER-BOUND RIGHTINTERVAL))
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM MERGE-INTERVALS VALUE-000))))

;;; (DEFUN (ALL-TAXONOMY-NODE-INTERVALS (CONS OF INTERVAL)) ...)

(CL:DEFUN ALL-TAXONOMY-NODE-INTERVALS (NODE)
  (CL:RETURN-FROM ALL-TAXONOMY-NODE-INTERVALS (%INTERVALS NODE)))

;;; (DEFUN (INTERN-TAXONOMY-NODE-INTERVAL INTERVAL) ...)

(CL:DEFUN INTERN-TAXONOMY-NODE-INTERVAL (NODE LOWERBOUND UPPERBOUND)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LOWERBOUND UPPERBOUND))
  #+MCL
  (CL:CHECK-TYPE LOWERBOUND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UPPERBOUND CL:FIXNUM)
  (CL:LET* ((SELF-000 (NEW-INTERVAL)))
   (CL:SETF (%LOWER-BOUND SELF-000) LOWERBOUND)
   (CL:SETF (%UPPER-BOUND SELF-000) UPPERBOUND)
   (CL:LET* ((INTERVAL SELF-000))
    (ADD-TAXONOMY-NODE-INTERVAL NODE INTERVAL)
    (CL:RETURN-FROM INTERN-TAXONOMY-NODE-INTERVAL INTERVAL))))

;;; (DEFUN ADD-TAXONOMY-NODE-INTERVAL ...)

(CL:DEFUN ADD-TAXONOMY-NODE-INTERVAL (NODE INTERVAL)
  (CL:SETF (%INTERVALS NODE) (CONS INTERVAL (%INTERVALS NODE)))
  (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND NODE) (%LOWER-BOUND INTERVAL))
  (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND NODE) (%UPPER-BOUND INTERVAL))
  :VOID)

;;; (DEFUN REMOVE-TAXONOMY-NODE-INTERVAL ...)

(CL:DEFUN REMOVE-TAXONOMY-NODE-INTERVAL (NODE INTERVAL)
  (CL:LET* ((INTERVALS (%INTERVALS NODE)))
   (CL:SETQ INTERVALS
    (CL:SETF (%INTERVALS NODE) (REMOVE INTERVALS INTERVAL)))
   (CL:COND
    ((CL:EQ INTERVALS NIL)
     (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND NODE) -1)
     (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND NODE) -1))
    (CL:T
     (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND NODE)
      (%LOWER-BOUND (%%VALUE INTERVALS)))
     (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND NODE)
      (%UPPER-BOUND (%%VALUE INTERVALS))))))
  :VOID)

;;; (DEFUN (ADJOIN-TAXONOMY-NODE-INTERVAL? BOOLEAN) ...)

(CL:DEFUN ADJOIN-TAXONOMY-NODE-INTERVAL? (NODE INTERVAL)
  (CL:LET* ((INTERVALSTOREMOVE NIL))
   (CL:LET* ((INT NULL) (ITER-000 (%INTERVALS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INT (%%VALUE ITER-000))
     (CL:IF (CL:< (%LOWER-BOUND INT) (%LOWER-BOUND INTERVAL))
      (CL:IF (CL:>= (%UPPER-BOUND INT) (%UPPER-BOUND INTERVAL))
       (CL:RETURN-FROM ADJOIN-TAXONOMY-NODE-INTERVAL? CL:NIL)
       (CL:WHEN
        (CL:<= (%LOWER-BOUND INTERVAL) (CL:1+ (%UPPER-BOUND INT)))
        (REMOVE-TAXONOMY-NODE-INTERVAL NODE INT)
        (ADJOIN-TAXONOMY-NODE-INTERVAL? NODE
         (MERGE-INTERVALS INT INTERVAL))
        (CL:RETURN-FROM ADJOIN-TAXONOMY-NODE-INTERVAL? CL:T)))
      (CL:IF (CL:>= (%UPPER-BOUND INTERVAL) (%UPPER-BOUND INT))
       (CL:SETQ INTERVALSTOREMOVE (CONS INT INTERVALSTOREMOVE))
       (CL:WHEN
        (CL:<= (%LOWER-BOUND INT) (CL:1+ (%UPPER-BOUND INTERVAL)))
        (REMOVE-TAXONOMY-NODE-INTERVAL NODE INT)
        (ADJOIN-TAXONOMY-NODE-INTERVAL? NODE
         (MERGE-INTERVALS INTERVAL INT))
        (CL:RETURN-FROM ADJOIN-TAXONOMY-NODE-INTERVAL? CL:T))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((INT NULL) (ITER-001 INTERVALSTOREMOVE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ INT (%%VALUE ITER-001))
     (REMOVE-TAXONOMY-NODE-INTERVAL NODE INT)
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (ADD-TAXONOMY-NODE-INTERVAL NODE INTERVAL)
   (CL:RETURN-FROM ADJOIN-TAXONOMY-NODE-INTERVAL? CL:T)))

;;; (DEFUN PROPAGATE-FOREIGN-INTERVAL ...)

(CL:DEFUN PROPAGATE-FOREIGN-INTERVAL (NODE INTERVAL)
  (CL:WHEN (CL:EQ (%MARKER NODE) INTERVAL)
   (CL:RETURN-FROM PROPAGATE-FOREIGN-INTERVAL))
  (CL:SETF (%MARKER NODE) INTERVAL)
  (CL:WHEN (ADJOIN-TAXONOMY-NODE-INTERVAL? NODE INTERVAL)
   (CL:LET* ((PARENT NULL) (ITER-000 (%PARENTS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000))
     (PROPAGATE-FOREIGN-INTERVAL PARENT INTERVAL)
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN UNCOMPUTE-TOTAL-ANCESTORS ...)

(CL:DEFUN UNCOMPUTE-TOTAL-ANCESTORS (NODE)
  (CL:WHEN (CL:< (%TOTAL-ANCESTORS NODE) 0)
   (CL:RETURN-FROM UNCOMPUTE-TOTAL-ANCESTORS))
  (CL:SETF (%TOTAL-ANCESTORS NODE) -1)
  (CL:LET* ((CHILD NULL) (ITER-000 (%CHILDREN NODE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-000))
    (UNCOMPUTE-TOTAL-ANCESTORS CHILD)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN HELP-COMPUTE-TOTAL-ANCESTORS ...)

(CL:DEFUN HELP-COMPUTE-TOTAL-ANCESTORS (NODE)
  (CL:WHEN (CL:>= (%TOTAL-ANCESTORS NODE) 0)
   (CL:RETURN-FROM HELP-COMPUTE-TOTAL-ANCESTORS))
  (CL:LET* ((TOTALANCESTORS 0) (PARENTANCESTORS 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TOTALANCESTORS PARENTANCESTORS))
   (CL:LET* ((PARENT NULL) (ITER-000 (%PARENTS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000))
     (CL:SETQ PARENTANCESTORS (%TOTAL-ANCESTORS PARENT))
     (CL:WHEN (CL:< PARENTANCESTORS 0)
      (CL:RETURN-FROM HELP-COMPUTE-TOTAL-ANCESTORS))
     (CL:SETQ TOTALANCESTORS (CL:+ TOTALANCESTORS PARENTANCESTORS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%TOTAL-ANCESTORS NODE) (CL:1+ TOTALANCESTORS))
   (CL:LET* ((CHILD NULL) (ITER-001 (%CHILDREN NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-001))
     (HELP-COMPUTE-TOTAL-ANCESTORS CHILD)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  :VOID)

;;; (DEFUN COMPUTE-TOTAL-ANCESTORS ...)

(CL:DEFUN COMPUTE-TOTAL-ANCESTORS (NODE)
  (UNCOMPUTE-TOTAL-ANCESTORS NODE)
  (HELP-COMPUTE-TOTAL-ANCESTORS NODE)
  :VOID)

;;; (DEFUN CREATE-TAXONOMY-SPANNING-TREE ...)

(CL:DEFUN CREATE-TAXONOMY-SPANNING-TREE (GRAPH NODE)
  (CL:WHEN (CL:NOT (CL:= (%LABEL NODE) NULL-INTEGER))
   (CL:RETURN-FROM CREATE-TAXONOMY-SPANNING-TREE))
  (CL:SETF (%LABEL NODE) MARKER-LABEL)
  (CL:LET* ((MAXPARENT NULL) (MAXPARENTVALUE NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MAXPARENTVALUE))
   (CL:LET* ((PARENT NULL) (ITER-000 (%PARENTS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-000))
     (CL:WHEN
      (CL:OR (CL:= MAXPARENTVALUE NULL-INTEGER)
       (CL:> (%TOTAL-ANCESTORS PARENT) MAXPARENTVALUE))
      (CL:SETQ MAXPARENT PARENT)
      (CL:SETQ MAXPARENTVALUE (%TOTAL-ANCESTORS PARENT)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((PARENT NULL) (ITER-001 (%PARENTS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ PARENT (%%VALUE ITER-001))
     (CL:IF (CL:EQ PARENT MAXPARENT)
      (CL:SETF (%TREE-CHILDREN PARENT)
       (CONS NODE (%TREE-CHILDREN PARENT)))
      (PUSH (%BROKEN-LINKS GRAPH) (CONS PARENT (CONS NODE NIL))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((CHILD NULL) (ITER-002 (%CHILDREN NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ CHILD (%%VALUE ITER-002))
     (CREATE-TAXONOMY-SPANNING-TREE GRAPH CHILD)
     (CL:SETQ ITER-002 (%%REST ITER-002)))))
  :VOID)

;;; (DEFUN CREATE-TAXONOMY-SPANNING-FOREST ...)

(CL:DEFUN CREATE-TAXONOMY-SPANNING-FOREST (GRAPH)
  (CLEAR-TAXONOMY-GRAPH GRAPH)
  (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL)
  (CL:LET* ((ROOT NULL) (ITER-000 (%THE-CONS-LIST (%ROOTS GRAPH))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ROOT (%%VALUE ITER-000)) (COMPUTE-TOTAL-ANCESTORS ROOT)
    (CREATE-TAXONOMY-SPANNING-TREE GRAPH ROOT)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CREATE-TAXONOMY-TREE-INTERVALS GRAPH)
  (CL:LET*
   ((LINK NULL) (ITER-001 (%THE-CONS-LIST (%BROKEN-LINKS GRAPH))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ LINK (%%VALUE ITER-001))
    (PROPAGATE-FOREIGN-INTERVAL (%%VALUE LINK)
     (%INITIAL-INTERVAL (%%VALUE (%%REST LINK))))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CLEAR (%BROKEN-LINKS GRAPH))
  (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:T)
  :VOID)

;;; (DEFUN FINALIZE-TAXONOMY-GRAPH ...)

(CL:DEFUN FINALIZE-TAXONOMY-GRAPH (GRAPH)
  "Finalize the taxonomy graph `graph'."
  (CL:COND
   ((CL:AND (%INCREMENTAL-MODE? GRAPH)
     (CL:> (%NUMBER-OF-NODES GRAPH) 0)
     (CL:<
      (CL:/
       (CL:FLOAT
        (MAX (%NUMBER-OF-FOREIGN-INTERVAL-NODES GRAPH)
         (LENGTH (%ADDED-LINKS GRAPH)))
        0.0d0)
       (%NUMBER-OF-NODES GRAPH))
      (%RENUMBER-RATIO GRAPH)))
    (CL:LET*
     ((LINK NULL) (ITER-000 (%THE-CONS-LIST (%ADDED-LINKS GRAPH))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ LINK (%%VALUE ITER-000))
      (INCREMENTALLY-LINK-TAXONOMY-NODES GRAPH (%%VALUE LINK)
       (%%VALUE (%%REST LINK)))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CLEAR (%ADDED-LINKS GRAPH)))
   (CL:T (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL)
    (CL:LET*
     ((LINK NULL) (ITER-001 (%THE-CONS-LIST (%ADDED-LINKS GRAPH))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ LINK (%%VALUE ITER-001))
      (LINK-TAXONOMY-NODES GRAPH (%%VALUE LINK)
       (%%VALUE (%%REST LINK)))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CLEAR (%ADDED-LINKS GRAPH))
    (CREATE-TAXONOMY-SPANNING-FOREST GRAPH)))
  :VOID)

;;; (DEFUN FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY ...)

(CL:DEFUN FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY (GRAPH)
  (CL:SETF (%INCREMENTAL-MODE? GRAPH) CL:NIL)
  (FINALIZE-TAXONOMY-GRAPH GRAPH)
  :VOID)

;;; (DEFUN (TAXONOMY-SUBNODE-OF? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-SUBNODE-OF? (SUB-NODE SUPER-NODE)
  "Return TRUE if `sub-node' is a descendant of `super-node'."
  (CL:LET* ((SUB-NODE-LABEL (%LABEL SUB-NODE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUB-NODE-LABEL))
   (CL:LET* ((INTERVAL NULL) (ITER-000 (%INTERVALS SUPER-NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INTERVAL (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:>= SUB-NODE-LABEL (%LOWER-BOUND INTERVAL))
       (CL:<= SUB-NODE-LABEL (%UPPER-BOUND INTERVAL)))
      (CL:RETURN-FROM TAXONOMY-SUBNODE-OF? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM TAXONOMY-SUBNODE-OF? CL:NIL)))

;;; (DEFUN (SLOW-TAXONOMY-SUBNODE-OF? BOOLEAN) ...)

(CL:DEFUN SLOW-TAXONOMY-SUBNODE-OF? (SUBNODE SUPERNODE)
  (CL:WHEN (CL:EQ SUBNODE SUPERNODE)
   (CL:RETURN-FROM SLOW-TAXONOMY-SUBNODE-OF? CL:T))
  (CL:LET* ((PARENT NULL) (ITER-000 (%PARENTS SUBNODE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ PARENT (%%VALUE ITER-000))
    (CL:WHEN (SLOW-TAXONOMY-SUBNODE-OF? PARENT SUPERNODE)
     (CL:RETURN-FROM SLOW-TAXONOMY-SUBNODE-OF? CL:T))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM SLOW-TAXONOMY-SUBNODE-OF? CL:NIL))

;;; (DEFUN PRINT-TAXONOMY-TREE ...)

(CL:DEFUN PRINT-TAXONOMY-TREE (NODE INDENT STREAM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 INDENT)
    (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " ")
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) NODE EOL)
  (CL:LET* ((CHILD NULL) (ITER-001 (%CHILDREN NODE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-001))
    (PRINT-TAXONOMY-TREE CHILD (CL:+ INDENT 2) STREAM)
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  :VOID)

;;; (DEFUN PRINT-TAXONOMY-GRAPH ...)

(CL:DEFUN PRINT-TAXONOMY-GRAPH (GRAPH STREAM)
  (CL:LET* ((ROOT NULL) (ITER-000 (%THE-CONS-LIST (%ROOTS GRAPH))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ROOT (%%VALUE ITER-000))
    (PRINT-TAXONOMY-TREE ROOT 0 STREAM)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN PRINT-TAXONOMY-SPANNING-TREE ...)

(CL:DEFUN PRINT-TAXONOMY-SPANNING-TREE (NODE INDENT STREAM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 INDENT)
    (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000) (CL:SETQ I I)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " ")
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) NODE EOL)
  (CL:LET* ((CHILD NULL) (ITER-001 (%TREE-CHILDREN NODE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ CHILD (%%VALUE ITER-001))
    (PRINT-TAXONOMY-SPANNING-TREE CHILD (CL:+ INDENT 2) STREAM)
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  :VOID)

;;; (DEFUN PRINT-TAXONOMY-SPANNING-FOREST ...)

(CL:DEFUN PRINT-TAXONOMY-SPANNING-FOREST (GRAPH STREAM)
  (CL:LET* ((ROOT NULL) (ITER-000 (%THE-CONS-LIST (%ROOTS GRAPH))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ROOT (%%VALUE ITER-000))
    (PRINT-TAXONOMY-SPANNING-TREE ROOT 0 STREAM)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

(CL:DEFUN STARTUP-TAXONOMIES ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SYM-TAXONOMIES-STELLA-STARTUP-TAXONOMIES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TAXONOMIES" NULL 0))
    (CL:SETQ SYM-TAXONOMIES-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL
      0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *TAXONOMY-POSTORDER-NUMBER* NULL-INTEGER))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "TAXONOMY-ROOT?"
     "(DEFUN (TAXONOMY-ROOT? BOOLEAN) ((NODE TAXONOMY-NODE)) :DOCUMENTATION \"Return `true' if `node' is a taxonomy root node.\" :GLOBALLY-INLINE? TRUE (RETURN (EMPTY? (PARENTS NODE))))"
     (CL:FUNCTION TAXONOMY-ROOT?) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-ROOT"
     "(DEFUN ADD-TAXONOMY-ROOT ((GRAPH TAXONOMY-GRAPH) (ROOT TAXONOMY-NODE)) :DOCUMENTATION \"Add `root' as a root node to `graph'.  Only do this if
`root' does not have any parents and is not a `graph' root already.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ADD-TAXONOMY-ROOT) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-TAXONOMY-ROOT"
     "(DEFUN REMOVE-TAXONOMY-ROOT ((GRAPH TAXONOMY-GRAPH) (ROOT TAXONOMY-NODE)) :DOCUMENTATION \"Remove `root' from `graph's root nodes.\" :PUBLIC? TRUE)"
     (CL:FUNCTION REMOVE-TAXONOMY-ROOT) NULL)
    (DEFINE-FUNCTION-OBJECT "UPDATE-TAXONOMY-ROOTS"
     "(DEFUN UPDATE-TAXONOMY-ROOTS ((GRAPH TAXONOMY-GRAPH) (NODE TAXONOMY-NODE)) :DOCUMENTATION \"Update `graph's roots according to `node's current state.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UPDATE-TAXONOMY-ROOTS) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-TAXONOMY-NODE"
     "(DEFUN (CREATE-TAXONOMY-NODE TAXONOMY-NODE) ((GRAPH TAXONOMY-GRAPH) (NODE TAXONOMY-NODE) (NATIVEOBJECT OBJECT) (ROOT? BOOLEAN)) :DOCUMENTATION \"Link the taxonomy node `node' to `nativeObject' and add it
to `graph'.  If it is `null', a new node will be created.  Mark it as a root
node if `root?' is `true'.  Return the node.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CREATE-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-NODE"
     "(DEFUN ADD-TAXONOMY-NODE ((GRAPH TAXONOMY-GRAPH) (NODE TAXONOMY-NODE) (ROOT? BOOLEAN)) :DOCUMENTATION \"Add `node' to `graph'.  Mark it as a root node if `root?'
is `true'.  Even though this is part of the API, it should rarely be needed,
since `create-taxonomy-node' does everything that's necessary.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ADD-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-TAXONOMY-NODE"
     "(DEFUN REMOVE-TAXONOMY-NODE ((GRAPH TAXONOMY-GRAPH) (NODE TAXONOMY-NODE)) :PUBLIC? TRUE :DOCUMENTATION \"Remove `node' from `graph' and disconnect incident links.\")"
     (CL:FUNCTION REMOVE-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-TAXONOMY-LINK"
     "(DEFUN CREATE-TAXONOMY-LINK ((GRAPH TAXONOMY-GRAPH) (PARENT TAXONOMY-NODE) (CHILD TAXONOMY-NODE)) :PUBLIC? TRUE)"
     (CL:FUNCTION CREATE-TAXONOMY-LINK) NULL)
    (DEFINE-FUNCTION-OBJECT "LINK-TAXONOMY-NODES"
     "(DEFUN LINK-TAXONOMY-NODES ((GRAPH TAXONOMY-GRAPH) (PARENT TAXONOMY-NODE) (CHILD TAXONOMY-NODE)) :DOCUMENTATION \"Cross-link `parent' and `child' in `graph'.
IMPORTANT: This will automatically insert a backlink from `child' to
`parent', so, for maximum efficiency it should not be called a second time
with the arguments reversed.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LINK-TAXONOMY-NODES) NULL)
    (DEFINE-FUNCTION-OBJECT "INCREMENTALLY-LINK-TAXONOMY-NODES"
     "(DEFUN INCREMENTALLY-LINK-TAXONOMY-NODES ((GRAPH TAXONOMY-GRAPH) (PARENT TAXONOMY-NODE) (CHILD TAXONOMY-NODE)))"
     (CL:FUNCTION INCREMENTALLY-LINK-TAXONOMY-NODES) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-NEXT-POSTORDER-INTERVAL"
     "(DEFUN (CREATE-NEXT-POSTORDER-INTERVAL INTERVAL) ((GRAPH TAXONOMY-GRAPH)))"
     (CL:FUNCTION CREATE-NEXT-POSTORDER-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT "ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE"
     "(DEFUN (ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE INTERVAL) ((PARENT TAXONOMY-NODE)))"
     (CL:FUNCTION ALLOCATE-INTERVAL-FOR-NEW-LEAF-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNLINK-TAXONOMY-NODES"
     "(DEFUN UNLINK-TAXONOMY-NODES ((GRAPH TAXONOMY-GRAPH) (PARENT TAXONOMY-NODE) (CHILD TAXONOMY-NODE)) :DOCUMENTATION \"Remove link between `parent' and `child'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UNLINK-TAXONOMY-NODES) NULL)
    (DEFINE-FUNCTION-OBJECT "INCREMENTALLY-UNLINK-TAXONOMY-NODES"
     "(DEFUN INCREMENTALLY-UNLINK-TAXONOMY-NODES ((GRAPH TAXONOMY-GRAPH) (PARENT TAXONOMY-NODE) (CHILD TAXONOMY-NODE)))"
     (CL:FUNCTION INCREMENTALLY-UNLINK-TAXONOMY-NODES) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-TAXONOMY-NODES"
     "(DEFUN (ALL-TAXONOMY-NODES (ITERATOR OF TAXONOMY-NODE)) ((GRAPH TAXONOMY-GRAPH)) :DOCUMENTATION \"Given a taxonomy `graph' that has been finalized,
return an iterator that generates all the graph's nodes.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALL-TAXONOMY-NODES) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-TAXONOMY-NODES-NEXT?"
     "(DEFUN (ALL-TAXONOMY-NODES-NEXT? BOOLEAN) ((SELF (ALL-PURPOSE-ITERATOR OF TAXONOMY-NODE))))"
     (CL:FUNCTION ALL-TAXONOMY-NODES-NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-TAXONOMY-NODE"
     "(DEFUN (FIND-TAXONOMY-NODE TAXONOMY-NODE) ((GRAPH TAXONOMY-GRAPH) (LABEL INTEGER)) :DOCUMENTATION \"Return some node in `graph' with label `label'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION FIND-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "LABELED-TAXONOMY-NODE?"
     "(DEFUN (LABELED-TAXONOMY-NODE? BOOLEAN) ((NODE TAXONOMY-NODE)) :GLOBALLY-INLINE? TRUE (RETURN (DEFINED? (LABEL NODE))))"
     (CL:FUNCTION LABELED-TAXONOMY-NODE?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED? BOOLEAN) ((SELF TAXONOMY-NODE)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (LABEL SELF) DELETED-LABEL)))"
     (WRAP-METHOD-CODE (CL:FUNCTION DELETED?)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF TAXONOMY-NODE) (VALUE BOOLEAN)))"
     (WRAP-METHOD-CODE (CL:FUNCTION DELETED?-SETTER)) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-TAXONOMY-NODE"
     "(DEFUN CLEAR-TAXONOMY-NODE ((NODE TAXONOMY-NODE)) :DOCUMENTATION \"Clear all taxonomy-graph-specific information of `node',
but retain information about the native object and associated links.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLEAR-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-TAXONOMY-NODE"
     "(DEFUN INITIALIZE-TAXONOMY-NODE ((NODE TAXONOMY-NODE)) :DOCUMENTATION \"Completely clear and initialize `node'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INITIALIZE-TAXONOMY-NODE) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-CLEAR-TAXONOMY-GRAPH"
     "(DEFUN HELP-CLEAR-TAXONOMY-GRAPH ((NODE TAXONOMY-NODE)))"
     (CL:FUNCTION HELP-CLEAR-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-TAXONOMY-GRAPH"
     "(DEFUN CLEAR-TAXONOMY-GRAPH ((GRAPH TAXONOMY-GRAPH)) :DOCUMENTATION \"Clear all taxonomy-graph-specific information of `graph',
but retain information about the native network and associated links.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLEAR-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-TAXONOMY-GRAPH"
     "(DEFUN INITIALIZE-TAXONOMY-GRAPH ((GRAPH TAXONOMY-GRAPH)) :DOCUMENTATION \"Completely clear the taxonomy graph `graph'.
NOTE: Any nodes associated with `graph' will not be cleared.  If they are
to be reused, they have to be cleared with `initialize-taxonomy-node'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION INITIALIZE-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-CREATE-TAXONOMY-TREE-INTERVALS"
     "(DEFUN (HELP-CREATE-TAXONOMY-TREE-INTERVALS INTEGER) ((SELF TAXONOMY-NODE)))"
     (CL:FUNCTION HELP-CREATE-TAXONOMY-TREE-INTERVALS) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-TAXONOMY-TREE-INTERVALS"
     "(DEFUN CREATE-TAXONOMY-TREE-INTERVALS ((GRAPH TAXONOMY-GRAPH)))"
     (CL:FUNCTION CREATE-TAXONOMY-TREE-INTERVALS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (MEMBER? BOOLEAN) ((INTERVAL INTERVAL) (N INTEGER)) :GLOBALLY-INLINE? TRUE (RETURN (AND (>= N (LOWER-BOUND INTERVAL)) (<= N (UPPER-BOUND INTERVAL)))))"
     (WRAP-METHOD-CODE (CL:FUNCTION MEMBER?)) NULL)
    (DEFINE-FUNCTION-OBJECT "SUBINTERVAL-OF?"
     "(DEFUN (SUBINTERVAL-OF? BOOLEAN) ((SUBINTERVAL INTERVAL) (SUPERINTERVAL INTERVAL)) :GLOBALLY-INLINE? TRUE (RETURN (AND (<= (UPPER-BOUND SUBINTERVAL) (UPPER-BOUND SUPERINTERVAL)) (>= (LOWER-BOUND SUBINTERVAL) (LOWER-BOUND SUPERINTERVAL)))))"
     (CL:FUNCTION SUBINTERVAL-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "MERGE-INTERVALS"
     "(DEFUN (MERGE-INTERVALS INTERVAL) ((LEFTINTERVAL INTERVAL) (RIGHTINTERVAL INTERVAL)) :GLOBALLY-INLINE? TRUE (RETURN (NEW INTERVAL :LOWER-BOUND (LOWER-BOUND LEFTINTERVAL) :UPPER-BOUND (UPPER-BOUND RIGHTINTERVAL))))"
     (CL:FUNCTION MERGE-INTERVALS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-TAXONOMY-NODE-INTERVALS"
     "(DEFUN (ALL-TAXONOMY-NODE-INTERVALS (CONS OF INTERVAL)) ((NODE TAXONOMY-NODE)) :GLOBALLY-INLINE? TRUE (RETURN (INTERVALS NODE)))"
     (CL:FUNCTION ALL-TAXONOMY-NODE-INTERVALS) NULL)
    (DEFINE-FUNCTION-OBJECT "INTERN-TAXONOMY-NODE-INTERVAL"
     "(DEFUN (INTERN-TAXONOMY-NODE-INTERVAL INTERVAL) ((NODE TAXONOMY-NODE) (LOWERBOUND INTEGER) (UPPERBOUND INTEGER)))"
     (CL:FUNCTION INTERN-TAXONOMY-NODE-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-NODE-INTERVAL"
     "(DEFUN ADD-TAXONOMY-NODE-INTERVAL ((NODE TAXONOMY-NODE) (INTERVAL INTERVAL)))"
     (CL:FUNCTION ADD-TAXONOMY-NODE-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT "REMOVE-TAXONOMY-NODE-INTERVAL"
     "(DEFUN REMOVE-TAXONOMY-NODE-INTERVAL ((NODE TAXONOMY-NODE) (INTERVAL INTERVAL)))"
     (CL:FUNCTION REMOVE-TAXONOMY-NODE-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT "ADJOIN-TAXONOMY-NODE-INTERVAL?"
     "(DEFUN (ADJOIN-TAXONOMY-NODE-INTERVAL? BOOLEAN) ((NODE TAXONOMY-NODE) (INTERVAL INTERVAL)))"
     (CL:FUNCTION ADJOIN-TAXONOMY-NODE-INTERVAL?) NULL)
    (DEFINE-FUNCTION-OBJECT "PROPAGATE-FOREIGN-INTERVAL"
     "(DEFUN PROPAGATE-FOREIGN-INTERVAL ((NODE TAXONOMY-NODE) (INTERVAL INTERVAL)))"
     (CL:FUNCTION PROPAGATE-FOREIGN-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT "UNCOMPUTE-TOTAL-ANCESTORS"
     "(DEFUN UNCOMPUTE-TOTAL-ANCESTORS ((NODE TAXONOMY-NODE)))"
     (CL:FUNCTION UNCOMPUTE-TOTAL-ANCESTORS) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-COMPUTE-TOTAL-ANCESTORS"
     "(DEFUN HELP-COMPUTE-TOTAL-ANCESTORS ((NODE TAXONOMY-NODE)))"
     (CL:FUNCTION HELP-COMPUTE-TOTAL-ANCESTORS) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-TOTAL-ANCESTORS"
     "(DEFUN COMPUTE-TOTAL-ANCESTORS ((NODE TAXONOMY-NODE)))"
     (CL:FUNCTION COMPUTE-TOTAL-ANCESTORS) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-TAXONOMY-SPANNING-TREE"
     "(DEFUN CREATE-TAXONOMY-SPANNING-TREE ((GRAPH TAXONOMY-GRAPH) (NODE TAXONOMY-NODE)))"
     (CL:FUNCTION CREATE-TAXONOMY-SPANNING-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-TAXONOMY-SPANNING-FOREST"
     "(DEFUN CREATE-TAXONOMY-SPANNING-FOREST ((GRAPH TAXONOMY-GRAPH)))"
     (CL:FUNCTION CREATE-TAXONOMY-SPANNING-FOREST) NULL)
    (DEFINE-FUNCTION-OBJECT "FINALIZE-TAXONOMY-GRAPH"
     "(DEFUN FINALIZE-TAXONOMY-GRAPH ((GRAPH TAXONOMY-GRAPH)) :DOCUMENTATION \"Finalize the taxonomy graph `graph'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION FINALIZE-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY"
     "(DEFUN FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY ((GRAPH TAXONOMY-GRAPH)))"
     (CL:FUNCTION FINALIZE-TAXONOMY-GRAPH-NONINCREMENTALLY) NULL)
    (DEFINE-FUNCTION-OBJECT "TAXONOMY-SUBNODE-OF?"
     "(DEFUN (TAXONOMY-SUBNODE-OF? BOOLEAN) ((SUB-NODE TAXONOMY-NODE) (SUPER-NODE TAXONOMY-NODE)) :DOCUMENTATION \"Return TRUE if `sub-node' is a descendant of `super-node'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION TAXONOMY-SUBNODE-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "SLOW-TAXONOMY-SUBNODE-OF?"
     "(DEFUN (SLOW-TAXONOMY-SUBNODE-OF? BOOLEAN) ((SUBNODE TAXONOMY-NODE) (SUPERNODE TAXONOMY-NODE)))"
     (CL:FUNCTION SLOW-TAXONOMY-SUBNODE-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-TAXONOMY-TREE"
     "(DEFUN PRINT-TAXONOMY-TREE ((NODE TAXONOMY-NODE) (INDENT INTEGER) (STREAM OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-TAXONOMY-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-TAXONOMY-GRAPH"
     "(DEFUN PRINT-TAXONOMY-GRAPH ((GRAPH TAXONOMY-GRAPH) (STREAM OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-TAXONOMY-GRAPH) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-TAXONOMY-SPANNING-TREE"
     "(DEFUN PRINT-TAXONOMY-SPANNING-TREE ((NODE TAXONOMY-NODE) (INDENT INTEGER) (STREAM OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-TAXONOMY-SPANNING-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-TAXONOMY-SPANNING-FOREST"
     "(DEFUN PRINT-TAXONOMY-SPANNING-FOREST ((GRAPH TAXONOMY-GRAPH) (STREAM OUTPUT-STREAM)))"
     (CL:FUNCTION PRINT-TAXONOMY-SPANNING-FOREST) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-TAXONOMIES"
     "(DEFUN STARTUP-TAXONOMIES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-TAXONOMIES) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-TAXONOMIES-STELLA-STARTUP-TAXONOMIES)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-TAXONOMIES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupTaxonomies") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *NUMBERING-INTERVAL* INTEGER 100 :PUBLIC? TRUE :DOCUMENTATION \"Spacing between postorder numbers for nodes.  Allows limited
incremental insertions without having to renumber the whole graph.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT MARKER-LABEL INTEGER -99 :DOCUMENTATION \"Dummy label used for marking a node\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFCONSTANT DELETED-LABEL INTEGER -99 :DOCUMENTATION \"Label used for marking deleted nodes\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *TAXONOMY-POSTORDER-NUMBER* INTEGER NULL)" NULL)))
  :VOID)
