;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; methods.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-METHODS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-OBJECT NULL)
(CL:DEFVAR SGT-METHODS-STELLA-VOID NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LIKE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SIZE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-OF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-NULL NULL)
(CL:DEFVAR SGT-METHODS-STELLA-ARRAY NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SELF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-IN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-OUT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-INOUT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS NULL)
(CL:DEFVAR SYM-METHODS-STELLA-ARGUMENT-LIST NULL)
(CL:DEFVAR |SYM-METHODS-STELLA-&REST| NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR |SYM-METHODS-STELLA-&BODY| NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-METHODS-STELLA-CONS NULL)
(CL:DEFVAR KWD-METHODS-TYPE NULL)
(CL:DEFVAR KWD-METHODS-RETURN-TYPES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-METHODS-PUBLIC? NULL)
(CL:DEFVAR KWD-METHODS-ABSTRACT? NULL)
(CL:DEFVAR KWD-METHODS-NATIVE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-NATIVE? NULL)
(CL:DEFVAR KWD-METHODS-CONSTRUCTOR? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-CONSTRUCTOR? NULL)
(CL:DEFVAR KWD-METHODS-GLOBALLY-INLINE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR KWD-METHODS-INLINE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS NULL)
(CL:DEFVAR KWD-METHODS-AUXILIARY? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR KWD-METHODS-DOCUMENTATION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR KWD-METHODS-RETURNS NULL)
(CL:DEFVAR KWD-METHODS-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR KWD-METHODS-INHERITS-THROUGH NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH NULL)
(CL:DEFVAR KWD-METHODS-PROPERTIES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-PROPERTIES NULL)
(CL:DEFVAR KWD-METHODS-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-METHODS-COMMAND? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-COMMAND? NULL)
(CL:DEFVAR KWD-METHODS-LISP-MACRO? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR KWD-METHODS-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR KWD-METHODS-C-CALLABLE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-C-CALLABLE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CONCATENATE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-THE-CODE NULL)
(CL:DEFVAR KWD-METHODS-FUNCTION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINE-INLINE-METHOD-CODE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-QUOTE NULL)
(CL:DEFVAR KWD-METHODS-METHOD NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT NULL)
(CL:DEFVAR SGT-METHODS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-EQUIVALENT-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LET NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CURSOR NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VALUE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-VALUE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LOOP NULL)
(CL:DEFVAR SYM-METHODS-STELLA-WHEN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-RETURN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-METHODS-STELLA-IF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINED? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-COLLECTION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-FIRST NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-VECTOR NULL)
(CL:DEFVAR SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-MACRO? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFSPECIAL NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFCONSTANT NULL)
(CL:DEFVAR KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-HOME-MODULE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-LITERAL NULL)
(CL:DEFVAR SGT-METHODS-STELLA-STRING NULL)
(CL:DEFVAR SGT-METHODS-STELLA-INTEGER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-METHODS-STELLA-LONG-INTEGER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-CHARACTER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-METHODS-STELLA-FUNCTION-CODE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-WRAPPER NULL)
(CL:DEFVAR SYM-METHODS-STELLA-STARTUP-METHODS NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *ROOT-MODULE* SYMBOL-SYM STANDARD-OUTPUT
  *MODULE* NULL-FUNCTION-CODE-WRAPPER *REDEFINE-RELATION-HOOKS*
  NULL-STRING-WRAPPER STANDARD-WARNING TRUE-WRAPPER FALSE-WRAPPER
  NULL-INTEGER STANDARD-ERROR EOL NIL))

;;; (DEFUN (APPLY OBJECT) ...)

(CL:DEFUN APPLY (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type OBJECT.
Currently limited to at most 10 `arguments'."
  (CL:IF (CL:EQ ARGUMENTS NIL) (CL:RETURN-FROM APPLY (CL:FUNCALL CODE))
   (CL:LET* ((ARG1 (%%VALUE ARGUMENTS)))
    (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
    (CL:WHEN (CL:EQ ARGUMENTS NIL)
     (CL:RETURN-FROM APPLY (CL:FUNCALL CODE ARG1)))
    (CL:LET* ((ARG2 (%%VALUE ARGUMENTS)))
     (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
     (CL:WHEN (CL:EQ ARGUMENTS NIL)
      (CL:RETURN-FROM APPLY (CL:FUNCALL CODE ARG1 ARG2)))
     (CL:LET* ((ARG3 (%%VALUE ARGUMENTS)))
      (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
      (CL:WHEN (CL:EQ ARGUMENTS NIL)
       (CL:RETURN-FROM APPLY (CL:FUNCALL CODE ARG1 ARG2 ARG3)))
      (CL:LET* ((ARG4 (%%VALUE ARGUMENTS)))
       (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
       (CL:WHEN (CL:EQ ARGUMENTS NIL)
        (CL:RETURN-FROM APPLY (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4)))
       (CL:LET* ((ARG5 (%%VALUE ARGUMENTS)))
        (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
        (CL:WHEN (CL:EQ ARGUMENTS NIL)
         (CL:RETURN-FROM APPLY
          (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5)))
        (CL:LET* ((ARG6 (%%VALUE ARGUMENTS)))
         (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
         (CL:WHEN (CL:EQ ARGUMENTS NIL)
          (CL:RETURN-FROM APPLY
           (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5 ARG6)))
         (CL:LET* ((ARG7 (%%VALUE ARGUMENTS)))
          (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
          (CL:WHEN (CL:EQ ARGUMENTS NIL)
           (CL:RETURN-FROM APPLY
            (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7)))
          (CL:LET* ((ARG8 (%%VALUE ARGUMENTS)))
           (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
           (CL:WHEN (CL:EQ ARGUMENTS NIL)
            (CL:RETURN-FROM APPLY
             (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7
              ARG8)))
           (CL:LET* ((ARG9 (%%VALUE ARGUMENTS)))
            (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
            (CL:WHEN (CL:EQ ARGUMENTS NIL)
             (CL:RETURN-FROM APPLY
              (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7 ARG8
               ARG9)))
            (CL:LET* ((ARG10 (%%VALUE ARGUMENTS)))
             (CL:SETQ ARGUMENTS (%%REST ARGUMENTS))
             (CL:WHEN (CL:EQ ARGUMENTS NIL)
              (CL:RETURN-FROM APPLY
               (CL:FUNCALL CODE ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7 ARG8
                ARG9 ARG10)))
             (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
               "Too many function arguments in `apply'.Maximum is 10.")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION
                (THE-STRING-READER STREAM-000))))))))))))))))

;;; (DEFUN (APPLY-METHOD OBJECT) ...)

(CL:DEFUN APPLY-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
OBJECT."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-INTEGER-METHOD INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) APPLY-INTEGER-METHOD))
(CL:DEFUN APPLY-INTEGER-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
INTEGER."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-LONG-INTEGER-METHOD LONG-INTEGER) ...)

(CL:DEFUN APPLY-LONG-INTEGER-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
LONG-INTEGER."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-LONG-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-LONG-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-LONG-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-LONG-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-LONG-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-STRING-METHOD STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  APPLY-STRING-METHOD))
(CL:DEFUN APPLY-STRING-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
STRING."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-BOOLEAN-METHOD BOOLEAN) ...)

(CL:DEFUN APPLY-BOOLEAN-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
BOOLEAN."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-FLOAT-METHOD FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT)
  APPLY-FLOAT-METHOD))
(CL:DEFUN APPLY-FLOAT-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
FLOAT."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (DEFINED-TYPE? BOOLEAN) ...)

(CL:DEFUN DEFINED-TYPE? (TYPE)
  (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE TYPE)) (VALUETYPE NULL))
   (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
    (CL:SETQ VALUETYPE (PRIMARY-TYPE VALUE))
    (CL:RETURN-FROM DEFINED-TYPE?
     (CL:OR (CL:EQ SGT-METHODS-STELLA-SURROGATE VALUETYPE)
      (CL:EQ SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER VALUETYPE)
      (CL:EQ SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER VALUETYPE))))
   (CL:RETURN-FROM DEFINED-TYPE? CL:NIL)))

;;; (DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFUN REAL-TYPE-SPECIFIER (TYPE)
  (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE TYPE)))
   (CL:IF (DEFINED-TYPE? TYPE)
    (CL:IF (TYPE? VALUE)
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER (REAL-TYPE-SPECIFIER VALUE))
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER VALUE))
    (CL:RETURN-FROM REAL-TYPE-SPECIFIER TYPE))))

;;; (DEFUN (CANONICAL-TYPE TYPE) ...)

(CL:DEFUN CANONICAL-TYPE (TYPE)
  (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE TYPE)))
   (CL:IF (CL:NOT (CL:EQ CLASS NULL))
    (CL:RETURN-FROM CANONICAL-TYPE (%CLASS.CLASS-TYPE CLASS))
    (CL:RETURN-FROM CANONICAL-TYPE TYPE))))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SURROGATE))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
   (REAL-TYPE-SPECIFIER TYPESPECTREE)))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SYMBOL))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
   (REAL-TYPE-SPECIFIER (TYPIFY TYPESPECTREE))))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE OBJECT))
  (CL:CERROR "Continue anyway? " "Illegal type specification `~A'"
   TYPESPECTREE)
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-STELLA-OBJECT))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(%%DEFCONSMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE CL:CONS))
  (CL:COND
   ((CL:EQ TYPESPECTREE NIL)
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-STELLA-VOID))
   ((CL:EQ (%%VALUE TYPESPECTREE) SYM-METHODS-STELLA-LIKE)
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
     (YIELD-ANCHORED-TYPE-SPECIFIER TYPESPECTREE)))
   (CL:T
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
     (YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPECTREE)))))

;;; (DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-PARAMETRIC-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-PARAMETRIC-TYPE-SPECIFIER)) (PARAMETERTYPESPEC NULL)
    (CURSOR TYPESPECTREE))
   (CL:LET* ((HEAD-000 (%%VALUE CURSOR)))
    (CL:SETQ CURSOR (%%REST CURSOR))
    (CL:LET*
     ((BASETYPE (TYPIFY HEAD-000))
      (REALBASETYPESPEC (REAL-TYPE-SPECIFIER BASETYPE))
      (DEFINEDBASETYPE? (CL:NOT (CL:EQ BASETYPE REALBASETYPESPEC))))
     (CL:LET* ((HEAD-001 (%%VALUE CURSOR)))
      (CL:SETQ CURSOR (%%REST CURSOR))
      (CL:LET* ((OPERATOR HEAD-001) (ARRAYTYPE? CL:NIL))
       (CL:WHEN DEFINEDBASETYPE?
        (CL:SETQ BASETYPE (TYPE-SPEC-TO-BASE-TYPE REALBASETYPESPEC)))
       (CL:SETF
        (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE TYPESPEC)
        (VERIFY-TYPE BASETYPE))
       (CL:WHEN (ARRAY-TYPE-SPECIFIER? TYPESPEC)
        (CL:WHEN (CL:EQ OPERATOR SYM-METHODS-STELLA-SIZE)
         (CL:LET* ((HEAD-002 (%%VALUE CURSOR)))
          (CL:SETQ CURSOR (%%REST CURSOR))
          (CL:SETQ OPERATOR HEAD-002)))
        (CL:SETQ ARRAYTYPE? CL:T)
        (CL:SETF
         (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS TYPESPEC)
         (PARSE-ARRAY-DIMENSIONS-SPEC OPERATOR))
        (CL:LET* ((HEAD-003 (%%VALUE CURSOR)))
         (CL:SETQ CURSOR (%%REST CURSOR)) (CL:SETQ OPERATOR HEAD-003)))
       (CL:WHEN
        (CL:AND ARRAYTYPE?
         (CL:EQ
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS TYPESPEC)
          NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Illegal array type specifier dimensions: `"
           (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'." EOL)))
        (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
         (YIELD-PARAMETRIC-TYPE-SPECIFIER
          (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF
           NIL))))
       (CL:WHEN (CL:NOT (CL:EQ OPERATOR SYM-METHODS-STELLA-OF))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Bad type specifier `"
           (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'." EOL)))
        (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
         (YIELD-PARAMETRIC-TYPE-SPECIFIER
          (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF
           NIL))))
       (CL:LET*
        ((P NULL) (ITER-000 CURSOR)
         (INTO-000
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
           TYPESPEC))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ P (%%VALUE ITER-000))
         (CL:SETQ PARAMETERTYPESPEC (YIELD-TYPE-SPECIFIER P))
         (CL:WHEN (ARRAY-TYPE-SPECIFIER? PARAMETERTYPESPEC)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM
             (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal nested array type specifier: " EOL "   `"
             (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'" EOL
             "   Use multi-dimensional arrays instead." EOL)))
          (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
           (YIELD-PARAMETRIC-TYPE-SPECIFIER
            (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF
             NIL))))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS PARAMETERTYPESPEC NIL))
           (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-000) NIL)
            (CL:SETF (%LIST.THE-CONS-LIST INTO-000) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST
             (%LIST.THE-CONS-LIST INTO-000) COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000) (CONS PARAMETERTYPESPEC NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:WHEN DEFINEDBASETYPE?
        (CL:COND
         ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?
           (SAFE-PRIMARY-TYPE REALBASETYPESPEC))
          (CL:PROGN
           (CL:LET* ((TEST-VALUE-000 CL:NIL))
            (CL:SETQ TEST-VALUE-000
             (CL:=
              (LENGTH
               (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
                REALBASETYPESPEC))
              (LENGTH
               (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
                TYPESPEC))))
            (CL:WHEN TEST-VALUE-000
             (CL:LET* ((ALWAYS?-000 CL:T))
              (CL:LET*
               ((PARTYPE NULL)
                (ITER-001
                 (%LIST.THE-CONS-LIST
                  (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
                   TYPESPEC)))
                (RPARTYPE NULL)
                (ITER-002
                 (%LIST.THE-CONS-LIST
                  (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
                   REALBASETYPESPEC))))
               (CL:LOOP WHILE
                (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
                 (CL:NOT (CL:EQ ITER-002 NIL)))
                DO (CL:SETQ PARTYPE (%%VALUE ITER-001))
                (CL:SETQ RPARTYPE (%%VALUE ITER-002))
                (CL:WHEN
                 (CL:NOT
                  (OPTIMISTIC-SUBTYPE-OF?
                   (TYPE-SPEC-TO-BASE-TYPE PARTYPE)
                   (TYPE-SPEC-TO-BASE-TYPE RPARTYPE)))
                 (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
                (CL:SETQ ITER-001 (%%REST ITER-001))
                (CL:SETQ ITER-002 (%%REST ITER-002))))
              (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
            (CL:WHEN (CL:NOT TEST-VALUE-000)
             (CL:LET* ((*PRINTREADABLY?* CL:T))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
               (%%PRINT-STREAM
                (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
                " Parameter types of `"
                (DE-UGLIFY-PARSE-TREE TYPESPECTREE)
                "' are incompatible " EOL
                " with parameter types of defined type `"
                (%%VALUE TYPESPECTREE) "'." EOL)))
             (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
              (YIELD-PARAMETRIC-TYPE-SPECIFIER
               (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF
                NIL)))))))
         (CL:T)))
       (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPEC)))))))

;;; (DEFUN (PARSE-ARRAY-DIMENSIONS-SPEC (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN PARSE-ARRAY-DIMENSIONS-SPEC (DIMENSIONSSPEC)
  (CL:LET* ((DIMENSIONS (NEW-LIST)))
   (CL:WHEN (CL:EQ DIMENSIONSSPEC NULL)
    (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC NULL))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CONS? DIMENSIONSSPEC)
      (CL:NOT (CL:EQ DIMENSIONSSPEC NIL))))
    (CL:SETQ DIMENSIONSSPEC (CONS DIMENSIONSSPEC NIL)))
   (CL:LET*
    ((DIMSPEC NULL) (ITER-000 DIMENSIONSSPEC) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIMSPEC (%%VALUE ITER-000))
     (CL:WHEN (CONS? DIMSPEC) (CL:SETQ DIMSPEC (%%VALUE DIMSPEC)))
     (CL:COND
      ((CL:OR (CL:EQ DIMSPEC NULL)
        (CL:EQ DIMSPEC SYM-METHODS-STELLA-NULL))
       (CL:SETQ DIMSPEC NULL))
      ((INTEGER? DIMSPEC))
      (CL:T (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC NULL)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS DIMSPEC NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST DIMENSIONS) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST DIMENSIONS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST DIMENSIONS)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS DIMSPEC NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC DIMENSIONS)))

;;; (DEFUN (YIELD-ARRAY-DIMENSIONS-TREE CONS) ...)

(CL:DEFUN YIELD-ARRAY-DIMENSIONS-TREE (ARRAYTYPE)
  (CL:LET*
   ((DIMENSIONS
     (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS ARRAYTYPE))
    (RESULT NIL))
   (CL:WHEN (CL:EQ DIMENSIONS NULL)
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE NULL))
   (CL:LET*
    ((DIM NULL) (ITER-000 (%LIST.THE-CONS-LIST DIMENSIONS))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIM (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (CL:IF (CL:EQ DIM NULL) NIL (CONS DIM NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CL:IF (CL:EQ DIM NULL) NIL (CONS DIM NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:= (LENGTH RESULT) 1)
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE (%%VALUE RESULT))
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE RESULT))))

;;; (DEFUN (ARRAY-TYPE-SPECIFIER? BOOLEAN) ...)

(CL:DEFUN ARRAY-TYPE-SPECIFIER? (TYPESPEC)
  (CL:COND
   ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?
     (SAFE-PRIMARY-TYPE TYPESPEC))
    (CL:PROGN
     (CL:LET*
      ((BASETYPE
        (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE TYPESPEC)))
      (CL:WHEN (CL:EQ BASETYPE SGT-METHODS-STELLA-ARRAY)
       (CL:RETURN-FROM ARRAY-TYPE-SPECIFIER? CL:T)))))
   (CL:T))
  (CL:RETURN-FROM ARRAY-TYPE-SPECIFIER? CL:NIL))

;;; (DEFUN (ARRAY-TYPE-RANK INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) ARRAY-TYPE-RANK))
(CL:DEFUN ARRAY-TYPE-RANK (ARRAYTYPE)
  (CL:LET*
   ((DIMENSIONS
     (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS ARRAYTYPE)))
   (CL:IF (CL:EQ DIMENSIONS NULL)
    (CL:RETURN-FROM ARRAY-TYPE-RANK NULL-INTEGER)
    (CL:RETURN-FROM ARRAY-TYPE-RANK (LENGTH DIMENSIONS)))))

;;; (DEFUN (ARRAY-TYPE-DIMENSIONS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN ARRAY-TYPE-DIMENSIONS (ARRAYTYPE)
  (CL:RETURN-FROM ARRAY-TYPE-DIMENSIONS
   (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS ARRAYTYPE)))

;;; (DEFUN (INDEFINITE-ARRAY-TYPE? BOOLEAN) ...)

(CL:DEFUN INDEFINITE-ARRAY-TYPE? (ARRAYTYPE)
  (CL:LET*
   ((DIMENSIONS
     (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS ARRAYTYPE)))
   (CL:IF (CL:EQ DIMENSIONS NULL)
    (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:T)
    (CL:LET* ((DIM NULL) (ITER-000 (%LIST.THE-CONS-LIST DIMENSIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ DIM (%%VALUE ITER-000))
      (CL:WHEN (CL:EQ DIM NULL)
       (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:NIL)))

;;; (DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-ANCHORED-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-ANCHORED-TYPE-SPECIFIER))
    (LIKEARGUMENT (%%VALUE (%%REST TYPESPECTREE))))
   (CL:WHEN (CL:NOT (CL:EQ LIKEARGUMENT SYM-METHODS-STELLA-SELF))
    (CL:SETF
     (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME TYPESPEC)
     (PERMANENTIFY (%%VALUE LIKEARGUMENT))))
   (CL:RETURN-FROM YIELD-ANCHORED-TYPE-SPECIFIER TYPESPEC)))

;;; (DEFUN INCORPORATE-INPUT-PARAMETERS ...)

(CL:DEFUN INCORPORATE-INPUT-PARAMETERS (METHOD PARAMETERS)
  (CL:WHEN (CL:EQ PARAMETERS NIL)
   (CL:RETURN-FROM INCORPORATE-INPUT-PARAMETERS))
  (CL:LET*
   ((NAME NULL) (TS NULL) (DIRECTION NULL) (VARIABLEARGS? CL:NIL))
   (CL:SETF (%METHOD-SLOT.METHOD-PARAMETER-NAMES METHOD) (NEW-LIST))
   (CL:SETF (%METHOD-SLOT.METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
    (NEW-LIST))
   (CL:LET* ((P NULL) (ITER-000 PARAMETERS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-CONS)
         (CL:PROGN
          (CL:CASE (LENGTH P)
           (2 (CL:SETQ DIRECTION SYM-METHODS-STELLA-IN))
           (3
            (CL:COND
             ((CL:OR (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-IN)
               (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-OUT)
               (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-INOUT))
              (CL:SETQ DIRECTION (%%VALUE P))
              (CL:WHEN
               (NULL-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD))
               (SET-DYNAMIC-SLOT-VALUE
                (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
                SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS
                (NEW-LIST) NULL)
               (CL:LET* ((PAR NULL) (ITER-001 PARAMETERS))
                (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
                 (CL:SETQ PAR (%%VALUE ITER-001))
                 (CL:IF (CL:EQ PAR P) (CL:RETURN)
                  (INSERT (METHOD-PARAMETER-DIRECTIONS METHOD)
                   SYM-METHODS-STELLA-IN))
                 (CL:SETQ ITER-001 (%%REST ITER-001))))))
             (CL:T
              (CL:LET* ((*PRINTREADABLY?* CL:T))
               (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
               (SIGNAL-TRANSLATION-ERROR)
               (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
                (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
                (%%PRINT-STREAM
                 (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
                 " Illegal direction for method parameter: `"
                 (DE-UGLIFY-PARSE-TREE P) "'." EOL)))
              (CL:SETQ DIRECTION SYM-METHODS-STELLA-IN)))
            (CL:SETQ P (%%REST P)))
           (CL:OTHERWISE
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
               " Illegal method parameter: `" (DE-UGLIFY-PARSE-TREE P)
               "'." EOL)))
            (CL:GO :CONTINUE)))
          (CL:IF VARIABLEARGS?
           (CL:LET*
            ((VARARGTYPE
              (LIST* SYM-METHODS-STELLA-ARGUMENT-LIST
               SYM-METHODS-STELLA-OF (%%VALUE (%%REST P)) NIL)))
            (CL:SETQ NAME (%%VALUE P))
            (CL:SETQ TS (YIELD-TYPE-SPECIFIER VARARGTYPE)))
           (CL:PROGN
            (CL:WHEN
             (CL:NOT
              (CL:AND (SYMBOL? (%%VALUE P))
               (CL:OR (SYMBOL? (%%VALUE (%%REST P)))
                (SURROGATE? (%%VALUE (%%REST P)))
                (CONS? (%%VALUE (%%REST P))))))
             (CL:LET* ((*PRINTREADABLY?* CL:T))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
               (%%PRINT-STREAM
                (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
                " Illegal method parameter: `" (DE-UGLIFY-PARSE-TREE P)
                "'." EOL)))
             (CL:GO :CONTINUE))
            (CL:SETQ NAME (%%VALUE P))
            (CL:SETQ TS
             (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST P))))))))
        ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
         (CL:PROGN
          (CL:COND
           ((CL:EQ P |SYM-METHODS-STELLA-&REST|)
            (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS? TRUE-WRAPPER
             FALSE-WRAPPER)
            (CL:SETQ VARIABLEARGS? CL:T) (CL:GO :CONTINUE))
           ((CL:EQ P |SYM-METHODS-STELLA-&BODY|)
            (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
             SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT? TRUE-WRAPPER
             FALSE-WRAPPER)
            (CL:GO :CONTINUE))
           (CL:T
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM
               (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
               " Untyped parameter in parameter list: `"
               (DE-UGLIFY-PARSE-TREE PARAMETERS) "'." EOL)))
            (CL:SETQ NAME P)
            (CL:SETQ TS SGT-METHODS-STELLA-UNKNOWN)))))
        (CL:T
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal parameter list: `"
            (DE-UGLIFY-PARSE-TREE PARAMETERS) "'." EOL)))
         (CL:GO :CONTINUE))))
      (INSERT (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD) TS)
      (INSERT (METHOD-PARAMETER-NAMES METHOD) (PERMANENTIFY NAME))
      (CL:WHEN (DEFINED-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD))
       (INSERT (METHOD-PARAMETER-DIRECTIONS METHOD) DIRECTION))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE (METHOD-PARAMETER-NAMES METHOD))
   (REVERSE (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
   (REVERSE (METHOD-PARAMETER-DIRECTIONS METHOD)))
  :VOID)

;;; (DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ...)

(CL:DEFUN INCORPORATE-FIRST-INPUT-PARAMETER (METHOD)
  (CL:LET*
   ((PARAMETERTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (FIRSTARGTYPE (FIRST PARAMETERTYPESPECS)))
   (CL:WHEN (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? METHOD))
    (CL:COND
     ((EMPTY? PARAMETERTYPESPECS)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL
         " Method has no input parameters, converting it into a function."
         EOL)))
      (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? METHOD) CL:T)
      (CL:RETURN-FROM INCORPORATE-FIRST-INPUT-PARAMETER))
     ((CL:AND (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
       (CL:NOT (TYPE? FIRSTARGTYPE)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
         EOL
         " Illegal complex argument type for the first method parameter: "
         EOL "   `" (DE-UGLIFY-PARSE-TREE FIRSTARGTYPE) "'." EOL)))
      (CL:WHEN (ANCHORED-TYPE-SPECIFIER? FIRSTARGTYPE)
       (FIRST-SETTER (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
        SGT-METHODS-STELLA-UNKNOWN)
       (CL:SETQ FIRSTARGTYPE SGT-METHODS-STELLA-UNKNOWN)))))
   (CL:SETF (%METHOD-SLOT.SLOT-OWNER METHOD)
    (CL:IF (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
     (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE) NULL)))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ...)

(CL:DEFUN DEFINE-STELLA-METHOD-SLOT (INPUTNAME RETURNTYPES FUNCTION? INPUTPARAMETERS OPTIONS)
  "Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'."
  (CL:LET*
   ((NEWMETHOD (NEW-METHOD-SLOT)) (NAME (PERMANENTIFY INPUTNAME)))
   (CL:SETF (%METHOD-SLOT.SLOT-NAME NEWMETHOD) NAME)
   (CL:SETF (%METHOD-SLOT.METHOD-FUNCTION? NEWMETHOD) FUNCTION?)
   (INCORPORATE-INPUT-PARAMETERS NEWMETHOD INPUTPARAMETERS)
   (INCORPORATE-FIRST-INPUT-PARAMETER NEWMETHOD)
   (CL:WHEN (CL:EQ RETURNTYPES NIL)
    (CL:COND
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-TYPE) NULL))
      (CL:SETQ RETURNTYPES
       (CONS (LOOKUP OPTIONS KWD-METHODS-TYPE) NIL)))
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NULL))
      (CL:SETQ RETURNTYPES
       (CONS (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NIL)))))
   (CL:LET*
    ((TYPESPEC
      (CL:IF (CL:EQ RETURNTYPES NIL) SGT-METHODS-STELLA-VOID
       (YIELD-TYPE-SPECIFIER (%%VALUE RETURNTYPES)))))
    (CL:IF (TYPE? TYPESPEC)
     (CL:SETF (%METHOD-SLOT.SLOT-BASE-TYPE NEWMETHOD) TYPESPEC)
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER TYPESPEC NULL)))
   (CL:WHEN (CL:NOT (CL:EQ RETURNTYPES NIL))
    (CL:SETF (%METHOD-SLOT.METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD)
     (NEW-LIST)))
   (CL:LET*
    ((TS NULL) (ITER-000 RETURNTYPES)
     (INTO-000 (METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-000) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST INTO-000) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST INTO-000)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-001 (ALLOCATE-ITERATOR OPTIONS)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ KEY (%KV-LIST-ITERATOR.KEY ITER-001))
     (CL:SETQ VALUE (%KV-LIST-ITERATOR.VALUE ITER-001))
     (CL:LET* ((TEST-VALUE-000 KEY))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-PUBLIC?)
        (CL:SETF (%METHOD-SLOT.SLOT-PUBLIC? NEWMETHOD)
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-ABSTRACT?)
        (CL:SETF (%METHOD-SLOT.ABSTRACT? NEWMETHOD)
         (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-NATIVE?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-NATIVE?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-CONSTRUCTOR?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-CONSTRUCTOR?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-GLOBALLY-INLINE?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-INLINE)
        (CL:WHEN (EMPTY? (METHOD-INLINED-FUNCTIONS NEWMETHOD))
         (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
          SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS (NEW-LIST) NULL))
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((CL:EQ TEST-VALUE-001 SGT-METHODS-STELLA-CONS)
           (CL:PROGN
            (CL:LET* ((FNNAME NULL) (ITER-002 VALUE))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
              (CL:SETQ FNNAME (%%VALUE ITER-002))
              (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) FNNAME)
              (CL:SETQ ITER-002 (%%REST ITER-002))))))
          ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
           (CL:PROGN
            (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) VALUE)))
          (CL:T (CL:WARN "Illegal :inline argument: `~A'" VALUE)))))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-AUXILIARY?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-SLOT-AUXILIARY?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-DOCUMENTATION)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-DOCUMENTATION
         (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
         NULL-STRING-WRAPPER))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-METHODS-TYPE)
         (CL:EQ TEST-VALUE-000 KWD-METHODS-RETURNS)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-STORAGE-SLOT)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-STORAGE-SLOT (PERMANENTIFY VALUE) NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-INHERITS-THROUGH)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH
         (PERMANENTIFY VALUE) NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-PROPERTIES)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-PROPERTIES VALUE NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-META-ATTRIBUTES)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-META-ATTRIBUTES VALUE NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-COMMAND?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-COMMAND?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-LISP-MACRO?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-LISP-MACRO?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-EVALUATE-ARGUMENTS?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-C-CALLABLE?)
        (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-C-CALLABLE?
         (CL:IF (%BOOLEAN-WRAPPER.WRAPPER-VALUE VALUE) TRUE-WRAPPER
          FALSE-WRAPPER)
         FALSE-WRAPPER))
       (CL:T
        (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? NEWMETHOD KEY VALUE))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-WARNING)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
           (%%PRINT-STREAM
            (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
            " Skipping invalid method option `"
            (DE-UGLIFY-PARSE-TREE KEY) "'" EOL
            "in the definition of method `"
            (%METHOD-SLOT.SLOT-OWNER NEWMETHOD) "'.`"
            (DE-UGLIFY-PARSE-TREE NAME) "'." EOL)))))))))
   (CL:RETURN-FROM DEFINE-STELLA-METHOD-SLOT NEWMETHOD)))

;;; (DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ...)

(CL:DEFUN ATTACH-METHOD-SLOT-TO-OWNER (NEWMETHOD)
  (CL:WHEN (%METHOD-SLOT.METHOD-FUNCTION? NEWMETHOD)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER
    (ATTACH-FUNCTION NEWMETHOD)))
  (CL:WHEN
   (CL:EQ
    (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER NEWMETHOD))
    NULL)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER NEWMETHOD))
  (CL:WHEN (CL:NOT (UNDEFINE-CONFLICTING-DEFINITIONS? NEWMETHOD))
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER NULL))
  (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER
   (ATTACH-SLOT-TO-OWNER NEWMETHOD)))

;;; (DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* ...)

(CL:DEFVAR *MAXIMUM-STRING-CONSTANT-SIZE* 4000
  "Maximum size for a string constant in the target language.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAXIMUM-STRING-CONSTANT-SIZE*))

;;; (DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ...)

(CL:DEFUN YIELD-STRING-CONSTANT-TREE (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((LENGTH (CL:THE CL:FIXNUM (CL:LENGTH STRING))) (CHUNKS NIL)
    (START 0) (STRINGTREE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH START))
   (CL:WHEN (CL:<= LENGTH *MAXIMUM-STRING-CONSTANT-SIZE*)
    (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE (WRAP-STRING STRING)))
   (CL:LOOP WHILE
    (CL:< (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*) LENGTH) DO
    (CL:SETQ CHUNKS
     (CONS
      (WRAP-STRING
       (SUBSEQUENCE STRING START
        (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
      CHUNKS))
    (CL:SETQ START (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
   (CL:WHEN (CL:< START LENGTH)
    (CL:SETQ CHUNKS
     (CONS (WRAP-STRING (SUBSEQUENCE STRING START LENGTH)) CHUNKS)))
   (CL:SETQ STRINGTREE (%%VALUE CHUNKS))
   (CL:LET* ((CHUNK NULL) (ITER-000 (%%REST CHUNKS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHUNK (%%VALUE ITER-000))
     (CL:SETQ STRINGTREE
      (LIST* SYM-METHODS-STELLA-CONCATENATE CHUNK
       (CONS STRINGTREE NIL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE STRINGTREE)))

;;; (DEFUN (DEFINE-FUNCTION-OBJECT-EAGERLY? BOOLEAN) ...)

(CL:DEFUN DEFINE-FUNCTION-OBJECT-EAGERLY? (FUNCTION)
  (CL:LET*
   ((METHODCLASS
     (%SURROGATE.SURROGATE-VALUE SGT-METHODS-STELLA-METHOD-SLOT))
    (SLOT NULL))
   (CL:LET*
    ((SLOTNAME NULL) (VALUE NULL)
     (ITER-000
      (%KEY-VALUE-LIST.THE-KV-LIST
       (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ SLOTNAME (%KV-CONS.KEY ITER-000))
     (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000)) (CL:SETQ VALUE VALUE)
     (CL:SETQ SLOT (LOOKUP-SLOT METHODCLASS SLOTNAME))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ SLOT NULL))
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
          SYM-METHODS-STELLA-SLOT-OPTION-HANDLER NULL)
         NULL)))
      (CL:RETURN-FROM DEFINE-FUNCTION-OBJECT-EAGERLY? CL:T))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
   (CL:RETURN-FROM DEFINE-FUNCTION-OBJECT-EAGERLY? CL:NIL)))

;;; (DEFUN (YIELD-DEFINE-STELLA-METHOD-OBJECT CONS) ...)

(CL:DEFUN YIELD-DEFINE-STELLA-METHOD-OBJECT (METHOD CODEMETHOD WRAPPERMETHOD)
  (CL:LET*
   ((NAME (WRAP-STRING (STRINGIFY (%METHOD-SLOT.SLOT-NAME METHOD)))))
   (CL:COND
    ((%METHOD-SLOT.METHOD-FUNCTION? METHOD)
     (CL:COND
      ((DEFINE-FUNCTION-OBJECT-EAGERLY? METHOD)
       (CL:SETQ NAME SYM-METHODS-STELLA-NULL))
      ((CL:NOT
        (EQL-TO-STRING? NAME
         (%SYMBOL.SYMBOL-NAME (%METHOD-SLOT.SLOT-NAME METHOD))))
       (CL:SETQ NAME
        (WRAP-STRING
         (CONCATENATE " " (%STRING-WRAPPER.WRAPPER-VALUE NAME))))))
     (CL:RETURN-FROM YIELD-DEFINE-STELLA-METHOD-OBJECT
      (LIST* SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT NAME
       (CONS
        (YIELD-STRING-CONSTANT-TREE
         (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE METHOD))
        (CONS
         (CL:IF (CL:NOT (CL:EQ CODEMETHOD NULL))
          (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-FUNCTION
           (%METHOD-SLOT.SLOT-NAME CODEMETHOD) NIL)
          SYM-METHODS-STELLA-NULL)
         (CONS
          (CL:IF (CL:NOT (CL:EQ WRAPPERMETHOD NULL))
           (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-FUNCTION
            (%METHOD-SLOT.SLOT-NAME WRAPPERMETHOD)
            (CONS WRAPPERMETHOD NIL))
           SYM-METHODS-STELLA-NULL)
          NIL))))))
    ((INLINE-METHOD? METHOD)
     (CL:RETURN-FROM YIELD-DEFINE-STELLA-METHOD-OBJECT
      (LIST* SYM-METHODS-STELLA-DEFINE-INLINE-METHOD-CODE
       (%METHOD-SLOT.SLOT-OWNER METHOD)
       (LIST*
        (LIST* SYM-METHODS-STELLA-QUOTE (%METHOD-SLOT.SLOT-NAME METHOD)
         NIL)
        (CL:IF (CL:NOT (CL:EQ CODEMETHOD NULL))
         (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-METHOD
          (%METHOD-SLOT.SLOT-OWNER CODEMETHOD)
          (CONS (%METHOD-SLOT.SLOT-NAME CODEMETHOD) NIL))
         SYM-METHODS-STELLA-NULL)
        (CONS SYM-METHODS-STELLA-NULL NIL)))))
    (CL:T
     (CL:RETURN-FROM YIELD-DEFINE-STELLA-METHOD-OBJECT
      (LIST* SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT
       (YIELD-STRING-CONSTANT-TREE
        (%METHOD-SLOT.METHOD-STRINGIFIED-SOURCE METHOD))
       (CONS
        (CL:IF (CL:NOT (CL:EQ CODEMETHOD NULL))
         (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-METHOD
          (%METHOD-SLOT.SLOT-OWNER CODEMETHOD)
          (CONS (%METHOD-SLOT.SLOT-NAME CODEMETHOD) NIL))
         SYM-METHODS-STELLA-NULL)
        (CONS SYM-METHODS-STELLA-NULL NIL))))))))

;;; (DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ...)

(CL:DEFUN YIELD-CLASS-PARAMETER-TYPES (CLASS)
  (CL:LET* ((TYPES NIL))
   (CL:LET*
    ((PNAME NULL) (ITER-000 (%LIST.THE-CONS-LIST (PARAMETERS CLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PNAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (%SLOT.SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (%SLOT.SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-CLASS-PARAMETER-TYPES TYPES)))

;;; (DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN OPTIMISTIC-SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUBTYPE) NULL))
    (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NULL))
    (%CLASS.CLASS-FINALIZED? (%SURROGATE.SURROGATE-VALUE SUBTYPE)))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF?
    (SUBTYPE-OF? SUBTYPE SUPERTYPE))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF? CL:T)))

;;; (DEFUN WARN-OF-PARAMETER-MISMATCH ...)

(CL:DEFUN WARN-OF-PARAMETER-MISMATCH (SELF MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET*
   ((INHERITEDTYPES
     (YIELD-CLASS-PARAMETER-TYPES
      (%SURROGATE.SURROGATE-VALUE
       (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF)))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:WARN
     "`~A'~%Type `~A' takes parameters of type ~%`~A' but was modified by a list of types `~A'"
     MESSAGE (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF)
     INHERITEDTYPES
     (%LIST.THE-CONS-LIST
      (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES SELF)))))
  :VOID)

;;; (DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ...)

(CL:DEFUN VALIDATE-TYPE-SPECIFIER (SELF ANCHORCLASS SKIPANCHOREDTYPE?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:EQ
        (%SURROGATE.SURROGATE-VALUE
         (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF))
        NULL)
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER
        SGT-METHODS-STELLA-UNKNOWN))
      (CL:LET*
       ((PARAMETERDIFFERENTIAL
         (CL:-
          (LENGTH
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES SELF))
          (LENGTH
           (PARAMETERS
            (%SURROGATE.SURROGATE-VALUE
             (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE
              SELF)))))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM PARAMETERDIFFERENTIAL))
       (CL:COND
        ((CL:> PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH SELF
          "Too many parameters in type specification."))
        ((CL:< PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH SELF
          "Not enough parameters in type specification."))
        (CL:T
         (CL:LET*
          ((BASECLASS
            (%SURROGATE.SURROGATE-VALUE
             (TYPE-SPEC-TO-BASE-TYPE SELF))))
          (CL:WHEN (%CLASS.CLASS-SLOTS-FINALIZED? BASECLASS)
           (CL:LET*
            ((INHERITEDTYPES (YIELD-CLASS-PARAMETER-TYPES BASECLASS)))
            (CL:LET*
             ((SUPERTYPE NULL) (ITER-000 INHERITEDTYPES)
              (SUBTYPESPEC NULL)
              (ITER-001
               (%LIST.THE-CONS-LIST
                (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
                 SELF))))
             (CL:LOOP WHILE
              (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
               (CL:NOT (CL:EQ ITER-001 NIL)))
              DO (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
              (CL:SETQ SUBTYPESPEC (%%VALUE ITER-001))
              (CL:WHEN
               (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUBTYPESPEC))
                (CL:NOT (CL:EQ SUPERTYPE SGT-METHODS-STELLA-UNKNOWN))
                (CL:NOT
                 (OPTIMISTIC-SUBTYPE-OF?
                  (TYPE-SPEC-TO-BASE-TYPE SUBTYPESPEC) SUPERTYPE)))
               (WARN-OF-PARAMETER-MISMATCH SELF
                "Parametric subtype(s) don't specialize supertype(s)"))
              (CL:SETQ ITER-000 (%%REST ITER-000))
              (CL:SETQ ITER-001 (%%REST ITER-001)))))))))
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER
        (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF)))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN SKIPANCHOREDTYPE?
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:WHEN (CL:EQ ANCHORCLASS NULL)
       (CL:WARN
        "Illegal use of anchored type for function that has no first
argument (and hence nothing to anchor onto).")
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:LET*
       ((SLOTNAME
         (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME SELF))
        (ANCHORSLOT NULL))
       (CL:WHEN (CL:EQ SLOTNAME NULL)
        (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER
         (%CLASS.CLASS-TYPE ANCHORCLASS)))
       (CL:LET* ()
        (CL:SETQ ANCHORSLOT (LOOKUP-SLOT ANCHORCLASS SLOTNAME))
        (CL:WHEN (CL:EQ ANCHORSLOT NULL)
         (CL:CERROR "Continue anyway? "
          "Can't find a slot named `~A' on the class `~A'" SLOTNAME
          (CLASS-NAME ANCHORCLASS))))
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER
        (%SLOT.SLOT-BASE-TYPE ANCHORSLOT)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "validate-type-specifier: Not defined on `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SYNTHESIZE-METHOD-BODY CONS) ...)

(CL:DEFUN SYNTHESIZE-METHOD-BODY (METHOD)
  (CL:WHEN
   (CL:EQ (%SURROGATE.SURROGATE-VALUE SGT-METHODS-STELLA-BOOLEAN) NULL)
   (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
  (CL:LET*
   ((STORAGESLOTNAME
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-METHODS-STELLA-STORAGE-SLOT NULL))
    (INHERITANCESLOTNAME
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS METHOD)
      SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH NULL))
    (STORAGESLOT NULL) (INHERITANCESLOT NULL) (DEFAULTVALUE NULL))
   (CL:COND
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-STELLA-SUPER-CLASSES)
     (CL:SETQ INHERITANCESLOTNAME
      SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES))
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-STELLA-EQUIVALENT-SLOT)
     (CL:SETQ INHERITANCESLOTNAME
      SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT))
    (CL:T))
   (CL:SETQ STORAGESLOT
    (LOOKUP-SLOT
     (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER METHOD))
     STORAGESLOTNAME))
   (CL:WHEN (CL:EQ STORAGESLOT NULL)
    (CL:WARN
     ":storage-slot references non-existent slot `~A' on the class `~A'"
     STORAGESLOTNAME (%METHOD-SLOT.SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ INHERITANCESLOT
    (LOOKUP-SLOT
     (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER METHOD))
     INHERITANCESLOTNAME))
   (CL:WHEN (CL:EQ INHERITANCESLOT NULL)
    (CL:WARN
     ":inherits-through references non-existent slot `~A' on the class `~A'"
     INHERITANCESLOTNAME (%METHOD-SLOT.SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ DEFAULTVALUE (SYSTEM-DEFAULT-VALUE STORAGESLOT))
   (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY
    (CONS
     (LIST* SYM-METHODS-STELLA-LET
      (LIST*
       (LIST* SYM-METHODS-STELLA-CURSOR SYM-METHODS-STELLA-SELF NIL)
       (LIST* SYM-METHODS-STELLA-VALUE
        (LIST* SYM-METHODS-STELLA-SLOT-VALUE SYM-METHODS-STELLA-CURSOR
         STORAGESLOTNAME NIL)
        NIL)
       NIL)
      (LIST* SYM-METHODS-STELLA-LOOP
       (CONS SYM-METHODS-STELLA-WHEN
        (CONCATENATE
         (CL:IF
          (SUBTYPE-OF? (TYPE STORAGESLOT) SGT-METHODS-STELLA-BOOLEAN)
          (CONS SYM-METHODS-STELLA-VALUE NIL)
          (CONS
           (LIST* SYM-METHODS-STELLA-DEFINED? SYM-METHODS-STELLA-VALUE
            NIL)
           NIL))
         (CONS
          (LIST* SYM-METHODS-STELLA-RETURN SYM-METHODS-STELLA-VALUE
           NIL)
          NIL)))
       (LIST* SYM-METHODS-STELLA-SETQ SYM-METHODS-STELLA-CURSOR
        (CL:IF
         (CL:OR
          (SUBTYPE-OF? (TYPE INHERITANCESLOT)
           SGT-METHODS-STELLA-COLLECTION)
          (SUBTYPE-OF? (TYPE INHERITANCESLOT) SGT-METHODS-STELLA-CONS))
         (LIST* SYM-METHODS-STELLA-FIRST
          (CONS INHERITANCESLOTNAME
           (CONS SYM-METHODS-STELLA-CURSOR NIL))
          NIL)
         (CONS INHERITANCESLOTNAME
          (CONS SYM-METHODS-STELLA-CURSOR NIL)))
        NIL)
       (LIST* SYM-METHODS-STELLA-IF
        (LIST* SYM-METHODS-STELLA-DEFINED? SYM-METHODS-STELLA-CURSOR
         NIL)
        (LIST* SYM-METHODS-STELLA-SETQ SYM-METHODS-STELLA-VALUE
         (LIST* SYM-METHODS-STELLA-SLOT-VALUE SYM-METHODS-STELLA-CURSOR
          STORAGESLOTNAME NIL)
         NIL)
        (LIST* SYM-METHODS-STELLA-RETURN
         (CL:IF (CL:NOT (CL:EQ DEFAULTVALUE NULL)) DEFAULTVALUE
          SYM-METHODS-STELLA-NULL)
         NIL)
        NIL)
       NIL)
      NIL)
     NIL))))

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((OWNERCLASS
     (CL:IF (CL:NOT (CL:EQ (%METHOD-SLOT.SLOT-OWNER SELF) NULL))
      (%SURROGATE.SURROGATE-VALUE (%METHOD-SLOT.SLOT-OWNER SELF))
      NULL)))
   (CL:LET*
    ((TS NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-000))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS CL:NIL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
       SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
      NULL))
    (CL:SETF (%METHOD-SLOT.SLOT-BASE-TYPE SELF)
     (VALIDATE-TYPE-SPECIFIER
      (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
       SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
      OWNERCLASS CL:NIL)))
   (CL:LET*
    ((TS NULL) (ITER-001 (REST (METHOD-RETURN-TYPE-SPECIFIERS SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-001))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS CL:NIL)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  :VOID)

;;; (DEFUN UNDEFINE-EXTERNAL-SLOTS ...)

(CL:DEFUN UNDEFINE-EXTERNAL-SLOTS (NAME)
  (CL:LET* ((SLOTS NIL))
   (CL:LET* ((MODULE NULL) (ITER-000 (ALL-MODULES)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ MODULE (%ITERATOR.VALUE ITER-000))
     (CL:LET*
      ((SLOT NULL) (ITER-001 (ALL-SLOTS MODULE CL:T))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (NEXT? ITER-001) DO
       (CL:SETQ SLOT (%ITERATOR.VALUE ITER-001))
       (CL:WHEN
        (CL:AND (CL:EQ (%SLOT.SLOT-NAME SLOT) NAME)
         (%SLOT.SLOT-EXTERNAL? SLOT))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
          (CL:IF (CL:EQ SLOTS NIL) (CL:SETQ SLOTS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST SLOTS COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))
   (CL:LET* ((SLOT NULL) (ITER-002 SLOTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-002)) (DESTROY-EXTERNAL-SLOT SLOT)
     (CL:SETQ ITER-002 (%%REST ITER-002)))))
  :VOID)

;;; (DEFUN DESTROY-EXTERNAL-SLOT ...)

(CL:DEFUN DESTROY-EXTERNAL-SLOT (SELF)
  (CL:WHEN
   (CL:NOT
    (CL:OR (DELETED? SELF)
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? SELF))
     (CL:NOT (%SLOT.SLOT-EXTERNAL? SELF))))
   (CL:LET*
    ((OWNERCLASS (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER SELF))))
    (CL:WHEN (CL:NOT (CL:EQ OWNERCLASS NULL))
     (REMOVE (%CLASS.CLASS-LOCAL-SLOTS OWNERCLASS) SELF)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS) (DELETED?-SETTER SELF CL:T))))
  :VOID)

;;; (DEFUN DESTROY-METHOD ...)

(CL:DEFUN DESTROY-METHOD (SELF)
  (DESTROY-EXTERNAL-SLOT SELF)
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF SLOT))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "method-argument-count: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT 1))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF METHOD-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT
   (LENGTH (METHOD-PARAMETER-NAMES SELF))))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF TABLE))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT
   (CL:1- (LENGTH (%TABLE.TUPLE-DOMAINS SELF)))))

;;; (DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-VARIABLE-ARGUMENTS? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-VARIABLE-ARGUMENTS? CL:NIL))

;;; (DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-BODY-ARGUMENT? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-BODY-ARGUMENT? CL:NIL))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM ARITY 2))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF METHOD-SLOT))
  (CL:WHEN
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
   (CL:RETURN-FROM ARITY NULL-INTEGER))
  (CL:LET*
   ((RETURNTYPECOUNT (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS SELF)))
    (RESULT
     (CL:+ (LENGTH (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))
      RETURNTYPECOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RETURNTYPECOUNT RESULT))
   (CL:CASE RETURNTYPECOUNT
    (1
     (CL:IF
      (CL:EQ (FIRST (METHOD-RETURN-TYPE-SPECIFIERS SELF))
       SGT-METHODS-STELLA-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT))
      (CL:RETURN-FROM ARITY RESULT)))
    (0 (CL:RETURN-FROM ARITY RESULT))
    (CL:OTHERWISE
     (CL:IF
      (CL:EQ (LAST (METHOD-RETURN-TYPE-SPECIFIERS SELF))
       SGT-METHODS-STELLA-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT))
      (CL:RETURN-FROM ARITY RESULT))))))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF TABLE))
  (CL:IF
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%TABLE.DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE? FALSE-WRAPPER))
   (CL:RETURN-FROM ARITY NULL-INTEGER)
   (CL:RETURN-FROM ARITY (LENGTH (%TABLE.TUPLE-DOMAINS SELF)))))

;;; (DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ...)

(CL:DEFUN TYPE-SPEC-TO-BASE-TYPE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM TYPE-SPEC-TO-BASE-TYPE SELF)))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM TYPE-SPEC-TO-BASE-TYPE
       (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "type-spec-to-base-type: Not defined on `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (BASE-TYPE-TO-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN BASE-TYPE-TO-TYPE-SPEC (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((CLASS (%SURROGATE.SURROGATE-VALUE SELF))
        (PARAMETERS (PARAMETERS CLASS)) (PARAMETERTYPE NULL)
        (PARAMETERTYPES NULL))
       (CL:WHEN (NON-EMPTY? PARAMETERS)
        (CL:SETQ PARAMETERTYPES (NEW-LIST))
        (CL:LET*
         ((PARAMETER NULL) (ITER-000 (%LIST.THE-CONS-LIST PARAMETERS))
          (COLLECT-000 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ PARAMETER (%%VALUE ITER-000))
          (CL:SETQ PARAMETERTYPE
           (COMPUTE-RETURN-TYPE-SPEC (LOOKUP-SLOT CLASS PARAMETER)
            SELF))
          (CL:WHEN (UNKNOWN-TYPE? PARAMETERTYPE)
           (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS PARAMETERTYPE NIL))
            (CL:IF (CL:EQ (%LIST.THE-CONS-LIST PARAMETERTYPES) NIL)
             (CL:SETF (%LIST.THE-CONS-LIST PARAMETERTYPES) COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST
              (%LIST.THE-CONS-LIST PARAMETERTYPES) COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000) (CONS PARAMETERTYPE NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:LET* ((SELF-001 (NEW-PARAMETRIC-TYPE-SPECIFIER)))
         (CL:SETF
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF-001)
          SELF)
         (CL:SETF
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
           SELF-001)
          PARAMETERTYPES)
         (CL:LET* ((VALUE-000 SELF-001))
          (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC VALUE-000))))
       (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "base-type-to-type-spec: Not defined on `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (TYPE-SPEC-TO-CLASS CLASS) ...)

(CL:DEFUN TYPE-SPEC-TO-CLASS (SELF)
  (CL:RETURN-FROM TYPE-SPEC-TO-CLASS
   (%SURROGATE.SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SELF))))

;;; (DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ...)

(CL:DEFUN COMPATIBLE-PARAMETER-TYPES? (SUBTYPE SUPERTYPE)
  (CL:WHEN (CL:OR (TYPE? SUBTYPE) (TYPE? SUPERTYPE))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:T))
  (CL:LET* ((SUBCLASS NULL) (SUPERCLASS NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUBTYPE)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SUBCLASS (%SURROGATE.SURROGATE-VALUE SUBTYPE))))
     ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SUBCLASS
        (%SURROGATE.SURROGATE-VALUE
         (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SUBTYPE)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERTYPE)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ SUPERCLASS (%SURROGATE.SURROGATE-VALUE SUPERTYPE))))
     ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ SUPERCLASS
        (%SURROGATE.SURROGATE-VALUE
         (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SUPERTYPE)))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "`" TEST-VALUE-001 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:LET*
    ((SUPPAR NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (PARAMETERS SUPERCLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPPAR (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((SUBPAR NULL)
         (ITER-001 (%LIST.THE-CONS-LIST (PARAMETERS SUBCLASS))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ SUBPAR (%%VALUE ITER-001))
         (CL:WHEN (CL:EQ SUPPAR SUBPAR) (CL:SETQ FOUND?-000 CL:T)
          (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:WHEN (CL:NOT FOUND?-000)
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL)))
      (CL:LET*
       ((SUBPARTYPE (EXTRACT-PARAMETER-TYPE SUBTYPE SUPPAR))
        (SUPPARTYPE (EXTRACT-PARAMETER-TYPE SUPERTYPE SUPPAR)))
       (CL:WHEN (CL:EQ SUBPARTYPE SUPPARTYPE) (CL:GO :CONTINUE))
       (CL:WHEN
        (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUBPARTYPE))
         (CL:EQ
          (%SURROGATE.SURROGATE-VALUE
           (TYPE-SPEC-TO-BASE-TYPE SUBPARTYPE))
          NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Parameter type `" (TYPE-SPEC-TO-BASE-TYPE SUBPARTYPE)
           "' of `" (DE-UGLIFY-PARSE-TREE SUBTYPE)
           "' is not yet defined." EOL)))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL))
       (CL:WHEN
        (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUPPARTYPE))
         (CL:EQ
          (%SURROGATE.SURROGATE-VALUE
           (TYPE-SPEC-TO-BASE-TYPE SUPPARTYPE))
          NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Parameter type `" (TYPE-SPEC-TO-BASE-TYPE SUPPARTYPE)
           "' of `" (DE-UGLIFY-PARSE-TREE SUPERTYPE)
           "' is not yet defined." EOL)))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL))
       (CL:WHEN (CL:NOT (SUB-TYPE-SPEC-OF? SUBPARTYPE SUPPARTYPE))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL)))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:T)))

;;; (DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ...)

(CL:DEFUN SUB-TYPE-SPEC-OF? (SUBTYPE SUPERTYPE)
  (CL:WHEN (CL:EQ SUBTYPE SUPERTYPE)
   (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:T))
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE SUBTYPE)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUPERTYPE)))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND (SUBTYPE-OF? SUBTYPE SUPERTYPE)
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND
            (SUBTYPE-OF? SUBTYPE
             (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE
              SUPERTYPE))
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        (CL:T (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:NIL))))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERTYPE)))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND
            (SUBTYPE-OF?
             (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SUBTYPE)
             SUPERTYPE)
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-001)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND
            (SUBTYPE-OF?
             (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SUBTYPE)
             (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE
              SUPERTYPE))
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        (CL:T (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:NIL))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-002)
     (CL:PROGN
      (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
       (CL:AND (ANCHORED-TYPE-SPECIFIER? SUPERTYPE)
        (CL:EQ
         (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME SUBTYPE)
         (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME
          SUPERTYPE))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "sub-type-spec-of?: Not defined on `" SUBTYPE "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (VOID? BOOLEAN) ...)

(CL:DEFUN VOID? (TYPE)
  (CL:RETURN-FROM VOID? (CL:EQ TYPE SGT-METHODS-STELLA-VOID)))

;;; (DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EXTRACT-PARAMETER-TYPE (SELF PARAMETER)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((SLOT
         (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE SELF) PARAMETER)))
       (CL:IF (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
         (CL:VALUES (TYPE SLOT) CL:T))
        (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
         (CL:VALUES SGT-METHODS-STELLA-OBJECT CL:NIL))))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((PNAME NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST
          (PARAMETERS
           (%SURROGATE.SURROGATE-VALUE
            (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF)))))
        (PTYPE NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
           SELF))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ PNAME (%%VALUE ITER-000))
        (CL:SETQ PTYPE (%%VALUE ITER-001))
        (CL:WHEN (CL:EQ PNAME PARAMETER)
         (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
          (CL:VALUES PTYPE CL:T)))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
       (CL:VALUES SGT-METHODS-STELLA-OBJECT CL:NIL))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "extract-parameter-type: Not defined on `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-ANCHORED-TYPE-SPEC (OWNERTYPE RELTYPE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OWNERTYPE)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:EQ
        (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME RELTYPE)
        NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((SLOT
         (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE OWNERTYPE)
          (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME
           RELTYPE))))
       (CL:WHEN (CL:EQ SLOT NULL)
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Missing :parameter named `"
           (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME RELTYPE)
           "'" EOL "   for the class `"
           (DE-UGLIFY-PARSE-TREE OWNERTYPE) "'" EOL "." EOL)))
        (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC
         SGT-METHODS-STELLA-OBJECT))
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC
        (CL:IF
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
            SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
           NULL))
         (COMPUTE-RELATIVE-TYPE-SPEC
          (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
           SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
          OWNERTYPE)
         (%SLOT.SLOT-BASE-TYPE SLOT))))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:EQ
        (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME RELTYPE)
        NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((PNAME NULL)
        (ITER-000
         (%LIST.THE-CONS-LIST
          (PARAMETERS
           (%SURROGATE.SURROGATE-VALUE
            (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE
             OWNERTYPE)))))
        (PTYPE NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
           OWNERTYPE))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ PNAME (%%VALUE ITER-000))
        (CL:SETQ PTYPE (%%VALUE ITER-001))
        (CL:WHEN
         (CL:EQ PNAME
          (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME RELTYPE))
         (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC PTYPE))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC
        (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE OWNERTYPE)
        RELTYPE))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "compute-anchored-type-spec: Not defined on `" OWNERTYPE "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-RELATIVE-TYPE-SPEC (RELATIVETYPE OWNERTYPE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE RELATIVETYPE)))
   (CL:COND
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((TS NULL)
         (ITER-000
          (%LIST.THE-CONS-LIST
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
            RELATIVETYPE))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-000))
         (CL:WHEN (CL:NOT (TYPE? TS)) (CL:SETQ ALWAYS?-000 CL:NIL)
          (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:WHEN ALWAYS?-000
        (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
      (CL:LET*
       ((TYPESLIST (NEW-LIST)) (RELATIVETS NULL)
        (FOUNDRELATIVISTICTYPE? CL:NIL))
       (CL:LET*
        ((TS NULL)
         (ITER-001
          (%LIST.THE-CONS-LIST
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
            RELATIVETYPE)))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-001))
         (CL:SETQ RELATIVETS (COMPUTE-RELATIVE-TYPE-SPEC TS OWNERTYPE))
         (CL:WHEN (CL:NOT (CL:EQ RELATIVETS TS))
          (CL:SETQ FOUNDRELATIVISTICTYPE? CL:T))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS RELATIVETS NIL))
           (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TYPESLIST) NIL)
            (CL:SETF (%LIST.THE-CONS-LIST TYPESLIST) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST
             (%LIST.THE-CONS-LIST TYPESLIST) COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000) (CONS RELATIVETS NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:IF FOUNDRELATIVISTICTYPE?
        (CL:LET* ((NEWTS (NEW-PARAMETRIC-TYPE-SPECIFIER)))
         (CL:SETF
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE NEWTS)
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE
           RELATIVETYPE))
         (CL:SETF
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES NEWTS)
          TYPESLIST)
         (CL:SETF
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS NEWTS)
          (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS
           RELATIVETYPE))
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC NEWTS))
        (CL:PROGN (FREE TYPESLIST)
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE RELATIVETYPE))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "compute-relative-type-spec: Not defined on `" RELATIVETYPE "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF SLOT) FIRSTARGTYPE)
  (CL:SETQ FIRSTARGTYPE FIRSTARGTYPE)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "compute-return-type-spec: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF METHOD-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ
    (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
    NULL)
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC
    (%METHOD-SLOT.SLOT-BASE-TYPE SELF))
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF STORAGE-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ
    (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
    NULL)
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC (TYPE SELF))
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE))))

;;; (DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ...)

(CL:DEFUN YIELD-TYPE-SPEC-TREE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
       (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME SELF)
        (%SURROGATE.HOME-CONTEXT SELF) CL:T))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((LISTOFTYPES NIL))
       (CL:LET*
        ((TS NULL)
         (ITER-000
          (%LIST.THE-CONS-LIST
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES
            SELF)))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000 (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:IF (CL:EQ LISTOFTYPES NIL)
            (CL:SETQ LISTOFTYPES COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST LISTOFTYPES COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (CONS
         (INTERN-SYMBOL-IN-MODULE
          (%SURROGATE.SYMBOL-NAME
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF))
          (%SURROGATE.HOME-CONTEXT
           (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF))
          CL:T)
         (CONCATENATE
          (CL:IF (ARRAY-TYPE-SPECIFIER? SELF)
           (LIST* SYM-METHODS-STELLA-SIZE
            (YIELD-ARRAY-DIMENSIONS-TREE SELF) NIL)
           NIL)
          (CONS SYM-METHODS-STELLA-OF
           (CONCATENATE LISTOFTYPES NIL))))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF
       (CL:NOT
        (CL:EQ (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME SELF)
         NULL))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (LIST* SYM-METHODS-STELLA-LIKE
         (CONS (%ANCHORED-TYPE-SPECIFIER.SPECIFIER-PARAMETER-NAME SELF)
          (CONS SYM-METHODS-STELLA-SELF NIL))
         NIL))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (LIST* SYM-METHODS-STELLA-LIKE SYM-METHODS-STELLA-SELF NIL)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "validate-type-specifier: Not defined on `" SELF "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *FUNCTION-LOOKUP-TABLE* ...)

(CL:DEFVAR *FUNCTION-LOOKUP-TABLE* NULL
  "Lookup table for functions.")

;;; (DEFUN (ATTACH-FUNCTION METHOD-SLOT) ...)

(CL:DEFUN ATTACH-FUNCTION (NEWFUNCTION)
  (CL:LET*
   ((NAME (%METHOD-SLOT.SLOT-NAME NEWFUNCTION))
    (OLDFUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:WHEN (CL:NOT (UNDEFINE-CONFLICTING-DEFINITIONS? NEWFUNCTION))
    (CL:RETURN-FROM ATTACH-FUNCTION NULL))
   (INSERT-AT *FUNCTION-LOOKUP-TABLE* NAME NEWFUNCTION)
   (UNREGISTER-SLOT-NAME NEWFUNCTION)
   (CL:SETF (%METHOD-SLOT.SLOT-EXTERNAL? NEWFUNCTION) CL:T)
   (FINALIZE-SLOT-TYPE-COMPUTATIONS NEWFUNCTION)
   (CL:WHEN (CL:NOT (CL:EQ OLDFUNCTION NULL))
    (RUN-HOOKS *REDEFINE-RELATION-HOOKS*
     (LIST OLDFUNCTION NEWFUNCTION))
    (FREE OLDFUNCTION))
   (CL:RETURN-FROM ATTACH-FUNCTION NEWFUNCTION)))

;;; (DEFUN (LOOKUP-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION (FUNCTIONSYMBOL)
  "Return the function defined for 'functionSymbol', if it exists."
  (CL:SETQ FUNCTIONSYMBOL (SOFT-PERMANENTIFY FUNCTIONSYMBOL))
  (CL:LET* ((FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
     (CL:EQ (PRIMARY-TYPE FUNCTION) SGT-METHODS-STELLA-VECTOR))
    (CL:LET*
     ((RECORD FUNCTION)
      (DEFINITION
       (%STRING-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
         0)))
      (OLDFUNCTION
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
        1))
      (MODULENAME
       (%STRING-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
         2)))
      (CODE
       (CL:IF
        (CL:NOT
         (CL:EQ
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
           3)
          NULL))
        (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
          3))
        NULL))
      (WRAPPERCODE
       (CL:IF (CL:>= (LENGTH RECORD) 5)
        (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY RECORD))
          4))
        NULL)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION MODULENAME))
     (INSERT-AT *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL OLDFUNCTION)
     (CL:LET*
      ((*MODULE* (GET-STELLA-MODULE MODULENAME CL:T))
       (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:SETQ FUNCTION
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE
        (%SYMBOL.SYMBOL-NAME FUNCTIONSYMBOL) STELLA::NULL-STRING
        DEFINITION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTION NULL))
      (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
       (CL:SETF (%METHOD-SLOT.FUNCTION-CODE FUNCTION) CODE))
      (CL:WHEN (CL:NOT (CL:EQ WRAPPERCODE NULL))
       (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
        SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE
        (WRAP-FUNCTION-CODE WRAPPERCODE)
        NULL-FUNCTION-CODE-WRAPPER)))))
   (CL:RETURN-FROM LOOKUP-FUNCTION FUNCTION)))

;;; (DEFUN (LOOKUP-FUNCTION-BY-NAME FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION-BY-NAME (NAME)
  "Return a function with name 'name' visible from the current module.
Scan all visible symbols looking for one that has a function defined for it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((FUNCTION NULL) (SYMBOL NULL))
   (CL:LET* ((MODULE NULL) (ITER-000 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ MODULE (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ()
       (CL:SETQ SYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME MODULE CL:T))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SYMBOL NULL))))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* () (CL:SETQ FUNCTION (LOOKUP-FUNCTION SYMBOL))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FUNCTION NULL)))))
      (CL:WHEN TEST-VALUE-000
       (CL:RETURN-FROM LOOKUP-FUNCTION-BY-NAME FUNCTION)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-FUNCTION-BY-NAME NULL)))

;;; (DEFUN (LOOKUP-FUNCTION-BY-QUALIFIED-NAME METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-FUNCTION-BY-QUALIFIED-NAME (QUALIFIEDNAME)
  "Variant of `lookup-function-by-name' that can specify a starting
module through a `qualifiedName'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((FUNCTIONNAME STELLA::NULL-STRING) (MODULENAME STELLA::NULL-STRING)
    (KIND NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FUNCTIONNAME MODULENAME))
   (CL:MULTIPLE-VALUE-SETQ (FUNCTIONNAME MODULENAME KIND)
    (PARSE-STELLA-NAME QUALIFIEDNAME CL:T))
   (CL:SETQ KIND KIND)
   (CL:LET*
    ((*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
       (GET-STELLA-MODULE MODULENAME CL:T) *MODULE*))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:RETURN-FROM LOOKUP-FUNCTION-BY-QUALIFIED-NAME
     (LOOKUP-FUNCTION-BY-NAME FUNCTIONNAME)))))

;;; (DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION-OR-STELLA-FUNCTION (FUNCTIONSYMBOL)
  (CL:RETURN-FROM LOOKUP-FUNCTION-OR-STELLA-FUNCTION
   (LOOKUP-FUNCTION FUNCTIONSYMBOL)))

;;; (DEFUN (LOOKUP-FUNCTION-HOME-MODULE MODULE) ...)

(CL:DEFUN LOOKUP-FUNCTION-HOME-MODULE (FUNCTIONSYMBOL)
  (CL:SETQ FUNCTIONSYMBOL (SOFT-PERMANENTIFY FUNCTIONSYMBOL))
  (CL:LET* ((FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL)))
   (CL:WHEN (CL:EQ FUNCTION NULL)
    (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE NULL))
   (CL:LET* ((TEST-VALUE-000 (PRIMARY-TYPE FUNCTION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-VECTOR)
      (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE
       (GET-STELLA-MODULE
        (%STRING-WRAPPER.WRAPPER-VALUE
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY FUNCTION)) 2))
        CL:T)))
     ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-METHOD-SLOT)
      (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE
       (HOME-MODULE FUNCTION)))
     (CL:T (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE NULL))))))

;;; (DEFUN UNDEFINE-FUNCTION ...)

(CL:DEFUN UNDEFINE-FUNCTION (NAME)
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:WHEN (CL:NOT (CL:EQ FUNCTION NULL)) (DESTROY-FUNCTION FUNCTION)))
  :VOID)

;;; (DEFUN DESTROY-FUNCTION ...)

(CL:DEFUN DESTROY-FUNCTION (FUNCTION)
  (CL:LET*
   ((FUNCTIONNAME (%METHOD-SLOT.SLOT-NAME FUNCTION))
    (SLOTREF (%METHOD-SLOT.SLOT-SLOTREF FUNCTION))
    (REALFUNCTION (LOOKUP-FUNCTION FUNCTIONNAME)))
   (CL:WHEN (CL:EQ FUNCTION REALFUNCTION)
    (REMOVE-AT *FUNCTION-LOOKUP-TABLE* FUNCTIONNAME))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ SLOTREF NULL))
     (CL:EQ FUNCTION (%SURROGATE.SURROGATE-VALUE SLOTREF)))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE SLOTREF) NULL))
   (DELETED?-SETTER FUNCTION CL:T) (FREE FUNCTION))
  :VOID)

;;; (DEFUN (UNDEFINE-CONFLICTING-DEFINITIONS? BOOLEAN) ...)

(CL:DEFUN UNDEFINE-CONFLICTING-DEFINITIONS? (NEWSLOT)
  (CL:COND
   ((%METHOD-SLOT.METHOD-FUNCTION? NEWSLOT)
    (CL:WHEN (WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? NEWSLOT)
     (CL:WHEN
      (CL:NOT
       (Y-OR-N?
        "Do you want to remove the conflicting method definitions? "))
      (CL:RETURN-FROM UNDEFINE-CONFLICTING-DEFINITIONS? CL:NIL))
     (UNDEFINE-EXTERNAL-SLOTS (%METHOD-SLOT.SLOT-NAME NEWSLOT))
     (UNREGISTER-SLOT-NAME NEWSLOT))
    (CL:COND
     ((CL:NOT
       (CL:EQ (LOOKUP-MACRO (%METHOD-SLOT.SLOT-NAME NEWSLOT)) NULL))
      (CL:IF
       (CL:NOT
        (%BOOLEAN-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWSLOT)
          SYM-METHODS-STELLA-METHOD-MACRO? FALSE-WRAPPER)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM
          (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
          " Function `" (DE-UGLIFY-PARSE-TREE NEWSLOT)
          "' redefines an exisiting macro of the same name." EOL)))
       (CL:WHEN (CL:EQ (%METHOD-SLOT.FUNCTION-CODE NEWSLOT) NULL)
        (CL:SETF (%METHOD-SLOT.FUNCTION-CODE NEWSLOT)
         (%METHOD-SLOT.FUNCTION-CODE
          (LOOKUP-MACRO (%METHOD-SLOT.SLOT-NAME NEWSLOT)))))))
     ((CL:NOT
       (CL:EQ (LOOKUP-FUNCTION (%METHOD-SLOT.SLOT-NAME NEWSLOT)) NULL))
      (CL:WHEN
       (%BOOLEAN-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS NEWSLOT)
         SYM-METHODS-STELLA-METHOD-MACRO? FALSE-WRAPPER))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM
          (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
          " Macro `" (DE-UGLIFY-PARSE-TREE NEWSLOT)
          "' redefines an exisiting function of the same name."
          EOL)))))))
   (CL:T
    (CL:WHEN (WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? NEWSLOT)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      " Removing the preexisting function definition." EOL)
     (UNDEFINE-FUNCTION (%METHOD-SLOT.SLOT-NAME NEWSLOT)))))
  (CL:RETURN-FROM UNDEFINE-CONFLICTING-DEFINITIONS? CL:T))

;;; (DEFUN DEFINE-FUNCTION-OBJECT ...)

(CL:DEFUN DEFINE-FUNCTION-OBJECT (NAME DEFINITION CODE WRAPPERCODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME DEFINITION))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:IF (CL:EQ NAME STELLA::NULL-STRING)
   (CL:LET*
    ((FUNCTION
      (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE STELLA::NULL-STRING
       STELLA::NULL-STRING DEFINITION)))
    (CL:WHEN (CL:NOT (CL:EQ FUNCTION NULL))
     (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
      (CL:SETF (%METHOD-SLOT.FUNCTION-CODE FUNCTION) CODE))
     (CL:WHEN (CL:NOT (CL:EQ WRAPPERCODE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
       SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE
       (WRAP-FUNCTION-CODE WRAPPERCODE) NULL-FUNCTION-CODE-WRAPPER))
     (INSERT-AT *FUNCTION-LOOKUP-TABLE*
      (%METHOD-SLOT.SLOT-NAME FUNCTION) FUNCTION)))
   (CL:LET*
    ((NAMESYMBOL
      (CL:IF
       (CL:EQL
        (CL:LET ((SELF NAME) (POSITION 0))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        #\ )
       (READ-S-EXPRESSION-FROM-STRING NAME)
       (INTERN-SYMBOL-IN-MODULE NAME NULL CL:NIL)))
     (OLDFUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* NAMESYMBOL))
     (RECORD
      (NEW-VECTOR (CL:IF (CL:NOT (CL:EQ WRAPPERCODE NULL)) 5 4))))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ OLDFUNCTION NULL))
      (CL:EQ (PRIMARY-TYPE OLDFUNCTION) SGT-METHODS-STELLA-VECTOR))
     (CL:SETQ OLDFUNCTION NULL))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY RECORD))
      (VALUE (WRAP-STRING DEFINITION)) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY RECORD)) (VALUE OLDFUNCTION)
      (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%VECTOR.THE-ARRAY RECORD))
      (VALUE (WRAP-STRING (%MODULE.MODULE-FULL-NAME *MODULE*)))
      (POSITION 2))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY RECORD))
       (VALUE (WRAP-FUNCTION-CODE CODE)) (POSITION 3))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    (CL:WHEN (CL:NOT (CL:EQ WRAPPERCODE NULL))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY RECORD))
       (VALUE (WRAP-FUNCTION-CODE WRAPPERCODE)) (POSITION 4))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    (INSERT-AT *FUNCTION-LOOKUP-TABLE* NAMESYMBOL RECORD)))
  :VOID)

;;; (DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* ...)

(CL:DEFVAR *GLOBAL-VARIABLE-LOOKUP-TABLE* NULL
  "Lookup table for global variables.")

;;; (DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFUN INTERN-GLOBAL-VARIABLE (GLOBAL)
  (CL:LET*
   ((NAME (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL))
    (OLDGLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:WHEN (CL:NOT (CL:EQ OLDGLOBAL NULL))
    (CL:COND
     ((STRING-EQL?
       (%GLOBAL-VARIABLE.VARIABLE-STRINGIFIED-SOURCE GLOBAL)
       (%GLOBAL-VARIABLE.VARIABLE-STRINGIFIED-SOURCE OLDGLOBAL))
      (FREE GLOBAL) (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE OLDGLOBAL))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Redefining the global variable `"
       (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL) "'" EOL)
      (FREE OLDGLOBAL))))
   (INSERT-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* NAME GLOBAL)
   (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE GLOBAL)))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF GENERALIZED-SYMBOL))
  "Return a global variable with name 'self'."
  (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE
   (LOOKUP *GLOBAL-VARIABLE-LOOKUP-TABLE* SELF)))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF SURROGATE))
  "Return a global variable with name 'self'."
  (CL:LET*
   ((SYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE (%SURROGATE.SYMBOL-NAME SELF)
      (%SURROGATE.HOME-CONTEXT SELF) SYMBOL-SYM)))
   (CL:IF (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE
     (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL))))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF CL:STRING))
  "Return a global variable with name 'self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((SYMBOL (LOOKUP-SYMBOL SELF)))
   (CL:IF (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE
     (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL))))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-BY-NAME GLOBAL-VARIABLE) ...)

(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-BY-NAME (NAME)
  "Return a global variable with `name' visible from the current module.
Scan all visible symbols looking for one that has a global variable defined for it.
NOTE: this is more robust than STRING.lookup-global-variable which will fail if there
is a local symbol with `name' which shadows one higher up that is the name of a global."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((GLOBAL NULL) (SYMBOL NULL))
   (CL:LET* ((MODULE NULL) (ITER-000 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ MODULE (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ()
       (CL:SETQ SYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME MODULE CL:T))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SYMBOL NULL))))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* () (CL:SETQ GLOBAL (LOOKUP-GLOBAL-VARIABLE SYMBOL))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ GLOBAL NULL)))))
      (CL:WHEN TEST-VALUE-000
       (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-BY-NAME GLOBAL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-BY-NAME NULL)))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME GLOBAL-VARIABLE) ...)

(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME (QUALIFIEDNAME)
  "Variant of `lookup-global-variable-by-name' that can specify a starting
module through a `qualifiedName'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((GLOBALNAME STELLA::NULL-STRING) (MODULENAME STELLA::NULL-STRING)
    (KIND NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING GLOBALNAME MODULENAME))
   (CL:MULTIPLE-VALUE-SETQ (GLOBALNAME MODULENAME KIND)
    (PARSE-STELLA-NAME QUALIFIEDNAME CL:T))
   (CL:SETQ KIND KIND)
   (CL:LET*
    ((*MODULE*
      (CL:IF (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
       (GET-STELLA-MODULE MODULENAME CL:T) *MODULE*))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME
     (LOOKUP-GLOBAL-VARIABLE-BY-NAME GLOBALNAME)))))

;;; (DEFUN (GLOBAL-VARIABLE-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN GLOBAL-VARIABLE-TYPE-SPEC (GLOBAL)
  "Return the type spec for the global variable `global'."
  (CL:LET*
   ((TYPE
     (DYNAMIC-SLOT-VALUE (%GLOBAL-VARIABLE.DYNAMIC-SLOTS GLOBAL)
      SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER NULL)))
   (CL:IF (CL:NOT (CL:EQ TYPE NULL))
    (CL:RETURN-FROM GLOBAL-VARIABLE-TYPE-SPEC TYPE)
    (CL:RETURN-FROM GLOBAL-VARIABLE-TYPE-SPEC
     (%GLOBAL-VARIABLE.VARIABLE-TYPE GLOBAL)))))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ...)

(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-TYPE (NAME)
  (CL:LET* ((GLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:IF (CL:NOT (CL:EQ GLOBAL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-TYPE
     (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-TYPE NULL))))

;;; (DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE (TREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((TYPETREE (%%VALUE (%%REST (%%REST TREE))))
    (INITIALVALUETREE (FOURTH TREE)) (OPTIONSTREE (NTH-REST TREE 4))
    (SPECIAL? (CL:EQ (%%VALUE TREE) SYM-METHODS-STELLA-DEFSPECIAL))
    (CONSTANT? (CL:EQ (%%VALUE TREE) SYM-METHODS-STELLA-DEFCONSTANT))
    (NOINITIALVALUE? CL:NIL) (GLOBAL (NEW-GLOBAL-VARIABLE))
    (INTERNEDGLOBAL NULL))
   (CL:WHEN
    (CL:OR (CL:<= (LENGTH TREE) 3)
     (CL:AND
      (MEMBER?
       (GET-QUOTED-TREE
        "((:DOCUMENTATION :PUBLIC? :AUXILIARY?) \"/STELLA\")"
        "/STELLA")
       INITIALVALUETREE)
      (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH OPTIONSTREE)))))
    (CL:SETQ NOINITIALVALUE? CL:T)
    (CL:SETQ INITIALVALUETREE
     (CL:IF SPECIAL? KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL))
    (CL:SETQ OPTIONSTREE (NTH-REST TREE 3)))
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL)
    (PERMANENTIFY (%%VALUE (%%REST TREE))))
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-STRINGIFIED-SOURCE GLOBAL)
    STRINGIFIEDSOURCE)
   (CL:SETQ INTERNEDGLOBAL (INTERN-GLOBAL-VARIABLE GLOBAL))
   (RECORD-VARIABLE-HOME-MODULE INTERNEDGLOBAL)
   (CL:WHEN (CL:AND NOINITIALVALUE? (CL:NOT SPECIAL?))
    (CL:IF CONSTANT?
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Missing value in constant declaration." EOL)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Missing initial value in variable declaration." EOL))))
    (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:WHEN (CL:NOT (CL:EQ GLOBAL INTERNEDGLOBAL))
    (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:SETQ TYPETREE (YIELD-TYPE-SPECIFIER TYPETREE))
   (VALIDATE-TYPE-SPECIFIER TYPETREE NULL CL:T)
   (CL:IF (TYPE? TYPETREE)
    (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-TYPE GLOBAL) TYPETREE)
    (CL:PROGN
     (SET-DYNAMIC-SLOT-VALUE (%GLOBAL-VARIABLE.DYNAMIC-SLOTS GLOBAL)
      SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER TYPETREE NULL)
     (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-TYPE GLOBAL)
      (TYPE-SPEC-TO-BASE-TYPE TYPETREE))))
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-SPECIAL? GLOBAL) SPECIAL?)
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-CONSTANT? GLOBAL) CONSTANT?)
   (CL:WHEN (CL:NOT (CL:EQ OPTIONSTREE NIL))
    (CL:LET* ((OPTIONS (NEW-PROPERTY-LIST)))
     (CL:SETF (%PROPERTY-LIST.THE-PLIST OPTIONS) OPTIONSTREE)
     (CL:LET*
      ((KEY NULL) (VALUE NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST OPTIONS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:LET* ((TEST-VALUE-000 KEY))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-DOCUMENTATION)
          (CL:SETF (%GLOBAL-VARIABLE.DOCUMENTATION GLOBAL)
           (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-PUBLIC?)
          (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-PUBLIC? GLOBAL)
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (COERCE-TO-BOOLEAN VALUE))))
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-AUXILIARY?)
          (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-AUXILIARY? GLOBAL)
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (COERCE-TO-BOOLEAN VALUE))))
         (CL:T
          (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? GLOBAL KEY VALUE))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-WARNING)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
             (%%PRINT-STREAM
              (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
              " Skipping invalid variable option `"
              (DE-UGLIFY-PARSE-TREE KEY) "'" EOL
              "in the definition of variable `"
              (%GLOBAL-VARIABLE.VARIABLE-NAME GLOBAL) "'." EOL)))))))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
     (CL:SETF (%PROPERTY-LIST.THE-PLIST OPTIONS) NULL)))
   (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
    (CL:VALUES GLOBAL INITIALVALUETREE))))

;;; (DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  "Define a stella global variable using a parse tree derived from 'stringifiedSource'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
   (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL) STRINGIFIEDSOURCE)
  :VOID)

;;; (DEFUN DEFINE-GLOBAL-VARIABLE-OBJECT ...)

(CL:DEFUN DEFINE-GLOBAL-VARIABLE-OBJECT (DEFINITION NATIVEOBJECT)
  "Define a STELLA global variable object based on `definition', and initialize
its variable-native-object slot to `nativeObject' (which is primarily needed for C++)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION))
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:LET*
   ((GLOBAL
     (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
      (UNSTRINGIFY-STELLA-SOURCE DEFINITION NULL) DEFINITION)))
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-NATIVE-OBJECT GLOBAL)
    NATIVEOBJECT))
  :VOID)

;;; (DEFUN (RECORD-VARIABLE-HOME-MODULE MODULE) ...)

(CL:DEFUN RECORD-VARIABLE-HOME-MODULE (SELF)
  (CL:LET*
   ((NAME (%GLOBAL-VARIABLE.VARIABLE-NAME SELF))
    (NAMEMODULE (%SYMBOL.HOME-CONTEXT NAME))
    (DEFINITIONMODULE *MODULE*) (HOMEMODULE NAMEMODULE))
   (CL:IF (EXPLICITLY-QUALIFIED-NAME? NAME DEFINITIONMODULE)
    (CL:SETQ HOMEMODULE NAMEMODULE)
    (CL:SETQ HOMEMODULE DEFINITIONMODULE))
   (CL:WHEN (CL:NOT (CL:EQ HOMEMODULE NAMEMODULE))
    (SET-DYNAMIC-SLOT-VALUE (%GLOBAL-VARIABLE.DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-VARIABLE-HOME-MODULE HOMEMODULE NULL))
   (CL:RETURN-FROM RECORD-VARIABLE-HOME-MODULE HOMEMODULE)))

;;; (DEFUN DESTROY-GLOBAL-VARIABLE ...)

(CL:DEFUN DESTROY-GLOBAL-VARIABLE (VARIABLE)
  (CL:LET*
   ((VARIABLENAME (%GLOBAL-VARIABLE.VARIABLE-NAME VARIABLE))
    (REALVARIABLE (LOOKUP-GLOBAL-VARIABLE VARIABLENAME)))
   (CL:WHEN (CL:EQ VARIABLE REALVARIABLE)
    (REMOVE-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* VARIABLENAME))
   (DELETED?-SETTER VARIABLE CL:T) (FREE VARIABLE))
  :VOID)

;;; (DEFUN (GET-GLOBAL-VARIABLE-NATIVE-OBJECT NATIVE-OBJECT-POINTER) ...)

(CL:DEFUN GET-GLOBAL-VARIABLE-NATIVE-OBJECT (VARIABLE)
  "Return the native object of `variable' which can be used to access its runtime value.
In Lisp this is the Lisp symbol which holds the variable value, in C++ this is the address of the variable,
and in Java this is the declared Field object.  For C++ native object addresses are initialized at startup
time, for Lisp and Java native objects will be accessed upon first call and then cached in the slot."
  (CL:LET*
   ((VAROBJ (%GLOBAL-VARIABLE.VARIABLE-NATIVE-OBJECT VARIABLE)))
   (CL:WHEN (CL:NOT (CL:EQ VAROBJ NULL))
    (CL:RETURN-FROM GET-GLOBAL-VARIABLE-NATIVE-OBJECT VAROBJ))
   (CL:LET* ((*MODULE* (HOME-MODULE VARIABLE)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((*MODULE* *ROOT-MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:LET*
      ((LISPSYM
        (%STRING-WRAPPER.WRAPPER-VALUE
         (CL-TRANSLATE-GLOBAL-SYMBOL
          (%GLOBAL-VARIABLE.VARIABLE-NAME VARIABLE)))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LISPSYM))
      (CL:WHEN (CL:= (STRING-SEARCH LISPSYM "::" 0) NULL-INTEGER)
       (CL:SETQ LISPSYM
        (CONCATENATE (LISP-PACKAGE *ROOT-MODULE*) "::" LISPSYM)))
      (CL:SETQ VAROBJ (CL:READ-FROM-STRING LISPSYM)))))
   (CL:SETF (%GLOBAL-VARIABLE.VARIABLE-NATIVE-OBJECT VARIABLE) VAROBJ)
   (CL:RETURN-FROM GET-GLOBAL-VARIABLE-NATIVE-OBJECT VAROBJ)))

;;; (DEFUN (READ-NATIVE-VARIABLE-VALUE OBJECT) ...)

(CL:DEFUN READ-NATIVE-VARIABLE-VALUE (VAR TYPE)
  "Interpreted variable reader which reads a native code variable represented by
`var' of type `type' and returns its value which will be wrapped if necessary.  If `var' is a
special variable, this will access the current dynamic value at the top of the special stack.
This relies upon `type' being completely accurate and bad things will happen if it is not."
  (CL:COND
   ((SUBTYPE-OF? TYPE SGT-METHODS-STELLA-LITERAL)
    (CL:COND
     ((CL:EQ TYPE SGT-METHODS-STELLA-STRING)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-STRING (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-BOOLEAN)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (CL:IF (CL:SYMBOL-VALUE VAR) TRUE-WRAPPER FALSE-WRAPPER)))
     ((CL:EQ TYPE SGT-METHODS-STELLA-INTEGER)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-INTEGER (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-FLOAT)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-FLOAT (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-LONG-INTEGER)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-LONG-INTEGER (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-CHARACTER)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-CHARACTER (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-MUTABLE-STRING)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-MUTABLE-STRING (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-FUNCTION-CODE)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-FUNCTION-CODE (CL:SYMBOL-VALUE VAR))))
     ((CL:EQ TYPE SGT-METHODS-STELLA-METHOD-CODE)
      (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE
       (WRAP-METHOD-CODE (CL:SYMBOL-VALUE VAR))))
     (CL:T)))
   ((SUBTYPE-OF? TYPE SGT-METHODS-STELLA-OBJECT)
    (CL:RETURN-FROM READ-NATIVE-VARIABLE-VALUE (CL:SYMBOL-VALUE VAR))))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "Cannot read variables of type: `" TYPE "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFUN WRITE-NATIVE-VARIABLE-VALUE ...)

(CL:DEFUN WRITE-NATIVE-VARIABLE-VALUE (VAR TYPE VALUE)
  "Interpreted variable writer which sets a native code variable represented by
`var' of type `type' to `value' which will be unwrapped if necessary.  If `var' is a special
variable, this will change the current dynamic value at the top of the special stack.  This
relies upon `type' being completely accurate and bad things will happen if it is not."
  (CL:LET*
   ((VALUETYPE
     (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (PRIMARY-TYPE VALUE) TYPE)))
   (CL:COND
    ((SUBTYPE-OF? TYPE SGT-METHODS-STELLA-LITERAL)
     (CL:WHEN
      (CL:NOT
       (CL:AND (SUBTYPE-OF? VALUETYPE SGT-METHODS-STELLA-WRAPPER)
        (SUBTYPE-OF? (WRAPPED-TYPE-TO-TYPE VALUETYPE) TYPE)))
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "Variable type `" TYPE "' not compatible with value type `"
        (WRAPPED-TYPE-TO-TYPE VALUETYPE) "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
     (CL:COND
      ((CL:EQ TYPE SGT-METHODS-STELLA-STRING)
       (CL:LET* ((VAL (UNWRAP-STRING VALUE)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VAL)) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-BOOLEAN)
       (CL:LET* ((VAL (CL:EQ VALUE TRUE-WRAPPER))) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-INTEGER)
       (CL:LET* ((VAL (UNWRAP-INTEGER VALUE)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM VAL)) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-FLOAT)
       (CL:LET* ((VAL (UNWRAP-FLOAT VALUE)))
        (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VAL)) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-LONG-INTEGER)
       (CL:LET* ((VAL (UNWRAP-LONG-INTEGER VALUE))) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-CHARACTER)
       (CL:LET* ((VAL (UNWRAP-CHARACTER VALUE))) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-MUTABLE-STRING)
       (CL:LET* ((VAL (UNWRAP-MUTABLE-STRING VALUE)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VAL)) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-FUNCTION-CODE)
       (CL:LET* ((VAL (UNWRAP-FUNCTION-CODE VALUE))) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      ((CL:EQ TYPE SGT-METHODS-STELLA-METHOD-CODE)
       (CL:LET* ((VAL (UNWRAP-METHOD-CODE VALUE))) (CL:SET VAR VAL)
        (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
      (CL:T)))
    ((SUBTYPE-OF? TYPE SGT-METHODS-STELLA-OBJECT)
     (CL:WHEN (CL:NOT (SUBTYPE-OF? VALUETYPE TYPE))
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "Variable type `" TYPE "' not compatible with value type `"
        VALUETYPE "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))
     (CL:SET VAR VALUE) (CL:RETURN-FROM WRITE-NATIVE-VARIABLE-VALUE)))
   (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
     "Cannot write variables of type: `" TYPE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
  :VOID)

;;; (DEFUN (READ-GLOBAL-VARIABLE-VALUE OBJECT) ...)

(CL:DEFUN READ-GLOBAL-VARIABLE-VALUE (VARIABLE)
  "Interpreted global `variable' reader which reads and returns its native value
which will be wrapped if necessary.  This will access the value at the top of the special stack."
  (CL:RETURN-FROM READ-GLOBAL-VARIABLE-VALUE
   (READ-NATIVE-VARIABLE-VALUE
    (GET-GLOBAL-VARIABLE-NATIVE-OBJECT VARIABLE)
    (%GLOBAL-VARIABLE.VARIABLE-TYPE VARIABLE))))

;;; (DEFUN WRITE-GLOBAL-VARIABLE-VALUE ...)

(CL:DEFUN WRITE-GLOBAL-VARIABLE-VALUE (VARIABLE VALUE)
  "Interpreted global `variable' writer which sets its native value to `value'
unwrappig it if necessary.  This will change the current value at the top of the special stack."
  (WRITE-NATIVE-VARIABLE-VALUE
   (GET-GLOBAL-VARIABLE-NATIVE-OBJECT VARIABLE)
   (%GLOBAL-VARIABLE.VARIABLE-TYPE VARIABLE) VALUE)
  :VOID)

;;; (DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-PARSE-TREE (TREE)
  (CL:LET*
   ((TYPENAME (%%VALUE (%%REST TREE)))
    (TYPEDEFINITION
     (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST (%%REST TREE)))))
    (TYPE NULL))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE TYPENAME))
     (CL:PROGN (CL:SETQ TYPE (TYPIFY TYPENAME))
      (CL:WHEN
       (CL:AND (CL:NOT (DEFINED-TYPE? TYPE))
        (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE TYPE) NULL)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL " Cannot define type `" (DE-UGLIFY-PARSE-TREE TYPENAME)
          "', since `" (DE-UGLIFY-PARSE-TREE TYPE) "'" EOL
          "   already points to `" (%SURROGATE.SURROGATE-VALUE TYPE)
          "'." EOL)))
       (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL))
      (CL:SETF (%SURROGATE.SURROGATE-VALUE TYPE) TYPEDEFINITION)
      (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE)))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Illegal type name: `" (DE-UGLIFY-PARSE-TREE TYPENAME)
        "'." EOL)))
     (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL)))))

;;; (DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (DEFINE-STELLA-TYPE-FROM-PARSE-TREE
   (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS1 ()
  (CL:PROGN
   (CL:SETQ SGT-METHODS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL
     1))
   (CL:SETQ SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-LIKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIKE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-OUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-INOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INOUT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-DIRECTIONS" NULL
     0))
   (CL:SETQ SYM-METHODS-STELLA-ARGUMENT-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 0))
   (CL:SETQ |SYM-METHODS-STELLA-&REST|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&REST" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL
     0))
   (CL:SETQ |SYM-METHODS-STELLA-&BODY|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&BODY" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-BODY-ARGUMENT?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ KWD-METHODS-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-METHODS-RETURN-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-TYPES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ KWD-METHODS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-METHODS-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
   (CL:SETQ KWD-METHODS-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-NATIVE?" NULL 0))
   (CL:SETQ KWD-METHODS-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRUCTOR?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CONSTRUCTOR?" NULL 0))
   (CL:SETQ KWD-METHODS-GLOBALLY-INLINE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALLY-INLINE?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
   (CL:SETQ KWD-METHODS-INLINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INLINED-FUNCTIONS" NULL 0))
   (CL:SETQ KWD-METHODS-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ KWD-METHODS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ KWD-METHODS-RETURNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURNS" NULL 2))
   (CL:SETQ KWD-METHODS-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
   (CL:SETQ KWD-METHODS-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITS-THROUGH" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INHERITS-THROUGH" NULL 0))
   (CL:SETQ KWD-METHODS-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
   (CL:SETQ KWD-METHODS-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 0))
   (CL:SETQ KWD-METHODS-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMAND?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?" NULL 0))
   (CL:SETQ KWD-METHODS-LISP-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-MACRO?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-LISP-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
   (CL:SETQ KWD-METHODS-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-ARGUMENTS?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL
     0))
   (CL:SETQ KWD-METHODS-C-CALLABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "C-CALLABLE?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-C-CALLABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-C-CALLABLE?" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-HANDLER" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS2 ()
  (CL:PROGN
   (CL:SETQ SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-FUNCTION-OBJECT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-THE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
   (CL:SETQ KWD-METHODS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-DEFINE-INLINE-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-INLINE-METHOD-CODE" NULL
     0))
   (CL:SETQ SYM-METHODS-STELLA-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 0))
   (CL:SETQ KWD-METHODS-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-METHOD-OBJECT" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER-CLASSES" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-EQUIVALENT-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-SLOT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SUPER-CLASSES" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-EQUIVALENT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-LOOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-FIRST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY-TABLE?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-MACRO?" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFSPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSPECIAL" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFCONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONSTANT" NULL 0))
   (CL:SETQ KWD-METHODS-UNBOUND-SPECIAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-HOME-MODULE" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-STARTUP-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-METHODS" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "APPLY"
    "(DEFUN (APPLY OBJECT) ((CODE FUNCTION-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type OBJECT.
Currently limited to at most 10 `arguments'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION APPLY) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-METHOD"
    "(DEFUN (APPLY-METHOD OBJECT) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
OBJECT.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-INTEGER-METHOD"
    "(DEFUN (APPLY-INTEGER-METHOD INTEGER) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
INTEGER.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-INTEGER-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-LONG-INTEGER-METHOD"
    "(DEFUN (APPLY-LONG-INTEGER-METHOD LONG-INTEGER) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
LONG-INTEGER.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-LONG-INTEGER-METHOD)
    NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-STRING-METHOD"
    "(DEFUN (APPLY-STRING-METHOD STRING) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
STRING.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-STRING-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-BOOLEAN-METHOD"
    "(DEFUN (APPLY-BOOLEAN-METHOD BOOLEAN) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
BOOLEAN.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-BOOLEAN-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-FLOAT-METHOD"
    "(DEFUN (APPLY-FLOAT-METHOD FLOAT) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
FLOAT.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-FLOAT-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINED-TYPE?"
    "(DEFUN (DEFINED-TYPE? BOOLEAN) ((TYPE TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION DEFINED-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "REAL-TYPE-SPECIFIER"
    "(DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ((TYPE TYPE)))"
    (CL:FUNCTION REAL-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICAL-TYPE"
    "(DEFUN (CANONICAL-TYPE TYPE) ((TYPE TYPE)))"
    (CL:FUNCTION CANONICAL-TYPE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE TYPE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE SYMBOL)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE OBJECT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE CONS)))"
    (WRAP-METHOD-CODE (CL:FUNCTION YIELD-TYPE-SPECIFIER)) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-PARAMETRIC-TYPE-SPECIFIER"
    "(DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))"
    (CL:FUNCTION YIELD-PARAMETRIC-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-ARRAY-DIMENSIONS-SPEC"
    "(DEFUN (PARSE-ARRAY-DIMENSIONS-SPEC (LIST OF INTEGER-WRAPPER)) ((DIMENSIONSSPEC OBJECT)))"
    (CL:FUNCTION PARSE-ARRAY-DIMENSIONS-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ARRAY-DIMENSIONS-TREE"
    "(DEFUN (YIELD-ARRAY-DIMENSIONS-TREE CONS) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION YIELD-ARRAY-DIMENSIONS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-SPECIFIER?"
    "(DEFUN (ARRAY-TYPE-SPECIFIER? BOOLEAN) ((TYPESPEC TYPE-SPEC)))"
    (CL:FUNCTION ARRAY-TYPE-SPECIFIER?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-RANK"
    "(DEFUN (ARRAY-TYPE-RANK INTEGER) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION ARRAY-TYPE-RANK) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-DIMENSIONS"
    "(DEFUN (ARRAY-TYPE-DIMENSIONS (LIST OF INTEGER-WRAPPER)) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION ARRAY-TYPE-DIMENSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "INDEFINITE-ARRAY-TYPE?"
    "(DEFUN (INDEFINITE-ARRAY-TYPE? BOOLEAN) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION INDEFINITE-ARRAY-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ANCHORED-TYPE-SPECIFIER"
    "(DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))"
    (CL:FUNCTION YIELD-ANCHORED-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-INPUT-PARAMETERS"
    "(DEFUN INCORPORATE-INPUT-PARAMETERS ((METHOD METHOD-SLOT) (PARAMETERS CONS)))"
    (CL:FUNCTION INCORPORATE-INPUT-PARAMETERS) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-FIRST-INPUT-PARAMETER"
    "(DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION INCORPORATE-FIRST-INPUT-PARAMETER) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-METHOD-SLOT"
    "(DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ((INPUTNAME SYMBOL) (RETURNTYPES CONS) (FUNCTION? BOOLEAN) (INPUTPARAMETERS CONS) (OPTIONS KEYWORD-KEY-VALUE-LIST)) :DOCUMENTATION \"Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'.\")"
    (CL:FUNCTION DEFINE-STELLA-METHOD-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "ATTACH-METHOD-SLOT-TO-OWNER"
    "(DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ((NEWMETHOD METHOD-SLOT)))"
    (CL:FUNCTION ATTACH-METHOD-SLOT-TO-OWNER) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STRING-CONSTANT-TREE"
    "(DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ((STRING STRING)))"
    (CL:FUNCTION YIELD-STRING-CONSTANT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-FUNCTION-OBJECT-EAGERLY?"
    "(DEFUN (DEFINE-FUNCTION-OBJECT-EAGERLY? BOOLEAN) ((FUNCTION METHOD-SLOT)))"
    (CL:FUNCTION DEFINE-FUNCTION-OBJECT-EAGERLY?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-DEFINE-STELLA-METHOD-OBJECT"
    "(DEFUN (YIELD-DEFINE-STELLA-METHOD-OBJECT CONS) ((METHOD METHOD-SLOT) (CODEMETHOD METHOD-SLOT) (WRAPPERMETHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-DEFINE-STELLA-METHOD-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CLASS-PARAMETER-TYPES"
    "(DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ((CLASS CLASS)))"
    (CL:FUNCTION YIELD-CLASS-PARAMETER-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMISTIC-SUBTYPE-OF?"
    "(DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)))"
    (CL:FUNCTION OPTIMISTIC-SUBTYPE-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-OF-PARAMETER-MISMATCH"
    "(DEFUN WARN-OF-PARAMETER-MISMATCH ((SELF PARAMETRIC-TYPE-SPECIFIER) (MESSAGE STRING)))"
    (CL:FUNCTION WARN-OF-PARAMETER-MISMATCH) NULL)
   (DEFINE-FUNCTION-OBJECT "VALIDATE-TYPE-SPECIFIER"
    "(DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ((SELF TYPE-SPEC) (ANCHORCLASS CLASS) (SKIPANCHOREDTYPE? BOOLEAN)))"
    (CL:FUNCTION VALIDATE-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "SYNTHESIZE-METHOD-BODY"
    "(DEFUN (SYNTHESIZE-METHOD-BODY CONS) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION SYNTHESIZE-METHOD-BODY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION UNFINALIZE-LOCAL-SLOT)) NULL)
   (DEFINE-FUNCTION-OBJECT "UNDEFINE-EXTERNAL-SLOTS"
    "(DEFUN UNDEFINE-EXTERNAL-SLOTS ((NAME SYMBOL)))"
    (CL:FUNCTION UNDEFINE-EXTERNAL-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-EXTERNAL-SLOT"
    "(DEFUN DESTROY-EXTERNAL-SLOT ((SELF SLOT)))"
    (CL:FUNCTION DESTROY-EXTERNAL-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-METHOD"
    "(DEFUN DESTROY-METHOD ((SELF METHOD-SLOT)))"
    (CL:FUNCTION DESTROY-METHOD) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-ARGUMENT-COUNT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF STORAGE-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-ARGUMENT-COUNT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF METHOD-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-ARGUMENT-COUNT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF TABLE)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-ARGUMENT-COUNT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ((SELF STORAGE-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-VARIABLE-ARGUMENTS?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ((SELF STORAGE-SLOT)))"
    (WRAP-METHOD-CODE (CL:FUNCTION METHOD-BODY-ARGUMENT?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF STORAGE-SLOT)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ARITY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF METHOD-SLOT)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ARITY)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF TABLE)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ARITY)) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-SPEC-TO-BASE-TYPE"
    "(DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ((SELF TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION TYPE-SPEC-TO-BASE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "BASE-TYPE-TO-TYPE-SPEC"
    "(DEFUN (BASE-TYPE-TO-TYPE-SPEC TYPE-SPEC) ((SELF TYPE-SPEC)))"
    (CL:FUNCTION BASE-TYPE-TO-TYPE-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-SPEC-TO-CLASS"
    "(DEFUN (TYPE-SPEC-TO-CLASS CLASS) ((SELF TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION TYPE-SPEC-TO-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPATIBLE-PARAMETER-TYPES?"
    "(DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION COMPATIBLE-PARAMETER-TYPES?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUB-TYPE-SPEC-OF?"
    "(DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)))"
    (CL:FUNCTION SUB-TYPE-SPEC-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "VOID?"
    "(DEFUN (VOID? BOOLEAN) ((TYPE TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION VOID?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-PARAMETER-TYPE"
    "(DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ((SELF TYPE-SPEC) (PARAMETER SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION EXTRACT-PARAMETER-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-ANCHORED-TYPE-SPEC"
    "(DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ((OWNERTYPE TYPE-SPEC) (RELTYPE ANCHORED-TYPE-SPECIFIER)))"
    (CL:FUNCTION COMPUTE-ANCHORED-TYPE-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATIVE-TYPE-SPEC"
    "(DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ((RELATIVETYPE TYPE-SPEC) (OWNERTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-RELATIVE-TYPE-SPEC) NULL))
  :VOID)

(CL:DEFUN STARTUP-METHODS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-METHODS1)
    (HELP-STARTUP-METHODS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *FUNCTION-LOOKUP-TABLE* (NEW-HASH-TABLE))
    (CL:SETQ *GLOBAL-VARIABLE-LOOKUP-TABLE* (NEW-HASH-TABLE)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-METHODS3)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
     (WRAP-METHOD-CODE (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
     (WRAP-METHOD-CODE (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
     (WRAP-METHOD-CODE (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC)) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-TYPE-SPEC-TREE"
     "(DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ((SELF TYPE-SPEC)))"
     (CL:FUNCTION YIELD-TYPE-SPEC-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "ATTACH-FUNCTION"
     "(DEFUN (ATTACH-FUNCTION METHOD-SLOT) ((NEWFUNCTION METHOD-SLOT)))"
     (CL:FUNCTION ATTACH-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION"
     "(DEFUN (LOOKUP-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)) :DOCUMENTATION \"Return the function defined for 'functionSymbol', if it exists.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-BY-NAME"
     "(DEFUN (LOOKUP-FUNCTION-BY-NAME FUNCTION) ((NAME STRING)) :DOCUMENTATION \"Return a function with name 'name' visible from the current module.
Scan all visible symbols looking for one that has a function defined for it.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-FUNCTION-BY-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-BY-QUALIFIED-NAME"
     "(DEFUN (LOOKUP-FUNCTION-BY-QUALIFIED-NAME METHOD-SLOT) ((QUALIFIEDNAME STRING)) :DOCUMENTATION \"Variant of `lookup-function-by-name' that can specify a starting
module through a `qualifiedName'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-FUNCTION-BY-QUALIFIED-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-OR-STELLA-FUNCTION"
     "(DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)) :GLOBALLY-INLINE? TRUE (RETURN (LOOKUP-FUNCTION FUNCTIONSYMBOL)))"
     (CL:FUNCTION LOOKUP-FUNCTION-OR-STELLA-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-HOME-MODULE"
     "(DEFUN (LOOKUP-FUNCTION-HOME-MODULE MODULE) ((FUNCTIONSYMBOL SYMBOL)))"
     (CL:FUNCTION LOOKUP-FUNCTION-HOME-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNDEFINE-FUNCTION"
     "(DEFUN UNDEFINE-FUNCTION ((NAME SYMBOL)))"
     (CL:FUNCTION UNDEFINE-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-FUNCTION"
     "(DEFUN DESTROY-FUNCTION ((FUNCTION METHOD-SLOT)))"
     (CL:FUNCTION DESTROY-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "UNDEFINE-CONFLICTING-DEFINITIONS?"
     "(DEFUN (UNDEFINE-CONFLICTING-DEFINITIONS? BOOLEAN) ((NEWSLOT METHOD-SLOT)))"
     (CL:FUNCTION UNDEFINE-CONFLICTING-DEFINITIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-FUNCTION-OBJECT"
     "(DEFUN DEFINE-FUNCTION-OBJECT ((NAME STRING) (DEFINITION STRING) (CODE FUNCTION-CODE) (WRAPPERCODE FUNCTION-CODE)))"
     (CL:FUNCTION DEFINE-FUNCTION-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "INTERN-GLOBAL-VARIABLE"
     "(DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((GLOBAL GLOBAL-VARIABLE)))"
     (CL:FUNCTION INTERN-GLOBAL-VARIABLE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF GENERALIZED-SYMBOL)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (WRAP-METHOD-CODE (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF SURROGATE)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (WRAP-METHOD-CODE (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (WRAP-METHOD-CODE (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE)) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-GLOBAL-VARIABLE-BY-NAME"
     "(DEFUN (LOOKUP-GLOBAL-VARIABLE-BY-NAME GLOBAL-VARIABLE) ((NAME STRING)) :DOCUMENTATION \"Return a global variable with `name' visible from the current module.
Scan all visible symbols looking for one that has a global variable defined for it.
NOTE: this is more robust than STRING.lookup-global-variable which will fail if there
is a local symbol with `name' which shadows one higher up that is the name of a global.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-BY-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME"
     "(DEFUN (LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME GLOBAL-VARIABLE) ((QUALIFIEDNAME STRING)) :DOCUMENTATION \"Variant of `lookup-global-variable-by-name' that can specify a starting
module through a `qualifiedName'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-BY-QUALIFIED-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "GLOBAL-VARIABLE-TYPE-SPEC"
     "(DEFUN (GLOBAL-VARIABLE-TYPE-SPEC TYPE-SPEC) ((GLOBAL GLOBAL-VARIABLE)) :DOCUMENTATION \"Return the type spec for the global variable `global'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION GLOBAL-VARIABLE-TYPE-SPEC) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-GLOBAL-VARIABLE-TYPE"
     "(DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ((NAME SYMBOL)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ((TREE CONS) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE"
     "(DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)) :DOCUMENTATION \"Define a stella global variable using a parse tree derived from 'stringifiedSource'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION
      DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE)
     NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-GLOBAL-VARIABLE-OBJECT"
     "(DEFUN DEFINE-GLOBAL-VARIABLE-OBJECT ((DEFINITION STRING) (NATIVEOBJECT NATIVE-OBJECT-POINTER)) :DOCUMENTATION \"Define a STELLA global variable object based on `definition', and initialize
its variable-native-object slot to `nativeObject' (which is primarily needed for C++).\" :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-GLOBAL-VARIABLE-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-VARIABLE-HOME-MODULE"
     "(DEFUN (RECORD-VARIABLE-HOME-MODULE MODULE) ((SELF GLOBAL-VARIABLE)))"
     (CL:FUNCTION RECORD-VARIABLE-HOME-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-GLOBAL-VARIABLE"
     "(DEFUN DESTROY-GLOBAL-VARIABLE ((VARIABLE GLOBAL-VARIABLE)))"
     (CL:FUNCTION DESTROY-GLOBAL-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-GLOBAL-VARIABLE-NATIVE-OBJECT"
     "(DEFUN (GET-GLOBAL-VARIABLE-NATIVE-OBJECT NATIVE-OBJECT-POINTER) ((VARIABLE GLOBAL-VARIABLE)) :DOCUMENTATION \"Return the native object of `variable' which can be used to access its runtime value.
In Lisp this is the Lisp symbol which holds the variable value, in C++ this is the address of the variable,
and in Java this is the declared Field object.  For C++ native object addresses are initialized at startup
time, for Lisp and Java native objects will be accessed upon first call and then cached in the slot.\" :PUBLIC? TRUE)"
     (CL:FUNCTION GET-GLOBAL-VARIABLE-NATIVE-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-NATIVE-VARIABLE-VALUE"
     "(DEFUN (READ-NATIVE-VARIABLE-VALUE OBJECT) ((VAR NATIVE-OBJECT-POINTER) (TYPE TYPE)) :DOCUMENTATION \"Interpreted variable reader which reads a native code variable represented by
`var' of type `type' and returns its value which will be wrapped if necessary.  If `var' is a
special variable, this will access the current dynamic value at the top of the special stack.
This relies upon `type' being completely accurate and bad things will happen if it is not.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-NATIVE-VARIABLE-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "WRITE-NATIVE-VARIABLE-VALUE"
     "(DEFUN WRITE-NATIVE-VARIABLE-VALUE ((VAR NATIVE-OBJECT-POINTER) (TYPE TYPE) (VALUE OBJECT)) :DOCUMENTATION \"Interpreted variable writer which sets a native code variable represented by
`var' of type `type' to `value' which will be unwrapped if necessary.  If `var' is a special
variable, this will change the current dynamic value at the top of the special stack.  This
relies upon `type' being completely accurate and bad things will happen if it is not.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WRITE-NATIVE-VARIABLE-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-GLOBAL-VARIABLE-VALUE"
     "(DEFUN (READ-GLOBAL-VARIABLE-VALUE OBJECT) ((VARIABLE GLOBAL-VARIABLE)) :DOCUMENTATION \"Interpreted global `variable' reader which reads and returns its native value
which will be wrapped if necessary.  This will access the value at the top of the special stack.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-GLOBAL-VARIABLE-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "WRITE-GLOBAL-VARIABLE-VALUE"
     "(DEFUN WRITE-GLOBAL-VARIABLE-VALUE ((VARIABLE GLOBAL-VARIABLE) (VALUE OBJECT)) :DOCUMENTATION \"Interpreted global `variable' writer which sets its native value to `value'
unwrappig it if necessary.  This will change the current value at the top of the special stack.\" :PUBLIC? TRUE)"
     (CL:FUNCTION WRITE-GLOBAL-VARIABLE-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-TYPE-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE"
     "(DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-METHODS"
     "(DEFUN STARTUP-METHODS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-METHODS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-METHODS-STELLA-STARTUP-METHODS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupMethods") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* INTEGER 4000 :DOCUMENTATION \"Maximum size for a string constant in the target language.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *FUNCTION-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL STANDARD-OBJECT) (NEW (HASH-TABLE OF SYMBOL FUNCTION)) :DOCUMENTATION \"Lookup table for functions.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE) (NEW (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE)) :DOCUMENTATION \"Lookup table for global variables.\" :PUBLIC? TRUE)"
     NULL)))
  :VOID)
