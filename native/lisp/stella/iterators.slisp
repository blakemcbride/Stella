;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; iterators.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-ITERATORS-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR SGT-ITERATORS-STELLA-TABLE NULL)
(CL:DEFVAR SGT-ITERATORS-STELLA-CROSS-PRODUCT-ITERATOR NULL)
(CL:DEFVAR SYM-ITERATORS-STELLA-DOMAINS NULL)
(CL:DEFVAR SYM-ITERATORS-STELLA-CURSORS NULL)
(CL:DEFVAR SYM-ITERATORS-STELLA-STARTUP-ITERATORS NULL)
(CL:DEFVAR SYM-ITERATORS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* *SURROGATE-ARRAY*
  *GLOBAL-VARIABLE-LOOKUP-TABLE* FALSE-WRAPPER *SYMBOL-ARRAY*
  NULL-INTEGER NIL))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (LIKE SELF)) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-ITERATOR))
  "Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a 'foreach' statement)."
  (CL:RETURN-FROM ALLOCATE-ITERATOR SELF))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF ABSTRACT-ITERATOR))
  "Iterate over 'self', and count how many
items there are.  Bad idea if 'self' iterates over an infinite
collection, since in that case it will run forever.'"
  (CL:LET* ((COUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT))
   (CL:LET* ((I SELF))
    (CL:LOOP WHILE (NEXT? I) DO (CL:SETQ COUNT (CL:1+ COUNT))))
   (CL:RETURN-FROM LENGTH COUNT)))

;;; (DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD POP ((SELF ITERATOR))
  "Return the first item of the sequence represented by 'self',
or NULL if it is empty.  Destructively uses up the first iteration element."
  (CL:IF (NEXT? SELF) (CL:RETURN-FROM POP (%ITERATOR.VALUE SELF))
   (CL:RETURN-FROM POP NULL)))

;;; (DEFMETHOD (ADVANCE (LIKE SELF)) ...)

(CL:DEFMETHOD ADVANCE ((SELF ITERATOR) N)
  "Return 'self' after skipping over the first
'n' elements in the (remainder of the) iteration."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LOOP WHILE (CL:AND (CL:> N 0) (NEXT? SELF)) DO
   (CL:SETQ N (CL:1- N)))
  (CL:RETURN-FROM ADVANCE SELF))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF ITERATOR))
  "Return TRUE if the sequence represented by 'self'
has no elements.  Side-effect free."
  (CL:ERROR (NEW-STELLA-EXCEPTION "Missing 'empty?' method")))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF ITERATOR) VALUE)
  "Iterate over values of 'self', returning TRUE
if one of them is 'eql' to 'value."
  (CL:IF (CL:OR (CL:EQ VALUE NULL) (STANDARD-OBJECT? VALUE))
   (CL:LET* ((M NULL) (ITER-000 SELF))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ M (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (CL:EQ M VALUE) (CL:RETURN-FROM MEMBER? CL:T))))
   (CL:LET* ((M NULL) (ITER-001 SELF))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ M (%ITERATOR.VALUE ITER-001))
     (CL:WHEN (EQL? M VALUE) (CL:RETURN-FROM MEMBER? CL:T)))))
  (CL:RETURN-FROM MEMBER? CL:NIL))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:LET*
   ((CURSOR (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)))
   (CL:WHEN (CL:EQ CURSOR NIL) (CL:RETURN-FROM NEXT? CL:NIL))
   (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.VALUE SELF) (%%VALUE CURSOR))
   (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)
    (%%REST CURSOR))
   (CL:RETURN-FROM NEXT? CL:T)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:RETURN-FROM EMPTY?
   (CL:EQ (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF) NIL)))

;;; (DEFUN (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-DESTRUCTIVE-LIST-ITERATOR? (SELF)
  (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.THE-CONS-LIST SELF) NIL)
  (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF) NIL)
  (CL:RETURN-FROM TERMINATE-DESTRUCTIVE-LIST-ITERATOR? CL:T))

;;; (DEFMETHOD INSERT ...)

(CL:DEFMETHOD INSERT ((SELF DESTRUCTIVE-LIST-ITERATOR) VALUE)
  "Add 'value' to the front of the list 'self'."
  (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR SELF)
   (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.THE-CONS-LIST SELF)
    (CONS VALUE (%DESTRUCTIVE-LIST-ITERATOR.THE-CONS-LIST SELF))))
  :VOID)

;;; (DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(%%DEFCONSMETHOD ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ((SELF CL:CONS))
  (CL:LET* ((ITERATOR (NEW-DESTRUCTIVE-LIST-ITERATOR)))
   (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.THE-CONS-LIST ITERATOR) SELF)
   (CL:SETF (%DESTRUCTIVE-LIST-ITERATOR.LIST-ITERATOR-CURSOR ITERATOR)
    SELF)
   (CL:RETURN-FROM ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ITERATOR)))

;;; (DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ((SELF LIST))
  (CL:LET*
   ((ITERATOR
     (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (%LIST.THE-CONS-LIST SELF))))
   (CL:SETF (%LIST.THE-CONS-LIST SELF) NIL) (FREE SELF)
   (CL:RETURN-FROM ALLOCATE-DESTRUCTIVE-LIST-ITERATOR ITERATOR)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF ALL-PURPOSE-ITERATOR))
  "Apply the stored 'next?' function to 'self'."
  (CL:RETURN-FROM NEXT?
   (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE SELF) SELF)))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN
   (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-EMPTY-CODE SELF) NULL)
   (CL:ERROR (NEW-STELLA-EXCEPTION "Missing 'empty?' method")))
  (CL:RETURN-FROM EMPTY?
   (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-EMPTY-CODE SELF))))

;;; (DEFMETHOD (TERMINATE-ALL-PURPOSE-ITERATOR? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-ALL-PURPOSE-ITERATOR? ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN
   (CL:NOT
    (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF) NULL))
   (FREE (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF)))
  (CL:RETURN-FROM TERMINATE-ALL-PURPOSE-ITERATOR? CL:T))

;;; (DEFUN (FILTERED-NESTED-ITERATOR-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-NESTED-ITERATOR-NEXT? (SELF)
  (CL:LET*
   ((NESTEDITERATOR
     (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF))
    (VALUE NULL))
   (CL:LOOP WHILE (NEXT? NESTEDITERATOR) DO
    (CL:SETQ VALUE (%ITERATOR.VALUE NESTEDITERATOR))
    (CL:WHEN
     (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
      VALUE SELF)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) VALUE)
     (CL:RETURN-FROM FILTERED-NESTED-ITERATOR-NEXT? CL:T)))
   (CL:RETURN-FROM FILTERED-NESTED-ITERATOR-NEXT? CL:NIL)))

;;; (DEFUN (ITERATOR-CONS-LIST-NEXT? BOOLEAN) ...)

(CL:DEFUN ITERATOR-CONS-LIST-NEXT? (SELF)
  (CL:LET* ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
   (CL:WHEN (CL:EQ CURSOR NIL)
    (CL:RETURN-FROM ITERATOR-CONS-LIST-NEXT? CL:NIL))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) (%%VALUE CURSOR))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
    (%%REST CURSOR))
   (CL:RETURN-FROM ITERATOR-CONS-LIST-NEXT? CL:T)))

;;; (DEFUN (ITERATOR-CONS-LIST-EMPTY? BOOLEAN) ...)

(CL:DEFUN ITERATOR-CONS-LIST-EMPTY? (SELF)
  (CL:RETURN-FROM ITERATOR-CONS-LIST-EMPTY?
   (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF) NIL)))

;;; (DEFUN (FILTERED-CONCATENATED-ITERATOR-NEXT? BOOLEAN) ...)

(CL:DEFUN FILTERED-CONCATENATED-ITERATOR-NEXT? (SELF)
  (CL:LET*
   ((NESTEDITERATOR
     (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF))
    (FILTERCODE (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF))
    (VALUE NULL))
   (CL:LOOP
    (CL:LOOP WHILE (NEXT? NESTEDITERATOR) DO
     (CL:SETQ VALUE (%ITERATOR.VALUE NESTEDITERATOR))
     (CL:WHEN
      (CL:IF (CL:NOT (CL:EQ FILTERCODE NULL))
       (CL:FUNCALL FILTERCODE VALUE SELF) CL:T)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) VALUE)
      (CL:RETURN-FROM FILTERED-CONCATENATED-ITERATOR-NEXT? CL:T)))
    (CL:SETQ NESTEDITERATOR
     (%%VALUE (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     (%%REST (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
    (CL:IF (CL:EQ NESTEDITERATOR NULL) (CL:RETURN)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF)
      NESTEDITERATOR)))
   (CL:RETURN-FROM FILTERED-CONCATENATED-ITERATOR-NEXT? CL:NIL)))

;;; (DEFMETHOD (CONCATENATE ALL-PURPOSE-ITERATOR) ...)

(CL:DEFMETHOD CONCATENATE ((ITERATOR1 ITERATOR) ITERATOR2 CL:&REST OTHERITERATORS)
  "Return an iterator that first generates all values of
`iterator1', then those of `iterator2', and then those of all `otherIterators'.
The generated values can be filtered by supplying a filter function to the
resulting iterator."
  (CL:LET* ((ITERATORLIST (CONS ITERATOR2 NIL)))
   (CL:LET*
    ((ITERATOR NULL) (ITER-000 OTHERITERATORS) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ITERATOR (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITERATOR NIL))
       (CL:IF (CL:EQ ITERATORLIST NIL)
        (CL:SETQ ITERATORLIST COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ITERATORLIST COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITERATOR NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET* ((SELF-000 (NEW-ALL-PURPOSE-ITERATOR)))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF-000)
     ITERATOR1)
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF-000)
     ITERATORLIST)
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE SELF-000)
     (CL:FUNCTION FILTERED-CONCATENATED-ITERATOR-NEXT?))
    (CL:LET* ((VALUE-000 SELF-000))
     (CL:RETURN-FROM CONCATENATE VALUE-000)))))

;;; (DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:SETF (%INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
   (%INTEGER-INTERVAL-ITERATOR.LOWER-BOUND SELF))
  (CL:SETF (%INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF) CL:T)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:IF (%INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF)
   (CL:SETF (%INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
   (CL:SETF (%INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
    (CL:1+ (%INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF))))
  (CL:LET* ((UPPERBOUND (%INTEGER-INTERVAL-ITERATOR.UPPER-BOUND SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UPPERBOUND))
   (CL:SETF (%INTEGER-INTERVAL-ITERATOR.VALUE SELF)
    (%INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF))
   (CL:RETURN-FROM NEXT?
    (CL:OR (CL:= UPPERBOUND NULL-INTEGER)
     (CL:<= (%INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
      UPPERBOUND)))))

;;; (DEFUN (INTERVAL INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFUN INTERVAL (LOWERBOUND UPPERBOUND)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LOWERBOUND UPPERBOUND))
  #+MCL
  (CL:CHECK-TYPE LOWERBOUND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UPPERBOUND CL:FIXNUM)
  (CL:RETURN-FROM INTERVAL
   (NEW-INTEGER-INTERVAL-ITERATOR LOWERBOUND UPPERBOUND)))

;;; (DEFMETHOD (REVERSE REVERSE-INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFMETHOD REVERSE ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM REVERSE
   (REVERSE-INTERVAL (%INTEGER-INTERVAL-ITERATOR.LOWER-BOUND SELF)
    (%INTEGER-INTERVAL-ITERATOR.UPPER-BOUND SELF))))

;;; (DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR (SELF)
  (CL:SETF (%REVERSE-INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
   (%REVERSE-INTEGER-INTERVAL-ITERATOR.UPPER-BOUND SELF))
  (CL:SETF (%REVERSE-INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF)
   CL:T)
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR))
  (CL:IF (%REVERSE-INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF)
   (CL:SETF (%REVERSE-INTEGER-INTERVAL-ITERATOR.FIRST-ITERATION? SELF)
    CL:NIL)
   (CL:SETF (%REVERSE-INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
    (CL:1- (%REVERSE-INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF))))
  (CL:LET*
   ((LOWERBOUND (%REVERSE-INTEGER-INTERVAL-ITERATOR.LOWER-BOUND SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LOWERBOUND))
   (CL:SETF (%REVERSE-INTEGER-INTERVAL-ITERATOR.VALUE SELF)
    (%REVERSE-INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF))
   (CL:RETURN-FROM NEXT?
    (CL:OR (CL:= LOWERBOUND NULL-INTEGER)
     (CL:>= (%REVERSE-INTEGER-INTERVAL-ITERATOR.INTERVAL-CURSOR SELF)
      LOWERBOUND)))))

;;; (DEFUN (REVERSE-INTERVAL REVERSE-INTEGER-INTERVAL-ITERATOR) ...)

(CL:DEFUN REVERSE-INTERVAL (LOWERBOUND UPPERBOUND)
  "Create a reverse interval object."
  (CL:DECLARE (CL:TYPE CL:FIXNUM LOWERBOUND UPPERBOUND))
  #+MCL
  (CL:CHECK-TYPE LOWERBOUND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UPPERBOUND CL:FIXNUM)
  (CL:RETURN-FROM REVERSE-INTERVAL
   (NEW-REVERSE-INTEGER-INTERVAL-ITERATOR LOWERBOUND UPPERBOUND)))

;;; (DEFMETHOD (ALLOCATE-ITERATOR STRING-ITERATOR) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((SELF-000 (NEW-STRING-ITERATOR)))
   (CL:SETF (%STRING-ITERATOR.THE-STRING SELF-000) SELF)
   (CL:LET* ((ITERATOR SELF-000))
    (CL:SETF (%STRING-ITERATOR.CURSOR ITERATOR) 0)
    (CL:SETF (%STRING-ITERATOR.END ITERATOR)
     (CL:THE CL:FIXNUM (CL:LENGTH SELF)))
    (CL:RETURN-FROM ALLOCATE-ITERATOR ITERATOR))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF STRING-ITERATOR))
  (CL:LET* ((POS (%STRING-ITERATOR.CURSOR SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POS))
   (CL:WHEN (CL:< POS (%STRING-ITERATOR.END SELF))
    (CL:SETF (%STRING-ITERATOR.VALUE SELF)
     (CL:LET ((SELF (%STRING-ITERATOR.THE-STRING SELF)) (POSITION POS))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))))
    (CL:SETF (%STRING-ITERATOR.CURSOR SELF) (CL:1+ POS))
    (CL:RETURN-FROM NEXT? CL:T))
   (CL:RETURN-FROM NEXT? CL:NIL)))

;;; (DEFUN (ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-ALL-META-OBJECTS-ITERATOR (ARRAYSIZE NEXTCODE MODULE LOCAL?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAYSIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAYSIZE CL:FIXNUM)
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)) (MODULESLIST NIL))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER ITERATOR) 0)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER ITERATOR)
    ARRAYSIZE)
   (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
    (CL:IF LOCAL? (CL:SETQ MODULESLIST (CONS MODULE MODULESLIST))
     (CL:LET*
      ((MOD NULL) (ITER-000 (VISIBLE-MODULES MODULE))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ MOD (%%VALUE ITER-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS MOD NIL))
         (CL:IF (CL:EQ MODULESLIST NIL)
          (CL:SETQ MODULESLIST COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST MODULESLIST COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS MOD NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    MODULESLIST)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    NEXTCODE)
   (CL:RETURN-FROM ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR)))

;;; (DEFUN (SELECTED-META-OBJECT? BOOLEAN) ...)

(CL:DEFUN SELECTED-META-OBJECT? (SELF OBJECTMODULE)
  (CL:LET* ((MODULES (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
   (CL:IF (CL:EQ MODULES NIL)
    (CL:RETURN-FROM SELECTED-META-OBJECT? CL:T)
    (CL:IF (CL:EQ (%%REST MODULES) NIL)
     (CL:IF (CL:EQ OBJECTMODULE (%%VALUE MODULES))
      (CL:RETURN-FROM SELECTED-META-OBJECT? CL:T)
      (CL:RETURN-FROM SELECTED-META-OBJECT? CL:NIL))
     (CL:RETURN-FROM SELECTED-META-OBJECT?
      (MEMB? MODULES OBJECTMODULE))))))

;;; (DEFUN (ALL-SYMBOLS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SYMBOLS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SYMBOL NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SYMBOL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SYMBOL-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SYMBOL NULL))
      (SELECTED-META-OBJECT? SELF (%SYMBOL.HOME-CONTEXT SYMBOL)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SYMBOL)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
      (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-SYMBOLS-NEXT? CL:T))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-SYMBOLS-NEXT? CL:NIL)))

;;; (DEFUN (ALL-SYMBOLS (ITERATOR OF SYMBOL)) ...)

(CL:DEFUN ALL-SYMBOLS (MODULE LOCAL?)
  "Iterate over all symbols visible from 'module'.
If 'local?', return only symbols interned in 'module'.
If 'module' is null, return all symbols interned everywhere."
  (CL:RETURN-FROM ALL-SYMBOLS
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+ (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-SYMBOLS-NEXT?) MODULE LOCAL?)))

;;; (DEFUN (FILTER-PUBLIC-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PUBLIC-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-PUBLIC-SLOT? (%SLOT.SLOT-PUBLIC? SELF)))

;;; (DEFUN (FILTER-PRIVATE-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PRIVATE-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-PRIVATE-SLOT?
   (CL:NOT (%SLOT.SLOT-PUBLIC? SELF))))

;;; (DEFUN (FILTER-METHOD-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-METHOD-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-METHOD-SLOT? (METHOD-SLOT? SELF)))

;;; (DEFUN (FILTER-PUBLIC-METHOD-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-PUBLIC-METHOD-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-PUBLIC-METHOD-SLOT?
   (CL:AND (%SLOT.SLOT-PUBLIC? SELF) (METHOD-SLOT? SELF))))

;;; (DEFUN (FILTER-NON-EXTERNAL-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-EXTERNAL-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-NON-EXTERNAL-SLOT?
   (CL:NOT (%SLOT.SLOT-EXTERNAL? SELF))))

;;; (DEFUN (FILTER-NON-PARAMETER-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-PARAMETER-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-NON-PARAMETER-SLOT?
   (CL:NOT
    (MEMBER?
     (CLASS-PARAMETERS
      (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER SELF)))
     (%SLOT.SLOT-NAME SELF)))))

;;; (DEFUN (FILTER-NON-AUXILIARY-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-NON-AUXILIARY-SLOT? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-NON-AUXILIARY-SLOT?
   (CL:NOT
    (%BOOLEAN-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
      SYM-ITERATORS-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER)))))

;;; (DEFUN (FILTER-SLOT? BOOLEAN) ...)

(CL:DEFUN FILTER-SLOT? (SELF ITERATOR)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((FILTER NULL)
     (ITER-000 (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FILTER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:FUNCALL (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FILTER) SELF
        ITERATOR))
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((VALUE-000 ALWAYS?-000))
    (CL:RETURN-FROM FILTER-SLOT? VALUE-000))))

;;; (DEFUN (ALL-FUNCTIONS-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-FUNCTIONS-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SYMBOL NULL) (FUNCTION NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SYMBOL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SYMBOL-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SYMBOL NULL))
      (SELECTED-META-OBJECT? SELF
       (LOOKUP-FUNCTION-HOME-MODULE SYMBOL)))
     (CL:SETQ FUNCTION (LOOKUP-FUNCTION SYMBOL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
       (CL:OR
        (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
        (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
         FUNCTION SELF)))
      (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) FUNCTION)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-FUNCTIONS-NEXT? CL:T)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-FUNCTIONS-NEXT? CL:NIL)))

;;; (DEFUN (ALL-FUNCTIONS (ITERATOR OF FUNCTION)) ...)

(CL:DEFUN ALL-FUNCTIONS (MODULE LOCAL?)
  "Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere."
  (CL:RETURN-FROM ALL-FUNCTIONS
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+ (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-FUNCTIONS-NEXT?) MODULE LOCAL?)))

;;; (DEFUN (ALL-PUBLIC-FUNCTIONS (ITERATOR OF FUNCTION)) ...)

(CL:DEFUN ALL-PUBLIC-FUNCTIONS (MODULE LOCAL?)
  "Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere."
  (CL:LET* ((ITERATOR (ALL-FUNCTIONS MODULE LOCAL?)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-PUBLIC-SLOT?))
   (CL:RETURN-FROM ALL-PUBLIC-FUNCTIONS ITERATOR)))

;;; (DEFUN (ALL-VARIABLES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-VARIABLES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SYMBOL NULL) (VARIABLE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SYMBOL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SYMBOL-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SYMBOL NULL))
      (SELECTED-META-OBJECT? SELF (%SYMBOL.HOME-CONTEXT SYMBOL)))
     (CL:SETQ VARIABLE (LOOKUP *GLOBAL-VARIABLE-LOOKUP-TABLE* SYMBOL))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ VARIABLE NULL))
       (SELECTED-META-OBJECT? SELF (HOME-MODULE VARIABLE))
       (CL:OR
        (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
        (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
         VARIABLE SELF)))
      (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) VARIABLE)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-VARIABLES-NEXT? CL:T)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-VARIABLES-NEXT? CL:NIL)))

;;; (DEFUN (ALL-VARIABLES (ITERATOR OF GLOBAL-VARIABLE)) ...)

(CL:DEFUN ALL-VARIABLES (MODULE LOCAL?)
  "Iterate over all variables visible from 'module'.
If 'local?', return only variables bound to symbols interned in 'module'.
If 'module' is null, return all variables defined everywhere."
  (CL:RETURN-FROM ALL-VARIABLES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+ (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SYMBOL-ARRAY*))
    (CL:FUNCTION ALL-VARIABLES-NEXT?) MODULE LOCAL?)))

;;; (DEFUN (ALL-SURROGATES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-SURROGATES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SURROGATE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SURROGATE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SURROGATE-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
      (SELECTED-META-OBJECT? SELF (%SURROGATE.HOME-CONTEXT SURROGATE)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SURROGATE)
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
      (CL:1+ CURSOR))
     (CL:RETURN-FROM ALL-SURROGATES-NEXT? CL:T))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-SURROGATES-NEXT? CL:NIL)))

;;; (DEFUN (ALL-SURROGATES (ITERATOR OF SURROGATE)) ...)

(CL:DEFUN ALL-SURROGATES (MODULE LOCAL?)
  "Iterate over all surrogates visible from 'module'.
If 'local?', return only surrogates interned in 'module'.
If 'module' is null, return all surrogates interned everywhere."
  (CL:RETURN-FROM ALL-SURROGATES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
    (CL:FUNCTION ALL-SURROGATES-NEXT?) MODULE LOCAL?)))

;;; (DEFUN (ALL-CLASSES-NEXT? BOOLEAN) ...)

(CL:DEFUN ALL-CLASSES-NEXT? (SELF)
  (CL:LET*
   ((CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF))
    (SURROGATE NULL) (VALUE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:LOOP WHILE
    (CL:< CURSOR (%ALL-PURPOSE-ITERATOR.ITERATOR-SECOND-INTEGER SELF))
    DO
    (CL:SETQ SURROGATE
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY *SURROGATE-ARRAY*))
      CURSOR))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
      (SELECTED-META-OBJECT? SELF (%SURROGATE.HOME-CONTEXT SURROGATE)))
     (CL:SETQ VALUE (%SURROGATE.SURROGATE-VALUE SURROGATE))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ VALUE NULL)) (STELLA-CLASS? VALUE)
       (CL:EQ (%CLASS.CLASS-TYPE VALUE) SURROGATE))
      (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) VALUE)
      (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-INTEGER SELF)
       (CL:1+ CURSOR))
      (CL:RETURN-FROM ALL-CLASSES-NEXT? CL:T)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM ALL-CLASSES-NEXT? CL:NIL)))

;;; (DEFUN (ALL-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFUN ALL-CLASSES (MODULE LOCAL?)
  "Iterate over all classes visible from 'module'.
If 'local?', return only classes interned in 'module'.
If 'module' is null, return all classes interned everywhere."
  (CL:RETURN-FROM ALL-CLASSES
   (ALLOCATE-ALL-META-OBJECTS-ITERATOR
    (CL:1+
     (%EXTENSIBLE-SYMBOL-ARRAY.TOP-SYMBOL-OFFSET *SURROGATE-ARRAY*))
    (CL:FUNCTION ALL-CLASSES-NEXT?) MODULE LOCAL?)))

;;; (DEFUN (SLOTS-NEXT? BOOLEAN) ...)

(CL:DEFUN SLOTS-NEXT? (SELF)
  (CL:LET* ((SLOT NULL))
   (CL:LOOP
    (CL:LOOP
     (CL:LET* ()
      (CL:SETQ SLOT
       (%%VALUE (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
      (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
      (%%REST (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
     (CL:WHEN
      (CL:OR
       (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
       (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
        SLOT SELF))
      (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SLOT)
      (CL:RETURN-FROM SLOTS-NEXT? CL:T)))
    (CL:WHEN
     (CL:NOT
      (NEXT? (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF)))
     (CL:RETURN-FROM SLOTS-NEXT? CL:NIL))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     (%LIST.THE-CONS-LIST
      (%CLASS.CLASS-LOCAL-SLOTS
       (%ITERATOR.VALUE
        (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR SELF))))))))

;;; (DEFUN (ALL-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFUN ALL-SLOTS (MODULE LOCAL?)
  "Iterate over all slots visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION SLOTS-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-CLASSES MODULE LOCAL?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR) NIL)
   (CL:RETURN-FROM ALL-SLOTS ITERATOR)))

;;; (DEFUN (ALL-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN ALL-METHODS (MODULE LOCAL?)
  "Iterate over all methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION SLOTS-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-CLASSES MODULE LOCAL?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-METHOD-SLOT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR) NIL)
   (CL:RETURN-FROM ALL-METHODS ITERATOR)))

;;; (DEFUN (ALL-PUBLIC-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN ALL-PUBLIC-METHODS (MODULE LOCAL?)
  "Iterate over all public methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere."
  (CL:LET* ((ITERATOR (ALL-SLOTS MODULE LOCAL?)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-PUBLIC-METHOD-SLOT?))
   (CL:RETURN-FROM ALL-PUBLIC-METHODS ITERATOR)))

;;; (DEFUN (CLASS-METHODS-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-METHODS-NEXT? (SELF)
  (CL:LET* ((SLOT NULL))
   (CL:LOOP
    (CL:LET* ()
     (CL:SETQ SLOT
      (%%VALUE (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     (%%REST (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND (METHOD-SLOT? SLOT)
      (CL:OR
       (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
       (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
        SLOT SELF)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-METHODS-NEXT? CL:T)))
   (CL:RETURN-FROM CLASS-METHODS-NEXT? CL:NIL)))

;;; (DEFUN (CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN CLASS-METHODS (CLASS FILTERS)
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-METHODS-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR) FILTERS)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-METHODS ITERATOR)))

;;; (DEFUN (PUBLIC-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN PUBLIC-CLASS-METHODS (CLASS)
  "Iterate over all private methods attached to 'class'."
  (CL:RETURN-FROM PUBLIC-CLASS-METHODS
   (CLASS-METHODS CLASS
    (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-PUBLIC-SLOT?))
     (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
      (CONS
       (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?))
       NIL))))))

;;; (DEFUN (PRIVATE-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ...)

(CL:DEFUN PRIVATE-CLASS-METHODS (CLASS)
  "Iterate over all private methods attached to 'class'."
  (CL:RETURN-FROM PRIVATE-CLASS-METHODS
   (CLASS-METHODS CLASS
    (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-PRIVATE-SLOT?))
     (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
      (CONS
       (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?))
       NIL))))))

;;; (DEFUN (CLASS-STORAGE-SLOTS-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-STORAGE-SLOTS-NEXT? (SELF)
  (CL:LET* ((SLOT NULL))
   (CL:LOOP
    (CL:LET* ()
     (CL:SETQ SLOT
      (%%VALUE (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     (%%REST (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND (STORAGE-SLOT? SLOT)
      (CL:OR
       (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
       (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
        SLOT SELF)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-STORAGE-SLOTS-NEXT? CL:T)))
   (CL:RETURN-FROM CLASS-STORAGE-SLOTS-NEXT? CL:NIL)))

;;; (DEFUN (CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN CLASS-STORAGE-SLOTS (CLASS FILTERS)
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-STORAGE-SLOTS-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR) FILTERS)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-STORAGE-SLOTS ITERATOR)))

;;; (DEFUN (CLASS-TABLES-NEXT? BOOLEAN) ...)

(CL:DEFUN CLASS-TABLES-NEXT? (SELF)
  (CL:LET* ((SLOT NULL))
   (CL:LOOP
    (CL:LET* ()
     (CL:SETQ SLOT
      (%%VALUE (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
     (CL:WHEN (CL:EQ SLOT NULL) (CL:RETURN)))
    (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)
     (%%REST (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST SELF)))
    (CL:WHEN
     (CL:AND (ISA? SLOT SGT-ITERATORS-STELLA-TABLE)
      (CL:OR
       (CL:EQ (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF) NULL)
       (CL:FUNCALL (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE SELF)
        SLOT SELF)))
     (CL:SETF (%ALL-PURPOSE-ITERATOR.VALUE SELF) SLOT)
     (CL:RETURN-FROM CLASS-TABLES-NEXT? CL:T)))
   (CL:RETURN-FROM CLASS-TABLES-NEXT? CL:NIL)))

;;; (DEFUN (CLASS-TABLES (ITERATOR OF TABLE)) ...)

(CL:DEFUN CLASS-TABLES (CLASS FILTERS)
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION CLASS-TABLES-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-OBJECT ITERATOR) FILTERS)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-SLOT?))
   (CL:RETURN-FROM CLASS-TABLES ITERATOR)))

;;; (DEFUN (PUBLIC-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN PUBLIC-CLASS-STORAGE-SLOTS (CLASS)
  "Iterate over all public storage-slots attached to 'class'."
  (CL:RETURN-FROM PUBLIC-CLASS-STORAGE-SLOTS
   (CLASS-STORAGE-SLOTS CLASS
    (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-PUBLIC-SLOT?))
     (CONS
      (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?))
      (CONS
       (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
       (CONS
        (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?))
        NIL)))))))

;;; (DEFUN (PRIVATE-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ...)

(CL:DEFUN PRIVATE-CLASS-STORAGE-SLOTS (CLASS)
  "Iterate over all private storage-slots attached to 'class'."
  (CL:RETURN-FROM PRIVATE-CLASS-STORAGE-SLOTS
   (CLASS-STORAGE-SLOTS CLASS
    (CONS (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-PRIVATE-SLOT?))
     (CONS
      (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?))
      (CONS
       (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?))
       (CONS
        (WRAP-FUNCTION-CODE (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?))
        NIL)))))))

(CL:DEFUN NEW-CROSS-PRODUCT-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CROSS-PRODUCT-ITERATOR))
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.CURSORS SELF) NIL)
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF) NIL)
   (CL:RETURN-FROM NEW-CROSS-PRODUCT-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CROSS-PRODUCT-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-ITERATORS-STELLA-CROSS-PRODUCT-ITERATOR))

(CL:DEFUN ACCESS-CROSS-PRODUCT-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-ITERATORS-STELLA-DOMAINS)
    (CL:IF SETVALUE?
     (CL:SETF (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF) VALUE)
     (CL:SETQ VALUE (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF))))
   ((CL:EQ SLOTNAME SYM-ITERATORS-STELLA-CURSORS)
    (CL:IF SETVALUE?
     (CL:SETF (%CROSS-PRODUCT-ITERATOR.CURSORS SELF) VALUE)
     (CL:SETQ VALUE (%CROSS-PRODUCT-ITERATOR.CURSORS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CROSS-PRODUCT-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFUN (ALLOCATE-CROSS-PRODUCT-ITERATOR CROSS-PRODUCT-ITERATOR) ...)

(CL:DEFUN ALLOCATE-CROSS-PRODUCT-ITERATOR (DOMAINS)
  "Allocate a cross product iterator for a list of `domains'."
  (CL:LET* ((SELF-000 (NEW-CROSS-PRODUCT-ITERATOR)))
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF-000) DOMAINS)
   (CL:LET* ((ITERATOR SELF-000) (CURSORS NIL) (VALUES NIL))
    (CL:LET*
     ((DOMAIN NULL) (ITER-000 DOMAINS) (I NULL-INTEGER) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ DOMAIN (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:WHEN (CL:OR (CL:EQ DOMAIN NULL) (CL:EQ DOMAIN NIL))
       (CL:RETURN-FROM ALLOCATE-CROSS-PRODUCT-ITERATOR ITERATOR))
      (CL:SETQ CURSORS
       (CONS (CL:IF (CL:= I 0) DOMAIN (%%REST DOMAIN)) CURSORS))
      (CL:SETQ VALUES (CONS (%%VALUE DOMAIN) VALUES))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:SETF (%CROSS-PRODUCT-ITERATOR.CURSORS ITERATOR)
     (REVERSE CURSORS))
    (CL:SETF (%CROSS-PRODUCT-ITERATOR.VALUE ITERATOR) (REVERSE VALUES))
    (CL:RETURN-FROM ALLOCATE-CROSS-PRODUCT-ITERATOR ITERATOR))))

;;; (DEFMETHOD RESET ...)

(CL:DEFMETHOD RESET ((SELF CROSS-PRODUCT-ITERATOR))
  "Reset `self' to its initially allocated state.  Note, that
this is somewhat expensive, costing almost as much as allocating the iterator."
  (CL:LET*
   ((DOMAINS (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF)) (CURSORS NIL)
    (VALUES NIL))
   (CL:LET*
    ((DOMAIN NULL) (ITER-000 DOMAINS) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DOMAIN (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:OR (CL:EQ DOMAIN NULL) (CL:EQ DOMAIN NIL))
      (CL:RETURN-FROM RESET))
     (CL:SETQ CURSORS
      (CONS (CL:IF (CL:= I 0) DOMAIN (%%REST DOMAIN)) CURSORS))
     (CL:SETQ VALUES (CONS (%%VALUE DOMAIN) VALUES))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.CURSORS SELF) (REVERSE CURSORS))
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.VALUE SELF) (REVERSE VALUES)))
  :VOID)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF CROSS-PRODUCT-ITERATOR))
  (CL:LET*
   ((DOMAINS (%CROSS-PRODUCT-ITERATOR.DOMAINS SELF))
    (CURSORS (%CROSS-PRODUCT-ITERATOR.CURSORS SELF)) (CURSOR NIL)
    (VALUES (%CROSS-PRODUCT-ITERATOR.VALUE SELF)))
   (CL:WHEN (CL:EQ VALUES NULL) (CL:RETURN-FROM NEXT? CL:NIL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSORS NIL)) DO
    (CL:SETQ CURSOR (%%VALUE CURSORS))
    (CL:COND
     ((CL:NOT (CL:EQ CURSOR NIL))
      (FIRST-SETTER VALUES (%%VALUE CURSOR))
      (FIRST-SETTER CURSORS (%%REST CURSOR))
      (CL:RETURN-FROM NEXT? CL:T))
     (CL:T (CL:SETQ CURSOR (%%VALUE DOMAINS))
      (FIRST-SETTER VALUES (%%VALUE CURSOR))
      (FIRST-SETTER CURSORS (%%REST CURSOR))))
    (CL:SETQ CURSORS (%%REST CURSORS))
    (CL:SETQ DOMAINS (%%REST DOMAINS))
    (CL:SETQ VALUES (%%REST VALUES)))
   (CL:SETF (%CROSS-PRODUCT-ITERATOR.VALUE SELF) NULL)
   (CL:RETURN-FROM NEXT? CL:NIL)))

(CL:DEFUN HELP-STARTUP-ITERATORS1 ()
  (CL:PROGN
   (CL:SETQ SYM-ITERATORS-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ SGT-ITERATORS-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1))
   (CL:SETQ SGT-ITERATORS-STELLA-CROSS-PRODUCT-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CROSS-PRODUCT-ITERATOR" NULL 1))
   (CL:SETQ SYM-ITERATORS-STELLA-DOMAINS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOMAINS" NULL 0))
   (CL:SETQ SYM-ITERATORS-STELLA-CURSORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSORS" NULL 0))
   (CL:SETQ SYM-ITERATORS-STELLA-STARTUP-ITERATORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-ITERATORS" NULL 0))
   (CL:SETQ SYM-ITERATORS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-ITERATORS2 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR (LIKE SELF)) ((SELF ABSTRACT-ITERATOR)) :DOCUMENTATION \"Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a 'foreach' statement).\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-ITERATOR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF ABSTRACT-ITERATOR)) :DOCUMENTATION \"Iterate over 'self', and count how many
items there are.  Bad idea if 'self' iterates over an infinite
collection, since in that case it will run forever.'\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION LENGTH)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return the first item of the sequence represented by 'self',
or NULL if it is empty.  Destructively uses up the first iteration element.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION POP)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ADVANCE (LIKE SELF)) ((SELF ITERATOR) (N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Return 'self' after skipping over the first
'n' elements in the (remainder of the) iteration.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION ADVANCE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the sequence represented by 'self'
has no elements.  Side-effect free.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF ITERATOR) (VALUE OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Iterate over values of 'self', returning TRUE
if one of them is 'eql' to 'value.\")"
    (WRAP-METHOD-CODE (CL:FUNCTION MEMBER?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-DESTRUCTIVE-LIST-ITERATOR?"
    "(DEFUN (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? BOOLEAN) ((SELF DESTRUCTIVE-LIST-ITERATOR)))"
    (CL:FUNCTION TERMINATE-DESTRUCTIVE-LIST-ITERATOR?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INSERT ((SELF DESTRUCTIVE-LIST-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add 'value' to the front of the list 'self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION INSERT)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-DESTRUCTIVE-LIST-ITERATOR))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-DESTRUCTIVE-LIST-ITERATOR))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :DOCUMENTATION \"Apply the stored 'next?' function to 'self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION EMPTY?)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TERMINATE-ALL-PURPOSE-ITERATOR? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION TERMINATE-ALL-PURPOSE-ITERATOR?))
    NULL)
   (DEFINE-FUNCTION-OBJECT "FILTERED-NESTED-ITERATOR-NEXT?"
    "(DEFUN (FILTERED-NESTED-ITERATOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ITERATOR-CONS-LIST-NEXT?"
    "(DEFUN (ITERATOR-CONS-LIST-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ITERATOR-CONS-LIST-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ITERATOR-CONS-LIST-EMPTY?"
    "(DEFUN (ITERATOR-CONS-LIST-EMPTY? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ITERATOR-CONS-LIST-EMPTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTERED-CONCATENATED-ITERATOR-NEXT?"
    "(DEFUN (FILTERED-CONCATENATED-ITERATOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTERED-CONCATENATED-ITERATOR-NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONCATENATE ALL-PURPOSE-ITERATOR) ((ITERATOR1 ITERATOR) (ITERATOR2 ITERATOR) |&REST| (OTHERITERATORS ITERATOR)) :DOCUMENTATION \"Return an iterator that first generates all values of
`iterator1', then those of `iterator2', and then those of all `otherIterators'.
The generated values can be filtered by supplying a filter function to the
resulting iterator.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION CONCATENATE)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-INTEGER-INTERVAL-ITERATOR ((SELF INTEGER-INTERVAL-ITERATOR)))"
    (WRAP-METHOD-CODE
     (CL:FUNCTION INITIALIZE-INTEGER-INTERVAL-ITERATOR))
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF INTEGER-INTERVAL-ITERATOR)))"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERVAL"
    "(DEFUN (INTERVAL INTEGER-INTERVAL-ITERATOR) ((LOWERBOUND INTEGER) (UPPERBOUND INTEGER)) :PUBLIC? TRUE)"
    (CL:FUNCTION INTERVAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (REVERSE REVERSE-INTEGER-INTERVAL-ITERATOR) ((SELF INTEGER-INTERVAL-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION REVERSE)) NULL)
   (DEFINE-FUNCTION-OBJECT
    "INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR"
    "(DEFUN INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR)))"
    (CL:FUNCTION INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-FUNCTION-OBJECT "REVERSE-INTERVAL"
    "(DEFUN (REVERSE-INTERVAL REVERSE-INTEGER-INTERVAL-ITERATOR) ((LOWERBOUND INTEGER) (UPPERBOUND INTEGER)) :DOCUMENTATION \"Create a reverse interval object.\")"
    (CL:FUNCTION REVERSE-INTERVAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOCATE-ITERATOR STRING-ITERATOR) ((SELF STRING)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION ALLOCATE-ITERATOR)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF STRING-ITERATOR)) :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-ALL-META-OBJECTS-ITERATOR"
    "(DEFUN (ALLOCATE-ALL-META-OBJECTS-ITERATOR ITERATOR) ((ARRAYSIZE INTEGER) (NEXTCODE FUNCTION-CODE) (MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION ALLOCATE-ALL-META-OBJECTS-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECTED-META-OBJECT?"
    "(DEFUN (SELECTED-META-OBJECT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR) (OBJECTMODULE MODULE)) :PUBLIC? TRUE)"
    (CL:FUNCTION SELECTED-META-OBJECT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SYMBOLS-NEXT?"
    "(DEFUN (ALL-SYMBOLS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SYMBOLS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SYMBOLS"
    "(DEFUN (ALL-SYMBOLS (ITERATOR OF SYMBOL)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all symbols visible from 'module'.
If 'local?', return only symbols interned in 'module'.
If 'module' is null, return all symbols interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SYMBOLS) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-PUBLIC-SLOT?"
    "(DEFUN (FILTER-PUBLIC-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-PUBLIC-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-PRIVATE-SLOT?"
    "(DEFUN (FILTER-PRIVATE-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-PRIVATE-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-METHOD-SLOT?"
    "(DEFUN (FILTER-METHOD-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-METHOD-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-PUBLIC-METHOD-SLOT?"
    "(DEFUN (FILTER-PUBLIC-METHOD-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-PUBLIC-METHOD-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-NON-EXTERNAL-SLOT?"
    "(DEFUN (FILTER-NON-EXTERNAL-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-NON-EXTERNAL-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-NON-PARAMETER-SLOT?"
    "(DEFUN (FILTER-NON-PARAMETER-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-NON-PARAMETER-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-NON-AUXILIARY-SLOT?"
    "(DEFUN (FILTER-NON-AUXILIARY-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-NON-AUXILIARY-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-SLOT?"
    "(DEFUN (FILTER-SLOT? BOOLEAN) ((SELF SLOT) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FUNCTIONS-NEXT?"
    "(DEFUN (ALL-FUNCTIONS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-FUNCTIONS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FUNCTIONS"
    "(DEFUN (ALL-FUNCTIONS (ITERATOR OF FUNCTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-FUNCTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-PUBLIC-FUNCTIONS"
    "(DEFUN (ALL-PUBLIC-FUNCTIONS (ITERATOR OF FUNCTION)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all functions visible from 'module'.
If 'local?', return only functions bound to symbols interned in 'module'.
If 'module' is null, return all functions defined everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-PUBLIC-FUNCTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-VARIABLES-NEXT?"
    "(DEFUN (ALL-VARIABLES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-VARIABLES-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-VARIABLES"
    "(DEFUN (ALL-VARIABLES (ITERATOR OF GLOBAL-VARIABLE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all variables visible from 'module'.
If 'local?', return only variables bound to symbols interned in 'module'.
If 'module' is null, return all variables defined everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SURROGATES-NEXT?"
    "(DEFUN (ALL-SURROGATES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-SURROGATES-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SURROGATES"
    "(DEFUN (ALL-SURROGATES (ITERATOR OF SURROGATE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all surrogates visible from 'module'.
If 'local?', return only surrogates interned in 'module'.
If 'module' is null, return all surrogates interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SURROGATES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-CLASSES-NEXT?"
    "(DEFUN (ALL-CLASSES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION ALL-CLASSES-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-CLASSES"
    "(DEFUN (ALL-CLASSES (ITERATOR OF CLASS)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all classes visible from 'module'.
If 'local?', return only classes interned in 'module'.
If 'module' is null, return all classes interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "SLOTS-NEXT?"
    "(DEFUN (SLOTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION SLOTS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SLOTS"
    "(DEFUN (ALL-SLOTS (ITERATOR OF SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all slots visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-METHODS"
    "(DEFUN (ALL-METHODS (ITERATOR OF METHOD-SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-PUBLIC-METHODS"
    "(DEFUN (ALL-PUBLIC-METHODS (ITERATOR OF METHOD-SLOT)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Iterate over all public methods visible from 'module'.
If 'local?', return only methods interned in 'module'.
If 'module' is null, return all methods interned everywhere.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-PUBLIC-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-METHODS-NEXT?"
    "(DEFUN (CLASS-METHODS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION CLASS-METHODS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-METHODS"
    "(DEFUN (CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-CODE-WRAPPER))))"
    (CL:FUNCTION CLASS-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "PUBLIC-CLASS-METHODS"
    "(DEFUN (PUBLIC-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private methods attached to 'class'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PUBLIC-CLASS-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRIVATE-CLASS-METHODS"
    "(DEFUN (PRIVATE-CLASS-METHODS (ITERATOR OF METHOD-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private methods attached to 'class'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRIVATE-CLASS-METHODS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-STORAGE-SLOTS-NEXT?"
    "(DEFUN (CLASS-STORAGE-SLOTS-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION CLASS-STORAGE-SLOTS-NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-STORAGE-SLOTS"
    "(DEFUN (CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-CODE-WRAPPER))))"
    (CL:FUNCTION CLASS-STORAGE-SLOTS) NULL))
  :VOID)

(CL:DEFUN STARTUP-ITERATORS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-ITERATORS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CROSS-PRODUCT-ITERATOR"
        "(DEFCLASS CROSS-PRODUCT-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class that generates the cross product of a list of domains.
Each value tuple is represented as a CONS.  CAUTION: the value tuple will be modified
destructively, hence, it needs to be copied in case it needs to persist beyond a single
iteration.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE CONS)) :SLOTS ((DOMAINS :TYPE (CONS OF CONS) :INITIALLY NIL) (CURSORS :TYPE (CONS OF CONS) :INITIALLY NIL)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CROSS-PRODUCT-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CROSS-PRODUCT-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-ITERATORS2)
    (DEFINE-FUNCTION-OBJECT "CLASS-TABLES-NEXT?"
     "(DEFUN (CLASS-TABLES-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))"
     (CL:FUNCTION CLASS-TABLES-NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "CLASS-TABLES"
     "(DEFUN (CLASS-TABLES (ITERATOR OF TABLE)) ((CLASS CLASS) (FILTERS (CONS OF FUNCTION-CODE-WRAPPER))))"
     (CL:FUNCTION CLASS-TABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "PUBLIC-CLASS-STORAGE-SLOTS"
     "(DEFUN (PUBLIC-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all public storage-slots attached to 'class'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PUBLIC-CLASS-STORAGE-SLOTS) NULL)
    (DEFINE-FUNCTION-OBJECT "PRIVATE-CLASS-STORAGE-SLOTS"
     "(DEFUN (PRIVATE-CLASS-STORAGE-SLOTS (ITERATOR OF STORAGE-SLOT)) ((CLASS CLASS)) :DOCUMENTATION \"Iterate over all private storage-slots attached to 'class'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PRIVATE-CLASS-STORAGE-SLOTS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALLOCATE-CROSS-PRODUCT-ITERATOR"
     "(DEFUN (ALLOCATE-CROSS-PRODUCT-ITERATOR CROSS-PRODUCT-ITERATOR) ((DOMAINS (CONS OF CONS))) :DOCUMENTATION \"Allocate a cross product iterator for a list of `domains'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALLOCATE-CROSS-PRODUCT-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD RESET ((SELF CROSS-PRODUCT-ITERATOR)) :DOCUMENTATION \"Reset `self' to its initially allocated state.  Note, that
this is somewhat expensive, costing almost as much as allocating the iterator.\" :PUBLIC? TRUE)"
     (WRAP-METHOD-CODE (CL:FUNCTION RESET)) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF CROSS-PRODUCT-ITERATOR)))"
     (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-ITERATORS"
     "(DEFUN STARTUP-ITERATORS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-ITERATORS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-ITERATORS-STELLA-STARTUP-ITERATORS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-ITERATORS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupIterators") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))))
  :VOID)
