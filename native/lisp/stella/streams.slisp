;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; streams.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2023      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-STREAMS-STELLA-EOL NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-PRINT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STANDARD-OUTPUT NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-I NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-IN NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-INTERVAL NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-DO NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-IGNORE NULL)
(CL:DEFVAR KWD-STREAMS-COMMON-LISP NULL)
(CL:DEFVAR KWD-STREAMS-WARN NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STANDARD-WARNING NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-NULL NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STELLA-EXCEPTION NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SIGNAL-EXCEPTION NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-NEW NULL)
(CL:DEFVAR KWD-STREAMS-MESSAGE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-LET NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-OUTPUT-STRING-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-THE-STRING NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SIGNAL NULL)
(CL:DEFVAR KWD-STREAMS-JAVA NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-ERROR_MESSAGE_ NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-VERBATIM NULL)
(CL:DEFVAR KWD-STREAMS-CONTINUABLE-ERROR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-READ-EXCEPTION NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-DE-UGLIFY-PARSE-TREE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SPECIAL NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-*PRINTREADABLY?* NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-ERROR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SUPPRESS-WARNINGS? NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-PRINT-ERROR-CONTEXT NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STANDARD-ERROR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-NOTE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-WARNING NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-WHEN NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-NOT NULL)
(CL:DEFVAR KWD-STREAMS-ERROR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-*EVALUATIONTREE* NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-*EVALUATIONPARENTTREE* NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-EVALUATION-EXCEPTION NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STRINGIFY NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-VRLET NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STRING NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-CONCATENATE NULL)
(CL:DEFVAR KWD-STREAMS-CLOSED NULL)
(CL:DEFVAR KWD-STREAMS-IF-EXISTS NULL)
(CL:DEFVAR KWD-STREAMS-IF-EXISTS-ACTION NULL)
(CL:DEFVAR KWD-STREAMS-IF-NOT-EXISTS NULL)
(CL:DEFVAR KWD-STREAMS-IF-NOT-EXISTS-ACTION NULL)
(CL:DEFVAR KWD-STREAMS-SUPERSEDE NULL)
(CL:DEFVAR KWD-STREAMS-CREATE NULL)
(CL:DEFVAR KWD-STREAMS-CREATE-PATH NULL)
(CL:DEFVAR KWD-STREAMS-ABORT NULL)
(CL:DEFVAR KWD-STREAMS-PROBE NULL)
(CL:DEFVAR KWD-STREAMS-APPEND NULL)
(CL:DEFVAR KWD-STREAMS-OPEN NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-INPUT-FILE-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-OUTPUT-FILE-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-INPUT-STRING-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-OUTPUT-STRING-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-OUTPUT-STREAM NULL)
(CL:DEFVAR KWD-STREAMS-BLOCK NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-FILE-INPUT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-UNWIND-PROTECT NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-PROGN NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-OPEN-INPUT-FILE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-FREE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-FILE-OUTPUT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-OPEN-OUTPUT-FILE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-OUTPUT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-MV-SETQ NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-OPEN-NETWORK-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-OBJECT NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SUBSEQUENCE NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-POSITION NULL)
(CL:DEFVAR KWD-STREAMS-LETTER NULL)
(CL:DEFVAR KWD-STREAMS-DIGIT NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-THE-STREAM NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-S-EXPRESSION-ITERATOR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-VALUE NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-LINE-ITERATOR NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-NATIVE-LINE-ITERATOR NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-CHARACTER-ITERATOR NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SET-LOGGING-PARAMETERS NULL)
(CL:DEFVAR KWD-STREAMS-FUNCTION NULL)
(CL:DEFVAR KWD-STREAMS-LEVEL NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-SET-LOG-LEVEL NULL)
(CL:DEFVAR KWD-STREAMS-LOG-LEVELS NULL)
(CL:DEFVAR KWD-STREAMS-STREAM NULL)
(CL:DEFVAR KWD-STREAMS-PREFIX NULL)
(CL:DEFVAR KWD-STREAMS-MAX-WIDTH NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-STREAMS-STELLA-FILE-OUTPUT-STREAM NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-STARTUP-STREAMS NULL)
(CL:DEFVAR SYM-STREAMS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-FLOAT NULL-INTEGER
  *CHARACTER-TYPE-TABLE* NULL-CHARACTER *SAFETY*
  *TRANSLATOROUTPUTLANGUAGE* NIL))

;;; (DEFGLOBAL EOL ...)

(CL:DEFVAR EOL NULL
  "Generates a newline character when passed to a stream.")

;;; (DEFGLOBAL EOL-STRING ...)

(CL:DEFVAR EOL-STRING "
"
  "A string constant containing the character sequence
necessary to generate a newline.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING EOL-STRING))

;;; (DEFGLOBAL STELLA-CHARSET ...)

(CL:DEFVAR STELLA-CHARSET (CL:or #+allegro (CL:ignore-errors (excl::find-external-format :iso-8859-1))
                                 #+cmu :iso-8859-1
                                 #+sbcl :iso-8859-1
                                 :DEFAULT)
  "For STELLA we always assume an 8-bit transparent mapping from bytes to STRING characters
such as ISO-8859-1 (ISO-LATIN-1), since that's what C++ natively supports.  For Java and some Lisps, we have
to do some extra work to enforce this encoding when creating streams.  This is just a first iteration towards
this handling this, for example, in Lisp we'd also have to configure compile and load streams to properly encode
string constants that contain non-ASCII characters.")

;;; (DEFGLOBAL STANDARD-INPUT ...)

(CL:DEFVAR STANDARD-INPUT NULL
  "Denotes the standard input stream for the host language.")

;;; (DEFUN (MAKE-EARLY-OUTPUT-STREAM OUTPUT-STREAM) ...)

(CL:DEFUN MAKE-EARLY-OUTPUT-STREAM (NATIVESTREAM)
  (CL:LET* ((STREAM (NEW-OUTPUT-STREAM)))
   (CL:SETF (%OUTPUT-STREAM.NATIVE-STREAM STREAM) NATIVESTREAM)
   #+(or allegro cmu) (CL:ignore-errors (CL:setf (CL:stream-external-format nativestream) STELLA-CHARSET))
   (CL:RETURN-FROM MAKE-EARLY-OUTPUT-STREAM STREAM)))

;;; (DEFGLOBAL STANDARD-OUTPUT ...)

(CL:DEFVAR STANDARD-OUTPUT (MAKE-EARLY-OUTPUT-STREAM CL:*STANDARD-OUTPUT*)
  "Denotes the standard output stream for the host language.")

;;; (DEFGLOBAL STANDARD-WARNING ...)

(CL:DEFVAR STANDARD-WARNING (MAKE-EARLY-OUTPUT-STREAM CL:*ERROR-OUTPUT*)
  "Denotes the standard warning stream for the host language.")

;;; (DEFGLOBAL STANDARD-ERROR ...)

(CL:DEFVAR STANDARD-ERROR (MAKE-EARLY-OUTPUT-STREAM CL:*ERROR-OUTPUT*)
  "Denotes the standard error stream for the host language.")

;;; (DEFSPECIAL *IGNORETRANSLATIONERRORS?* ...)

(CL:DEFVAR *IGNORETRANSLATIONERRORS?* CL:T
  "If `true' all passes of a translation will always be performed
regardless of whether any errors were encountered.  Otherwise, translation
ends with the first pass that encountered an error.")

;;; (DEFGLOBAL SINGLE-QUOTE-STRING ...)

(CL:DEFVAR SINGLE-QUOTE-STRING NULL
  "Holds a string containing the single quote character.")

;;; (DEFGLOBAL SINGLE-BQUOTE-STRING ...)

(CL:DEFVAR SINGLE-BQUOTE-STRING NULL
  "Holds a string containing the single backquote character.")

;;; (DEFUN (FORMAT-MESSAGE-ARGUMENTS CONS) ...)

(CL:DEFUN FORMAT-MESSAGE-ARGUMENTS (MESSAGEARGUMENTSTREE TRAILINGEOL?)
  (CL:LET* ((AUGMENTEDARGUMENTS NIL))
   (CL:LET* ((ITEM NULL) (ITER-000 MESSAGEARGUMENTSTREE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ITEM (%%VALUE ITER-000))
     (CL:COND
      ((CL:OR (STRING? ITEM) (CL:EQ ITEM EOL))
       (CL:SETQ AUGMENTEDARGUMENTS (CONS ITEM AUGMENTEDARGUMENTS)))
      (CL:T
       (CL:SETQ AUGMENTEDARGUMENTS
        (CONS SINGLE-BQUOTE-STRING AUGMENTEDARGUMENTS))
       (CL:SETQ AUGMENTEDARGUMENTS (CONS ITEM AUGMENTEDARGUMENTS))
       (CL:SETQ AUGMENTEDARGUMENTS
        (CONS SINGLE-QUOTE-STRING AUGMENTEDARGUMENTS))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN TRAILINGEOL?
    (CL:SETQ AUGMENTEDARGUMENTS (CONS EOL AUGMENTEDARGUMENTS)))
   (CL:RETURN-FROM FORMAT-MESSAGE-ARGUMENTS
    (REVERSE AUGMENTEDARGUMENTS))))

;;; (DEFMACRO PRINT ...)

(CL:DEFUN PRINT (BODY)
  "Print arguments to the standard output stream."
  (CL:RETURN-FROM PRINT
   (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
    SYM-STREAMS-STELLA-STANDARD-OUTPUT (CONCATENATE BODY NIL))))

;;; (DEFMACRO PRINT-SPACES ...)

(CL:DEFUN PRINT-SPACES (BODY)
  "(print-spaces [stream] N) prints N spaces onto stream.  If
no stream form is provided, then STANDARD-OUTPUT will be used."
  (CL:IF (CL:EQ (%%REST BODY) NIL)
   (CL:RETURN-FROM PRINT-SPACES
    (LIST* SYM-STREAMS-STELLA-FOREACH SYM-STREAMS-STELLA-I
     SYM-STREAMS-STELLA-IN
     (LIST* SYM-STREAMS-STELLA-INTERVAL (WRAP-INTEGER 1) (%%VALUE BODY)
      NIL)
     SYM-STREAMS-STELLA-DO
     (LIST* SYM-STREAMS-STELLA-IGNORE SYM-STREAMS-STELLA-I NIL)
     (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
      SYM-STREAMS-STELLA-STANDARD-OUTPUT (WRAP-STRING " ") NIL)
     NIL))
   (CL:RETURN-FROM PRINT-SPACES
    (LIST* SYM-STREAMS-STELLA-FOREACH SYM-STREAMS-STELLA-I
     SYM-STREAMS-STELLA-IN
     (LIST* SYM-STREAMS-STELLA-INTERVAL (WRAP-INTEGER 1)
      (%%VALUE (%%REST BODY)) NIL)
     SYM-STREAMS-STELLA-DO
     (LIST* SYM-STREAMS-STELLA-IGNORE SYM-STREAMS-STELLA-I NIL)
     (LIST* SYM-STREAMS-STELLA-PRINT-STREAM (%%VALUE BODY)
      (CONS (WRAP-STRING " ") NIL))
     NIL))))

;;; (DEFMACRO INFORM ...)

(CL:DEFUN INFORM (BODY)
  "Print informative message, placing non-string arguments in quotes,
and terminating with a newline."
  (CL:SETQ BODY (FORMAT-MESSAGE-ARGUMENTS BODY CL:T))
  (CL:RETURN-FROM INFORM
   (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
    SYM-STREAMS-STELLA-STANDARD-OUTPUT (CONCATENATE BODY NIL))))

;;; (DEFMACRO WARN ...)

(CL:DEFUN WARN (BODY)
  "Signal warning message, placing non-string arguments in quotes."
  (CL:SETQ BODY (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL))
  (CL:IF (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-STREAMS-COMMON-LISP)
   (CL:RETURN-FROM WARN
    (LIST* SYM-STREAMS-STELLA-PRINT-STREAM KWD-STREAMS-WARN
     (CONCATENATE BODY NIL)))
   (CL:RETURN-FROM WARN
    (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
     SYM-STREAMS-STELLA-STANDARD-WARNING (WRAP-STRING "Warning: ")
     (CONCATENATE BODY (CONS SYM-STREAMS-STELLA-EOL NIL))))))

;;; (DEFMACRO SIGNAL ...)

(CL:DEFUN SIGNAL (TYPE BODY)
  "Signal error message, placing non-string arguments in quotes."
  (CL:WHEN (CL:EQ TYPE SYM-STREAMS-STELLA-NULL)
   (CL:SETQ TYPE SYM-STREAMS-STELLA-STELLA-EXCEPTION))
  (CL:IF
   (CL:AND (CL:= (LENGTH BODY) 1)
    (ISA? (%%VALUE BODY) SGT-STREAMS-STELLA-STRING-WRAPPER))
   (CL:RETURN-FROM SIGNAL
    (LIST* SYM-STREAMS-STELLA-SIGNAL-EXCEPTION
     (LIST* SYM-STREAMS-STELLA-NEW TYPE
      (LIST* KWD-STREAMS-MESSAGE (%%VALUE BODY) NIL))
     NIL))
   (CL:LET* ((STREAMVAR (LOCAL-GENSYM "STREAM")))
    (CL:RETURN-FROM SIGNAL
     (LIST* SYM-STREAMS-STELLA-LET
      (CONS
       (CONS STREAMVAR
        (CONS
         (LIST* SYM-STREAMS-STELLA-NEW
          SYM-STREAMS-STELLA-OUTPUT-STRING-STREAM NIL)
         NIL))
       NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
       (CONCATENATE (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL) NIL))
      (LIST* SYM-STREAMS-STELLA-SIGNAL-EXCEPTION
       (LIST* SYM-STREAMS-STELLA-NEW TYPE
        (LIST* KWD-STREAMS-MESSAGE
         (LIST* SYM-STREAMS-STELLA-THE-STRING STREAMVAR NIL) NIL))
       NIL)
      NIL)))))

;;; (DEFMACRO ERROR ...)

(CL:DEFUN ERROR (BODY)
  "Signal error message, placing non-string arguments in quotes."
  (CL:RETURN-FROM ERROR
   (LIST* SYM-STREAMS-STELLA-SIGNAL SYM-STREAMS-STELLA-STELLA-EXCEPTION
    (CONCATENATE BODY NIL))))

;;; (DEFMACRO CONTINUABLE-ERROR ...)

(CL:DEFUN CONTINUABLE-ERROR (BODY)
  "Signal error message, placing non-string arguments in quotes."
  (CL:SETQ BODY (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL))
  (CL:IF (CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-STREAMS-JAVA)
   (CL:IF
    (CL:AND (CL:= (LENGTH BODY) 1)
     (ISA? (%%VALUE BODY) SGT-STREAMS-STELLA-STRING-WRAPPER))
    (CL:RETURN-FROM CONTINUABLE-ERROR
     (LIST* SYM-STREAMS-STELLA-LET
      (CONS
       (LIST* SYM-STREAMS-STELLA-ERROR_MESSAGE_
        (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE BODY)))
        NIL)
       NIL)
      (LIST* SYM-STREAMS-STELLA-VERBATIM KWD-STREAMS-JAVA
       (WRAP-STRING "Native.continuableError(error_message_)") NIL)
      NIL))
    (CL:LET* ((STREAMVAR (LOCAL-GENSYM "STREAM")))
     (CL:RETURN-FROM CONTINUABLE-ERROR
      (LIST* SYM-STREAMS-STELLA-LET
       (CONS
        (CONS STREAMVAR
         (CONS
          (LIST* SYM-STREAMS-STELLA-NEW
           SYM-STREAMS-STELLA-OUTPUT-STRING-STREAM NIL)
          NIL))
        NIL)
       (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
        (CONCATENATE (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL) NIL))
       (LIST* SYM-STREAMS-STELLA-LET
        (CONS
         (LIST* SYM-STREAMS-STELLA-ERROR_MESSAGE_
          (LIST* SYM-STREAMS-STELLA-THE-STRING STREAMVAR NIL) NIL)
         NIL)
        (LIST* SYM-STREAMS-STELLA-VERBATIM KWD-STREAMS-JAVA
         (WRAP-STRING "Native.continuableError(error_message_)") NIL)
        NIL)
       NIL))))
   (CL:RETURN-FROM CONTINUABLE-ERROR
    (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
     KWD-STREAMS-CONTINUABLE-ERROR (CONCATENATE BODY NIL)))))

;;; (DEFMACRO SIGNAL-READ-ERROR ...)

(CL:DEFUN SIGNAL-READ-ERROR (BODY)
  "Specialized version of `signal' that throws a READ-EXCEPTION."
  (CL:RETURN-FROM SIGNAL-READ-ERROR
   (LIST* SYM-STREAMS-STELLA-SIGNAL SYM-STREAMS-STELLA-READ-EXCEPTION
    (CONCATENATE BODY NIL))))

;;; (DEFUN ENSURE-FILE-EXISTS ...)

(CL:DEFUN ENSURE-FILE-EXISTS (FILENAME CONTEXT)
  "Ensures that `filename' exists.  If not, an exception of
type `NO-SUCH-FILE-EXCEPTION' is thrown with `context' supplying
context for the error message."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME CONTEXT))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE CONTEXT CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
   (CL:LET*
    ((SELF-000
      (NEW-NO-SUCH-FILE-EXCEPTION
       (CONCATENATE CONTEXT ": file " FILENAME " does not exist"))))
    (CL:SETF (%FILENAME SELF-000) FILENAME)
    (CL:LET* ((EX SELF-000)) (CL:ERROR EX))))
  :VOID)

;;; (DEFUN ENSURE-FILE-DOES-NOT-EXIST ...)

(CL:DEFUN ENSURE-FILE-DOES-NOT-EXIST (FILENAME CONTEXT)
  "Ensures that `filename' does not exist.  If it does,
an exception of type `FILE-ALREADY-EXISTS-EXCEPTION' is thrown
with `context' supplying context for the error message."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME CONTEXT))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE CONTEXT CL:SIMPLE-STRING)
  (CL:WHEN (PROBE-FILE? FILENAME)
   (CL:LET*
    ((SELF-000
      (NEW-FILE-ALREADY-EXISTS-EXCEPTION
       (CONCATENATE CONTEXT ": file " FILENAME " already exists"))))
    (CL:SETF (%FILENAME SELF-000) FILENAME)
    (CL:LET* ((EX SELF-000)) (CL:ERROR EX))))
  :VOID)

;;; (DEFUN (FORMAT-WALK-MESSAGE-ARGUMENTS CONS) ...)

(CL:DEFUN FORMAT-WALK-MESSAGE-ARGUMENTS (MESSAGEARGUMENTSTREE)
  (CL:LET* ((IT (ALLOCATE-ITERATOR MESSAGEARGUMENTSTREE)))
   (CL:LOOP WHILE (NEXT? IT) DO
    (CL:LET* ((ITEM (%CONS-ITERATOR.VALUE IT)))
     (CL:COND
      ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE ITEM))
       (CL:PROGN
        (CL:WHEN (CL:NOT (CL:EQ ITEM EOL))
         (VALUE-SETTER IT
          (LIST* SYM-STREAMS-STELLA-DE-UGLIFY-PARSE-TREE ITEM NIL)))))
      (CL:T)))))
  (CL:RETURN-FROM FORMAT-WALK-MESSAGE-ARGUMENTS MESSAGEARGUMENTSTREE))

;;; (DEFMACRO WALK-ERROR ...)

(CL:DEFUN WALK-ERROR (BODY)
  (CL:LET*
   ((MESSAGEARGUMENTS
     (FORMAT-MESSAGE-ARGUMENTS (FORMAT-WALK-MESSAGE-ARGUMENTS BODY)
      CL:NIL)))
   (CL:RETURN-FROM WALK-ERROR
    (LIST* SYM-STREAMS-STELLA-SPECIAL
     (CONS
      (LIST* SYM-STREAMS-STELLA-*PRINTREADABLY?*
       SYM-STREAMS-STELLA-TRUE NIL)
      NIL)
     (CONS SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-ERROR NIL)
     (LIST* SYM-STREAMS-STELLA-UNLESS
      (CONS SYM-STREAMS-STELLA-SUPPRESS-WARNINGS? NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-ERROR-CONTEXT
       (WRAP-STRING ">> ERROR: ") SYM-STREAMS-STELLA-STANDARD-ERROR
       NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
       SYM-STREAMS-STELLA-STANDARD-ERROR SYM-STREAMS-STELLA-EOL
       (WRAP-STRING " ")
       (CONCATENATE MESSAGEARGUMENTS
        (LIST* (WRAP-STRING ".") SYM-STREAMS-STELLA-EOL NIL)))
      NIL)
     NIL))))

;;; (DEFMACRO WALK-INFORM ...)

(CL:DEFUN WALK-INFORM (BODY)
  (CL:LET*
   ((MESSAGEARGUMENTS
     (FORMAT-MESSAGE-ARGUMENTS (FORMAT-WALK-MESSAGE-ARGUMENTS BODY)
      CL:NIL)))
   (CL:RETURN-FROM WALK-INFORM
    (LIST* SYM-STREAMS-STELLA-SPECIAL
     (CONS
      (LIST* SYM-STREAMS-STELLA-*PRINTREADABLY?*
       SYM-STREAMS-STELLA-TRUE NIL)
      NIL)
     (CONS SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-NOTE NIL)
     (LIST* SYM-STREAMS-STELLA-UNLESS
      (CONS SYM-STREAMS-STELLA-SUPPRESS-WARNINGS? NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-ERROR-CONTEXT
       (WRAP-STRING ">> NOTE: ") SYM-STREAMS-STELLA-STANDARD-OUTPUT
       NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
       SYM-STREAMS-STELLA-STANDARD-OUTPUT SYM-STREAMS-STELLA-EOL
       (WRAP-STRING " ")
       (CONCATENATE MESSAGEARGUMENTS
        (LIST* (WRAP-STRING ".") SYM-STREAMS-STELLA-EOL NIL)))
      NIL)
     NIL))))

;;; (DEFMACRO WALK-WARN ...)

(CL:DEFUN WALK-WARN (BODY)
  (CL:LET*
   ((MESSAGEARGUMENTS
     (FORMAT-MESSAGE-ARGUMENTS (FORMAT-WALK-MESSAGE-ARGUMENTS BODY)
      CL:NIL)))
   (CL:RETURN-FROM WALK-WARN
    (LIST* SYM-STREAMS-STELLA-SPECIAL
     (CONS
      (LIST* SYM-STREAMS-STELLA-*PRINTREADABLY?*
       SYM-STREAMS-STELLA-TRUE NIL)
      NIL)
     (CONS SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-WARNING NIL)
     (LIST* SYM-STREAMS-STELLA-UNLESS
      (CONS SYM-STREAMS-STELLA-SUPPRESS-WARNINGS? NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-ERROR-CONTEXT
       (WRAP-STRING ">> WARNING: ") SYM-STREAMS-STELLA-STANDARD-WARNING
       NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-STREAM
       SYM-STREAMS-STELLA-STANDARD-WARNING SYM-STREAMS-STELLA-EOL
       (WRAP-STRING " ")
       (CONCATENATE MESSAGEARGUMENTS
        (LIST* (WRAP-STRING ".") SYM-STREAMS-STELLA-EOL NIL)))
      NIL)
     NIL))))

;;; (DEFMACRO SAFETY ...)

(CL:DEFUN SAFETY (LEVEL TEST BODY)
  "Signal warning message, placing non-string arguments in quotes."
  (CL:WHEN (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE LEVEL) *SAFETY*)
   (CL:RETURN-FROM SAFETY NULL))
  (CL:SETQ BODY (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL))
  (CL:RETURN-FROM SAFETY
   (LIST* SYM-STREAMS-STELLA-WHEN
    (LIST* SYM-STREAMS-STELLA-NOT TEST NIL)
    (LIST* SYM-STREAMS-STELLA-PRINT-STREAM KWD-STREAMS-ERROR
     (WRAP-STRING "Safety violation: ") (CONCATENATE BODY NIL))
    NIL)))

;;; (DEFMACRO EVALUATION-ERROR ...)

(CL:DEFUN EVALUATION-ERROR (BODY)
  (CL:LET* ((STREAMVAR (LOCAL-GENSYM "STREAM")))
   (CL:RETURN-FROM EVALUATION-ERROR
    (LIST* SYM-STREAMS-STELLA-LET
     (CONS
      (CONS STREAMVAR
       (CONS
        (LIST* SYM-STREAMS-STELLA-NEW
         SYM-STREAMS-STELLA-OUTPUT-STRING-STREAM NIL)
        NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
      (LIST* (WRAP-STRING "While evaluating '")
       SYM-STREAMS-STELLA-*EVALUATIONTREE* NIL))
     (LIST* SYM-STREAMS-STELLA-WHEN
      (LIST* SYM-STREAMS-STELLA-DEFINED?
       SYM-STREAMS-STELLA-*EVALUATIONPARENTTREE* NIL)
      (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
       (LIST* SYM-STREAMS-STELLA-EOL (WRAP-STRING "' inside '")
        SYM-STREAMS-STELLA-*EVALUATIONPARENTTREE* NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
      (LIST* (WRAP-STRING "':") SYM-STREAMS-STELLA-EOL NIL))
     (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAMVAR
      (CONCATENATE (FORMAT-MESSAGE-ARGUMENTS BODY CL:NIL) NIL))
     (LIST* SYM-STREAMS-STELLA-SIGNAL-EXCEPTION
      (LIST* SYM-STREAMS-STELLA-NEW
       SYM-STREAMS-STELLA-EVALUATION-EXCEPTION KWD-STREAMS-MESSAGE
       (LIST* SYM-STREAMS-STELLA-THE-STRING STREAMVAR NIL) NIL)
      NIL)
     NIL))))

;;; (DEFUN (FORMAT-STRING-MESSAGE-ARGUMENTS CONS) ...)

(CL:DEFUN FORMAT-STRING-MESSAGE-ARGUMENTS (MESSAGEARGUMENTS TRAILINGEOL?)
  (CL:LET*
   ((FORMATTEDARGUMENTS
     (FORMAT-MESSAGE-ARGUMENTS MESSAGEARGUMENTS TRAILINGEOL?)))
   (CL:LET* ((IT (ALLOCATE-ITERATOR FORMATTEDARGUMENTS)))
    (CL:LOOP WHILE (NEXT? IT) DO
     (CL:LET*
      ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE (%CONS-ITERATOR.VALUE IT))))
      (CL:COND ((SUBTYPE-OF-STRING? TEST-VALUE-000))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-LITERAL-WRAPPER)
        (VALUE-SETTER IT
         (WRAP-STRING (STRINGIFY (%CONS-ITERATOR.VALUE IT)))))
       (CL:T
        (CL:IF (CL:EQ (%CONS-ITERATOR.VALUE IT) SYM-STREAMS-STELLA-EOL)
         (VALUE-SETTER IT (WRAP-STRING EOL-STRING))
         (VALUE-SETTER IT
          (LIST* SYM-STREAMS-STELLA-STRINGIFY (%CONS-ITERATOR.VALUE IT)
           NIL))))))))
   (CL:RETURN-FROM FORMAT-STRING-MESSAGE-ARGUMENTS FORMATTEDARGUMENTS)))

;;; (DEFMACRO MESSAGE-TO-STRING ...)

(CL:DEFUN MESSAGE-TO-STRING (BODY)
  (CL:LET*
   ((MESSAGEARGUMENTS (FORMAT-STRING-MESSAGE-ARGUMENTS BODY CL:NIL))
    (MESSAGEVAR (LOCAL-GENSYM "MESSAGE")))
   (CL:RETURN-FROM MESSAGE-TO-STRING
    (LIST* SYM-STREAMS-STELLA-VRLET
     (CONS
      (CONS MESSAGEVAR
       (LIST* SYM-STREAMS-STELLA-STRING SYM-STREAMS-STELLA-NULL NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-SPECIAL
      (CONS
       (LIST* SYM-STREAMS-STELLA-*PRINTREADABLY?*
        SYM-STREAMS-STELLA-TRUE NIL)
       NIL)
      (LIST* SYM-STREAMS-STELLA-SETQ MESSAGEVAR
       (CONS
        (CONS SYM-STREAMS-STELLA-CONCATENATE
         (CONCATENATE MESSAGEARGUMENTS NIL))
        NIL))
      NIL)
     MESSAGEVAR NIL))))

;;; (DEFUN (TERMINATE-OUTPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-OUTPUT-STREAM? (SELF)
  (CL:LET* ((NATIVE-STREAM (%OUTPUT-STREAM.NATIVE-STREAM SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVE-STREAM NULL))
    (CL:CLOSE NATIVE-STREAM))
   (CL:SETF (%OUTPUT-STREAM.NATIVE-STREAM SELF) NULL)
   (CL:SETF (%OUTPUT-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
   (CL:RETURN-FROM TERMINATE-OUTPUT-STREAM? CL:T)))

;;; (DEFUN (TERMINATE-INPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-INPUT-STREAM? (SELF)
  (CL:LET* ((NATIVE-STREAM (%INPUT-STREAM.NATIVE-STREAM SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVE-STREAM NULL))
    (CL:CLOSE NATIVE-STREAM))
   (CL:SETF (%INPUT-STREAM.NATIVE-STREAM SELF) NULL)
   (CL:SETF (%INPUT-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
   (CL:RETURN-FROM TERMINATE-INPUT-STREAM? CL:T)))

;;; (DEFGLOBAL *OPEN-FILE-STREAMS* ...)

(CL:DEFVAR *OPEN-FILE-STREAMS* NULL
  "List of file streams that are currently open.")

;;; (DEFUN (OPEN-OUTPUT-FILE FILE-OUTPUT-STREAM) ...)

(CL:DEFUN OPEN-OUTPUT-FILE (FILENAME CL:&REST OPTIONS)
  "Open file `fileName' for output and return the resulting output stream.
By default the file will be created or overwritten if it already exists.
If `:IF-EXISTS' (or `:IF-EXISTS-ACTION') is one of the `options' its value
specifies what to do in case the file already exists.  If the value is
`:SUPERSEDE' the pre-existing file will be overwritten.  If the value is
`:APPEND' the preexisting file will be appended to (if the file did not
yet exist the file will simply be created).  If the value is `:ERROR' then
an error will be signaled.  If it is `:ABORT' or `:PROBE' the opening operation
will be aborted and NULL will be returned.

If `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') is one of the `options' its
value specifies what to do in case the file does not already exist.  If the
value is `:CREATE', the file will simply be created.  If the value is
`:CREATE-PATH' the file will be created plus any non-existing directories
in the directory path of `fileName' will also be created.  If the value is
`:ERROR' then an error will be signaled.  If it is `:ABORT' or `:PROBE' the
opening operation will be aborted and NULL will be returned."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((STREAM (NEW-OUTPUT-FILE-STREAM STELLA::NULL-STRING)))
   (CL:LET* ((ARGLIST-000 NIL))
    (CL:LET* ((ARG-000 NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
     (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
        (CL:IF (CL:EQ ARGLIST-000 NIL)
         (CL:SETQ ARGLIST-000 COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
    (CL:LET*
     ((THEOPTIONS
       (VET-OPTIONS ARGLIST-000
        (LIST* KWD-STREAMS-IF-EXISTS KWD-STREAMS-IF-EXISTS-ACTION
         KWD-STREAMS-IF-NOT-EXISTS KWD-STREAMS-IF-NOT-EXISTS-ACTION
         NIL))))
     (CL:LET* ((TEMP-000 (LOOKUP THEOPTIONS KWD-STREAMS-IF-EXISTS)))
      (CL:LET* ((CHOOSE-VALUE-000 NULL))
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL))
        (CL:SETQ CHOOSE-VALUE-000 TEMP-000)
        (CL:LET*
         ((TEMP-001 (LOOKUP THEOPTIONS KWD-STREAMS-IF-EXISTS-ACTION)))
         (CL:SETQ CHOOSE-VALUE-000
          (CL:IF (CL:NOT (CL:EQ TEMP-001 NULL)) TEMP-001
           KWD-STREAMS-SUPERSEDE))))
       (CL:SETF (%OUTPUT-FILE-STREAM.IF-EXISTS-ACTION STREAM)
        CHOOSE-VALUE-000)))
     (CL:LET*
      ((TEMP-002 (LOOKUP THEOPTIONS KWD-STREAMS-IF-NOT-EXISTS)))
      (CL:LET* ((CHOOSE-VALUE-001 NULL))
       (CL:IF (CL:NOT (CL:EQ TEMP-002 NULL))
        (CL:SETQ CHOOSE-VALUE-001 TEMP-002)
        (CL:LET*
         ((TEMP-003
           (LOOKUP THEOPTIONS KWD-STREAMS-IF-NOT-EXISTS-ACTION)))
         (CL:SETQ CHOOSE-VALUE-001
          (CL:IF (CL:NOT (CL:EQ TEMP-003 NULL)) TEMP-003
           KWD-STREAMS-CREATE))))
       (CL:SETF (%OUTPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION STREAM)
        CHOOSE-VALUE-001)))
     (CL:SETF (%OUTPUT-FILE-STREAM.FILENAME STREAM) FILENAME)
     (INITIALIZE-FILE-OUTPUT-STREAM STREAM)
     (CL:WHEN (CL:EQ (%OUTPUT-FILE-STREAM.NATIVE-STREAM STREAM) NULL)
      (CLOSE-STREAM STREAM) (CL:SETQ STREAM NULL))
     (CL:RETURN-FROM OPEN-OUTPUT-FILE STREAM)))))

;;; (DEFUN INITIALIZE-FILE-OUTPUT-STREAM ...)

(CL:DEFUN INITIALIZE-FILE-OUTPUT-STREAM (SELF)
  (CL:WHEN
   (CL:EQ (%OUTPUT-FILE-STREAM.FILENAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM INITIALIZE-FILE-OUTPUT-STREAM))
  (CL:LET*
   ((FILENAME
     (TRANSLATE-LOGICAL-PATHNAME (%OUTPUT-FILE-STREAM.FILENAME SELF)))
    (APPEND CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
   (CL:LET*
    ((TEST-VALUE-000 (%OUTPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION SELF)))
    (CL:COND ((CL:EQ TEST-VALUE-000 KWD-STREAMS-CREATE))
     ((CL:EQ TEST-VALUE-000 KWD-STREAMS-CREATE-PATH)
      (%ENSURE-DIRECTORIES-EXIST FILENAME))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-STREAMS-ABORT)
       (CL:EQ TEST-VALUE-000 KWD-STREAMS-PROBE))
      (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
       (CL:RETURN-FROM INITIALIZE-FILE-OUTPUT-STREAM)))
     ((CL:EQ TEST-VALUE-000 KWD-STREAMS-ERROR)
      (ENSURE-FILE-EXISTS FILENAME "initialize-file-output-stream"))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "initialize-file-output-stream: illegal :if-not-exists action: `"
        (%OUTPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION SELF) "'")
       (CL:ERROR
        (NEW-BAD-ARGUMENT-EXCEPTION
         (THE-STRING-READER STREAM-000)))))))
   (CL:LET*
    ((TEST-VALUE-001 (%OUTPUT-FILE-STREAM.IF-EXISTS-ACTION SELF)))
    (CL:COND ((CL:EQ TEST-VALUE-001 KWD-STREAMS-SUPERSEDE))
     ((CL:EQ TEST-VALUE-001 KWD-STREAMS-APPEND) (CL:SETQ APPEND CL:T))
     ((CL:OR (CL:EQ TEST-VALUE-001 KWD-STREAMS-ABORT)
       (CL:EQ TEST-VALUE-001 KWD-STREAMS-PROBE))
      (CL:WHEN (PROBE-FILE? FILENAME)
       (CL:RETURN-FROM INITIALIZE-FILE-OUTPUT-STREAM)))
     ((CL:EQ TEST-VALUE-001 KWD-STREAMS-ERROR)
      (ENSURE-FILE-DOES-NOT-EXIST FILENAME
       "initialize-file-output-stream"))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "initialize-file-output-stream: illegal :if-exists action: `"
        (%OUTPUT-FILE-STREAM.IF-EXISTS-ACTION SELF) "'")
       (CL:ERROR
        (NEW-BAD-ARGUMENT-EXCEPTION
         (THE-STRING-READER STREAM-001)))))))
   (CL:SETF (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF)
    (CL:OPEN FILENAME :DIRECTION :OUTPUT :IF-EXISTS
     (CL:IF APPEND :APPEND :SUPERSEDE) :IF-DOES-NOT-EXIST :CREATE
     :EXTERNAL-FORMAT STELLA-CHARSET))
   (CL:WHEN (CL:EQ (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF) NULL)
    (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
      "initialize-file-output-stream: Could not open `" SELF "'")
     (CL:ERROR
      (NEW-INPUT-OUTPUT-EXCEPTION (THE-STRING-READER STREAM-002)))))
   (CL:SETF (%OUTPUT-FILE-STREAM.STATE SELF) KWD-STREAMS-OPEN)
   (PUSH *OPEN-FILE-STREAMS* SELF))
  :VOID)

;;; (DEFUN (TERMINATE-FILE-OUTPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-FILE-OUTPUT-STREAM? (SELF)
  (CL:LET* ((NATIVE-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVE-STREAM NULL))
    (CL:CLOSE NATIVE-STREAM))
   (CL:SETF (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF) NULL)
   (CL:SETF (%OUTPUT-FILE-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
   (REMOVE *OPEN-FILE-STREAMS* SELF)
   (CL:RETURN-FROM TERMINATE-FILE-OUTPUT-STREAM? CL:T)))

;;; (DEFUN (OPEN-INPUT-FILE FILE-INPUT-STREAM) ...)

(CL:DEFUN OPEN-INPUT-FILE (FILENAME CL:&REST OPTIONS)
  "Open file `fileName' for input and return the resulting input stream.
By default signal an error if the file does not exist.  The only legal
option so far is `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') which
specifies what to do in case the file does not exist.  If its value is
`:ERROR' then an error will be signaled.  If it is `:ABORT' or `:PROBE'
the opening operation will be aborted and NULL will be returned."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((STREAM (NEW-INPUT-FILE-STREAM STELLA::NULL-STRING)))
   (CL:LET* ((ARGLIST-000 NIL))
    (CL:LET* ((ARG-000 NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
     (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
        (CL:IF (CL:EQ ARGLIST-000 NIL)
         (CL:SETQ ARGLIST-000 COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
    (CL:LET*
     ((THEOPTIONS
       (VET-OPTIONS ARGLIST-000
        (LIST* KWD-STREAMS-IF-NOT-EXISTS
         KWD-STREAMS-IF-NOT-EXISTS-ACTION NIL))))
     (CL:LET*
      ((TEMP-000 (LOOKUP THEOPTIONS KWD-STREAMS-IF-NOT-EXISTS)))
      (CL:LET* ((CHOOSE-VALUE-000 NULL))
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL))
        (CL:SETQ CHOOSE-VALUE-000 TEMP-000)
        (CL:LET*
         ((TEMP-001
           (LOOKUP THEOPTIONS KWD-STREAMS-IF-NOT-EXISTS-ACTION)))
         (CL:SETQ CHOOSE-VALUE-000
          (CL:IF (CL:NOT (CL:EQ TEMP-001 NULL)) TEMP-001
           KWD-STREAMS-ERROR))))
       (CL:SETF (%INPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION STREAM)
        CHOOSE-VALUE-000)))
     (CL:SETF (%INPUT-FILE-STREAM.FILENAME STREAM) FILENAME)
     (INITIALIZE-FILE-INPUT-STREAM STREAM)
     (CL:WHEN (CL:EQ (%INPUT-FILE-STREAM.NATIVE-STREAM STREAM) NULL)
      (CLOSE-STREAM STREAM) (CL:SETQ STREAM NULL))
     (CL:RETURN-FROM OPEN-INPUT-FILE STREAM)))))

;;; (DEFUN INITIALIZE-FILE-INPUT-STREAM ...)

(CL:DEFUN INITIALIZE-FILE-INPUT-STREAM (SELF)
  (CL:WHEN
   (CL:EQ (%INPUT-FILE-STREAM.FILENAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM INITIALIZE-FILE-INPUT-STREAM))
  (CL:LET*
   ((FILENAME
     (TRANSLATE-LOGICAL-PATHNAME (%INPUT-FILE-STREAM.FILENAME SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
   (CL:LET*
    ((TEST-VALUE-000 (%INPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-STREAMS-ABORT)
       (CL:EQ TEST-VALUE-000 KWD-STREAMS-PROBE))
      (CL:WHEN (CL:NOT (PROBE-FILE? FILENAME))
       (CL:RETURN-FROM INITIALIZE-FILE-INPUT-STREAM)))
     ((CL:EQ TEST-VALUE-000 KWD-STREAMS-ERROR)
      (ENSURE-FILE-EXISTS FILENAME "initialize-file-input-stream"))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "initialize-file-input-stream: illegal :if-not-exists action: `"
        (%INPUT-FILE-STREAM.IF-NOT-EXISTS-ACTION SELF) "'")
       (CL:ERROR
        (NEW-BAD-ARGUMENT-EXCEPTION
         (THE-STRING-READER STREAM-000)))))))
   (CL:SETF (%INPUT-FILE-STREAM.NATIVE-STREAM SELF)
    (CL:OPEN FILENAME :DIRECTION :INPUT :IF-DOES-NOT-EXIST :ERROR
     :EXTERNAL-FORMAT STELLA-CHARSET))
   (CL:WHEN (CL:EQ (%INPUT-FILE-STREAM.NATIVE-STREAM SELF) NULL)
    (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
      "initialize-file-input-stream: Could not open `" SELF "'")
     (CL:ERROR
      (NEW-INPUT-OUTPUT-EXCEPTION (THE-STRING-READER STREAM-001)))))
   (CL:SETF (%INPUT-FILE-STREAM.STATE SELF) KWD-STREAMS-OPEN)
   (PUSH *OPEN-FILE-STREAMS* SELF))
  :VOID)

;;; (DEFUN (TERMINATE-FILE-INPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-FILE-INPUT-STREAM? (SELF)
  (CL:LET* ((NATIVE-STREAM (%INPUT-FILE-STREAM.NATIVE-STREAM SELF)))
   (CL:WHEN (CL:NOT (CL:EQ NATIVE-STREAM NULL))
    (CL:CLOSE NATIVE-STREAM))
   (CL:SETF (%INPUT-FILE-STREAM.NATIVE-STREAM SELF) NULL)
   (CL:SETF (%INPUT-FILE-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
   (REMOVE *OPEN-FILE-STREAMS* SELF)
   (CL:RETURN-FROM TERMINATE-FILE-INPUT-STREAM? CL:T)))

;;; (DEFUN INITIALIZE-STRING-OUTPUT-STREAM ...)

(CL:DEFUN INITIALIZE-STRING-OUTPUT-STREAM (SELF)
  (CL:SETF (%OUTPUT-STRING-STREAM.NATIVE-STREAM SELF)
   (CL:let ((stream (CL:make-string-output-stream)))
         #+(or allegro cmu) (CL:ignore-errors (CL:setf (CL:stream-external-format stream) STELLA-CHARSET))
         stream))
  :VOID)

;;; (DEFUN (TERMINATE-STRING-OUTPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-STRING-OUTPUT-STREAM? (SELF)
  (CL:SETF (%OUTPUT-STRING-STREAM.NATIVE-STREAM SELF) NULL)
  (CL:SETF (%OUTPUT-STRING-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
  (CL:RETURN-FROM TERMINATE-STRING-OUTPUT-STREAM? CL:T))

;;; (DEFMETHOD (THE-STRING-READER STRING) ...)

(CL:DEFMETHOD THE-STRING-READER ((SELF OUTPUT-STRING-STREAM))
  (CL:LET*
   ((NATIVE-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM SELF))
    (STRING STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (SETQ STRING (CL:GET-OUTPUT-STREAM-STRING NATIVE-STREAM))
   (CL:WHEN (CL:EQ STRING STELLA::NULL-STRING) (CL:SETQ STRING ""))
   (CL:RETURN-FROM THE-STRING-READER STRING)))

;;; (DEFUN INITIALIZE-STRING-INPUT-STREAM ...)

(CL:DEFUN INITIALIZE-STRING-INPUT-STREAM (SELF)
  (CL:LET* ((STRING (%INPUT-STRING-STREAM.THE-STRING SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:SETF (%INPUT-STRING-STREAM.NATIVE-STREAM SELF)
    (CL:let ((stream (CL:make-string-input-stream string)))
         #+(or allegro cmu) (CL:ignore-errors (CL:setf (CL:stream-external-format stream) STELLA-CHARSET))
         stream)))
  :VOID)

;;; (DEFUN (TERMINATE-STRING-INPUT-STREAM? BOOLEAN) ...)

(CL:DEFUN TERMINATE-STRING-INPUT-STREAM? (SELF)
  (CL:SETF (%INPUT-STRING-STREAM.NATIVE-STREAM SELF) NULL)
  (CL:SETF (%INPUT-STRING-STREAM.STATE SELF) KWD-STREAMS-CLOSED)
  (CL:RETURN-FROM TERMINATE-STRING-INPUT-STREAM? CL:T))

;;; (DEFUN CLOSE-STREAM ...)

(CL:DEFUN CLOSE-STREAM (SELF)
  "Close the stream `self'."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-INPUT-FILE-STREAM)
     (CL:PROGN (TERMINATE-FILE-INPUT-STREAM? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-OUTPUT-FILE-STREAM)
     (CL:PROGN (TERMINATE-FILE-OUTPUT-STREAM? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-STREAMS-STELLA-INPUT-STRING-STREAM)
     (CL:PROGN (TERMINATE-STRING-INPUT-STREAM? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-STREAMS-STELLA-OUTPUT-STRING-STREAM)
     (CL:PROGN (TERMINATE-STRING-OUTPUT-STREAM? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-INPUT-STREAM)
     (CL:PROGN (TERMINATE-INPUT-STREAM? SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-OUTPUT-STREAM)
     (CL:PROGN (TERMINATE-OUTPUT-STREAM? SELF)))
    (CL:T)))
  :VOID)

;;; (DEFUN CLEAR-INPUT ...)

(CL:DEFUN CLEAR-INPUT (SELF)
  "Clear all buffered raw and tokenized input of `self'."
  (CL:LET* ((NATIVE-STREAM (%INPUT-STREAM.NATIVE-STREAM SELF)))
   (CL:CLEAR-INPUT NATIVE-STREAM)
   (CL:SETF (%INPUT-STREAM.TOKENIZER-STATE SELF) NULL))
  :VOID)

;;; (DEFUN FLUSH-OUTPUT ...)

(CL:DEFUN FLUSH-OUTPUT (SELF)
  "Flush all buffered output of `self'."
  (CL:LET* ((NATIVE-STREAM (%OUTPUT-STREAM.NATIVE-STREAM SELF)))
   (CL:FORCE-OUTPUT NATIVE-STREAM))
  :VOID)

;;; (DEFUN CLOSE-ALL-FILES ...)

(CL:DEFUN CLOSE-ALL-FILES ()
  "Close all currently open file streams.  Use for emergencies or for cleanup."
  (CL:LET* ((OPENSTREAMS (COPY *OPEN-FILE-STREAMS*)))
   (CL:LET*
    ((STREAM NULL) (ITER-000 (%LIST.THE-CONS-LIST OPENSTREAMS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ STREAM (%%VALUE ITER-000)) (CLOSE-STREAM STREAM)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (FREE OPENSTREAMS))
  :VOID)

;;; (DEFUN (OPEN-NETWORK-STREAM INPUT-STREAM OUTPUT-STREAM) ...)

(CL:DEFUN OPEN-NETWORK-STREAM (HOST PORT)
  "Open a TCP/IP network stream to `host' at `port' and return the result
as an input/output stream pair."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING HOST) (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  (CL:LET* ((IN NULL) (OUT NULL)) (CL:progn
         (CL:setq in (%%open-network-stream host port))
         (setq out in)
         #+(or allegro cmu) (CL:ignore-errors (CL:setf (CL:stream-external-format in) STELLA-CHARSET)))
   (CL:LET* ((SELF-000 (NEW-INPUT-STREAM)))
    (CL:SETF (%INPUT-STREAM.NATIVE-STREAM SELF-000) IN)
    (CL:SETF (%INPUT-STREAM.STATE SELF-000) KWD-STREAMS-OPEN)
    (CL:SETF (%INPUT-STREAM.BUFFERING-SCHEME SELF-000)
     KWD-STREAMS-BLOCK)
    (CL:LET* ((VALUE-000 SELF-000))
     (CL:LET* ((SELF-001 (NEW-OUTPUT-STREAM)))
      (CL:SETF (%OUTPUT-STREAM.NATIVE-STREAM SELF-001) OUT)
      (CL:SETF (%OUTPUT-STREAM.STATE SELF-001) KWD-STREAMS-OPEN)
      (CL:LET* ((VALUE-001 SELF-001))
       (CL:RETURN-FROM OPEN-NETWORK-STREAM
        (CL:VALUES VALUE-000 VALUE-001))))))))

;;; (DEFMACRO WITH-INPUT-FILE ...)

(CL:DEFUN WITH-INPUT-FILE (BINDING BODY)
  "Sets up an unwind-protected form which opens a file for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is `(WITH-INPUT-FILE (var filename options*) body+)' where `options'
can be any that are legal for `open-input-file' (which see)."
  (CL:LET* ((VAR (%%VALUE BINDING)))
   (CL:RETURN-FROM WITH-INPUT-FILE
    (LIST* SYM-STREAMS-STELLA-LET
     (CONS
      (CONS VAR
       (LIST* SYM-STREAMS-STELLA-FILE-INPUT-STREAM
        SYM-STREAMS-STELLA-NULL NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-UNWIND-PROTECT
      (LIST* SYM-STREAMS-STELLA-PROGN
       (LIST* SYM-STREAMS-STELLA-SETQ VAR
        (CONS
         (LIST* SYM-STREAMS-STELLA-OPEN-INPUT-FILE
          (%%VALUE (%%REST BINDING))
          (CONCATENATE (%%REST (%%REST BINDING)) NIL))
         NIL))
       (CONCATENATE BODY NIL))
      (LIST* SYM-STREAMS-STELLA-WHEN
       (LIST* SYM-STREAMS-STELLA-DEFINED? VAR NIL)
       (LIST* SYM-STREAMS-STELLA-FREE VAR NIL) NIL)
      NIL)
     NIL))))

;;; (DEFMACRO WITH-OUTPUT-FILE ...)

(CL:DEFUN WITH-OUTPUT-FILE (BINDING BODY)
  "Sets up an unwind-protected form which opens a file for
output and closes it afterwards.  The stream for writing is bound to the
variable provided in the macro form.
Syntax is `(WITH-OUTPUT-FILE (var filename options*) body+)' where `options'
can be any that are legal for `open-output-file' (which see)."
  (CL:LET* ((VAR (%%VALUE BINDING)))
   (CL:RETURN-FROM WITH-OUTPUT-FILE
    (LIST* SYM-STREAMS-STELLA-LET
     (CONS
      (CONS VAR
       (LIST* SYM-STREAMS-STELLA-FILE-OUTPUT-STREAM
        SYM-STREAMS-STELLA-NULL NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-UNWIND-PROTECT
      (LIST* SYM-STREAMS-STELLA-PROGN
       (LIST* SYM-STREAMS-STELLA-SETQ VAR
        (CONS
         (LIST* SYM-STREAMS-STELLA-OPEN-OUTPUT-FILE
          (%%VALUE (%%REST BINDING))
          (CONCATENATE (%%REST (%%REST BINDING)) NIL))
         NIL))
       (CONCATENATE BODY NIL))
      (LIST* SYM-STREAMS-STELLA-WHEN
       (LIST* SYM-STREAMS-STELLA-DEFINED? VAR NIL)
       (LIST* SYM-STREAMS-STELLA-FREE VAR NIL) NIL)
      NIL)
     NIL))))

;;; (DEFMACRO WITH-NETWORK-STREAM ...)

(CL:DEFUN WITH-NETWORK-STREAM (BINDING BODY)
  "Sets up an unwind-protected form which opens a network
socket stream to a host and port for input and output and closes it afterwards.
Separate variables as provided in the call are bound to the input and output
streams. Syntax is (WITH-NETWORK-STREAM (varIn varOut hostname port) body+)"
  (CL:LET*
   ((VAR-IN (%%VALUE BINDING)) (VAR-OUT (%%VALUE (%%REST BINDING))))
   (CL:RETURN-FROM WITH-NETWORK-STREAM
    (LIST* SYM-STREAMS-STELLA-LET
     (LIST*
      (CONS VAR-IN
       (LIST* SYM-STREAMS-STELLA-INPUT-STREAM SYM-STREAMS-STELLA-NULL
        NIL))
      (CONS VAR-OUT
       (LIST* SYM-STREAMS-STELLA-OUTPUT-STREAM SYM-STREAMS-STELLA-NULL
        NIL))
      NIL)
     (LIST* SYM-STREAMS-STELLA-UNWIND-PROTECT
      (LIST* SYM-STREAMS-STELLA-PROGN
       (LIST* SYM-STREAMS-STELLA-MV-SETQ
        (CONS VAR-IN (CONS VAR-OUT NIL))
        (LIST* SYM-STREAMS-STELLA-OPEN-NETWORK-STREAM
         (%%VALUE (%%REST (%%REST BINDING)))
         (CONS (FOURTH BINDING) NIL))
        NIL)
       (CONCATENATE BODY NIL))
      (LIST* SYM-STREAMS-STELLA-WHEN
       (LIST* SYM-STREAMS-STELLA-DEFINED? VAR-IN NIL)
       (LIST* SYM-STREAMS-STELLA-FREE VAR-IN NIL) NIL)
      (LIST* SYM-STREAMS-STELLA-WHEN
       (LIST* SYM-STREAMS-STELLA-DEFINED? VAR-OUT NIL)
       (LIST* SYM-STREAMS-STELLA-FREE VAR-OUT NIL) NIL)
      NIL)
     NIL))))

;;; (DEFUN (NATIVE-FILE-INPUT-STREAM-POSITION LONG-INTEGER) ...)

(CL:DEFUN NATIVE-FILE-INPUT-STREAM-POSITION (NSTREAM)
  (CL:RETURN-FROM NATIVE-FILE-INPUT-STREAM-POSITION
   (CL:file-position nstream)))

;;; (DEFUN (NATIVE-FILE-INPUT-STREAM-POSITION-SETTER LONG-INTEGER) ...)

(CL:DEFUN NATIVE-FILE-INPUT-STREAM-POSITION-SETTER (NSTREAM NEWPOS)
  (CL:file-position nstream newpos)
  (CL:RETURN-FROM NATIVE-FILE-INPUT-STREAM-POSITION-SETTER NEWPOS))

;;; (DEFMETHOD (STREAM-POSITION LONG-INTEGER) ...)

(CL:DEFMETHOD STREAM-POSITION ((SELF INPUT-FILE-STREAM))
  "Return the current position of the file input cursor in `self'."
  (CL:LET*
   ((POSITION
     (NATIVE-FILE-INPUT-STREAM-POSITION
      (%INPUT-FILE-STREAM.NATIVE-STREAM SELF)))
    (STATE (%INPUT-FILE-STREAM.TOKENIZER-STATE SELF)))
   (CL:WHEN (CL:NOT (CL:EQ STATE NULL))
    (CL:SETQ POSITION (CL:- POSITION (BUFFERED-INPUT-LENGTH STATE))))
   (CL:RETURN-FROM STREAM-POSITION POSITION)))

;;; (DEFMETHOD (STREAM-POSITION-SETTER LONG-INTEGER) ...)

(CL:DEFMETHOD STREAM-POSITION-SETTER ((SELF INPUT-FILE-STREAM) NEWPOS)
  "Set the current position of the file input cursor in `self' to `newpos'.
If `self' has any tokenizer state associated with it, this will also reset
to the start state of the tokenizer table; otherwise, behavior would be
unpredictable unless the character class of the new position is exactly the
same as the one following the most recent token."
  (CL:LET*
   ((NSTREAM (%INPUT-FILE-STREAM.NATIVE-STREAM SELF))
    (STATE (%INPUT-FILE-STREAM.TOKENIZER-STATE SELF)))
   (CL:WHEN (CL:NOT (CL:EQ STATE NULL))
    (CL:LET*
     ((FILEPOSITION (NATIVE-FILE-INPUT-STREAM-POSITION NSTREAM))
      (OFFSET (CL:- FILEPOSITION NEWPOS)) (BUFFERED 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM BUFFERED))
     (CL:WHEN (CL:> OFFSET 0)
      (CL:SETQ BUFFERED (BUFFERED-INPUT-LENGTH STATE))
      (CL:WHEN (CL:<= OFFSET BUFFERED)
       (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR STATE)
        (CL:TRUNCATE
         (MOD
          (CL:+ (%TOKENIZER-STREAM-STATE.CURSOR STATE)
           (CL:- BUFFERED OFFSET))
          (CL:TRUNCATE (%TOKENIZER-STREAM-STATE.BUFFER-SIZE STATE)))))
       (RESET STATE) (CL:RETURN-FROM STREAM-POSITION-SETTER NEWPOS)))
     (CLEAR STATE) (RESET STATE)))
   (NATIVE-FILE-INPUT-STREAM-POSITION-SETTER NSTREAM NEWPOS)
   (CL:RETURN-FROM STREAM-POSITION-SETTER NEWPOS)))

;;; (DEFUN (NATIVE-FILE-OUTPUT-STREAM-POSITION LONG-INTEGER) ...)

(CL:DEFUN NATIVE-FILE-OUTPUT-STREAM-POSITION (NSTREAM)
  (CL:RETURN-FROM NATIVE-FILE-OUTPUT-STREAM-POSITION
   (CL:file-position nstream)))

;;; (DEFUN (NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER LONG-INTEGER) ...)

(CL:DEFUN NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER (NSTREAM NEWPOS)
  (CL:file-position nstream newpos)
  (CL:RETURN-FROM NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER NEWPOS))

;;; (DEFMETHOD (STREAM-POSITION LONG-INTEGER) ...)

(CL:DEFMETHOD STREAM-POSITION ((SELF OUTPUT-FILE-STREAM))
  "Return the current position of the file input cursor in `self'."
  (CL:RETURN-FROM STREAM-POSITION
   (CL:LET ((NSTREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF)))
    (CL:file-position nstream))))

;;; (DEFMETHOD (STREAM-POSITION-SETTER LONG-INTEGER) ...)

(CL:DEFMETHOD STREAM-POSITION-SETTER ((SELF OUTPUT-FILE-STREAM) NEWPOS)
  "Set the current position of the file input cursor in `self' to `newpos'."
  (NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER
   (%OUTPUT-FILE-STREAM.NATIVE-STREAM SELF) NEWPOS)
  (CL:RETURN-FROM STREAM-POSITION-SETTER NEWPOS))

;;; (DEFGLOBAL *HTML-QUOTED-CHARACTERS* ...)

(CL:DEFVAR *HTML-QUOTED-CHARACTERS* "><&\"")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *HTML-QUOTED-CHARACTERS*))

;;; (DEFUN (EXPAND-MARKUP-TAG-FUNCTION CONS) ...)

(CL:DEFUN EXPAND-MARKUP-TAG-FUNCTION (TAG-AND-STREAM BODY XML?)
  (CL:LET*
   ((TAG (%%VALUE TAG-AND-STREAM)) (TAGVAR NULL)
    (TAGVALUE STELLA::NULL-STRING)
    (STREAM (%%VALUE (%%REST TAG-AND-STREAM)))
    (EOLARGUMENT (%%VALUE (%%REST (%%REST TAG-AND-STREAM))))
    (EOL?
     (CL:AND (CL:NOT (CL:EQ EOLARGUMENT NULL))
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       (COERCE-TO-BOOLEAN EOLARGUMENT)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TAGVALUE))
   (CL:IF (CL:EQ BODY NIL)
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TAG)))
     (CL:COND
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN
        (CL:IF EOL?
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
           (CONS
            (WRAP-STRING
             (CONCATENATE "<" (%STRING-WRAPPER.WRAPPER-VALUE TAG)
              (CL:IF XML? "/>" ">")))
            (CONS SYM-STREAMS-STELLA-EOL NIL))))
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
           (CONS
            (WRAP-STRING
             (CONCATENATE "<" (%STRING-WRAPPER.WRAPPER-VALUE TAG)
              (CL:IF XML? "/>" ">")))
            NIL))))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-OBJECT)
       (CL:PROGN
        (CL:IF EOL?
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
           (LIST* (WRAP-STRING "<") TAG
            (CONS (CL:IF XML? (WRAP-STRING "/>") (WRAP-STRING ">"))
             (CONS SYM-STREAMS-STELLA-EOL NIL)))))
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
           (LIST* (WRAP-STRING "<") TAG
            (CONS (CL:IF XML? (WRAP-STRING "/>") (WRAP-STRING ">"))
             NIL)))))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TAG)))
     (CL:COND
      ((SUBTYPE-OF-STRING? TEST-VALUE-001)
       (CL:PROGN (CL:SETQ TAGVALUE (%STRING-WRAPPER.WRAPPER-VALUE TAG))
        (CL:IF EOL?
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PROGN
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (CONS (WRAP-STRING (CONCATENATE "<" TAGVALUE ">")) NIL))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (CONS
               (WRAP-STRING
                (CONCATENATE "</"
                 (SUBSEQUENCE TAGVALUE 0 (POSITION TAGVALUE #\  0))
                 ">"))
               (CONS SYM-STREAMS-STELLA-EOL NIL)))
             NIL))))
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PROGN
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (CONS (WRAP-STRING (CONCATENATE "<" TAGVALUE ">")) NIL))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (CONS
               (WRAP-STRING
                (CONCATENATE "</"
                 (SUBSEQUENCE TAGVALUE 0 (POSITION TAGVALUE #\  0))
                 ">"))
               NIL))
             NIL)))))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
       (CL:PROGN
        (CL:IF EOL?
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PROGN
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (LIST* (WRAP-STRING "<") TAG (CONS (WRAP-STRING ">") NIL)))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (LIST* (WRAP-STRING "</")
               (LIST* SYM-STREAMS-STELLA-SUBSEQUENCE TAG
                (LIST* (WRAP-INTEGER 0)
                 (LIST* SYM-STREAMS-STELLA-POSITION TAG
                  (LIST* (WRAP-CHARACTER #\ ) (WRAP-INTEGER 0) NIL))
                 NIL))
               (WRAP-STRING ">") SYM-STREAMS-STELLA-EOL NIL))
             NIL))))
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-PROGN
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (LIST* (WRAP-STRING "<") TAG (CONS (WRAP-STRING ">") NIL)))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (LIST* (WRAP-STRING "</")
               (LIST* SYM-STREAMS-STELLA-SUBSEQUENCE TAG
                (LIST* (WRAP-INTEGER 0)
                 (LIST* SYM-STREAMS-STELLA-POSITION TAG
                  (LIST* (WRAP-CHARACTER #\ ) (WRAP-INTEGER 0) NIL))
                 NIL))
               (WRAP-STRING ">") NIL))
             NIL)))))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-STREAMS-STELLA-OBJECT)
       (CL:PROGN (CL:SETQ TAGVAR (GENSYM "TAG"))
        (CL:IF EOL?
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-LET
           (CONS
            (CONS TAGVAR (LIST* SYM-STREAMS-STELLA-STRING TAG NIL))
            NIL)
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (LIST* (WRAP-STRING "<") TAGVAR
             (CONS (WRAP-STRING ">") NIL)))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (LIST* (WRAP-STRING "</")
               (LIST* SYM-STREAMS-STELLA-SUBSEQUENCE TAGVAR
                (LIST* (WRAP-INTEGER 0)
                 (LIST* SYM-STREAMS-STELLA-POSITION TAGVAR
                  (LIST* (WRAP-CHARACTER #\ ) (WRAP-INTEGER 0) NIL))
                 NIL))
               (WRAP-STRING ">") SYM-STREAMS-STELLA-EOL NIL))
             NIL))))
         (CL:RETURN-FROM EXPAND-MARKUP-TAG-FUNCTION
          (LIST* SYM-STREAMS-STELLA-LET
           (CONS
            (CONS TAGVAR (LIST* SYM-STREAMS-STELLA-STRING TAG NIL))
            NIL)
           (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
            (LIST* (WRAP-STRING "<") TAGVAR
             (CONS (WRAP-STRING ">") NIL)))
           (CONCATENATE BODY
            (CONS
             (LIST* SYM-STREAMS-STELLA-PRINT-STREAM STREAM
              (LIST* (WRAP-STRING "</")
               (LIST* SYM-STREAMS-STELLA-SUBSEQUENCE TAGVAR
                (LIST* (WRAP-INTEGER 0)
                 (LIST* SYM-STREAMS-STELLA-POSITION TAGVAR
                  (LIST* (WRAP-CHARACTER #\ ) (WRAP-INTEGER 0) NIL))
                 NIL))
               (WRAP-STRING ">") NIL))
             NIL)))))))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
         TEST-VALUE-001 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))

;;; (DEFMACRO WITH-HTML-TAG ...)

(CL:DEFUN WITH-HTML-TAG (TAG-AND-STREAM BODY)
  (CL:RETURN-FROM WITH-HTML-TAG
   (EXPAND-MARKUP-TAG-FUNCTION TAG-AND-STREAM BODY CL:NIL)))

;;; (DEFMACRO WITH-XML-TAG ...)

(CL:DEFUN WITH-XML-TAG (TAG-AND-STREAM BODY)
  (CL:RETURN-FROM WITH-XML-TAG
   (EXPAND-MARKUP-TAG-FUNCTION TAG-AND-STREAM BODY CL:T)))

;;; (DEFUN (HTML-CHARACTER-NEEDS-QUOTING? BOOLEAN) ...)

(CL:DEFUN HTML-CHARACTER-NEEDS-QUOTING? (CH)
  (CL:RETURN-FROM HTML-CHARACTER-NEEDS-QUOTING?
   (MEMBER? *HTML-QUOTED-CHARACTERS* CH)))

;;; (DEFUN WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS ...)

(CL:DEFUN WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS (STREAM CH)
  (CL:CASE CH (#\> (%%PRINT-STREAM STREAM "&gt;"))
   (#\< (%%PRINT-STREAM STREAM "&lt;"))
   (#\& (%%PRINT-STREAM STREAM "&amp;"))
   (#\" (%%PRINT-STREAM STREAM "&quot;"))
   ((#\Linefeed #\Return)
    (%%PRINT-STREAM STREAM "&#" (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))
     ";"))
   (CL:OTHERWISE (%%PRINT-STREAM STREAM CH)))
  (CL:RETURN-FROM WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS)
  :VOID)

;;; (DEFUN WRITE-HTML-QUOTING-SPECIAL-CHARACTERS ...)

(CL:DEFUN WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (STREAM INPUT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:LET*
   ((CH NULL-CHARACTER) (VECTOR-000 INPUT) (INDEX-000 0)
    (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
    (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ CH
     (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))))
    (WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS STREAM CH)
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (CL:RETURN-FROM WRITE-HTML-QUOTING-SPECIAL-CHARACTERS)
  :VOID)

;;; (DEFUN WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS ...)

(CL:DEFUN WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS (STREAM INPUT)
  "Writes a string and replaces unallowed URL characters according to RFC 2396
with %-format URL escape sequences."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:LET*
   ((CH NULL-CHARACTER) (VECTOR-000 INPUT) (INDEX-000 0)
    (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
    (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ CH
     (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))))
    (CL:IF
     (CL:OR
      (CL:EQ
       (CL:AREF *CHARACTER-TYPE-TABLE*
        (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
       KWD-STREAMS-LETTER)
      (CL:EQ
       (CL:AREF *CHARACTER-TYPE-TABLE*
        (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
       KWD-STREAMS-DIGIT))
     (%%PRINT-STREAM STREAM CH)
     (CL:CASE CH ((#\- #\_ #\. #\~) (%%PRINT-STREAM STREAM CH))
      (CL:OTHERWISE
       (CL:LET* ((CODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
        (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
        (CL:IF (CL:< CODE 16)
         (%%PRINT-STREAM STREAM "%0"
          (INTEGER-TO-HEX-STRING (CL:TRUNCATE CODE)))
         (%%PRINT-STREAM STREAM "%"
          (INTEGER-TO-HEX-STRING (CL:TRUNCATE CODE))))))))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (CL:RETURN-FROM WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS)
  :VOID)

;;; (DEFUN (HEX-CHARACTER-VALUE INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) HEX-CHARACTER-VALUE))
(CL:DEFUN HEX-CHARACTER-VALUE (C)
  "Convert the base-16 hex character `c' into a base-10 number."
  (CL:LET* ((CODE (CL:THE CL:FIXNUM (CL:CHAR-CODE C))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE))
   (CL:COND
    ((CL:< CODE 65)
     (CL:RETURN-FROM HEX-CHARACTER-VALUE (CL:- CODE 48)))
    ((CL:< CODE 97)
     (CL:RETURN-FROM HEX-CHARACTER-VALUE (CL:- CODE 55)))
    (CL:T (CL:RETURN-FROM HEX-CHARACTER-VALUE (CL:- CODE 87))))))

;;; (DEFUN (UNESCAPE-URL-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  UNESCAPE-URL-STRING))
(CL:DEFUN UNESCAPE-URL-STRING (INPUT)
  "Takes a string and replaces %-format URL escape sequences with their real
character equivalent according to RFC 2396."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:IF (CL:= (POSITION INPUT #\% 0) NULL-INTEGER)
   (CL:RETURN-FROM UNESCAPE-URL-STRING INPUT)
   (CL:LET*
    ((RESULT
      (MAKE-RAW-MUTABLE-STRING (CL:THE CL:FIXNUM (CL:LENGTH INPUT))))
     (I-OUT 0) (I-IN 0) (CHAR-SAVE NULL-CHARACTER) (CHAR-VALUE 0)
     (ESCAPE-VALUE 0) (I-MAX (CL:THE CL:FIXNUM (CL:LENGTH INPUT))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT)
     (CL:TYPE CL:FIXNUM I-OUT I-IN CHAR-VALUE ESCAPE-VALUE I-MAX))
    (CL:LOOP WHILE (CL:< I-IN I-MAX) DO
     (CL:IF
      (CL:EQL
       (CL:LET ((SELF INPUT) (POSITION I-IN))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))
       #\%)
      (CL:PROGN (CL:SETQ I-IN (CL:1+ I-IN))
       (CL:IF (CL:< I-IN I-MAX)
        (CL:PROGN
         (CL:SETQ CHAR-SAVE
          (CL:LET ((SELF INPUT) (POSITION I-IN))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (CL:SETQ CHAR-VALUE (HEX-CHARACTER-VALUE CHAR-SAVE))
         (CL:SETQ I-IN (CL:1+ I-IN))
         (CL:IF
          (CL:AND (CL:NOT (CL:= CHAR-VALUE NULL-INTEGER))
           (CL:< I-IN I-MAX))
          (CL:PROGN (CL:SETQ ESCAPE-VALUE (CL:* 16 CHAR-VALUE))
           (CL:SETQ CHAR-VALUE
            (HEX-CHARACTER-VALUE
             (CL:LET ((SELF INPUT) (POSITION I-IN))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
               (CL:THE CL:FIXNUM POSITION)))))
           (CL:IF (CL:NOT (CL:= CHAR-VALUE NULL-INTEGER))
            (CL:PROGN
             (CL:LET
              ((SELF RESULT)
               (CH
                (CL:CODE-CHAR
                 (CL:THE CL:FIXNUM (CL:+ ESCAPE-VALUE CHAR-VALUE))))
               (POSITION I-OUT))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (SETF
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION))
               (CL:THE CL:CHARACTER CH))))
            (CL:PROGN
             (CL:LET ((SELF RESULT) (CH #\%) (POSITION I-OUT))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (SETF
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION))
               (CL:THE CL:CHARACTER CH)))
             (CL:LET
              ((SELF RESULT) (CH CHAR-SAVE)
               (POSITION (CL:SETQ I-OUT (CL:1+ I-OUT))))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (SETF
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION))
               (CL:THE CL:CHARACTER CH)))
             (CL:LET
              ((SELF RESULT)
               (CH
                (CL:LET ((SELF INPUT) (POSITION I-IN))
                 (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                  (CL:TYPE CL:FIXNUM POSITION))
                 (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                  (CL:THE CL:FIXNUM POSITION))))
               (POSITION (CL:SETQ I-OUT (CL:1+ I-OUT))))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (SETF
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION))
               (CL:THE CL:CHARACTER CH))))))
          (CL:PROGN
           (CL:LET ((SELF RESULT) (CH #\%) (POSITION I-OUT))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (SETF
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION))
             (CL:THE CL:CHARACTER CH)))
           (CL:LET
            ((SELF RESULT) (CH CHAR-SAVE)
             (POSITION (CL:SETQ I-OUT (CL:1+ I-OUT))))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (SETF
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION))
             (CL:THE CL:CHARACTER CH)))))
         (CL:SETQ I-OUT (CL:1+ I-OUT)) (CL:SETQ I-IN (CL:1+ I-IN)))
        (CL:PROGN
         (CL:LET ((SELF RESULT) (CH #\%) (POSITION I-OUT))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (SETF
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))
           (CL:THE CL:CHARACTER CH)))
         (CL:SETQ I-OUT (CL:1+ I-OUT)))))
      (CL:PROGN
       (CL:LET
        ((SELF RESULT)
         (CH
          (CL:LET ((SELF INPUT) (POSITION I-IN))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (POSITION I-OUT))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ I-OUT (CL:1+ I-OUT)) (CL:SETQ I-IN (CL:1+ I-IN)))))
    (CL:RETURN-FROM UNESCAPE-URL-STRING (SUBSEQUENCE RESULT 0 I-OUT)))))

;;; (DEFGLOBAL *HTML-ESCAPE-TABLE* ...)

(CL:DEFVAR *HTML-ESCAPE-TABLE* NULL)

;;; (DEFUN (UNESCAPE-HTML-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  UNESCAPE-HTML-STRING))
(CL:DEFUN UNESCAPE-HTML-STRING (INPUT)
  "Replaces HTML escape sequences such as &amp; with their
associated characters."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:LET*
   ((INCURSOR 0) (OUTCURSOR 0)
    (ESCAPESTART (POSITION INPUT #\& INCURSOR)) (ESCAPEEND -1)
    (INPUTLENGTH -1) (OUTPUT STELLA::NULL-STRING) (CHARACTER NULL))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM INCURSOR OUTCURSOR ESCAPESTART ESCAPEEND
     INPUTLENGTH)
    (CL:TYPE CL:SIMPLE-STRING OUTPUT))
   (CL:LOOP
    (CL:TAGBODY
     (CL:WHEN (CL:= ESCAPESTART NULL-INTEGER)
      (CL:IF (NULL? OUTPUT) (CL:RETURN-FROM UNESCAPE-HTML-STRING INPUT)
       (CL:RETURN)))
     (CL:SETQ ESCAPEEND (POSITION INPUT #\; ESCAPESTART))
     (CL:WHEN (CL:= ESCAPEEND NULL-INTEGER)
      (CL:IF (NULL? OUTPUT) (CL:RETURN-FROM UNESCAPE-HTML-STRING INPUT)
       (CL:RETURN)))
     (CL:SETQ CHARACTER
      (LOOKUP *HTML-ESCAPE-TABLE*
       (WRAP-STRING
        (SUBSEQUENCE INPUT (CL:1+ ESCAPESTART) ESCAPEEND))))
     (CL:WHEN (CL:EQ CHARACTER NULL)
      (CL:SETQ ESCAPESTART (POSITION INPUT #\& ESCAPEEND))
      (CL:GO :CONTINUE))
     (CL:WHEN (NULL? OUTPUT)
      (CL:SETQ INPUTLENGTH (CL:THE CL:FIXNUM (CL:LENGTH INPUT)))
      (CL:SETQ OUTPUT (MAKE-RAW-MUTABLE-STRING INPUTLENGTH)))
     (CL:LOOP WHILE (CL:< INCURSOR ESCAPESTART) DO
      (CL:LET
       ((SELF OUTPUT)
        (CH
         (CL:LET ((SELF INPUT) (POSITION INCURSOR))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (POSITION OUTCURSOR))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ INCURSOR (CL:1+ INCURSOR))
      (CL:SETQ OUTCURSOR (CL:1+ OUTCURSOR)))
     (CL:LET
      ((SELF OUTPUT) (CH (%CHARACTER-WRAPPER.WRAPPER-VALUE CHARACTER))
       (POSITION OUTCURSOR))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ OUTCURSOR (CL:1+ OUTCURSOR))
     (CL:SETQ INCURSOR (CL:1+ ESCAPEEND))
     (CL:SETQ ESCAPESTART (POSITION INPUT #\& ESCAPEEND)) :CONTINUE))
   (CL:LOOP WHILE (CL:< INCURSOR INPUTLENGTH) DO
    (CL:LET
     ((SELF OUTPUT)
      (CH
       (CL:LET ((SELF INPUT) (POSITION INCURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))))
      (POSITION OUTCURSOR))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (SETF
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION))
      (CL:THE CL:CHARACTER CH)))
    (CL:SETQ INCURSOR (CL:1+ INCURSOR))
    (CL:SETQ OUTCURSOR (CL:1+ OUTCURSOR)))
   (CL:RETURN-FROM UNESCAPE-HTML-STRING
    (SUBSEQUENCE
     (CL:LET ((S OUTPUT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
      (CL:THE CL:SIMPLE-STRING S))
     0 OUTCURSOR))))

(CL:DEFUN ACCESS-STREAM-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-STREAMS-STELLA-THE-STREAM)
    (CL:IF SETVALUE? (CL:SETF (%STREAM-ITERATOR.THE-STREAM SELF) VALUE)
     (CL:SETQ VALUE (%STREAM-ITERATOR.THE-STREAM SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STREAM-ITERATOR-SLOT-VALUE VALUE))

(CL:DEFUN NEW-S-EXPRESSION-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-S-EXPRESSION-ITERATOR))
   (CL:SETF (%S-EXPRESSION-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%S-EXPRESSION-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%S-EXPRESSION-ITERATOR.THE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-S-EXPRESSION-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF S-EXPRESSION-ITERATOR))
  (CL:WHEN (TERMINATE-STREAM-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF S-EXPRESSION-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-STREAMS-STELLA-S-EXPRESSION-ITERATOR))

(CL:DEFUN ACCESS-S-EXPRESSION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-STREAMS-STELLA-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%S-EXPRESSION-ITERATOR.VALUE SELF) VALUE)
     (CL:SETQ VALUE (%S-EXPRESSION-ITERATOR.VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-S-EXPRESSION-ITERATOR-SLOT-VALUE VALUE))

(CL:DEFUN NEW-LINE-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-LINE-ITERATOR))
   (CL:SETF (%LINE-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%LINE-ITERATOR.VALUE SELF) STELLA::NULL-STRING)
   (CL:SETF (%LINE-ITERATOR.THE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-LINE-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF LINE-ITERATOR))
  (CL:WHEN (TERMINATE-STREAM-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LINE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-STREAMS-STELLA-LINE-ITERATOR))

(CL:DEFUN ACCESS-LINE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-STREAMS-STELLA-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%LINE-ITERATOR.VALUE SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%LINE-ITERATOR.VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-LINE-ITERATOR-SLOT-VALUE VALUE))

(CL:DEFUN NEW-NATIVE-LINE-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-NATIVE-LINE-ITERATOR))
   (CL:SETF (%NATIVE-LINE-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%NATIVE-LINE-ITERATOR.VALUE SELF) STELLA::NULL-STRING)
   (CL:SETF (%NATIVE-LINE-ITERATOR.THE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-NATIVE-LINE-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF NATIVE-LINE-ITERATOR))
  (CL:WHEN (TERMINATE-STREAM-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NATIVE-LINE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-STREAMS-STELLA-NATIVE-LINE-ITERATOR))

(CL:DEFUN ACCESS-NATIVE-LINE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-STREAMS-STELLA-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%NATIVE-LINE-ITERATOR.VALUE SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%NATIVE-LINE-ITERATOR.VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-NATIVE-LINE-ITERATOR-SLOT-VALUE VALUE))

(CL:DEFUN NEW-CHARACTER-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CHARACTER-ITERATOR))
   (CL:SETF (%CHARACTER-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%CHARACTER-ITERATOR.VALUE SELF) NULL-CHARACTER)
   (CL:SETF (%CHARACTER-ITERATOR.THE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-CHARACTER-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF CHARACTER-ITERATOR))
  (CL:WHEN (TERMINATE-STREAM-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CHARACTER-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-STREAMS-STELLA-CHARACTER-ITERATOR))

(CL:DEFUN ACCESS-CHARACTER-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-STREAMS-STELLA-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%CHARACTER-ITERATOR.VALUE SELF)
      (%CHARACTER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-CHARACTER (%CHARACTER-ITERATOR.VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CHARACTER-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFUN (TERMINATE-STREAM-ITERATOR? BOOLEAN) ...)

(CL:DEFUN TERMINATE-STREAM-ITERATOR? (SELF)
  (CL:WHEN (CL:NOT (CL:EQ (%STREAM-ITERATOR.THE-STREAM SELF) NULL))
   (FREE (%STREAM-ITERATOR.THE-STREAM SELF)))
  (CL:RETURN-FROM TERMINATE-STREAM-ITERATOR? CL:T))

;;; (DEFUN (S-EXPRESSIONS S-EXPRESSION-ITERATOR) ...)

(CL:DEFUN S-EXPRESSIONS (STREAM)
  (CL:LET* ((SELF-000 (NEW-S-EXPRESSION-ITERATOR)))
   (CL:SETF (%S-EXPRESSION-ITERATOR.THE-STREAM SELF-000) STREAM)
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM S-EXPRESSIONS VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF S-EXPRESSION-ITERATOR))
  (CL:SETF (%S-EXPRESSION-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
  (CL:LET* ((OBJECT NULL) (EOF? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (OBJECT EOF?)
    (READ-S-EXPRESSION (%S-EXPRESSION-ITERATOR.THE-STREAM SELF)))
   (CL:COND
    (EOF? (CLOSE-STREAM (%S-EXPRESSION-ITERATOR.THE-STREAM SELF))
     (CL:RETURN-FROM NEXT? CL:NIL))
    (CL:T (CL:SETF (%S-EXPRESSION-ITERATOR.VALUE SELF) OBJECT)
     (CL:RETURN-FROM NEXT? CL:T)))))

;;; (DEFUN (NATIVE-LINES NATIVE-LINE-ITERATOR) ...)

(CL:DEFUN NATIVE-LINES (STREAM)
  (CL:LET* ((SELF-000 (NEW-NATIVE-LINE-ITERATOR)))
   (CL:SETF (%NATIVE-LINE-ITERATOR.THE-STREAM SELF-000) STREAM)
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM NATIVE-LINES VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF NATIVE-LINE-ITERATOR))
  (CL:LET*
   ((LINE (NATIVE-READ-LINE (%NATIVE-LINE-ITERATOR.THE-STREAM SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
   (CL:SETF (%NATIVE-LINE-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
   (CL:SETF (%NATIVE-LINE-ITERATOR.VALUE SELF) LINE)
   (CL:COND
    ((CL:EQ LINE STELLA::NULL-STRING)
     (CLOSE-STREAM (%NATIVE-LINE-ITERATOR.THE-STREAM SELF))
     (CL:RETURN-FROM NEXT? CL:NIL))
    (CL:T (CL:RETURN-FROM NEXT? CL:T)))))

;;; (DEFUN (LINES LINE-ITERATOR) ...)

(CL:DEFUN LINES (STREAM)
  (CL:LET* ((SELF-000 (NEW-LINE-ITERATOR)))
   (CL:SETF (%LINE-ITERATOR.THE-STREAM SELF-000) STREAM)
   (CL:LET* ((VALUE-000 SELF-000)) (CL:RETURN-FROM LINES VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF LINE-ITERATOR))
  (CL:LET* ((LINE (READ-LINE (%LINE-ITERATOR.THE-STREAM SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
   (CL:SETF (%LINE-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
   (CL:SETF (%LINE-ITERATOR.VALUE SELF) LINE)
   (CL:COND
    ((CL:EQ LINE STELLA::NULL-STRING)
     (CLOSE-STREAM (%LINE-ITERATOR.THE-STREAM SELF))
     (CL:RETURN-FROM NEXT? CL:NIL))
    (CL:T (CL:RETURN-FROM NEXT? CL:T)))))

;;; (DEFUN (CHARACTERS CHARACTER-ITERATOR) ...)

(CL:DEFUN CHARACTERS (STREAM)
  (CL:LET* ((SELF-000 (NEW-CHARACTER-ITERATOR)))
   (CL:SETF (%CHARACTER-ITERATOR.THE-STREAM SELF-000) STREAM)
   (CL:LET* ((VALUE-000 SELF-000))
    (CL:RETURN-FROM CHARACTERS VALUE-000))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF CHARACTER-ITERATOR))
  (CL:SETF (%CHARACTER-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
  (CL:LET* ((CHAR NULL-CHARACTER) (EOF? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?)
    (READ-CHARACTER (%CHARACTER-ITERATOR.THE-STREAM SELF)))
   (CL:COND
    (EOF? (CL:SETF (%CHARACTER-ITERATOR.VALUE SELF) NULL-CHARACTER)
     (CLOSE-STREAM (%CHARACTER-ITERATOR.THE-STREAM SELF))
     (CL:RETURN-FROM NEXT? CL:NIL))
    (CL:T (CL:SETF (%CHARACTER-ITERATOR.VALUE SELF) CHAR)
     (CL:RETURN-FROM NEXT? CL:T)))))

;;; (DEFGLOBAL *LOGGING-REGISTRY* ...)

(CL:DEFVAR *LOGGING-REGISTRY* NULL)

;;; (DEFGLOBAL *LOGGING-LOCAL-TIME-ZONE* ...)

(CL:DEFVAR *LOGGING-LOCAL-TIME-ZONE* NULL-FLOAT)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *LOGGING-LOCAL-TIME-ZONE*))

;;; (DEFUN (LOOKUP-LOGGING-PARAMETER OBJECT) ...)

(CL:DEFUN LOOKUP-LOGGING-PARAMETER (MODULE PARAMETER DEFAULT)
  "Lookup logging `parameter' for `module'.  Use `default' if no
value is defined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:LET* ((VALUE NULL))
   (CL:LET*
    ((MOD NULL) (PROPS NULL)
     (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST *LOGGING-REGISTRY*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ MOD (%KV-CONS.KEY ITER-000))
     (CL:SETQ PROPS (%KV-CONS.VALUE ITER-000))
     (CL:WHEN
      (STRING-EQUAL? MODULE (%STRING-WRAPPER.WRAPPER-VALUE MOD))
      (CL:LET* ((TEMP-000 (LOOKUP PROPS PARAMETER)))
       (CL:SETQ VALUE
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 DEFAULT)))
      (CL:RETURN))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-LOGGING-PARAMETER VALUE)))

;;; (DEFUN SET-LOGGING-PARAMETERS ...)

(CL:DEFUN %SET-LOGGING-PARAMETERS (MODULE |PARAMS&VALUES|)
  "Set logging parameters for `module'.  The supported parameters are:
  :LOG-LEVELS - a cons list of legal levels in ascending log level order;
                for example, (:NONE :LOW :MEDIUM :HIGH) or (0 1 2 3).
  :LEVEL      - the current log level for `module'
  :STREAM     - the stream or file to log to (defaults to STANDARD-OUTPUT)
  :PREFIX     - the prefix to use to identify the module (defaults to `module')
  :MAX-WIDTH  - logging output lines will be kept to approximately this width
                (defaults to 10000, minimum width of about 30 is used to
                print line header information)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:LET*
   ((OPTIONS
     (VET-OPTIONS |PARAMS&VALUES|
      (GET-QUOTED-TREE
       "((:LOG-LEVELS :LEVEL :STREAM :PREFIX :MAX-WIDTH) \"/STELLA\")"
       "/STELLA")))
    (LOGINFO NULL))
   (CL:LET*
    ((MOD NULL) (PROPS NULL)
     (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST *LOGGING-REGISTRY*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
     (CL:SETQ MOD (%KV-CONS.KEY ITER-000))
     (CL:SETQ PROPS (%KV-CONS.VALUE ITER-000))
     (CL:WHEN
      (STRING-EQUAL? MODULE (%STRING-WRAPPER.WRAPPER-VALUE MOD))
      (CL:SETQ LOGINFO PROPS))
     (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000))))
   (CL:WHEN (CL:EQ LOGINFO NULL) (CL:SETQ LOGINFO (NEW-PROPERTY-LIST))
    (INSERT-AT *LOGGING-REGISTRY* (WRAP-STRING MODULE) LOGINFO))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-001 (%PROPERTY-LIST.THE-PLIST OPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-001))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
     (INSERT-AT LOGINFO KEY VALUE)
     (CL:SETQ ITER-001 (%%REST (%%REST ITER-001))))))
  :VOID)

(CL:DEFUN SET-LOGGING-PARAMETERS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-LOGGING-PARAMETERS
   (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%%REST ARGUMENTS))
  :VOID)

(CL:DEFMACRO SET-LOGGING-PARAMETERS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set logging parameters for `module'.  The supported parameters are:
  :LOG-LEVELS - a cons list of legal levels in ascending log level order;
                for example, (:NONE :LOW :MEDIUM :HIGH) or (0 1 2 3).
  :LEVEL      - the current log level for `module'
  :STREAM     - the stream or file to log to (defaults to STANDARD-OUTPUT)
  :PREFIX     - the prefix to use to identify the module (defaults to `module')
  :MAX-WIDTH  - logging output lines will be kept to approximately this width
                (defaults to 10000, minimum width of about 30 is used to
                print line header information)."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-LOGGING-PARAMETERS|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-LOGGING-PARAMETERS)))

;;; (DEFUN SET-LOG-LEVEL ...)

(CL:DEFUN %SET-LOG-LEVEL (MODULE LEVEL)
  "Set the log-level for `module' to `level'.  This is a
convenience function for this common operation."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (%SET-LOGGING-PARAMETERS MODULE (CONS-LIST KWD-STREAMS-LEVEL LEVEL))
  :VOID)

(CL:DEFUN SET-LOG-LEVEL-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-LOG-LEVEL (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%%VALUE (%%REST ARGUMENTS)))
  :VOID)

(CL:DEFMACRO SET-LOG-LEVEL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set the log-level for `module' to `level'.  This is a
convenience function for this common operation."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-LOG-LEVEL|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-LOG-LEVEL)))

;;; (DEFUN (LOG-LEVEL<= BOOLEAN) ...)

(CL:DEFUN LOG-LEVEL<= (LEVEL MODULE)
  "Return TRUE if `level' is lower than or equal to the current
log level of `module'.  Return FALSE if any of them are undefined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:LET*
   ((LOGLEVELS
     (LOOKUP-LOGGING-PARAMETER MODULE KWD-STREAMS-LOG-LEVELS NIL))
    (MODULELEVEL
     (LOOKUP-LOGGING-PARAMETER MODULE KWD-STREAMS-LEVEL NULL))
    (POS1 (POSITION LOGLEVELS LEVEL 0))
    (POS2 (POSITION LOGLEVELS MODULELEVEL 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM POS1 POS2))
   (CL:RETURN-FROM LOG-LEVEL<=
    (CL:AND (CL:NOT (CL:= POS1 NULL-INTEGER))
     (CL:NOT (CL:= POS2 NULL-INTEGER)) (CL:<= POS1 POS2)))))

;;; (DEFGLOBAL *LOG-INDENT-LEVEL* ...)

(CL:DEFVAR *LOG-INDENT-LEVEL* 0
  "The number of spaces to print before the content of a log message.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *LOG-INDENT-LEVEL*))

;;; (DEFUN BUMP-LOG-INDENT ...)

(CL:DEFUN BUMP-LOG-INDENT ()
  "Increase the indentation level for subsequent log messages."
  (CL:SETQ *LOG-INDENT-LEVEL* (CL:+ *LOG-INDENT-LEVEL* 2))
  :VOID)

;;; (DEFUN UNBUMP-LOG-INDENT ...)

(CL:DEFUN UNBUMP-LOG-INDENT ()
  "Decrease the indentation level for subsequent log messages."
  (CL:SETQ *LOG-INDENT-LEVEL* (CL:- *LOG-INDENT-LEVEL* 2))
  :VOID)

;;; (DEFUN (GET-LOG-STREAM OUTPUT-STREAM) ...)

(CL:DEFUN GET-LOG-STREAM (MODULE)
  "Return a valid log stream for `module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:LET*
   ((STREAMSPEC
     (LOOKUP-LOGGING-PARAMETER MODULE KWD-STREAMS-STREAM
      STANDARD-OUTPUT)))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE STREAMSPEC)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM GET-LOG-STREAM
        (OPEN-OUTPUT-FILE (%STRING-WRAPPER.WRAPPER-VALUE STREAMSPEC)
         KWD-STREAMS-IF-EXISTS KWD-STREAMS-APPEND
         KWD-STREAMS-IF-NOT-EXISTS KWD-STREAMS-CREATE))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-STREAMS-STELLA-OUTPUT-STREAM)
      (CL:PROGN (CL:RETURN-FROM GET-LOG-STREAM STREAMSPEC)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN LOG-MESSAGE ...)

(CL:DEFUN LOG-MESSAGE (MODULE LOGLEVEL MESSAGE)
  "Log all elements of `message' to `module's log stream if
`logLevel' is the same or lower than the `module's log level.  Interprets `EOL'
or :EOL to print a line terminator."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:WHEN (LOG-LEVEL<= LOGLEVEL MODULE)
   (CL:LET*
    ((LOG (GET-LOG-STREAM MODULE))
     (MODULEPREFIX
      (%STRING-WRAPPER.WRAPPER-VALUE
       (LOOKUP-LOGGING-PARAMETER MODULE KWD-STREAMS-PREFIX
        (WRAP-STRING MODULE))))
     (MAXROOM
      (%INTEGER-WRAPPER.WRAPPER-VALUE
       (LOOKUP-LOGGING-PARAMETER MODULE KWD-STREAMS-MAX-WIDTH
        (WRAP-INTEGER 10000))))
     (ROOM MAXROOM) (ELTSTRING STELLA::NULL-STRING))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULEPREFIX ELTSTRING)
     (CL:TYPE CL:FIXNUM MAXROOM ROOM))
    (CL:UNWIND-PROTECT
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG) "["
       (CALENDAR-DATE-TO-STRING (MAKE-CURRENT-DATE-TIME)
        *LOGGING-LOCAL-TIME-ZONE* CL:NIL CL:NIL)
       (CL:IF (STRING-EQL? MODULEPREFIX "") "" " ") MODULEPREFIX "] ")
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 1)
        (UPPER-BOUND-000 *LOG-INDENT-LEVEL*)
        (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
        (CL:SETQ I ITER-000) (CL:SETQ I I)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG) " ")
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:SETQ ROOM
       (CL:- ROOM
        (CL:+ 27 (CL:THE CL:FIXNUM (CL:LENGTH MODULEPREFIX))
         *LOG-INDENT-LEVEL*)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (CL:LET* ((ELT NULL) (ITER-001 MESSAGE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ ELT (%%VALUE ITER-001))
         (CL:TAGBODY
          (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELT)))
           (CL:COND
            ((SUBTYPE-OF-STRING? TEST-VALUE-000)
             (CL:PROGN
              (CL:SETQ ELTSTRING (%STRING-WRAPPER.WRAPPER-VALUE ELT))))
            ((SUBTYPE-OF? TEST-VALUE-000
              SGT-STREAMS-STELLA-GENERALIZED-SYMBOL)
             (CL:PROGN
              (CL:COND
               ((STRING-EQL? (%GENERALIZED-SYMBOL.SYMBOL-NAME ELT)
                 "EOL")
                (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG) EOL)
                (CL:SETQ ROOM MAXROOM) (CL:GO :CONTINUE))
               (CL:T (CL:SETQ ELTSTRING (STRINGIFY ELT))))))
            (CL:T (CL:SETQ ELTSTRING (STRINGIFY ELT)))))
          (CL:IF (CL:< ROOM (CL:THE CL:FIXNUM (CL:LENGTH ELTSTRING)))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG)
            (SUBSEQUENCE ELTSTRING 0 ROOM) "...")
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG)
            ELTSTRING))
          :CONTINUE)
         (CL:SETQ ITER-001 (%%REST ITER-001)))))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM LOG) EOL)
      (FLUSH-OUTPUT LOG)))
    (CL:WHEN (ISA? LOG SGT-STREAMS-STELLA-FILE-OUTPUT-STREAM)
     (CLOSE-STREAM LOG))))
  :VOID)

;;; (DEFUN LOGMSG ...)

(CL:DEFUN LOGMSG (MODULE LOGLEVEL CL:&REST MESSAGE)
  "Log all elements of `message' to `module's log stream if
`logLevel' is the same or lower than the `module's log level.  Interprets `EOL'
or :EOL to print a line terminator."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULE))
  #+MCL
  (CL:CHECK-TYPE MODULE CL:SIMPLE-STRING)
  (CL:LET* ((ARGLIST-000 NIL))
   (CL:LET* ((ARG-000 NULL) (ITER-000 MESSAGE) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
       (CL:IF (CL:EQ ARGLIST-000 NIL) (CL:SETQ ARGLIST-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (LOG-MESSAGE MODULE LOGLEVEL ARGLIST-000))
  :VOID)

(CL:DEFUN HELP-STARTUP-STREAMS1 ()
  (CL:PROGN
   (CL:SETQ SYM-STREAMS-STELLA-EOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EOL" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-PRINT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-STANDARD-OUTPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OUTPUT" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-I
    (INTERN-RIGID-SYMBOL-WRT-MODULE "I" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
   (CL:SETQ KWD-STREAMS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-STREAMS-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-STANDARD-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-WARNING" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-STELLA-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-EXCEPTION" NULL 0))
   (CL:SETQ SGT-STREAMS-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-SIGNAL-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-EXCEPTION" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
   (CL:SETQ KWD-STREAMS-MESSAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MESSAGE" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-OUTPUT-STRING-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STRING-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-THE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-STRING" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SIGNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL" NULL 0))
   (CL:SETQ KWD-STREAMS-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-ERROR_MESSAGE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR_MESSAGE_" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-VERBATIM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM" NULL 0))
   (CL:SETQ KWD-STREAMS-CONTINUABLE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUABLE-ERROR" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-READ-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-EXCEPTION" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-DE-UGLIFY-PARSE-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DE-UGLIFY-PARSE-TREE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-*PRINTREADABLY?*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*PRINTREADABLY?*" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-TRANSLATION-ERROR" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SUPPRESS-WARNINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPRESS-WARNINGS?" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-PRINT-ERROR-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-ERROR-CONTEXT" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-STANDARD-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-ERROR" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-NOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-TRANSLATION-NOTE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SIGNAL-TRANSLATION-WARNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIGNAL-TRANSLATION-WARNING" NULL
     0))
   (CL:SETQ SYM-STREAMS-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ KWD-STREAMS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-*EVALUATIONTREE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONTREE*" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-*EVALUATIONPARENTTREE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*EVALUATIONPARENTTREE*" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-EVALUATION-EXCEPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATION-EXCEPTION" NULL 0))
   (CL:SETQ SGT-STREAMS-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-STRINGIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRINGIFY" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-VRLET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ KWD-STREAMS-CLOSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED" NULL 2))
   (CL:SETQ KWD-STREAMS-IF-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-EXISTS" NULL 2))
   (CL:SETQ KWD-STREAMS-IF-EXISTS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-EXISTS-ACTION" NULL 2))
   (CL:SETQ KWD-STREAMS-IF-NOT-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-NOT-EXISTS" NULL 2))
   (CL:SETQ KWD-STREAMS-IF-NOT-EXISTS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-NOT-EXISTS-ACTION" NULL 2))
   (CL:SETQ KWD-STREAMS-SUPERSEDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERSEDE" NULL 2))
   (CL:SETQ KWD-STREAMS-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 2))
   (CL:SETQ KWD-STREAMS-CREATE-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE-PATH" NULL 2))
   (CL:SETQ KWD-STREAMS-ABORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABORT" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-STREAMS2 ()
  (CL:PROGN
   (CL:SETQ KWD-STREAMS-PROBE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROBE" NULL 2))
   (CL:SETQ KWD-STREAMS-APPEND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "APPEND" NULL 2))
   (CL:SETQ KWD-STREAMS-OPEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN" NULL 2))
   (CL:SETQ SGT-STREAMS-STELLA-INPUT-FILE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-FILE-STREAM" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-OUTPUT-FILE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-FILE-STREAM" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-INPUT-STRING-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STRING-STREAM" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-OUTPUT-STRING-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STRING-STREAM" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 1))
   (CL:SETQ KWD-STREAMS-BLOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BLOCK" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-FILE-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-INPUT-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-UNWIND-PROTECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNWIND-PROTECT" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-OPEN-INPUT-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-INPUT-FILE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-FREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FREE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-FILE-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-OUTPUT-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-OPEN-OUTPUT-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-OUTPUT-FILE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-MV-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MV-SETQ" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-OPEN-NETWORK-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-NETWORK-STREAM" NULL 0))
   (CL:SETQ SGT-STREAMS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-SUBSEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSEQUENCE" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-POSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITION" NULL 0))
   (CL:SETQ KWD-STREAMS-LETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LETTER" NULL 2))
   (CL:SETQ KWD-STREAMS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-THE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-STREAM" NULL 0))
   (CL:SETQ SGT-STREAMS-STELLA-S-EXPRESSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "S-EXPRESSION-ITERATOR" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SGT-STREAMS-STELLA-LINE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LINE-ITERATOR" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-NATIVE-LINE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-LINE-ITERATOR" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-CHARACTER-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-ITERATOR" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-SET-LOGGING-PARAMETERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-LOGGING-PARAMETERS" NULL 0))
   (CL:SETQ KWD-STREAMS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-STREAMS-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LEVEL" NULL 2))
   (CL:SETQ SYM-STREAMS-STELLA-SET-LOG-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-LOG-LEVEL" NULL 0))
   (CL:SETQ KWD-STREAMS-LOG-LEVELS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOG-LEVELS" NULL 2))
   (CL:SETQ KWD-STREAMS-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 2))
   (CL:SETQ KWD-STREAMS-PREFIX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX" NULL 2))
   (CL:SETQ KWD-STREAMS-MAX-WIDTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX-WIDTH" NULL 2))
   (CL:SETQ SGT-STREAMS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SGT-STREAMS-STELLA-FILE-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-OUTPUT-STREAM" NULL 1))
   (CL:SETQ SYM-STREAMS-STELLA-STARTUP-STREAMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-STREAMS" NULL 0))
   (CL:SETQ SYM-STREAMS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-STREAMS3 ()
  (CL:PROGN (CL:SETQ EOL SYM-STREAMS-STELLA-EOL)
   (CL:LET* ((SELF-000 (NEW-INPUT-STREAM)))
    (CL:SETF (%INPUT-STREAM.NATIVE-STREAM SELF-000)
     CL:*STANDARD-INPUT*)
    (CL:SETQ STANDARD-INPUT SELF-000))
   (CL:SETQ SINGLE-QUOTE-STRING (WRAP-STRING "'"))
   (CL:SETQ SINGLE-BQUOTE-STRING (WRAP-STRING "`"))
   (CL:SETQ *OPEN-FILE-STREAMS* (NEW-LIST))
   (CL:SETQ *HTML-ESCAPE-TABLE* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *LOGGING-REGISTRY* (NEW-KEY-VALUE-LIST))
   (CL:SETQ *LOGGING-LOCAL-TIME-ZONE* (GET-LOCAL-TIME-ZONE)))
  :VOID)

(CL:DEFUN HELP-STARTUP-STREAMS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "MAKE-EARLY-OUTPUT-STREAM"
    "(DEFUN (MAKE-EARLY-OUTPUT-STREAM OUTPUT-STREAM) ((NATIVESTREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION MAKE-EARLY-OUTPUT-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "FORMAT-MESSAGE-ARGUMENTS"
    "(DEFUN (FORMAT-MESSAGE-ARGUMENTS CONS) ((MESSAGEARGUMENTSTREE CONS) (TRAILINGEOL? BOOLEAN)))"
    (CL:FUNCTION FORMAT-MESSAGE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT"
    "(DEFUN PRINT (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Print arguments to the standard output stream.\")"
    (CL:FUNCTION PRINT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-SPACES"
    "(DEFUN PRINT-SPACES (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"(print-spaces [stream] N) prints N spaces onto stream.  If
no stream form is provided, then STANDARD-OUTPUT will be used.\")"
    (CL:FUNCTION PRINT-SPACES) NULL)
   (DEFINE-FUNCTION-OBJECT "INFORM"
    "(DEFUN INFORM (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Print informative message, placing non-string arguments in quotes,
and terminating with a newline.\")" (CL:FUNCTION INFORM) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN"
    "(DEFUN WARN (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Signal warning message, placing non-string arguments in quotes.\")"
    (CL:FUNCTION WARN) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL"
    "(DEFUN SIGNAL ((TYPE SYMBOL) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Signal error message, placing non-string arguments in quotes.\")"
    (CL:FUNCTION SIGNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "ERROR"
    "(DEFUN ERROR (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Signal error message, placing non-string arguments in quotes.\")"
    (CL:FUNCTION ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "CONTINUABLE-ERROR"
    "(DEFUN CONTINUABLE-ERROR (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Signal error message, placing non-string arguments in quotes.\")"
    (CL:FUNCTION CONTINUABLE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-READ-ERROR"
    "(DEFUN SIGNAL-READ-ERROR (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Specialized version of `signal' that throws a READ-EXCEPTION.\")"
    (CL:FUNCTION SIGNAL-READ-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-FILE-EXISTS"
    "(DEFUN ENSURE-FILE-EXISTS ((FILENAME STRING) (CONTEXT STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Ensures that `filename' exists.  If not, an exception of
type `NO-SUCH-FILE-EXCEPTION' is thrown with `context' supplying
context for the error message.\")" (CL:FUNCTION ENSURE-FILE-EXISTS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-FILE-DOES-NOT-EXIST"
    "(DEFUN ENSURE-FILE-DOES-NOT-EXIST ((FILENAME STRING) (CONTEXT STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Ensures that `filename' does not exist.  If it does,
an exception of type `FILE-ALREADY-EXISTS-EXCEPTION' is thrown
with `context' supplying context for the error message.\")"
    (CL:FUNCTION ENSURE-FILE-DOES-NOT-EXIST) NULL)
   (DEFINE-FUNCTION-OBJECT "FORMAT-WALK-MESSAGE-ARGUMENTS"
    "(DEFUN (FORMAT-WALK-MESSAGE-ARGUMENTS CONS) ((MESSAGEARGUMENTSTREE CONS)))"
    (CL:FUNCTION FORMAT-WALK-MESSAGE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-ERROR"
    "(DEFUN WALK-ERROR (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WALK-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-INFORM"
    "(DEFUN WALK-INFORM (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WALK-INFORM) NULL)
   (DEFINE-FUNCTION-OBJECT "WALK-WARN"
    "(DEFUN WALK-WARN (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WALK-WARN) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFETY"
    "(DEFUN SAFETY ((LEVEL INTEGER-WRAPPER) (TEST OBJECT) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Signal warning message, placing non-string arguments in quotes.\")"
    (CL:FUNCTION SAFETY) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATION-ERROR"
    "(DEFUN EVALUATION-ERROR (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION EVALUATION-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "FORMAT-STRING-MESSAGE-ARGUMENTS"
    "(DEFUN (FORMAT-STRING-MESSAGE-ARGUMENTS CONS) ((MESSAGEARGUMENTS CONS) (TRAILINGEOL? BOOLEAN)))"
    (CL:FUNCTION FORMAT-STRING-MESSAGE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "MESSAGE-TO-STRING"
    "(DEFUN MESSAGE-TO-STRING (|&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION MESSAGE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-OUTPUT-STREAM?"
    "(DEFUN (TERMINATE-OUTPUT-STREAM? BOOLEAN) ((SELF OUTPUT-STREAM)))"
    (CL:FUNCTION TERMINATE-OUTPUT-STREAM?) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-INPUT-STREAM?"
    "(DEFUN (TERMINATE-INPUT-STREAM? BOOLEAN) ((SELF INPUT-STREAM)))"
    (CL:FUNCTION TERMINATE-INPUT-STREAM?) NULL)
   (DEFINE-FUNCTION-OBJECT "OPEN-OUTPUT-FILE"
    "(DEFUN (OPEN-OUTPUT-FILE FILE-OUTPUT-STREAM) ((FILENAME STRING) |&REST| (OPTIONS KEYWORD)) :DOCUMENTATION \"Open file `fileName' for output and return the resulting output stream.
By default the file will be created or overwritten if it already exists.
If `:IF-EXISTS' (or `:IF-EXISTS-ACTION') is one of the `options' its value
specifies what to do in case the file already exists.  If the value is
`:SUPERSEDE' the pre-existing file will be overwritten.  If the value is
`:APPEND' the preexisting file will be appended to (if the file did not
yet exist the file will simply be created).  If the value is `:ERROR' then
an error will be signaled.  If it is `:ABORT' or `:PROBE' the opening operation
will be aborted and NULL will be returned.

If `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') is one of the `options' its
value specifies what to do in case the file does not already exist.  If the
value is `:CREATE', the file will simply be created.  If the value is
`:CREATE-PATH' the file will be created plus any non-existing directories
in the directory path of `fileName' will also be created.  If the value is
`:ERROR' then an error will be signaled.  If it is `:ABORT' or `:PROBE' the
opening operation will be aborted and NULL will be returned.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OPEN-OUTPUT-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-FILE-OUTPUT-STREAM"
    "(DEFUN INITIALIZE-FILE-OUTPUT-STREAM ((SELF FILE-OUTPUT-STREAM)))"
    (CL:FUNCTION INITIALIZE-FILE-OUTPUT-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-FILE-OUTPUT-STREAM?"
    "(DEFUN (TERMINATE-FILE-OUTPUT-STREAM? BOOLEAN) ((SELF FILE-OUTPUT-STREAM)))"
    (CL:FUNCTION TERMINATE-FILE-OUTPUT-STREAM?) NULL)
   (DEFINE-FUNCTION-OBJECT "OPEN-INPUT-FILE"
    "(DEFUN (OPEN-INPUT-FILE FILE-INPUT-STREAM) ((FILENAME STRING) |&REST| (OPTIONS KEYWORD)) :DOCUMENTATION \"Open file `fileName' for input and return the resulting input stream.
By default signal an error if the file does not exist.  The only legal
option so far is `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') which
specifies what to do in case the file does not exist.  If its value is
`:ERROR' then an error will be signaled.  If it is `:ABORT' or `:PROBE'
the opening operation will be aborted and NULL will be returned.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OPEN-INPUT-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-FILE-INPUT-STREAM"
    "(DEFUN INITIALIZE-FILE-INPUT-STREAM ((SELF FILE-INPUT-STREAM)))"
    (CL:FUNCTION INITIALIZE-FILE-INPUT-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-FILE-INPUT-STREAM?"
    "(DEFUN (TERMINATE-FILE-INPUT-STREAM? BOOLEAN) ((SELF FILE-INPUT-STREAM)))"
    (CL:FUNCTION TERMINATE-FILE-INPUT-STREAM?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-STRING-OUTPUT-STREAM"
    "(DEFUN INITIALIZE-STRING-OUTPUT-STREAM ((SELF OUTPUT-STRING-STREAM)))"
    (CL:FUNCTION INITIALIZE-STRING-OUTPUT-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-STRING-OUTPUT-STREAM?"
    "(DEFUN (TERMINATE-STRING-OUTPUT-STREAM? BOOLEAN) ((SELF OUTPUT-STRING-STREAM)))"
    (CL:FUNCTION TERMINATE-STRING-OUTPUT-STREAM?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (THE-STRING-READER STRING) ((SELF OUTPUT-STRING-STREAM)))"
    (WRAP-METHOD-CODE (CL:FUNCTION THE-STRING-READER)) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-STRING-INPUT-STREAM"
    "(DEFUN INITIALIZE-STRING-INPUT-STREAM ((SELF INPUT-STRING-STREAM)))"
    (CL:FUNCTION INITIALIZE-STRING-INPUT-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-STRING-INPUT-STREAM?"
    "(DEFUN (TERMINATE-STRING-INPUT-STREAM? BOOLEAN) ((SELF INPUT-STRING-STREAM)))"
    (CL:FUNCTION TERMINATE-STRING-INPUT-STREAM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSE-STREAM"
    "(DEFUN CLOSE-STREAM ((SELF STREAM)) :DOCUMENTATION \"Close the stream `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLOSE-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-INPUT"
    "(DEFUN CLEAR-INPUT ((SELF INPUT-STREAM)) :DOCUMENTATION \"Clear all buffered raw and tokenized input of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-INPUT) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-OUTPUT"
    "(DEFUN FLUSH-OUTPUT ((SELF OUTPUT-STREAM)) :DOCUMENTATION \"Flush all buffered output of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FLUSH-OUTPUT) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSE-ALL-FILES"
    "(DEFUN CLOSE-ALL-FILES () :DOCUMENTATION \"Close all currently open file streams.  Use for emergencies or for cleanup.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLOSE-ALL-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "OPEN-NETWORK-STREAM"
    "(DEFUN (OPEN-NETWORK-STREAM INPUT-STREAM OUTPUT-STREAM) ((HOST STRING) (PORT INTEGER)) :DOCUMENTATION \"Open a TCP/IP network stream to `host' at `port' and return the result
as an input/output stream pair.\" :PUBLIC? TRUE)"
    (CL:FUNCTION OPEN-NETWORK-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-INPUT-FILE"
    "(DEFUN WITH-INPUT-FILE ((BINDING CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Sets up an unwind-protected form which opens a file for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is `(WITH-INPUT-FILE (var filename options*) body+)' where `options'
can be any that are legal for `open-input-file' (which see).\")"
    (CL:FUNCTION WITH-INPUT-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-OUTPUT-FILE"
    "(DEFUN WITH-OUTPUT-FILE ((BINDING CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Sets up an unwind-protected form which opens a file for
output and closes it afterwards.  The stream for writing is bound to the
variable provided in the macro form.
Syntax is `(WITH-OUTPUT-FILE (var filename options*) body+)' where `options'
can be any that are legal for `open-output-file' (which see).\")"
    (CL:FUNCTION WITH-OUTPUT-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-NETWORK-STREAM"
    "(DEFUN WITH-NETWORK-STREAM ((BINDING CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Sets up an unwind-protected form which opens a network
socket stream to a host and port for input and output and closes it afterwards.
Separate variables as provided in the call are bound to the input and output
streams. Syntax is (WITH-NETWORK-STREAM (varIn varOut hostname port) body+)\")"
    (CL:FUNCTION WITH-NETWORK-STREAM) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-FILE-INPUT-STREAM-POSITION"
    "(DEFUN (NATIVE-FILE-INPUT-STREAM-POSITION LONG-INTEGER) ((NSTREAM NATIVE-INPUT-STREAM)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (VERBATIM :CPP \"nstream->clear(std::ios::goodbit)\" :OTHERWISE NULL) (RETURN (VERBATIM :COMMON-LISP \"(CL:file-position nstream)\" :CPP \"nstream->tellg()\" :JAVA \"((NativeFileInputStream)nstream).position()\")))"
    (CL:FUNCTION NATIVE-FILE-INPUT-STREAM-POSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-FILE-INPUT-STREAM-POSITION-SETTER"
    "(DEFUN (NATIVE-FILE-INPUT-STREAM-POSITION-SETTER LONG-INTEGER) ((NSTREAM NATIVE-INPUT-STREAM) (NEWPOS LONG-INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (VERBATIM :COMMON-LISP \"(CL:file-position nstream newpos)\" :CPP \"nstream->clear(std::ios::goodbit);nstream->seekg(newpos)\" :JAVA \"((NativeFileInputStream)nstream).position(newpos)\") (RETURN NEWPOS))"
    (CL:FUNCTION NATIVE-FILE-INPUT-STREAM-POSITION-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (STREAM-POSITION LONG-INTEGER) ((SELF FILE-INPUT-STREAM)) :DOCUMENTATION \"Return the current position of the file input cursor in `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION STREAM-POSITION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (STREAM-POSITION-SETTER LONG-INTEGER) ((SELF FILE-INPUT-STREAM) (NEWPOS LONG-INTEGER)) :DOCUMENTATION \"Set the current position of the file input cursor in `self' to `newpos'.
If `self' has any tokenizer state associated with it, this will also reset
to the start state of the tokenizer table; otherwise, behavior would be
unpredictable unless the character class of the new position is exactly the
same as the one following the most recent token.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION STREAM-POSITION-SETTER)) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-FILE-OUTPUT-STREAM-POSITION"
    "(DEFUN (NATIVE-FILE-OUTPUT-STREAM-POSITION LONG-INTEGER) ((NSTREAM NATIVE-OUTPUT-STREAM)) :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP \"(CL:file-position nstream)\" :CPP \"nstream->tellp()\" :JAVA \"((NativeFileOutputStream)nstream).position()\")))"
    (CL:FUNCTION NATIVE-FILE-OUTPUT-STREAM-POSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER"
    "(DEFUN (NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER LONG-INTEGER) ((NSTREAM NATIVE-OUTPUT-STREAM) (NEWPOS LONG-INTEGER)) :GLOBALLY-INLINE? TRUE (VERBATIM :COMMON-LISP \"(CL:file-position nstream newpos)\" :CPP \"nstream->seekp(newpos)\" :JAVA \"((NativeFileOutputStream)nstream).position(newpos)\") (RETURN NEWPOS))"
    (CL:FUNCTION NATIVE-FILE-OUTPUT-STREAM-POSITION-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (STREAM-POSITION LONG-INTEGER) ((SELF FILE-OUTPUT-STREAM)) :DOCUMENTATION \"Return the current position of the file input cursor in `self'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION STREAM-POSITION)) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (STREAM-POSITION-SETTER LONG-INTEGER) ((SELF FILE-OUTPUT-STREAM) (NEWPOS LONG-INTEGER)) :DOCUMENTATION \"Set the current position of the file input cursor in `self' to `newpos'.\" :PUBLIC? TRUE)"
    (WRAP-METHOD-CODE (CL:FUNCTION STREAM-POSITION-SETTER)) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-MARKUP-TAG-FUNCTION"
    "(DEFUN (EXPAND-MARKUP-TAG-FUNCTION CONS) ((TAG-AND-STREAM CONS) (BODY CONS) (XML? BOOLEAN)))"
    (CL:FUNCTION EXPAND-MARKUP-TAG-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-HTML-TAG"
    "(DEFUN WITH-HTML-TAG ((TAG-AND-STREAM CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WITH-HTML-TAG) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-XML-TAG"
    "(DEFUN WITH-XML-TAG ((TAG-AND-STREAM CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WITH-XML-TAG) NULL)
   (DEFINE-FUNCTION-OBJECT "HTML-CHARACTER-NEEDS-QUOTING?"
    "(DEFUN (HTML-CHARACTER-NEEDS-QUOTING? BOOLEAN) ((CH CHARACTER)))"
    (CL:FUNCTION HTML-CHARACTER-NEEDS-QUOTING?) NULL)
   (DEFINE-FUNCTION-OBJECT
    "WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS"
    "(DEFUN WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS ((STREAM NATIVE-OUTPUT-STREAM) (CH CHARACTER)) :GLOBALLY-INLINE? TRUE (CASE CH (#\\> (PRINT-STREAM STREAM \"&gt;\")) (#\\< (PRINT-STREAM STREAM \"&lt;\")) (#\\& (PRINT-STREAM STREAM \"&amp;\")) (#\\\" (PRINT-STREAM STREAM \"&quot;\")) ((#\\Linefeed #\\Return) (PRINT-STREAM STREAM \"&#\" (CHARACTER-CODE CH) \";\")) (OTHERWISE (PRINT-STREAM STREAM CH))) (RETURN))"
    (CL:FUNCTION WRITE-HTML-CHARACTER-QUOTING-SPECIAL-CHARACTERS) NULL)
   (DEFINE-FUNCTION-OBJECT "WRITE-HTML-QUOTING-SPECIAL-CHARACTERS"
    "(DEFUN WRITE-HTML-QUOTING-SPECIAL-CHARACTERS ((STREAM NATIVE-OUTPUT-STREAM) (INPUT STRING)))"
    (CL:FUNCTION WRITE-HTML-QUOTING-SPECIAL-CHARACTERS) NULL)
   (DEFINE-FUNCTION-OBJECT "WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS"
    "(DEFUN WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS ((STREAM NATIVE-OUTPUT-STREAM) (INPUT STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Writes a string and replaces unallowed URL characters according to RFC 2396
with %-format URL escape sequences.\")"
    (CL:FUNCTION WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS) NULL)
   (DEFINE-FUNCTION-OBJECT "HEX-CHARACTER-VALUE"
    "(DEFUN (HEX-CHARACTER-VALUE INTEGER) ((C CHARACTER)) :DOCUMENTATION \"Convert the base-16 hex character `c' into a base-10 number.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (LET ((CODE (CHARACTER-CODE C))) (COND ((< CODE 65) (RETURN (- CODE 48))) ((< CODE 97) (RETURN (- CODE 55))) (OTHERWISE (RETURN (- CODE 87))))))"
    (CL:FUNCTION HEX-CHARACTER-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNESCAPE-URL-STRING"
    "(DEFUN (UNESCAPE-URL-STRING STRING) ((INPUT STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Takes a string and replaces %-format URL escape sequences with their real
character equivalent according to RFC 2396.\")"
    (CL:FUNCTION UNESCAPE-URL-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "UNESCAPE-HTML-STRING"
    "(DEFUN (UNESCAPE-HTML-STRING STRING) ((INPUT STRING)) :DOCUMENTATION \"Replaces HTML escape sequences such as &amp; with their
associated characters.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNESCAPE-HTML-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "TERMINATE-STREAM-ITERATOR?"
    "(DEFUN (TERMINATE-STREAM-ITERATOR? BOOLEAN) ((SELF STREAM-ITERATOR)))"
    (CL:FUNCTION TERMINATE-STREAM-ITERATOR?) NULL))
  :VOID)

(CL:DEFUN STARTUP-STREAMS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-STREAMS1)
    (HELP-STARTUP-STREAMS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-STREAMS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STREAM-ITERATOR"
        "(DEFCLASS STREAM-ITERATOR (ABSTRACT-ITERATOR) :PUBLIC? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Iterator that yields tokens from an input stream.\" :SLOTS ((THE-STREAM :TYPE INPUT-STREAM)) :TERMINATOR TERMINATE-STREAM-ITERATOR?)")))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STREAM-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "S-EXPRESSION-ITERATOR"
        "(DEFCLASS S-EXPRESSION-ITERATOR (STREAM-ITERATOR) :PUBLIC? TRUE :DOCUMENTATION \"Iterator that yields s-expressions from an input stream.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-S-EXPRESSION-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-S-EXPRESSION-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LINE-ITERATOR"
        "(DEFCLASS LINE-ITERATOR (STREAM-ITERATOR) :PUBLIC? TRUE :DOCUMENTATION \"Iterator that yields lines with any line terminator sequence from an input stream.\" :PARAMETERS ((ANY-VALUE :TYPE STRING)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LINE-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-LINE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-LINE-ITERATOR"
        "(DEFCLASS NATIVE-LINE-ITERATOR (STREAM-ITERATOR) :PUBLIC? TRUE :DOCUMENTATION \"Iterator that yields lines from an input stream.\" :PARAMETERS ((ANY-VALUE :TYPE STRING)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-NATIVE-LINE-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-NATIVE-LINE-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CHARACTER-ITERATOR"
        "(DEFCLASS CHARACTER-ITERATOR (STREAM-ITERATOR) :PUBLIC? TRUE :DOCUMENTATION \"Iterator that yields characters from an input stream.\" :PARAMETERS ((ANY-VALUE :TYPE CHARACTER)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CHARACTER-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CHARACTER-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-STREAMS4)
    (DEFINE-FUNCTION-OBJECT "S-EXPRESSIONS"
     "(DEFUN (S-EXPRESSIONS S-EXPRESSION-ITERATOR) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE)"
     (CL:FUNCTION S-EXPRESSIONS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF S-EXPRESSION-ITERATOR)) :PUBLIC? TRUE)"
     (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
    (DEFINE-FUNCTION-OBJECT "NATIVE-LINES"
     "(DEFUN (NATIVE-LINES NATIVE-LINE-ITERATOR) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE)"
     (CL:FUNCTION NATIVE-LINES) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF NATIVE-LINE-ITERATOR)) :PUBLIC? TRUE)"
     (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
    (DEFINE-FUNCTION-OBJECT "LINES"
     "(DEFUN (LINES LINE-ITERATOR) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE)"
     (CL:FUNCTION LINES) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF LINE-ITERATOR)) :PUBLIC? TRUE)"
     (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
    (DEFINE-FUNCTION-OBJECT "CHARACTERS"
     "(DEFUN (CHARACTERS CHARACTER-ITERATOR) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE)"
     (CL:FUNCTION CHARACTERS) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF CHARACTER-ITERATOR)) :PUBLIC? TRUE)"
     (WRAP-METHOD-CODE (CL:FUNCTION NEXT?)) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-LOGGING-PARAMETER"
     "(DEFUN (LOOKUP-LOGGING-PARAMETER OBJECT) ((MODULE STRING) (PARAMETER KEYWORD) (DEFAULT OBJECT)) :DOCUMENTATION \"Lookup logging `parameter' for `module'.  Use `default' if no
value is defined.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-LOGGING-PARAMETER) NULL)
    (DEFINE-FUNCTION-OBJECT "SET-LOGGING-PARAMETERS"
     "(DEFUN SET-LOGGING-PARAMETERS ((MODULE STRING) |&REST| (|PARAMS&VALUES| OBJECT)) :DOCUMENTATION \"Set logging parameters for `module'.  The supported parameters are:
  :LOG-LEVELS - a cons list of legal levels in ascending log level order;
                for example, (:NONE :LOW :MEDIUM :HIGH) or (0 1 2 3).
  :LEVEL      - the current log level for `module'
  :STREAM     - the stream or file to log to (defaults to STANDARD-OUTPUT)
  :PREFIX     - the prefix to use to identify the module (defaults to `module')
  :MAX-WIDTH  - logging output lines will be kept to approximately this width
                (defaults to 10000, minimum width of about 30 is used to
                print line header information).\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %SET-LOGGING-PARAMETERS)
     (CL:FUNCTION SET-LOGGING-PARAMETERS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "SET-LOG-LEVEL"
     "(DEFUN SET-LOG-LEVEL ((MODULE STRING) (LEVEL OBJECT)) :DOCUMENTATION \"Set the log-level for `module' to `level'.  This is a
convenience function for this common operation.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %SET-LOG-LEVEL)
     (CL:FUNCTION SET-LOG-LEVEL-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "LOG-LEVEL<="
     "(DEFUN (LOG-LEVEL<= BOOLEAN) ((LEVEL OBJECT) (MODULE STRING)) :DOCUMENTATION \"Return TRUE if `level' is lower than or equal to the current
log level of `module'.  Return FALSE if any of them are undefined.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOG-LEVEL<=) NULL)
    (DEFINE-FUNCTION-OBJECT "BUMP-LOG-INDENT"
     "(DEFUN BUMP-LOG-INDENT () :DOCUMENTATION \"Increase the indentation level for subsequent log messages.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION BUMP-LOG-INDENT) NULL)
    (DEFINE-FUNCTION-OBJECT "UNBUMP-LOG-INDENT"
     "(DEFUN UNBUMP-LOG-INDENT () :DOCUMENTATION \"Decrease the indentation level for subsequent log messages.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION UNBUMP-LOG-INDENT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-LOG-STREAM"
     "(DEFUN (GET-LOG-STREAM OUTPUT-STREAM) ((MODULE STRING)) :DOCUMENTATION \"Return a valid log stream for `module'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION GET-LOG-STREAM) NULL)
    (DEFINE-FUNCTION-OBJECT "LOG-MESSAGE"
     "(DEFUN LOG-MESSAGE ((MODULE STRING) (LOGLEVEL OBJECT) (MESSAGE CONS)) :DOCUMENTATION \"Log all elements of `message' to `module's log stream if
`logLevel' is the same or lower than the `module's log level.  Interprets `EOL'
or :EOL to print a line terminator.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOG-MESSAGE) NULL)
    (DEFINE-FUNCTION-OBJECT "LOGMSG"
     "(DEFUN LOGMSG ((MODULE STRING) (LOGLEVEL OBJECT) |&REST| (MESSAGE OBJECT)) :DOCUMENTATION \"Log all elements of `message' to `module's log stream if
`logLevel' is the same or lower than the `module's log level.  Interprets `EOL'
or :EOL to print a line terminator.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOGMSG) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-STREAMS"
     "(DEFUN STARTUP-STREAMS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-STREAMS) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-STREAMS-STELLA-STARTUP-STREAMS)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-STREAMS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupStreams") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL EOL SYMBOL (QUOTE EOL) :DOCUMENTATION \"Generates a newline character when passed to a stream.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT "(DEFGLOBAL EOL-STRING STRING \"
\" :DOCUMENTATION \"A string constant containing the character sequence
necessary to generate a newline.\" :PUBLIC? TRUE)" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL STELLA-CHARSET NATIVE-CHARSET-ENCODING (VERBATIM :JAVA \"java.nio.charset.Charset.forName(\\\"ISO-8859-1\\\")\" :COMMON-LISP \"(CL:or #+allegro (CL:ignore-errors (excl::find-external-format :iso-8859-1))
                                 #+cmu :iso-8859-1
                                 :DEFAULT)\" :OTHERWISE NULL) :DOCUMENTATION \"For STELLA we always assume an 8-bit transparent mapping from bytes to STRING characters
such as ISO-8859-1 (ISO-LATIN-1), since that's what C++ natively supports.  For Java and some Lisps, we have
to do some extra work to enforce this encoding when creating streams.  This is just a first iteration towards
this handling this, for example, in Lisp we'd also have to configure compile and load streams to properly encode
string constants that contain non-ASCII characters.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL STANDARD-INPUT INPUT-STREAM NULL :DOCUMENTATION \"Denotes the standard input stream for the host language.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL STANDARD-OUTPUT OUTPUT-STREAM (VERBATIM :OTHERWISE (MAKE-EARLY-OUTPUT-STREAM (VERBATIM :COMMON-LISP CL:*STANDARD-OUTPUT* :CPP \"&std::cout\" :JAVA \"#$(STELLAROOT).javalib.NativeOutputStream.create(java.lang.System.out)\"))) :DOCUMENTATION \"Denotes the standard output stream for the host language.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL STANDARD-WARNING OUTPUT-STREAM (VERBATIM :OTHERWISE (MAKE-EARLY-OUTPUT-STREAM (VERBATIM :COMMON-LISP CL:*ERROR-OUTPUT* :CPP \"&std::cerr\" :JAVA \"#$(STELLAROOT).javalib.NativeOutputStream.create(java.lang.System.err)\"))) :DOCUMENTATION \"Denotes the standard warning stream for the host language.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL STANDARD-ERROR OUTPUT-STREAM (VERBATIM :OTHERWISE (MAKE-EARLY-OUTPUT-STREAM (VERBATIM :COMMON-LISP CL:*ERROR-OUTPUT* :CPP \"&std::cerr\" :JAVA \"#$(STELLAROOT).javalib.NativeOutputStream.create(java.lang.System.err)\"))) :DOCUMENTATION \"Denotes the standard error stream for the host language.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFSPECIAL *IGNORETRANSLATIONERRORS?* BOOLEAN TRUE :DOCUMENTATION \"If `true' all passes of a translation will always be performed
regardless of whether any errors were encountered.  Otherwise, translation
ends with the first pass that encountered an error.\" :PUBLIC? TRUE)"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL SINGLE-QUOTE-STRING STRING-WRAPPER (WRAP-LITERAL \"'\") :DOCUMENTATION \"Holds a string containing the single quote character.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL SINGLE-BQUOTE-STRING STRING-WRAPPER (WRAP-LITERAL \"`\") :DOCUMENTATION \"Holds a string containing the single backquote character.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *OPEN-FILE-STREAMS* (LIST OF STREAM) (NEW (LIST OF STREAM)) :DOCUMENTATION \"List of file streams that are currently open.\")"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *HTML-QUOTED-CHARACTERS* STRING \"><&\\\"\")" NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *HTML-ESCAPE-TABLE* KEY-VALUE-LIST (NEW KEY-VALUE-LIST))"
     NULL)
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "lt")
     (WRAP-CHARACTER #\<))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "gt")
     (WRAP-CHARACTER #\>))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "amp")
     (WRAP-CHARACTER #\&))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "quot")
     (WRAP-CHARACTER #\"))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "apos")
     (WRAP-CHARACTER #\'))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "nbsp")
     (WRAP-CHARACTER #\ ))
    (INSERT-AT *HTML-ESCAPE-TABLE* (WRAP-STRING "NBSP")
     (WRAP-CHARACTER #\ ))
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOGGING-REGISTRY* (KEY-VALUE-LIST OF STRING-WRAPPER (PROPERTY-LIST OF KEYWORD OBJECT)) (NEW KEY-VALUE-LIST))"
     NULL)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOGGING-LOCAL-TIME-ZONE* FLOAT (GET-LOCAL-TIME-ZONE))"
     NULL)
    (REGISTER-NATIVE-NAME SYM-STREAMS-STELLA-SET-LOGGING-PARAMETERS
     KWD-STREAMS-COMMON-LISP KWD-STREAMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-STREAMS-STELLA-SET-LOG-LEVEL
     KWD-STREAMS-COMMON-LISP KWD-STREAMS-FUNCTION)
    (DEFINE-GLOBAL-VARIABLE-OBJECT
     "(DEFGLOBAL *LOG-INDENT-LEVEL* INTEGER 0 :DOCUMENTATION \"The number of spaces to print before the content of a log message.\" :PUBLIC? TRUE)"
     NULL)))
  :VOID)
